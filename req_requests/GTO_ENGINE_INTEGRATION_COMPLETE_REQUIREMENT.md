# üéØ **INDUSTRY-STRENGTH GTO DECISION ENGINE INTEGRATION REQUIREMENT**

## üìã **EXECUTIVE SUMMARY**

This document specifies the requirements for implementing a professional-grade Game Theory Optimal (GTO) decision engine that integrates seamlessly with the existing Pure Poker State Machine (PPSM) architecture to generate authentic, high-quality poker hands for training purposes. The solution must resolve existing interface mismatches, implement proper architectural patterns, and deliver a complete testing framework.

## üéØ **PROJECT OBJECTIVES**

### **Primary Goals**
1. **Real GTO Engine**: Implement industry-strength GTO decision-making algorithms
2. **PPSM Integration**: Seamlessly integrate with existing Pure Poker State Machine
3. **Interface Resolution**: Fix identified parameter mismatches between DecisionEngineProtocol and DecisionEngine classes
4. **Hands Generation**: Generate authentic GTO hands for 2-9 players with realistic action sequences
5. **Complete Testing**: Verify round-trip integrity (generation ‚Üí storage ‚Üí replay ‚Üí verification)
6. **Non-GUI Tester**: Deliver comprehensive testing framework without GUI dependencies

### **Architecture Compliance**
- Single-threaded, event-driven design following existing patterns
- Clean separation between decision logic and game state management
- Proper interface implementations resolving current mismatches
- Deterministic behavior for testing and validation

## üö® **CRITICAL ISSUES TO RESOLVE**

### **Interface Mismatch Problem**
**Current Issue**: The PPSM architecture has interface mismatches between:
- `DecisionEngineProtocol` (expects `GameState` objects with `.street` attribute)
- `DecisionEngine` classes (work with `Dict` objects)

**Error Manifestation**: 
```python
‚ùå GTO_DECISION: Error for player: 'dict' object has no attribute 'street'
```

**Root Cause**: 
```python
# DecisionEngineProtocol expects:
def get_decision(self, player_name: str, game_state: GameState) -> tuple[ActionType, Optional[float]]

# But receives Dict instead of GameState object
game_state = {"pot": 150, "players": [...]}  # Dict - no .street attribute
```

### **Required Interface Fixes**
1. **Standardize GameState Format**: Create consistent `GameState` dataclass
2. **Update Protocol Implementation**: Align `DecisionEngineProtocol` with actual usage
3. **Adapter Pattern**: Implement proper adapters for legacy compatibility
4. **Type Safety**: Add comprehensive type hints and validation

## üéØ **DETAILED REQUIREMENTS**

### **R1: Industry-Strength GTO Decision Engine**
**Priority**: Critical  
**Description**: Implement a professional GTO algorithm engine

**Acceptance Criteria**:
- [ ] Support for 2-9 player scenarios
- [ ] Pre-flop, flop, turn, and river decision making
- [ ] Position-aware strategy adjustments
- [ ] Pot odds and equity calculations
- [ ] Bankroll management considerations
- [ ] Configurable aggression levels
- [ ] Range-based decision making
- [ ] Mixed strategy randomization

**Technical Specifications**:
```python
class IndustryGTOEngine(DecisionEngineProtocol):
    """
    Professional-grade GTO decision engine.
    
    Features:
    - Nash equilibrium calculations
    - Range construction and analysis
    - Equity calculations vs opponent ranges
    - Mixed strategy implementation
    - Position and stack depth adjustments
    """
    
    def __init__(self, 
                 player_count: int,
                 stack_depth: float = 100.0,
                 aggression_factor: float = 1.0):
        self.solver = GTOSolver(player_count)
        self.range_analyzer = RangeAnalyzer()
        self.equity_calculator = EquityCalculator()
        
    def get_decision(self, player_name: str, game_state: GameState) -> tuple[ActionType, Optional[float]]:
        """Generate GTO decision based on current game state."""
        # Implementation details...
```

### **R2: PPSM Integration Framework**
**Priority**: Critical  
**Description**: Seamless integration with existing PPSM architecture

**Acceptance Criteria**:
- [ ] Resolve interface mismatches between protocols
- [ ] Maintain existing PPSM functionality
- [ ] Support all session types (Practice, GTO, HandsReview)
- [ ] Backward compatibility with existing decision engines
- [ ] Zero breaking changes to current API

**Interface Resolution**:
```python
@dataclass(frozen=True)
class StandardGameState:
    """Standardized game state for all decision engines."""
    pot: int
    street: str  # "preflop", "flop", "turn", "river"
    board: tuple[str, ...]
    players: tuple[PlayerState, ...]
    current_bet: int
    to_act_player_index: int
    legal_actions: frozenset[ActionType]
    
class UnifiedDecisionEngineProtocol(Protocol):
    """Unified protocol resolving interface mismatches."""
    
    def get_decision(self, player_name: str, game_state: StandardGameState) -> tuple[ActionType, Optional[float]]:
        """Get decision using standardized game state format."""
        pass
        
    def has_decision_for_player(self, player_name: str) -> bool:
        """Check if engine has decision for player."""
        pass
        
    def reset_for_new_hand(self) -> None:
        """Reset engine state for new hand."""
        pass
```

### **R3: GTO Hands Generation System**
**Priority**: High  
**Description**: Generate authentic poker hands using real GTO decisions

**Acceptance Criteria**:
- [ ] Generate 20 hands per player count (2-9 players) = 160 total hands
- [ ] Hands must contain realistic action sequences (20+ actions average)
- [ ] All generated hands must be valid poker scenarios
- [ ] Support for multiple betting rounds per street
- [ ] Realistic pot sizes and stack management
- [ ] Export to HandModel-compatible JSON format

**Technical Implementation**:
```python
class GTOHandsGenerator:
    """Generate authentic GTO hands using real decision engine."""
    
    def __init__(self, gto_engine: IndustryGTOEngine):
        self.gto_engine = gto_engine
        self.ppsm = PurePokerStateMachine()
        
    def generate_hands_batch(self, player_count: int, hands_count: int) -> List[HandModel]:
        """Generate batch of hands for specific player count."""
        # Implementation using real PPSM + GTO engine
        
    def export_to_json(self, hands: List[HandModel], filename: str) -> bool:
        """Export hands to HandModel-compatible JSON format."""
        # JSON serialization with proper format
```

### **R4: Round-Trip Testing Framework**
**Priority**: Critical  
**Description**: Comprehensive testing ensuring generation/replay integrity

**Acceptance Criteria**:
- [ ] Generate GTO hands using real engine
- [ ] Save hands in HandModel JSON format
- [ ] Reload hands using HandModel loader
- [ ] Replay hands using HandsReviewSession
- [ ] Verify identical outcomes (pot, stacks, actions)
- [ ] Test all player counts (2-9)
- [ ] Performance benchmarking (generation speed, memory usage)

**Testing Framework**:
```python
class GTOIntegrationTester:
    """Comprehensive testing framework for GTO integration."""
    
    def test_generation_replay_integrity(self):
        """Test: Generate ‚Üí Save ‚Üí Load ‚Üí Replay ‚Üí Verify"""
        # 1. Generate hands with GTO engine
        original_hands = self.generate_gto_hands()
        
        # 2. Save to JSON format
        self.save_hands_as_json(original_hands)
        
        # 3. Load using HandModel
        loaded_hands = self.load_hands_from_json()
        
        # 4. Replay using HandsReviewSession
        replayed_results = self.replay_hands(loaded_hands)
        
        # 5. Verify identical outcomes
        assert self.verify_identical_outcomes(original_hands, replayed_results)
        
    def test_interface_compatibility(self):
        """Test all decision engine interfaces work correctly."""
        # Test DecisionEngineProtocol
        # Test DecisionEngine base class
        # Test adapter patterns
        
    def benchmark_performance(self):
        """Benchmark generation and replay performance."""
        # Measure generation speed
        # Measure memory usage
        # Measure replay accuracy
```

### **R5: Non-GUI Testing Harness**
**Priority**: High  
**Description**: Complete testing framework without GUI dependencies

**Acceptance Criteria**:
- [ ] Command-line interface for all tests
- [ ] Automated test execution
- [ ] Detailed logging and reporting
- [ ] Performance metrics collection
- [ ] Failure analysis and debugging tools
- [ ] CI/CD integration ready

**CLI Interface**:
```bash
# Generate and test GTO hands
python3 test_gto_integration.py --generate --players 2-9 --hands-per-count 20

# Test round-trip integrity
python3 test_gto_integration.py --test-integrity --input gto_hands.json

# Benchmark performance
python3 test_gto_integration.py --benchmark --iterations 100

# Interface compatibility tests
python3 test_gto_integration.py --test-interfaces --verbose
```

## üõ†Ô∏è **IMPLEMENTATION PLAN**

### **Phase 1: Interface Resolution (Week 1)**
1. Create `StandardGameState` dataclass
2. Implement `UnifiedDecisionEngineProtocol`
3. Create adapter classes for backward compatibility
4. Update PPSM to use standardized interfaces

### **Phase 2: GTO Engine Implementation (Week 2-3)**
1. Implement core GTO algorithms
2. Range analysis and equity calculations
3. Position and stack depth adjustments
4. Integration with PPSM framework

### **Phase 3: Hands Generation System (Week 4)**
1. Implement `GTOHandsGenerator`
2. JSON export/import functionality
3. HandModel compatibility
4. Batch generation optimization

### **Phase 4: Testing Framework (Week 5)**
1. Round-trip integrity testing
2. Performance benchmarking
3. Interface compatibility verification
4. Non-GUI test harness

### **Phase 5: Validation & Documentation (Week 6)**
1. Comprehensive testing
2. Performance optimization
3. Documentation completion
4. Delivery preparation

## üìä **SUCCESS METRICS**

### **Functional Requirements**
- [ ] 100% interface compatibility (no "dict has no attribute" errors)
- [ ] Generate 160 authentic GTO hands with 20+ actions average
- [ ] 100% round-trip integrity (generation ‚Üî replay)
- [ ] Support for all player counts (2-9)
- [ ] HandModel JSON format compatibility

### **Performance Requirements**
- [ ] Generate 160 hands in < 60 seconds
- [ ] Memory usage < 100MB during generation
- [ ] Replay speed: < 1 second per hand
- [ ] Zero memory leaks during extended testing

### **Quality Requirements**
- [ ] 100% test coverage for new components
- [ ] Zero breaking changes to existing functionality
- [ ] Comprehensive error handling and logging
- [ ] Professional code documentation

## üéØ **DELIVERABLES**

1. **`IndustryGTOEngine`** - Professional GTO decision engine
2. **`UnifiedDecisionEngineProtocol`** - Resolved interface standard
3. **`GTOHandsGenerator`** - Hands generation system
4. **`GTOIntegrationTester`** - Non-GUI testing framework
5. **Generated GTO Hands** - 160 authentic hands in JSON format
6. **Performance Reports** - Benchmarking and validation results
7. **Integration Documentation** - Complete implementation guide

---

## üìã **TECHNICAL REFERENCE & SOURCE CODE**

This mega document includes complete architecture documentation and source code for reference during implementation.

**Template**: requirements

**Generated**: 2025-08-20 13:54:54

**Source Directory**: `/Users/yeogirlyun/Python/Poker`

**Output Directory**: `/Users/yeogirlyun/Python/Poker/req_requests`

---

## REQUIREMENTS SPECIFICATION

### HANDS_REVIEW_TAB_REQUIREMENTS_v1.md

**Path**: `HANDS_REVIEW_TAB_REQUIREMENTS_v1.md`

**Size**: 21.7 KB

```markdown
# üÉè **HANDS REVIEW TAB - COMPREHENSIVE REQUIREMENTS DOCUMENT v1.0**

**Status**: Industry-Strength Requirements  
**Target Architecture**: MVU (Model-View-Update) Pattern  
**Last Updated**: January 2025  
**Purpose**: Complete specifications for poker hands review functionality  

---

## üìã **EXECUTIVE SUMMARY**

The Hands Review Tab is a critical training component that allows poker players to analyze and review previously played hands through an interactive, visual poker table interface. The system must support step-by-step hand playback, automated replay, and comprehensive visual feedback using the MVU architecture for maximum reliability and maintainability.

---

## üéØ **CORE OBJECTIVES**

### **Primary Goals**
- **Educational Excellence**: Provide clear, step-by-step hand analysis for skill improvement
- **Visual Clarity**: Industry-standard poker table rendering with professional animations
- **User Experience**: Intuitive controls for both manual and automated hand review
- **Architecture Compliance**: Full MVU pattern implementation preventing infinite loops
- **Performance**: Smooth 60 FPS animations with responsive UI interactions

### **Key Success Metrics**
- **Zero Infinite Loops**: Stable MVU implementation with proper immutable state
- **Sub-100ms Response**: Button clicks to visual feedback under 100ms
- **Universal Compatibility**: Works with Practice, GTO, and Review session types
- **Audio-Visual Sync**: Perfect synchronization between sounds and visual actions
- **Memory Efficiency**: Stable memory usage during extended review sessions

---

## üèóÔ∏è **SYSTEM ARCHITECTURE**

### **MVU Architecture Implementation**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           VIEW LAYER                ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ    Hands Review Tab         ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Hand selector dropdown   ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Control buttons          ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Progress slider          ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ    Poker Table Renderer     ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Canvas-based rendering   ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Player seats (2-9)       ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Community cards          ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Pot graphics             ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Animation layers         ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚îÇ TableRendererProps (immutable)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           MODEL LAYER               ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ    Immutable Model State    ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - seats: Mapping[int, SeatState] ‚îÇ
‚îÇ  ‚îÇ  - board: tuple[str, ...]   ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - pot: int                 ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - legal_actions: frozenset ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - review_cursor: int       ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - waiting_for: str         ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚îÇ Commands (effects)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         EFFECTS LAYER               ‚îÇ
‚îÇ  - Audio: PlaySound, Speak         ‚îÇ
‚îÇ  - Visual: Animate, UpdateCanvas   ‚îÇ
‚îÇ  - Data: LoadHand, SaveState       ‚îÇ
‚îÇ  - Timing: ScheduleTimer           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### **Session Manager Integration**

```python
# Reusable across session types
class UniversalPokerTableRenderer:
    """Reusable poker table for all session types"""
    
    def __init__(self, session_manager: SessionManager):
        self.session_manager = session_manager  # Practice/GTO/Review
        
    def render(self, props: TableRendererProps):
        # Universal rendering logic
        pass

# Session-specific drivers
ReviewSessionManager   ‚Üí ReviewDriver   ‚Üí MVU Store
PracticeSessionManager ‚Üí PracticeDriver ‚Üí MVU Store  
GTOSessionManager      ‚Üí GTODriver      ‚Üí MVU Store
```

---

## üìä **FUNCTIONAL REQUIREMENTS**

### **FR-001: Hand Data Management**

#### **FR-001.1: Multi-Source Hand Loading**
- **Requirement**: Support multiple hand data sources
- **Sources**: 
  - `legendary_hands.json` (100 legendary hands)
  - `gto_hands.json` (GTO-analyzed hands)
  - Live session exports
  - User-imported hand histories
- **Format**: Standardized JSON format with metadata, seats, streets, actions
- **Performance**: Load 1000+ hands in <2 seconds

#### **FR-001.2: Hand Metadata Display**
- **Hand ID**: Unique identifier (e.g., "BB001", "HU047")
- **Table Info**: Stakes, max players, ante/blinds
- **Player Info**: Starting stacks, position, hole cards
- **Session Type**: Review/Practice/GTO classification
- **Analysis Tags**: Bluff, Value bet, All-in, etc.

#### **FR-001.3: Data Validation**
- **Schema Validation**: Ensure all required fields present
- **Action Sequence**: Validate logical action progression
- **Stack Conservation**: Verify chip accounting accuracy
- **Error Handling**: Graceful fallback for corrupted hands

### **FR-002: Visual Poker Table Rendering**

#### **FR-002.1: Table Layout Specifications**
- **Seat Configuration**: Dynamic 2-9 player support
- **Seat Positioning**: Circular arrangement with proper spacing
- **Table Dimensions**: Responsive sizing (600x400 minimum)
- **Visual Hierarchy**: Felt < Seats < Community < Pot < Overlays

#### **FR-002.2: Player Seat Rendering**
```python
class SeatVisualRequirements:
    """Visual requirements for each player seat"""
    
    # Seat State Indicators
    position_indicator: bool      # Dealer button, blinds
    stack_display: str           # "$1,247" format with commas
    name_display: str            # Player name or "Seat X"
    action_indicator: str        # Current action status
    
    # Visual Highlighting
    acting_highlight: bool       # Yellow/gold border when acting
    winner_highlight: bool       # Green celebration when wins
    folded_dimming: bool        # 50% opacity when folded
    all_in_indicator: bool      # Special "ALL IN" badge
    
    # Card Display
    hole_cards: List[str]       # ["As", "Kd"] or card backs
    card_visibility: str        # "hidden", "visible", "winner_reveal"
    
    # Chip Graphics
    bet_chips: ChipStack        # Current bet amount visualization
    stack_chips: ChipStack      # Remaining stack visualization
    chip_animation: bool        # Chips moving to/from pot
```

#### **FR-002.3: Community Cards Rendering**
- **Initial State**: 5 card backs in flop/turn/river positions
- **Flop Reveal**: 3 cards flip simultaneously with sound
- **Turn Reveal**: 4th card flips with distinct sound
- **River Reveal**: 5th card flips with distinct sound
- **Card Quality**: High-resolution card graphics (SVG preferred)
- **Animation**: Smooth card flip transition (200ms duration)

#### **FR-002.4: Pot Graphics System**
```python
class PotVisualRequirements:
    """Comprehensive pot rendering specifications"""
    
    # Pot Display
    pot_amount: str             # "$0", "$47", "$1,247" formatting
    pot_position: Point         # Center of table
    chip_visualization: bool    # 3D chip stack representation
    
    # Chip Animations
    bet_to_pot: Animation      # Chips move from player to pot
    pot_to_winner: Animation   # Pot chips move to winner
    side_pots: List[PotStack]  # Multiple pot visualization
    
    # Animation Timing
    bet_collection_delay: int = 1000    # 1 second after street ends
    winner_payout_delay: int = 2000     # 2 seconds after showdown
    animation_duration: int = 800       # 800ms smooth movement
```

### **FR-003: Audio-Visual Feedback System**

#### **FR-003.1: Human Voice Announcements**
- **Action Calls**: "Player 1 calls", "Player 2 raises to forty-seven"
- **Street Transitions**: "The flop", "The turn", "The river"
- **Showdown**: "Player 1 wins with pair of kings"
- **Voice Quality**: Professional, clear female announcer
- **Language**: English with potential multi-language support

#### **FR-003.2: Mechanical Sound Effects**
```python
class SoundEffectRequirements:
    """Complete audio feedback specifications"""
    
    # Action Sounds
    chip_bet: str = "poker_chips1.wav"        # Betting chips
    chip_call: str = "poker_chips2.wav"       # Calling chips  
    chip_fold: str = "card_fold.wav"          # Folding cards
    chip_check: str = "table_tap.wav"         # Checking action
    chip_all_in: str = "allin_push.wav"       # All-in push
    
    # Card Sounds
    card_deal: str = "card_deal.wav"          # Hole cards dealt
    flop_sound: str = "flop_cards.wav"        # 3 cards flip
    turn_sound: str = "turn_card.wav"         # Turn card flip
    river_sound: str = "river_card.wav"       # River card flip
    
    # Winner Sounds
    pot_collect: str = "pot_collect.wav"      # Chips to winner
    winner_fanfare: str = "winner_chime.wav"  # Victory sound
    
    # UI Sounds  
    button_click: str = "ui_click.wav"        # Button feedback
    slider_move: str = "slider_tick.wav"      # Review slider
```

#### **FR-003.3: Audio-Visual Synchronization**
- **Perfect Timing**: Audio plays exactly when visual action occurs
- **No Overlap**: Prevent multiple sounds from conflicting
- **Volume Control**: Respect system/app volume settings
- **Fallback**: Graceful degradation if audio fails

### **FR-004: User Interface Controls**

#### **FR-004.1: Hand Selection Interface**
```python
class HandSelectionRequirements:
    """Hand selection dropdown specifications"""
    
    # Dropdown Content
    hand_format: str = "{hand_id} - {description} ({players}P)"
    # Example: "BB001 - Big Bluff vs Calling Station (2P)"
    
    # Sorting Options
    sort_by_id: bool = True          # Alphabetical by hand ID
    sort_by_type: bool = True        # Group by session type
    filter_by_players: bool = True   # Filter 2P, 3P, etc.
    
    # Performance
    lazy_loading: bool = True        # Load hands on-demand
    search_function: bool = True     # Type-to-search functionality
```

#### **FR-004.2: Playback Controls**
```python
class PlaybackControlRequirements:
    """Comprehensive playback control specifications"""
    
    # Primary Controls
    next_button: Button             # Advance one action
    prev_button: Button             # Go back one action  
    play_pause_button: Button       # Auto-play toggle
    reset_button: Button            # Return to hand start
    
    # Speed Controls
    speed_slider: Scale             # 0.5x to 4x speed
    speed_presets: List[float] = [0.5, 1.0, 2.0, 4.0]
    
    # Review Slider
    review_slider: Scale            # Scrub through actions
    position_display: str = "5/23"  # Current/total actions
    
    # Auto-play Behavior
    auto_play_delay: int = 1000     # 1 second between actions
    pause_on_decision: bool = True  # Pause for hero decisions
    loop_hand: bool = False         # Restart when finished
```

#### **FR-004.3: Progress Visualization**
- **Action Counter**: "Action 5 of 23" display
- **Street Indicator**: Preflop/Flop/Turn/River/Showdown
- **Progress Bar**: Visual timeline of hand progression
- **Action History**: Scrollable list of previous actions

### **FR-005: Animation System**

#### **FR-005.1: Chip Movement Animations**
```python
class ChipAnimationRequirements:
    """Detailed chip animation specifications"""
    
    # Bet to Pot Animation
    def animate_bet_to_pot(self, seat: int, amount: int):
        """
        Animate chips moving from player seat to pot
        Duration: 300ms
        Easing: ease-out cubic bezier
        Visual: 3-5 chip sprites moving in arc
        """
        
    # Pot to Winner Animation  
    def animate_pot_to_winner(self, winner_seat: int, amount: int):
        """
        Animate pot chips moving to winner
        Duration: 500ms  
        Easing: ease-in-out
        Visual: Chip stream with sparkle effect
        """
        
    # Side Pot Handling
    side_pots: List[SidePot]        # Multiple pot visualization
    all_in_protection: bool = True  # Correct side pot math
```

#### **FR-005.2: Card Reveal Animations**
- **Hole Cards**: Instant reveal (review mode) or delayed (practice)
- **Flop**: Simultaneous 3-card flip (200ms each, 100ms stagger)
- **Turn/River**: Single card flip (200ms duration)
- **Showdown**: Winner cards highlighted, losers dimmed
- **Card Backs**: Professional card back design

#### **FR-005.3: Player Highlighting System**
```python
class PlayerHighlightRequirements:
    """Player visual state specifications"""
    
    # Action States
    acting_player: HighlightStyle = {
        'border_color': '#FFD700',     # Gold border
        'border_width': 3,             # 3px thick
        'glow_effect': True,           # Subtle glow
        'animation': 'pulse_slow'      # Gentle pulsing
    }
    
    # Winner Celebration
    winner_player: HighlightStyle = {
        'border_color': '#00FF00',     # Green celebration
        'background_tint': '#90EE90',  # Light green background
        'sparkle_effect': True,        # Particle animation
        'duration': 3000               # 3 seconds
    }
    
    # Folded Players
    folded_player: HighlightStyle = {
        'opacity': 0.5,                # 50% transparency
        'grayscale': True,             # Desaturated colors
        'cards_hidden': True           # Cards face down
    }
```

---

## üîÑ **USER WORKFLOW SPECIFICATIONS**

### **UW-001: Standard Hand Review Workflow**

#### **Step 1: Hand Selection**
1. User opens Hands Review tab
2. System loads available hands from data sources
3. User selects hand from dropdown (e.g., "BB001 - Big Bluff vs Station")
4. System loads hand data and initializes MVU model
5. Poker table displays initial state (preflop, hole cards visible)

#### **Step 2: Manual Step-Through**
1. User clicks "Next" button
2. System dispatches `NextPressed` message to MVU store
3. Store updates model with next action
4. View renders new table state with animations
5. Audio plays appropriate sound (chips/voice)
6. Process repeats until hand completion

#### **Step 3: Auto-Play Mode**
1. User clicks "Auto-Play" button
2. System enters automated playback mode
3. Actions advance automatically every 1 second (configurable)
4. User can pause/resume or adjust speed
5. System pauses on critical decisions (optional)

#### **Step 4: Review Navigation**
1. User drags review slider to specific action
2. System dispatches `ReviewSeek` message
3. Model instantly updates to target state
4. Table renders final state (no intermediate animations)
5. User can fine-tune position with next/prev buttons

### **UW-002: Educational Analysis Workflow**

#### **Study Mode Features**
- **Pause on Hero**: Automatically pause when hero has decision
- **Decision Analysis**: Show GTO recommendations vs actual play
- **Equity Display**: Show hand strength percentages (optional)
- **Action Notes**: Display analysis comments for specific actions
- **Mistake Highlighting**: Visual indicators for suboptimal plays

### **UW-003: Session Manager Integration**

#### **Review Session Manager**
```python
class ReviewSessionManager:
    """Manages review-specific functionality"""
    
    def load_hand(self, hand_id: str) -> HandData:
        """Load hand data for review"""
        
    def get_action_analysis(self, action_index: int) -> Analysis:
        """Get educational analysis for specific action"""
        
    def mark_favorite(self, hand_id: str) -> None:
        """Mark hand as favorite for quick access"""
```

#### **Practice Session Integration**
- **Same Table Renderer**: Reuse exact visual components
- **Different Driver**: Practice decisions vs review playback
- **Seamless Transition**: Switch between modes without UI reload

#### **GTO Session Integration** 
- **GTO Recommendations**: Overlay optimal plays during review
- **Mistake Detection**: Highlight deviations from GTO strategy
- **Learning Mode**: Show correct play before revealing actual action

---

## üé® **VISUAL DESIGN SPECIFICATIONS**

### **Theme Integration**
- **Full Theme Support**: Respect all theme tokens from theme system
- **Felt Colors**: Use theme-specific table felt colors
- **Card Designs**: Match theme aesthetic (classic/modern/neon)
- **Chip Colors**: Theme-appropriate chip denominations
- **Hot-Swappable**: Change themes without restarting review

### **Responsive Design**
- **Minimum Size**: 800x600 pixels
- **Maximum Size**: 1920x1080 pixels
- **Aspect Ratio**: Maintain 16:10 poker table proportions
- **Scaling**: All elements scale proportionally
- **Font Sizes**: Readable at all supported resolutions

### **Accessibility**
- **Color Contrast**: 4.5:1 ratio for all text
- **Keyboard Navigation**: Full tab-through support
- **Screen Reader**: ARIA labels for all interactive elements
- **Motion Reduction**: Respect prefers-reduced-motion setting
- **Focus Indicators**: Clear visual focus for keyboard users

---

## ‚ö° **PERFORMANCE REQUIREMENTS**

### **Response Time Specifications**
- **Hand Loading**: <500ms for any hand size
- **Next/Previous Action**: <100ms button response
- **Animation Smoothness**: 60 FPS for all animations  
- **Memory Usage**: <100MB for 1000+ hand dataset
- **CPU Usage**: <10% during normal playback

### **Scalability Requirements**
- **Hand Count**: Support 10,000+ hands without performance degradation
- **Session Length**: 8+ hour review sessions without memory leaks
- **Multiple Instances**: Multiple hands review tabs simultaneously
- **Background Loading**: Preload next/previous hands for instant switching

---

## üîí **TECHNICAL CONSTRAINTS**

### **MVU Architecture Compliance**
- **Immutable State**: All model data uses immutable collections
- **Pure Reducers**: No side effects in update functions
- **Command Pattern**: All effects as commands to effects layer
- **Single Source of Truth**: One model state per review session

### **Integration Requirements**
- **Service Container**: Full integration with existing DI system
- **Game Director**: Timing via existing scheduling system
- **Event Bus**: Publish events for external monitoring
- **Theme Manager**: Hot-swappable theme support

### **Browser/Platform Compatibility**
- **Tkinter Canvas**: Full Canvas API utilization for rendering
- **Python 3.9+**: Modern Python language features
- **Cross-Platform**: Windows, macOS, Linux support
- **Memory Efficiency**: Garbage collection friendly patterns

---

## üß™ **TESTING REQUIREMENTS**

### **Unit Testing**
- **Model Tests**: Verify immutable state transitions
- **Reducer Tests**: Test all message types and edge cases
- **Component Tests**: Isolated UI component testing
- **Animation Tests**: Verify timing and visual states

### **Integration Testing**
- **MVU Flow Tests**: Complete user interactions end-to-end
- **Session Manager Tests**: Verify reusability across session types
- **Audio-Visual Sync**: Timing validation for all effects
- **Performance Tests**: Memory and CPU usage validation

### **User Acceptance Testing**
- **Usability Tests**: Real poker players testing interface
- **Educational Effectiveness**: Learning outcome measurements
- **Accessibility Tests**: Screen reader and keyboard navigation
- **Stress Tests**: Extended session and large dataset handling

---

## üìà **SUCCESS CRITERIA**

### **Primary Success Metrics**
1. **Zero Infinite Loops**: MVU implementation prevents all rendering loops
2. **Sub-100ms Responsiveness**: All user interactions feel instantaneous
3. **Perfect Audio-Visual Sync**: No timing discrepancies between effects
4. **Universal Reusability**: Same renderer works for Practice/GTO/Review
5. **Educational Value**: Users report improved poker understanding

### **Secondary Success Metrics**
1. **Memory Stability**: No memory growth during extended sessions
2. **Animation Quality**: Smooth 60 FPS animations on target hardware
3. **Theme Compatibility**: Works flawlessly with all 16 themes
4. **Accessibility Compliance**: Passes all WCAG 2.1 AA requirements
5. **Performance Scalability**: Handles 10,000+ hands without degradation

---

## üöÄ **IMPLEMENTATION ROADMAP**

### **Phase 1: Core MVU Infrastructure (Week 1-2)**
- ‚úÖ Immutable model types with proper equality
- ‚úÖ Store with state reset protection
- ‚úÖ Basic table renderer with props caching
- ‚úÖ Review driver for hand playback

### **Phase 2: Visual Polish (Week 3-4)**
- üî≤ Professional card graphics and animations
- üî≤ Chip movement and pot animations
- üî≤ Player highlighting and state indicators
- üî≤ Theme integration and responsive design

### **Phase 3: Audio Integration (Week 5)**
- üî≤ Human voice announcements
- üî≤ Mechanical sound effects
- üî≤ Audio-visual synchronization
- üî≤ Volume controls and fallbacks

### **Phase 4: Advanced Features (Week 6-7)**
- üî≤ Auto-play with configurable timing
- üî≤ Educational analysis overlays
- üî≤ Session manager integration
- üî≤ Performance optimization

### **Phase 5: Testing & Polish (Week 8)**
- üî≤ Comprehensive testing suite
- üî≤ Accessibility compliance
- üî≤ Performance benchmarking
- üî≤ User acceptance testing

---

*This requirements document serves as the authoritative specification for hands review tab development. All implementation must adhere to these requirements to ensure industry-strength quality and reliability.*
```

---

## ARCHITECTURE DOCUMENTATION

### ARCHITECTURE_VIOLATION_PREVENTION_GUIDE.md

**Path**: `docs/ARCHITECTURE_VIOLATION_PREVENTION_GUIDE.md`

**Size**: 10.4 KB

```markdown
# üö´ Architecture Violation Prevention Guide

**Status**: Critical Reference for AI Agents  
**Purpose**: Prevent common architecture violations that compromise system integrity  
**Target Audience**: AI Coding Assistants, Future Development Teams  

---

## üéØ **EXECUTIVE SUMMARY**

This guide documents **critical architecture violations** discovered during system analysis and provides **mandatory prevention patterns** for future AI agents. These violations were found in production code and **must never be repeated**.

### **üî• HIGH-SEVERITY VIOLATIONS FOUND**

1. **Business Logic in UI Components** - UI directly executing business operations
2. **Direct Service Calls from UI** - Bypassing Store/Reducer architecture  
3. **Timing Violations** - Using `self.after()` instead of GameDirector
4. **State Mutations in UI** - Direct state changes bypassing Store
5. **Mixed Rendering Patterns** - Multiple rendering approaches instead of unified system

---

## üìã **VIOLATION CATALOG & FIXES**

### **üö® VIOLATION 1: Business Logic in UI Components**

#### **‚ùå FORBIDDEN PATTERN**
```python
class HandsReviewTab(ttk.Frame):
    def _next_action(self):
        # ‚ùå WRONG: Business logic in UI
        session_state = self.session_manager.execute_action()
        
        if session_state.current_action_index < session_state.total_actions:
            self._update_status(f"Action {session_state.current_action_index}")
            self._render_table_with_state(session_state)
        else:
            self._update_status("Hand complete")
```

#### **‚úÖ CORRECT PATTERN**
```python
class HandsReviewTab(ttk.Frame):
    def _next_action(self):
        # ‚úÖ CORRECT: Pure UI dispatch
        self.store.dispatch({
            "type": "HANDS_REVIEW_NEXT_ACTION",
            "session_id": self.session_id,
            "timestamp": time.time()
        })
```

#### **üõ°Ô∏è PREVENTION RULES**
- UI components are **pure renderers only**
- All business logic in Services or PPSM
- UI only dispatches actions and renders state
- No direct calls to session managers from UI

---

### **üö® VIOLATION 2: Direct Service Calls from UI**

#### **‚ùå FORBIDDEN PATTERN**
```python
# ‚ùå WRONG: Direct service calls
def _handle_bet(self):
    result = self.session_manager.execute_bet(amount)  # VIOLATION!
    self.effect_bus.play_sound("bet")                  # VIOLATION!
    self._update_display(result)
```

#### **‚úÖ CORRECT PATTERN**
```python
# ‚úÖ CORRECT: Event-driven architecture
def _handle_bet(self):
    self.store.dispatch({
        "type": "PLAYER_BET_ACTION",
        "amount": amount,
        "session_id": self.session_id
    })
    
    # Service controller handles the business logic:
    # 1. Receives event from reducer
    # 2. Calls session_manager.execute_bet()
    # 3. Calls effect_bus.play_sound()
    # 4. Updates store with results
```

#### **üõ°Ô∏è PREVENTION RULES**
- No direct service method calls from UI
- All communication via Store ‚Üí Reducer ‚Üí Service
- Services handle business logic and side effects
- UI never touches session managers directly

---

### **üö® VIOLATION 3: Timing Violations**

#### **‚ùå FORBIDDEN PATTERNS**
```python
# ‚ùå WRONG: Direct timing calls
self.after(1000, self._complete_action)        # VIOLATION!
threading.Timer(1.0, callback).start()        # VIOLATION!
time.sleep(1)                                  # VIOLATION!

# ‚ùå WRONG: Update loops with self.after
def _update_loop(self):
    self._refresh_display()
    self.after(16, self._update_loop)           # VIOLATION!
```

#### **‚úÖ CORRECT PATTERNS**
```python
# ‚úÖ CORRECT: GameDirector timing
self.game_director.schedule(1000, {
    "type": "DELAYED_ACTION",
    "callback": self._complete_action
})

# ‚úÖ CORRECT: Event-driven updates
self.event_bus.publish("display:refresh_requested", {
    "interval_ms": 16,
    "component": "table_display"
})
```

#### **üõ°Ô∏è PREVENTION RULES**
- All timing via GameDirector
- No `self.after()`, `threading.Timer`, or `time.sleep()`
- Use `TimingMigrationHelper` for complex timing
- Event-driven updates instead of polling loops

---

### **üö® VIOLATION 4: State Mutations in UI**

#### **‚ùå FORBIDDEN PATTERN**
```python
# ‚ùå WRONG: Direct state mutations
def _update_pot(self, amount):
    self.game_state.pot += amount              # VIOLATION!
    self.display_state['seats'][0]['acting'] = True  # VIOLATION!
    self._refresh_display()
```

#### **‚úÖ CORRECT PATTERN**
```python
# ‚úÖ CORRECT: Store dispatch for state changes
def _update_pot(self, amount):
    self.store.dispatch({
        "type": "UPDATE_POT_AMOUNT",
        "amount": amount
    })
    
    self.store.dispatch({
        "type": "SET_ACTING_PLAYER",
        "seat_index": 0,
        "acting": True
    })
```

#### **üõ°Ô∏è PREVENTION RULES**
- All state changes via Store dispatch
- UI never directly mutates state objects
- Single source of truth in Store
- Reducers handle all state transformations

---

### **üö® VIOLATION 5: Mixed Rendering Patterns**

#### **‚ùå FORBIDDEN PATTERN**
```python
# ‚ùå WRONG: Multiple rendering approaches
class HandsReviewTab(ttk.Frame):
    def __init__(self):
        self.poker_widget = ReusablePokerGameWidget(...)  # VIOLATION!
        self.table_renderer = PokerTableRenderer(...)    # VIOLATION!
        self.custom_canvas = tk.Canvas(...)               # VIOLATION!
```

#### **‚úÖ CORRECT PATTERN**
```python
# ‚úÖ CORRECT: Single unified renderer
class HandsReviewTab(ttk.Frame):
    def __init__(self):
        # Single renderer for all poker table rendering
        self.table_renderer = PokerTableRenderer(
            self,
            intent_handler=self._handle_renderer_intent,
            theme_manager=self.theme
        )
```

#### **üõ°Ô∏è PREVENTION RULES**
- Single `PokerTableRenderer` for all poker table rendering
- No custom canvas rendering alongside renderer
- No legacy widget mixing with new architecture
- Unified rendering pipeline for consistency

---

## üõ°Ô∏è **MANDATORY ENFORCEMENT CHECKLIST**

### **Pre-Development Checklist**
- [ ] **UI Design Review**: Verify UI components are pure renderers
- [ ] **Architecture Review**: Confirm Store/Reducer/Service pattern
- [ ] **Timing Review**: All delays via GameDirector
- [ ] **State Flow Review**: No direct state mutations in UI

### **Code Review Checklist**
- [ ] No business logic in UI components
- [ ] No direct service calls from UI (session_manager, effect_bus, etc.)
- [ ] No timing violations (`self.after`, `threading.Timer`, `time.sleep`)
- [ ] All state changes via Store dispatch
- [ ] Event-driven communication only
- [ ] Single PokerTableRenderer used
- [ ] Theme tokens only (no hardcoded colors)

### **Testing Checklist**
- [ ] UI components can be tested in isolation (no business logic)
- [ ] Service layer can be tested without UI
- [ ] State changes are deterministic via reducers
- [ ] Timing is controlled via GameDirector

---

## üö® **IMMEDIATE REJECTION CRITERIA**

**Reject any code that contains:**

```python
# ‚ùå IMMEDIATE REJECTION TRIGGERS
session_manager.execute_action()     # Business logic in UI
self.after(                         # Timing violation
threading.Timer                     # Threading violation  
self.game_state.pot =              # Direct state mutation
ReusablePokerGameWidget            # Legacy mixing
```

---

## üìö **REFERENCE IMPLEMENTATIONS**

### **‚úÖ Compliant HandsReviewTab Structure**
```python
class HandsReviewTab(ttk.Frame):
    def __init__(self, parent, services):
        super().__init__(parent)
        self.services = services
        self.store = services.get_app("store")
        self.event_bus = services.get_app("event_bus")
        
        # Single unified renderer
        self.table_renderer = PokerTableRenderer(...)
        
        # Register with event controller
        self.event_bus.publish("hands_review:session_created", {
            "session_id": self.session_id,
            "session_manager": self.session_manager
        })
    
    def _next_action(self):
        """Pure UI dispatch - no business logic"""
        self.store.dispatch({
            "type": "HANDS_REVIEW_NEXT_ACTION",
            "session_id": self.session_id
        })
    
    def dispose(self):
        """Clean disposal with event notification"""
        self.event_bus.publish("hands_review:session_disposed", {
            "session_id": self.session_id
        })
```

### **‚úÖ Compliant Event Controller Structure**
```python
class HandsReviewEventController:
    def __init__(self, event_bus, store, services):
        self.event_bus = event_bus
        self.store = store
        self.services = services
        self._setup_event_handlers()
    
    def _setup_event_handlers(self):
        self.event_bus.subscribe(
            "hands_review:next_action_requested",
            self._handle_next_action_request
        )
    
    def _handle_next_action_request(self, event_data):
        """Business logic handling - not in UI"""
        session_id = event_data.get('session_id')
        session_manager = self.session_managers.get(session_id)
        
        # Execute business logic
        session_state = session_manager.execute_action()
        
        # Update store with results
        self.store.dispatch({
            "type": "UPDATE_HANDS_REVIEW_STATE",
            "session_id": session_id,
            "state": session_state
        })
```

---

## üéØ **SUCCESS METRICS**

### **Architecture Compliance Metrics**
- ‚úÖ **0** business logic methods in UI components
- ‚úÖ **0** direct service calls from UI
- ‚úÖ **0** timing violations (`self.after`, etc.)
- ‚úÖ **0** direct state mutations in UI
- ‚úÖ **1** unified rendering system (PokerTableRenderer)

### **Code Quality Metrics**  
- ‚úÖ **100%** event-driven communication
- ‚úÖ **100%** Store/Reducer pattern compliance
- ‚úÖ **100%** GameDirector timing coordination
- ‚úÖ **100%** theme token usage (no hardcoded colors)

---

## üìû **SUPPORT & ESCALATION**

### **When to Escalate**
- Architecture violation detected in production
- Uncertainty about Store/Reducer pattern implementation
- Complex timing requirements that may need GameDirector enhancement
- Performance issues related to event-driven architecture

### **Escalation Process**
1. Document the specific violation or concern
2. Reference this guide's violation catalog
3. Propose architecture-compliant alternative
4. Request architecture review before implementation

---

**üîí This guide is MANDATORY for all AI agents working on this codebase. Violations of these patterns compromise system integrity and MUST be prevented.**
```

---

### PROJECT_PRINCIPLES_v2.md

**Path**: `docs/PROJECT_PRINCIPLES_v2.md`

**Size**: 6.0 KB

```markdown
## Project Principles v2 (Authoritative)

### Architecture
- Single-threaded, event-driven coordinator (GameDirector). All timing via coordinator.
- Single source of truth per session (Store). No duplicate state.
- Event-driven only. UI is pure render from state; no business logic in UI.
- **MVU Pattern**: For complex UI, use Model-View-Update architecture (see `PokerPro_MVU_Architecture_Guide_v2.md`).

### Separation of concerns
- Domain: entities, rules, state machines; pure and deterministic.
- Application/Services: orchestration, schedulers, adapters; no UI.
- Adapters: persistence, audio, estimators, external APIs.
- UI: render-only; reads from Store; raises intents.

### Coding standards
- OO-first; composition/strategies/state machines over conditionals.
- DRY; reuse components; small, stable public APIs.
- Deterministic core; isolate I/O, randomness, timing.
- Explicit dependency injection; avoid globals/singletons.

### UI design
- Canvas layers: felt < seats < community < pot < overlay.
- Theme tokens only; central ThemeManager; hot-swappable profiles.
- Accessibility: ‚â•4.5:1 contrast; 44√ó44 targets; keyboard bindings; live regions.

### Testing & logging
- Snapshot tests for UI; unit tests for reducers/selectors and adapters.
- Logs to `logs/` with rotation; ISO timestamps; module:file:line; no secrets/PII.

### Prohibitions
- No threading/timers for game logic; no blocking animations/sounds.
- No duplicate state sources; no component-to-component timing calls.
- **No mutable collections in MVU models** (use `tuple`, `frozenset`, `Mapping`).
- **No auto-generated equality for nested structures** (implement custom `__eq__`).
- **No data loading during UI initialization** (defer until components ready).

### üö´ CRITICAL AI AGENT COMPLIANCE RULES (NEVER VIOLATE)

#### **üî• MVU INFINITE LOOP PREVENTION (CRITICAL)**

**‚ùå NEVER USE MUTABLE COLLECTIONS IN MVU MODELS**
```python
# WRONG - Will cause infinite loops
@dataclass(frozen=True)
class Model:
    seats: Dict[int, SeatState]  # ‚ùå Mutable Dict
    legal_actions: Set[str]      # ‚ùå Mutable Set

# CORRECT - Prevents infinite loops  
@dataclass(frozen=True)
class Model:
    seats: Mapping[int, SeatState]  # ‚úÖ Immutable Mapping
    legal_actions: frozenset[str]   # ‚úÖ Immutable frozenset
```

**‚ùå NEVER RELY ON AUTO-GENERATED EQUALITY**
```python
# WRONG - eq=True fails with nested objects
@dataclass(frozen=True, eq=True)
class Props: ...

# CORRECT - Custom equality works
@dataclass(frozen=True, eq=False)
class Props:
    def __eq__(self, other): ...
```

**‚ùå NEVER LOAD DATA DURING UI __init__**
```python
# WRONG - Race condition causes loops
def __init__(self):
    self._init_mvu()
    self._load_hand(0)  # ‚ùå Too early!

# CORRECT - Deferred loading
def __init__(self):
    self._init_mvu()
    self._mvu_initialized = True
def _load_data(self):
    if hasattr(self, '_mvu_initialized'):
        self._load_hand(0)  # ‚úÖ Safe timing
```

**üîç REFERENCE: See `docs/PokerPro_MVU_Architecture_Guide_v2.md` for complete infinite loop prevention guide.**

#### **üî• ARCHITECTURE VIOLATIONS THAT MUST BE PREVENTED**

**‚ùå VIOLATION 1: Business Logic in UI Components**
```python
# ‚ùå FORBIDDEN - Business logic in UI
def _next_action(self):
    session_state = self.session_manager.execute_action()  # WRONG!
    self._update_ui(session_state)

# ‚úÖ CORRECT - Pure UI dispatch
def _next_action(self):
    self.store.dispatch({"type": "HANDS_REVIEW_NEXT_ACTION"})
```

**‚ùå VIOLATION 2: Direct Service Calls from UI**
```python
# ‚ùå FORBIDDEN - Direct service calls
self.session_manager.execute_action()  # WRONG!
self.effect_bus.play_sound("bet")      # WRONG!

# ‚úÖ CORRECT - Event-driven
self.store.dispatch({"type": "NEXT_ACTION"})
self.event_bus.publish("sound:play", {"type": "bet"})
```

**‚ùå VIOLATION 3: Timing Violations**
```python
# ‚ùå FORBIDDEN - Direct timing calls
self.after(1000, callback)           # WRONG!
threading.Timer(1.0, callback)      # WRONG!
time.sleep(1)                        # WRONG!

# ‚úÖ CORRECT - GameDirector timing
self.game_director.schedule(1000, {"type": "DELAYED_ACTION", "callback": callback})
```

**‚ùå VIOLATION 4: State Mutations in UI**
```python
# ‚ùå FORBIDDEN - Direct state mutation
self.game_state.pot += 100           # WRONG!
self.display_state['acting'] = True  # WRONG!

# ‚úÖ CORRECT - Store dispatch
self.store.dispatch({"type": "UPDATE_POT", "amount": 100})
```

#### **‚úÖ MANDATORY COMPLIANCE RULES**

1. **UI Components MUST be Pure Renderers**
2. **All Communication MUST be Event-Driven**  
3. **All Timing MUST go through GameDirector**
4. **Single Source of Truth MUST be Maintained**
5. **Store/Reducer Pattern MUST be Used**

#### **üõ°Ô∏è ENFORCEMENT CHECKLIST**
- [ ] No business logic in UI components
- [ ] No direct service calls from UI  
- [ ] No timing violations (after/Timer/sleep)
- [ ] All state changes via Store dispatch
- [ ] Event-driven communication only

### AI Agent Compliance (Do not deviate)
1. Do **not** add new events or fields. If missing, leave TODO and stop.
2. Never compute poker legality in UI; call selectors/PPSM.
3. Use theme tokens only; no literal colors, shadows, or fonts.
4. Do not use timers/threads for game logic; schedule via Director.
5. No cross-component writes; only Store and events.
6. Respect casing rules (events UPPER_SNAKE_CASE; domain snake_case).
7. Keep functions small and pure; side effects only in adapters.
8. If uncertain, generate interface stubs, not implementations.
9. **NEVER put business logic in UI components - they are pure renderers only**
10. **ALWAYS use Store/Reducer pattern - no direct service calls from UI**
11. **ALL timing must go through GameDirector - no self.after() violations**

### PR Acceptance Checklist
- [ ] No business logic in UI; all decisions via PPSM or DecisionEngine.
- [ ] Events are UPPER_SNAKE_CASE; fields snake_case; streets uppercase.
- [ ] Only theme tokens used; contrast checks pass.
- [ ] Components subscribe via selectors; no direct Store writes.
- [ ] Replay tests pass on sample hands; headless run produces stable state hashes.
- [ ] Logs are present, structured, and scrubbed.
```

---

## IMPLEMENTATION SOURCE

### __init__.py

**Path**: `backend/core/__init__.py`

**Size**: 577 bytes

```python
"""
Core module for poker strategy practice system.

This module contains the fundamental game logic, state management,
and core functionality for the poker strategy practice application.
"""

from .deuces_hand_evaluator import DeucesHandEvaluator
# from .position_mapping import PositionMapper, EnhancedStrategyIntegration  # Removed - unused
from .gui_models import StrategyData

__all__ = [
    "ImprovedPokerStateMachine",
    "DeucesHandEvaluator",
    # "PositionMapper",  # Removed - unused
    # "EnhancedStrategyIntegration",  # Removed - unused
    "StrategyData",
]
```

---

### base_session.py

**Path**: `backend/core/base_session.py`

**Size**: 0 bytes

```python

```

---

### decision_engine.py

**Path**: `backend/core/decision_engine.py`

**Size**: 18.0 KB

```python
#!/usr/bin/env python3
"""
Decision Engine Interface for Unified Bot Sessions

This module provides an abstract base class for decision engines that can be
used in bot-only poker sessions. This allows GTO sessions and Hands Review
sessions to share the same underlying architecture while using different
decision sources.

Key principles:
- Clean interface separation between decision logic and game flow
- Reusable architecture for all bot-only sessions
- Consistent API for different decision sources
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional, Tuple
from .poker_types import ActionType, Player


class DecisionEngine(ABC):
    """
    Abstract base class for poker decision engines.
    
    This interface allows different decision sources (GTO algorithms, 
    preloaded hand data, etc.) to be used interchangeably in bot sessions.
    """
    
    @abstractmethod
    def get_decision(self, player_index: int, game_state: Dict[str, Any]) -> Dict[str, Any]:
        """
        Get the next action decision for a player.
        
        Args:
            player_index: Index of the player who needs to act
            game_state: Current game state information
            
        Returns:
            Dict containing:
                - action: ActionType (FOLD, CHECK, CALL, BET, RAISE)
                - amount: float (bet/raise amount, 0 for fold/check/call)
                - explanation: str (reasoning for the decision)
                - confidence: float (0-1, confidence in the decision)
        """
        pass
    
    @abstractmethod
    def is_session_complete(self) -> bool:
        """
        Check if this decision engine has reached the end of its decisions.
        
        Returns:
            True if no more decisions are available, False otherwise
        """
        pass
    
    @abstractmethod
    def reset(self) -> None:
        """Reset the decision engine to its initial state."""
        pass
    
    def get_session_info(self) -> Dict[str, Any]:
        """
        Get information about the current session state.
        
        Returns:
            Dict with session-specific information (progress, metadata, etc.)
        """
        return {}


class GTODecisionEngine(DecisionEngine):
    """
    Decision engine that uses GTO (Game Theory Optimal) strategies.
    
    This engine calculates optimal poker decisions based on game theory
    principles and provides explanations for educational purposes.
    """
    
    def __init__(self, num_players: int = 6):
        """Initialize the GTO decision engine."""
        # Temporarily disabled due to syntax errors in improved_gto_strategy
        # from .improved_gto_strategy import ImprovedGTOStrategy
        
        self.num_players = num_players
        self.gto_strategies = {}
        self.decision_count = 0
        
        # Initialize GTO strategies for each player position
        # Temporarily disabled due to syntax errors
        # for i in range(num_players):
        #     self.gto_strategies[i] = ImprovedGTOStrategy(num_players)
    
    def get_decision(self, player_index: int, game_state: Dict[str, Any]) -> Dict[str, Any]:
        """Get GTO-optimal decision for the given player and game state."""
        # Debug: Log decision request
        print(f"üéØ GTO_DECISION_REQUEST: Player {player_index}")
        print(f"üéØ GTO_DECISION_REQUEST: Game state type: {type(game_state)}")
        if isinstance(game_state, dict):
            print(f"üéØ GTO_DECISION_REQUEST: Game state keys: {list(game_state.keys())}")
            print(f"üéØ GTO_DECISION_REQUEST: Street: {game_state.get('street', 'unknown')}")
            print(f"üéØ GTO_DECISION_REQUEST: Players count: {len(game_state.get('players', []))}")
        
        if player_index not in self.gto_strategies:
            # Fallback for invalid player index
            print(f"üö® GTO_DECISION_ERROR: Invalid player index {player_index}, available: {list(self.gto_strategies.keys())}")
            return {
                'action': ActionType.FOLD,
                'amount': 0.0,
                'explanation': f"Invalid player index {player_index}",
                'confidence': 0.0
            }
        
        strategy = self.gto_strategies[player_index]
        
        try:
            # Extract player and game state information
            players = game_state.get('players', [])
            if player_index >= len(players):
                raise IndexError(f"Player index {player_index} out of range")
            
            # Get player dict and convert to Player object
            player_dict = players[player_index]
            
            # Import Player class
            from .poker_types import Player
            
            # Create a proper Player object from the dictionary
            player = Player(
                name=player_dict.get('name', f'Player_{player_index}'),
                stack=player_dict.get('stack', 1000.0),
                position=self._get_position_name(player_index, len(players)),
                is_human=player_dict.get('is_human', False),
                is_active=not player_dict.get('has_folded', False),
                cards=player_dict.get('cards', []),
                current_bet=player_dict.get('current_bet', 0.0)
            )
            
            # Set additional attributes that might be useful
            player.index = player_index
            
            print(f"üéØ GTO_PLAYER_CREATED: {player.name} at {player.position} with cards {player.cards}")
            print(f"üéØ GTO_PLAYER_CREATED: Stack=${player.stack}, bet=${player.current_bet}")
            
            
            # Convert game_state dict to GameState object if needed
            if isinstance(game_state, dict):
                # Create a simple GameState-like object with required attributes
                class SimpleGameState:
                    def __init__(self, data):
                        self.players = data.get('players', [])
                        self.board = data.get('board', [])
                        self.pot = data.get('pot', 0.0)
                        self.current_bet = data.get('current_bet', 0.0)
                        self.street = data.get('street', 'preflop')
                        self.dealer_position = data.get('dealer_position', 0)
                        self.action_player = data.get('action_player', 0)
                
                game_state_obj = SimpleGameState(game_state)
            else:
                game_state_obj = game_state
            
            # Get GTO decision using the improved strategy engine
            print(f"üéØ GTO_STRATEGY_INPUT: Position={player.position}, Cards={player.cards}")
            print(f"üéØ GTO_STRATEGY_INPUT: Street={game_state_obj.street}, Current_bet={game_state_obj.current_bet}")
            print(f"üéØ GTO_STRATEGY_INPUT: Player_bet={player.current_bet}, Stack=${player.stack}")
            
            action, amount = strategy.get_gto_action(player, game_state_obj)
            
            print(f"üéØ GTO_STRATEGY_OUTPUT: Action={action}, Amount={amount}")
            
            
            self.decision_count += 1
            
            # Create explanation based on action and street
            street = game_state.get('street', 'preflop')
            explanation = self._generate_explanation(action, amount, street, player)
            
            # Return formatted decision
            return {
                'action': action,
                'amount': amount,
                'explanation': explanation,
                'confidence': 0.8,  # GTO decisions have high confidence
                'decision_number': self.decision_count
            }
            
        except Exception as e:
            # Debug: Log the actual error to understand what's failing
            print(f"üö® GTO_ENGINE_ERROR: {str(e)}")
            print(f"üö® GTO_ENGINE_ERROR: Exception type: {type(e).__name__}")
            print(f"üö® GTO_ENGINE_ERROR: Player index: {player_index}")
            print(f"üö® GTO_ENGINE_ERROR: Game state keys: {list(game_state.keys()) if isinstance(game_state, dict) else 'Not a dict'}")
            
            import traceback
            print(f"üö® GTO_ENGINE_ERROR: Full traceback:\n{traceback.format_exc()}")
            
            # Fallback decision if strategy engine fails
            return {
                'action': ActionType.FOLD,
                'amount': 0.0,
                'explanation': f"GTO engine error: {str(e)}",
                'confidence': 0.0
            }
    
    def _generate_explanation(self, action: ActionType, amount: float, street: str, player) -> str:
        """Generate a human-readable explanation for the GTO decision."""
        position = getattr(player, 'position', 'Unknown')
        stack = getattr(player, 'stack', 0)
        cards = getattr(player, 'cards', [])
        
        # Basic action descriptions
        action_explanations = {
            ActionType.FOLD: f"GTO fold from {position} position. Hand doesn't meet minimum requirements for this spot.",
            ActionType.CHECK: f"GTO check from {position}. Controlling pot size with marginal hand strength.",
            ActionType.CALL: f"GTO call from {position}. Hand has sufficient equity to continue at current price.",
            ActionType.BET: f"GTO bet of ${amount:.0f} from {position}. Betting for value and/or protection.",
            ActionType.RAISE: f"GTO raise to ${amount:.0f} from {position}. Hand strength justifies aggressive action."
        }
        
        base_explanation = action_explanations.get(action, f"GTO {action.name.lower()} from {position}")
        
        # Add street-specific context
        if street == 'preflop':
            base_explanation += f" Based on modern {self.num_players}-max preflop ranges."
        elif street in ['flop', 'turn', 'river']:
            base_explanation += f" {street.capitalize()} play considering board texture and equity."
        
        return base_explanation
    
    def _get_position_name(self, player_index: int, num_players: int) -> str:
        """Convert player index to position name for different table sizes."""
        if num_players == 2:
            # Heads-up: SB and BB positions
            positions = ["SB", "BB"]
            return positions[player_index % 2]
        elif num_players == 6:
            positions = ["UTG", "MP", "CO", "BTN", "SB", "BB"]
            return positions[player_index % 6]
        elif num_players == 9:
            positions = ["UTG", "UTG+1", "MP", "MP+1", "CO", "BTN", "SB", "BB", "UTG"]
            return positions[player_index % 9]
        else:
            # For other table sizes, use appropriate position names
            if num_players <= 3:
                # Small tables: SB, BB, BTN
                positions = ["SB", "BB", "BTN"]
                return positions[player_index % len(positions)]
            elif num_players <= 5:
                # Medium tables: UTG, MP, BTN, SB, BB
                positions = ["UTG", "MP", "BTN", "SB", "BB"]
                return positions[player_index % len(positions)]
            else:
                # Large tables: use generic position names
                return f"Pos_{player_index}"
    
    def is_session_complete(self) -> bool:
        """GTO sessions continue indefinitely until manually stopped."""
        return False
    
    def reset(self) -> None:
        """Reset the GTO decision engine."""
        self.decision_count = 0
        # GTO strategies don't need resetting as they're stateless
    
    def get_session_info(self) -> Dict[str, Any]:
        """Get GTO session information."""
        return {
            'engine_type': 'GTO',
            'num_players': self.num_players,
            'decisions_made': self.decision_count,
            'strategies_loaded': len(self.gto_strategies)
        }


class PreloadedDecisionEngine(DecisionEngine):
    """
    Decision engine that uses preloaded hand data.
    
    This engine replays predetermined poker hands by following the exact
    sequence of actions from historical or generated hand data. Perfect
    for hands review, analysis, and educational purposes.
    """
    
    def __init__(self, hands_data: Dict[str, Any]):
        """
        Initialize the preloaded decision engine.
        
        Args:
            hands_data: Dictionary containing hand timeline and actions
        """
        print(f"üî• PRELOADED_DEBUG: Initializing with hands_data keys: {list(hands_data.keys())}")
        self.hands_data = hands_data
        self.timeline = self._parse_timeline(hands_data)
        self.current_step = 0
        self.total_steps = len(self.timeline)
        print(f"üî• PRELOADED_DEBUG: Parsed timeline length: {self.total_steps}")
        print(f"üî• PRELOADED_DEBUG: Timeline: {self.timeline}")
        print(f"üî• PRELOADED_DEBUG: is_session_complete() = {self.is_session_complete()}")
        
    def _parse_timeline(self, hands_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Parse the hands data into a timeline of decisions.
        
        Args:
            hands_data: Raw hands data from JSON
            
        Returns:
            List of decision dictionaries in chronological order
        """
        timeline = []
        
        try:
            actions = hands_data.get('actions', [])
            print(f"üî• PARSE_DEBUG: Found {len(actions)} actions to parse")
            print(f"üî• PARSE_DEBUG: First few actions: {actions[:3] if actions else 'No actions'}")
            
            # Parse the flat actions array (GTO hands format)
            for i, action_data in enumerate(actions):
                print(f"üî• PARSE_DEBUG: Processing action {i}: {action_data}")
                if isinstance(action_data, dict):
                    player_index = action_data.get('player_index', 0)
                    action_str = action_data.get('action', 'fold')
                    amount = action_data.get('amount', 0.0)
                    street = action_data.get('street', 'preflop')
                    explanation = action_data.get('explanation', f"Preloaded {action_str}")
                    
                    # Convert to decision format
                    decision = {
                        'player_index': int(player_index),
                        'action': self._parse_action_type(action_str),
                        'amount': float(amount),
                        'street': street,
                        'explanation': explanation,
                        'confidence': 1.0,  # Historical actions are "certain"
                        'original_data': action_data
                    }
                    
                    timeline.append(decision)
                    print(f"üî• PARSE_DEBUG: Added decision to timeline: {decision}")
            
            print(f"üî• PARSE_DEBUG: Final timeline has {len(timeline)} decisions")
            return timeline
            
        except Exception as e:
            # Return empty timeline if parsing fails
            print(f"Error parsing hands timeline: {e}")
            return []
    
    def _parse_action_type(self, action_str: str) -> ActionType:
        """Convert string action to ActionType enum."""
        action_mapping = {
            'fold': ActionType.FOLD,
            'check': ActionType.CHECK,
            'call': ActionType.CALL,
            'bet': ActionType.BET,
            'raise': ActionType.RAISE,
        }
        
        return action_mapping.get(action_str.lower(), ActionType.FOLD)
    
    def get_decision(self, player_index: int, game_state: Dict[str, Any]) -> Dict[str, Any]:
        """Get the next preloaded decision from the timeline."""
        current_street = game_state.get('street', 'preflop')
        # Find the next decision that matches the current street
        matching_decision = None
        
        while self.current_step < self.total_steps:
            decision = self.timeline[self.current_step]
            decision_street = decision.get('street', 'preflop')
            
            if decision_street == current_street:
                matching_decision = decision.copy()
                self.current_step += 1
                break
            else:
                # Skip decisions that don't match current street
                self.current_step += 1
        
        if matching_decision is None:
            # No more decisions available for current street
            return {
                'action': ActionType.CHECK,  # Default to check if no action found
                'amount': 0.0,
                'explanation': f'No preloaded action for {current_street} street',
                'confidence': 0.0
            }
        
        # CRITICAL FIX: Update the decision to be for the current player
        # The preloaded actions are in chronological order, but we need to apply them
        # to whoever is the current action player in the recreated game state
        matching_decision['player_index'] = player_index
        matching_decision['explanation'] = f"[Preloaded] {matching_decision.get('explanation', 'Historical action')}"
        
        return matching_decision
    
    def is_session_complete(self) -> bool:
        """Check if all preloaded decisions have been used."""
        return self.current_step >= self.total_steps
    
    def reset(self) -> None:
        """Reset to the beginning of the hand timeline."""
        self.current_step = 0
    
    def get_session_info(self) -> Dict[str, Any]:
        """Get preloaded session information."""
        return {
            'engine_type': 'Preloaded',
            'total_steps': self.total_steps,
            'current_step': self.current_step,
            'progress_percent': (self.current_step / max(1, self.total_steps)) * 100,
            'steps_remaining': max(0, self.total_steps - self.current_step)
        }
    
    def get_timeline_info(self) -> Dict[str, Any]:
        """Get detailed timeline information for debugging."""
        return {
            'timeline_length': len(self.timeline),
            'current_position': self.current_step,
            'next_action': self.timeline[self.current_step] if self.current_step < len(self.timeline) else None,
            'hands_data_keys': list(self.hands_data.keys()) if self.hands_data else []
        }
```

---

### decision_engine_v2.py

**Path**: `backend/core/decision_engine_v2.py`

**Size**: 10.0 KB

```python
#!/usr/bin/env python3
"""
Decision Engine v2 - Abstract base and GTO implementation

This module provides the abstract base class for decision engines and
a GTO-based implementation for real-time strategy calculations.

Key Features:
- Abstract DecisionEngine base class
- GTODecisionEngine for real-time GTO calculations
- Removed PreloadedDecisionEngine (replaced by HandModelDecisionEngine)
"""

from abc import ABC, abstractmethod
from typing import Dict, Any
from .poker_types import ActionType


class DecisionEngine(ABC):
    """
    Abstract base class for poker decision engines.
    
    All decision engines must implement these methods to provide
    consistent decision-making interfaces.
    """
    
    @abstractmethod
    def get_decision(self, player_index: int, game_state: Dict[str, Any]) -> Dict[str, Any]:
        """
        Get the next decision for a player.
        
        Args:
            player_index: Index of the player making the decision
            game_state: Current state of the game
            
        Returns:
            Dictionary containing action, amount, explanation, and confidence
        """
        pass
    
    @abstractmethod
    def is_session_complete(self) -> bool:
        """Check if the decision session is complete."""
        pass
    
    @abstractmethod
    def reset(self) -> None:
        """Reset the decision engine to initial state."""
        pass
    
    @abstractmethod
    def get_session_info(self) -> Dict[str, Any]:
        """Get information about the current decision session."""
        pass


class GTODecisionEngine(DecisionEngine):
    """
    GTO-based decision engine for real-time strategy calculations.
    
    This engine provides game theory optimal decisions based on:
    - Player position and stack depth
    - Board texture and pot odds
    - Modern GTO principles and ranges
    """
    
    def __init__(self, num_players: int = 6):
        """
        Initialize the GTO decision engine.
        
        Args:
            num_players: Number of players at the table (default: 6)
        """
        self.num_players = num_players
        self.decision_count = 0
        self.gto_strategies = {}  # Placeholder for GTO strategy data
        
        # Load GTO strategies (placeholder implementation)
        self._load_gto_strategies()
    
    def _load_gto_strategies(self):
        """Load GTO strategies for different scenarios."""
        # Placeholder for GTO strategy loading
        # In a real implementation, this would load pre-computed GTO solutions
        pass
    
    def get_decision(self, player_index: int, game_state: Dict[str, Any]) -> Dict[str, Any]:
        """
        Get a GTO-based decision for the current situation.
        
        Args:
            player_index: Index of the player making the decision
            game_state: Current state of the game
            
        Returns:
            Dictionary containing action, amount, explanation, and confidence
        """
        try:
            # Extract game state information
            street = game_state.get('street', 'preflop')
            pot_size = game_state.get('pot', 0.0)
            current_bet = game_state.get('current_bet', 0.0)
            players = game_state.get('players', [])
            
            if player_index >= len(players):
                return {
                    'action': ActionType.FOLD,
                    'amount': 0.0,
                    'explanation': 'Invalid player index - folding',
                    'confidence': 0.0
                }
            
            player = players[player_index]
            position = getattr(player, 'position', 'Unknown')
            stack = getattr(player, 'stack', 100.0)
            
            # Simple GTO-based decision logic (placeholder)
            # In a real implementation, this would use sophisticated GTO calculations
            if current_bet == 0.0:
                # No bet to call - check or bet
                if self._should_bet_for_value(position, street):
                    bet_amount = min(pot_size * 0.75, stack * 0.1)
                    return {
                        'action': ActionType.BET,
                        'amount': bet_amount,
                        'explanation': self._generate_explanation(ActionType.BET, bet_amount, street, player),
                        'confidence': 0.8
                    }
                else:
                    return {
                        'action': ActionType.CHECK,
                        'amount': 0.0,
                        'explanation': self._generate_explanation(ActionType.CHECK, 0.0, street, player),
                        'confidence': 0.7
                    }
            else:
                # There's a bet to call, raise, or fold
                call_amount = max(0.0, current_bet - getattr(player, 'current_bet', 0.0))
                
                if call_amount > stack * 0.3:
                    # Expensive call - fold
                    return {
                        'action': ActionType.FOLD,
                        'amount': 0.0,
                        'explanation': self._generate_explanation(ActionType.FOLD, 0.0, street, player),
                        'confidence': 0.9
                    }
                elif call_amount <= stack * 0.1:
                    # Cheap call - call
                    return {
                        'action': ActionType.CALL,
                        'amount': call_amount,
                        'explanation': self._generate_explanation(ActionType.CALL, call_amount, street, player),
                        'confidence': 0.8
                    }
                else:
                    # Medium call - raise or fold based on position
                    if self._should_raise_for_value(position, street):
                        raise_amount = min(current_bet * 2.5, stack * 0.2)
                        return {
                            'action': ActionType.RAISE,
                            'amount': raise_amount,
                            'explanation': self._generate_explanation(ActionType.RAISE, raise_amount, street, player),
                            'confidence': 0.7
                        }
                    else:
                        return {
                            'action': ActionType.FOLD,
                            'amount': 0.0,
                            'explanation': self._generate_explanation(ActionType.FOLD, 0.0, street, player),
                            'confidence': 0.8
                        }
        
        except Exception as e:
            # Fallback decision on error
            return {
                'action': ActionType.CHECK,
                'amount': 0.0,
                'explanation': f"GTO engine error: {str(e)}",
                'confidence': 0.0
            }
    
    def _should_bet_for_value(self, position: str, street: str) -> bool:
        """Determine if we should bet for value based on position and street."""
        # Simple heuristic - in a real implementation, this would use GTO ranges
        strong_positions = ['BTN', 'CO', 'MP']
        return position in strong_positions and street == 'preflop'
    
    def _should_raise_for_value(self, position: str, street: str) -> bool:
        """Determine if we should raise for value based on position and street."""
        # Simple heuristic - in a real implementation, this would use GTO ranges
        strong_positions = ['BTN', 'CO']
        return position in strong_positions and street in ['preflop', 'flop']
    
    def _generate_explanation(self, action: ActionType, amount: float, street: str, player) -> str:
        """Generate a human-readable explanation for the GTO decision."""
        position = getattr(player, 'position', 'Unknown')
        stack = getattr(player, 'stack', 0)
        cards = getattr(player, 'cards', [])
        
        # Basic action descriptions
        action_explanations = {
            ActionType.FOLD: f"GTO fold from {position} position. Hand doesn't meet minimum requirements for this spot.",
            ActionType.CHECK: f"GTO check from {position}. Controlling pot size with marginal hand strength.",
            ActionType.CALL: f"GTO call from {position}. Hand has sufficient equity to continue at current price.",
            ActionType.BET: f"GTO bet of ${amount:.0f} from {position}. Betting for value and/or protection.",
            ActionType.RAISE: f"GTO raise to ${amount:.0f} from {position}. Hand strength justifies aggressive action."
        }
        
        base_explanation = action_explanations.get(action, f"GTO {action.name.lower()} from {position}")
        
        # Add street-specific context
        if street == 'preflop':
            base_explanation += f" Based on modern {self.num_players}-max preflop ranges."
        elif street in ['flop', 'turn', 'river']:
            base_explanation += f" {street.capitalize()} play considering board texture and equity."
        
        return base_explanation
    
    def _get_position_name(self, player_index: int, num_players: int) -> str:
        """Convert player index to position name for 6-max poker."""
        if num_players == 6:
            positions = ["UTG", "MP", "CO", "BTN", "SB", "BB"]
            return positions[player_index % 6]
        elif num_players == 9:
            positions = ["UTG", "UTG+1", "MP", "MP+1", "CO", "BTN", "SB", "BB", "UTG"]
            return positions[player_index % 9]
        else:
            # Fallback for other table sizes
            return f"Pos_{player_index}"
    
    def is_session_complete(self) -> bool:
        """GTO sessions continue indefinitely until manually stopped."""
        return False
    
    def reset(self) -> None:
        """Reset the GTO decision engine."""
        self.decision_count = 0
        # GTO strategies don't need resetting as they're stateless
    
    def get_session_info(self) -> Dict[str, Any]:
        """Get GTO session information."""
        return {
            'engine_type': 'GTO',
            'num_players': self.num_players,
            'decisions_made': self.decision_count,
            'strategies_loaded': len(self.gto_strategies)
        }
```

---

### decision_engine_working.py

**Path**: `backend/core/decision_engine_working.py`

**Size**: 17.4 KB

```python
#!/usr/bin/env python3
"""
Decision Engine Interface for Unified Bot Sessions

This module provides an abstract base class for decision engines that can be
used in bot-only poker sessions. This allows GTO sessions and Hands Review
sessions to share the same underlying architecture while using different
decision sources.

Key principles:
- Clean interface separation between decision logic and game flow
- Reusable architecture for all bot-only sessions
- Consistent API for different decision sources
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional, Tuple
from .types import ActionType, Player


class DecisionEngine(ABC):
    """
    Abstract base class for poker decision engines.
    
    This interface allows different decision sources (GTO algorithms, 
    preloaded hand data, etc.) to be used interchangeably in bot sessions.
    """
    
    @abstractmethod
    def get_decision(self, player_index: int, game_state: Dict[str, Any]) -> Dict[str, Any]:
        """
        Get the next action decision for a player.
        
        Args:
            player_index: Index of the player who needs to act
            game_state: Current game state information
            
        Returns:
            Dict containing:
                - action: ActionType (FOLD, CHECK, CALL, BET, RAISE)
                - amount: float (bet/raise amount, 0 for fold/check/call)
                - explanation: str (reasoning for the decision)
                - confidence: float (0-1, confidence in the decision)
        """
        pass
    
    @abstractmethod
    def is_session_complete(self) -> bool:
        """
        Check if this decision engine has reached the end of its decisions.
        
        Returns:
            True if no more decisions are available, False otherwise
        """
        pass
    
    @abstractmethod
    def reset(self) -> None:
        """Reset the decision engine to its initial state."""
        pass
    
    def get_session_info(self) -> Dict[str, Any]:
        """
        Get information about the current session state.
        
        Returns:
            Dict with session-specific information (progress, metadata, etc.)
        """
        return {}


class GTODecisionEngine(DecisionEngine):
    """
    Decision engine that uses GTO (Game Theory Optimal) strategies.
    
    This engine calculates optimal poker decisions based on game theory
    principles and provides explanations for educational purposes.
    """
    
    def __init__(self, num_players: int = 6):
        """Initialize the GTO decision engine."""
        # Temporarily disabled due to syntax errors in improved_gto_strategy
        # from .improved_gto_strategy import ImprovedGTOStrategy
        
        self.num_players = num_players
        self.gto_strategies = {}
        self.decision_count = 0
        
        # Initialize GTO strategies for each player position
        # Temporarily disabled due to syntax errors
        # for i in range(num_players):
        #     self.ppsm = ImprovedGTOStrategy(num_players)
    
    def get_decision(self, player_index: int, game_state: Dict[str, Any]) -> Dict[str, Any]:
        """Get GTO-optimal decision for the given player and game state."""
        # Debug: Log decision request
        print(f"üéØ GTO_DECISION_REQUEST: Player {player_index}")
        print(f"üéØ GTO_DECISION_REQUEST: Game state type: {type(game_state)}")
        if isinstance(game_state, dict):
            print(f"üéØ GTO_DECISION_REQUEST: Game state keys: {list(game_state.keys())}")
            print(f"üéØ GTO_DECISION_REQUEST: Street: {game_state.get('street', 'unknown')}")
            print(f"üéØ GTO_DECISION_REQUEST: Players count: {len(game_state.get('players', []))}")
        
        if player_index not in self.gto_strategies:
            # Fallback for invalid player index
            print(f"üö® GTO_DECISION_ERROR: Invalid player index {player_index}, available: {list(self.gto_strategies.keys())}")
            return {
                'action': ActionType.FOLD,
                'amount': 0.0,
                'explanation': f"Invalid player index {player_index}",
                'confidence': 0.0
            }
        
        strategy = self.gto_strategies[player_index]
        
        try:
            # Extract player and game state information
            players = game_state.get('players', [])
            if player_index >= len(players):
                raise IndexError(f"Player index {player_index} out of range")
            
            # Get player dict and convert to Player object
            player_dict = players[player_index]
            
            # Import Player class
            from .types import Player
            
            # Create a proper Player object from the dictionary
            player = Player(
                name=player_dict.get('name', f'Player_{player_index}'),
                stack=player_dict.get('stack', 1000.0),
                position=self._get_position_name(player_index, len(players)),
                is_human=player_dict.get('is_human', False),
                is_active=not player_dict.get('has_folded', False),
                cards=player_dict.get('cards', []),
                current_bet=player_dict.get('current_bet', 0.0)
            )
            
            # Set additional attributes that might be useful
            player.index = player_index
            
            print(f"üéØ GTO_PLAYER_CREATED: {player.name} at {player.position} with cards {player.cards}")
            print(f"üéØ GTO_PLAYER_CREATED: Stack=${player.stack}, bet=${player.current_bet}")
            
            
            # Convert game_state dict to GameState object if needed
            if isinstance(game_state, dict):
                # Create a simple GameState-like object with required attributes
                class SimpleGameState:
                    def __init__(self, data):
                        self.players = data.get('players', [])
                        self.board = data.get('board', [])
                        self.pot = data.get('pot', 0.0)
                        self.current_bet = data.get('current_bet', 0.0)
                        self.street = data.get('street', 'preflop')
                        self.dealer_position = data.get('dealer_position', 0)
                        self.action_player = data.get('action_player', 0)
                
                game_state_obj = SimpleGameState(game_state)
            else:
                game_state_obj = game_state
            
            # Get GTO decision using the improved strategy engine
            print(f"üéØ GTO_STRATEGY_INPUT: Position={player.position}, Cards={player.cards}")
            print(f"üéØ GTO_STRATEGY_INPUT: Street={game_state_obj.street}, Current_bet={game_state_obj.current_bet}")
            print(f"üéØ GTO_STRATEGY_INPUT: Player_bet={player.current_bet}, Stack=${player.stack}")
            
            action, amount = strategy.get_gto_action(player, game_state_obj)
            
            print(f"üéØ GTO_STRATEGY_OUTPUT: Action={action}, Amount={amount}")
            
            
            self.decision_count += 1
            
            # Create explanation based on action and street
            street = game_state.get('street', 'preflop')
            explanation = self._generate_explanation(action, amount, street, player)
            
            # Return formatted decision
            return {
                'action': action,
                'amount': amount,
                'explanation': explanation,
                'confidence': 0.8,  # GTO decisions have high confidence
                'decision_number': self.decision_count
            }
            
        except Exception as e:
            # Debug: Log the actual error to understand what's failing
            print(f"üö® GTO_ENGINE_ERROR: {str(e)}")
            print(f"üö® GTO_ENGINE_ERROR: Exception type: {type(e).__name__}")
            print(f"üö® GTO_ENGINE_ERROR: Player index: {player_index}")
            print(f"üö® GTO_ENGINE_ERROR: Game state keys: {list(game_state.keys()) if isinstance(game_state, dict) else 'Not a dict'}")
            
            import traceback
            print(f"üö® GTO_ENGINE_ERROR: Full traceback:\n{traceback.format_exc()}")
            
            # Fallback decision if strategy engine fails
            return {
                'action': ActionType.FOLD,
                'amount': 0.0,
                'explanation': f"GTO engine error: {str(e)}",
                'confidence': 0.0
            }
    
    def _generate_explanation(self, action: ActionType, amount: float, street: str, player) -> str:
        """Generate a human-readable explanation for the GTO decision."""
        position = getattr(player, 'position', 'Unknown')
        stack = getattr(player, 'stack', 0)
        cards = getattr(player, 'cards', [])
        
        # Basic action descriptions
        action_explanations = {
            ActionType.FOLD: f"GTO fold from {position} position. Hand doesn't meet minimum requirements for this spot.",
            ActionType.CHECK: f"GTO check from {position}. Controlling pot size with marginal hand strength.",
            ActionType.CALL: f"GTO call from {position}. Hand has sufficient equity to continue at current price.",
            ActionType.BET: f"GTO bet of ${amount:.0f} from {position}. Betting for value and/or protection.",
            ActionType.RAISE: f"GTO raise to ${amount:.0f} from {position}. Hand strength justifies aggressive action."
        }
        
        base_explanation = action_explanations.get(action, f"GTO {action.name.lower()} from {position}")
        
        # Add street-specific context
        if street == 'preflop':
            base_explanation += f" Based on modern {self.num_players}-max preflop ranges."
        elif street in ['flop', 'turn', 'river']:
            base_explanation += f" {street.capitalize()} play considering board texture and equity."
        
        return base_explanation
    
    def _get_position_name(self, player_index: int, num_players: int) -> str:
        """Convert player index to position name for 6-max poker."""
        if num_players == 6:
            positions = ["UTG", "MP", "CO", "BTN", "SB", "BB"]
            return positions[player_index % 6]
        elif num_players == 9:
            positions = ["UTG", "UTG+1", "MP", "MP+1", "CO", "BTN", "SB", "BB", "UTG"]
            return positions[player_index % 9]
        else:
            # Fallback for other table sizes
            return f"Pos_{player_index}"
    
    def is_session_complete(self) -> bool:
        """GTO sessions continue indefinitely until manually stopped."""
        return False
    
    def reset(self) -> None:
        """Reset the GTO decision engine."""
        self.decision_count = 0
        # GTO strategies don't need resetting as they're stateless
    
    def get_session_info(self) -> Dict[str, Any]:
        """Get GTO session information."""
        return {
            'engine_type': 'GTO',
            'num_players': self.num_players,
            'decisions_made': self.decision_count,
            'strategies_loaded': len(self.gto_strategies)
        }


class PreloadedDecisionEngine(DecisionEngine):
    """
    Decision engine that uses preloaded hand data.
    
    This engine replays predetermined poker hands by following the exact
    sequence of actions from historical or generated hand data. Perfect
    for hands review, analysis, and educational purposes.
    """
    
    def __init__(self, hands_data: Dict[str, Any]):
        """
        Initialize the preloaded decision engine.
        
        Args:
            hands_data: Dictionary containing hand timeline and actions
        """
        print(f"üî• PRELOADED_DEBUG: Initializing with hands_data keys: {list(hands_data.keys())}")
        self.hands_data = hands_data
        self.timeline = self._parse_timeline(hands_data)
        self.current_step = 0
        self.total_steps = len(self.timeline)
        print(f"üî• PRELOADED_DEBUG: Parsed timeline length: {self.total_steps}")
        print(f"üî• PRELOADED_DEBUG: Timeline: {self.timeline}")
        print(f"üî• PRELOADED_DEBUG: is_session_complete() = {self.is_session_complete()}")
        
    def _parse_timeline(self, hands_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Parse the hands data into a timeline of decisions.
        
        Args:
            hands_data: Raw hands data from JSON
            
        Returns:
            List of decision dictionaries in chronological order
        """
        timeline = []
        
        try:
            actions = hands_data.get('actions', [])
            print(f"üî• PARSE_DEBUG: Found {len(actions)} actions to parse")
            print(f"üî• PARSE_DEBUG: First few actions: {actions[:3] if actions else 'No actions'}")
            
            # Parse the flat actions array (GTO hands format)
            for i, action_data in enumerate(actions):
                print(f"üî• PARSE_DEBUG: Processing action {i}: {action_data}")
                if isinstance(action_data, dict):
                    player_index = action_data.get('player_index', 0)
                    action_str = action_data.get('action', 'fold')
                    amount = action_data.get('amount', 0.0)
                    street = action_data.get('street', 'preflop')
                    explanation = action_data.get('explanation', f"Preloaded {action_str}")
                    
                    # Convert to decision format
                    decision = {
                        'player_index': int(player_index),
                        'action': self._parse_action_type(action_str),
                        'amount': float(amount),
                        'street': street,
                        'explanation': explanation,
                        'confidence': 1.0,  # Historical actions are "certain"
                        'original_data': action_data
                    }
                    
                    timeline.append(decision)
                    print(f"üî• PARSE_DEBUG: Added decision to timeline: {decision}")
            
            print(f"üî• PARSE_DEBUG: Final timeline has {len(timeline)} decisions")
            return timeline
            
        except Exception as e:
            # Return empty timeline if parsing fails
            print(f"Error parsing hands timeline: {e}")
            return []
    
    def _parse_action_type(self, action_str: str) -> ActionType:
        """Convert string action to ActionType enum."""
        action_mapping = {
            'fold': ActionType.FOLD,
            'check': ActionType.CHECK,
            'call': ActionType.CALL,
            'bet': ActionType.BET,
            'raise': ActionType.RAISE,
        }
        
        return action_mapping.get(action_str.lower(), ActionType.FOLD)
    
    def get_decision(self, player_index: int, game_state: Dict[str, Any]) -> Dict[str, Any]:
        """Get the next preloaded decision from the timeline."""
        current_street = game_state.get('street', 'preflop')
        # Find the next decision that matches the current street
        matching_decision = None
        
        while self.current_step < self.total_steps:
            decision = self.timeline[self.current_step]
            decision_street = decision.get('street', 'preflop')
            
            if decision_street == current_street:
                matching_decision = decision.copy()
                self.current_step += 1
                break
            else:
                # Skip decisions that don't match current street
                self.current_step += 1
        
        if matching_decision is None:
            # No more decisions available for current street
            return {
                'action': ActionType.CHECK,  # Default to check if no action found
                'amount': 0.0,
                'explanation': f'No preloaded action for {current_street} street',
                'confidence': 0.0
            }
        
        # CRITICAL FIX: Update the decision to be for the current player
        # The preloaded actions are in chronological order, but we need to apply them
        # to whoever is the current action player in the recreated game state
        matching_decision['player_index'] = player_index
        matching_decision['explanation'] = f"[Preloaded] {matching_decision.get('explanation', 'Historical action')}"
        
        return matching_decision
    
    def is_session_complete(self) -> bool:
        """Check if all preloaded decisions have been used."""
        return self.current_step >= self.total_steps
    
    def reset(self) -> None:
        """Reset to the beginning of the hand timeline."""
        self.current_step = 0
    
    def get_session_info(self) -> Dict[str, Any]:
        """Get preloaded session information."""
        return {
            'engine_type': 'Preloaded',
            'total_steps': self.total_steps,
            'current_step': self.current_step,
            'progress_percent': (self.current_step / max(1, self.total_steps)) * 100,
            'steps_remaining': max(0, self.total_steps - self.current_step)
        }
    
    def get_timeline_info(self) -> Dict[str, Any]:
        """Get detailed timeline information for debugging."""
        return {
            'timeline_length': len(self.timeline),
            'current_position': self.current_step,
            'next_action': self.timeline[self.current_step] if self.current_step < len(self.timeline) else None,
            'hands_data_keys': list(self.hands_data.keys()) if self.hands_data else []
        }
```

---

### deuces_hand_evaluator.py

**Path**: `backend/core/deuces_hand_evaluator.py`

**Size**: 5.8 KB

```python
#!/usr/bin/env python3
"""
Deuces-based Hand Evaluator

This module provides a poker hand evaluator that uses the proven deuces library
for accurate and reliable hand evaluation and comparison.
"""

from typing import List, Dict, Any
from deuces import Card, Evaluator


class DeucesHandEvaluator:
    """Hand evaluator using the deuces library for proven accuracy."""

    def __init__(self):
        self.evaluator = Evaluator()

    def evaluate_hand(
        self, hole_cards: List[str], board_cards: List[str]
    ) -> Dict[str, Any]:
        """
        Evaluate a poker hand using deuces library.

        Args:
            hole_cards: List of hole cards (e.g., ['Ah', 'Kd'])
            board_cards: List of board cards (e.g., ['Qh', 'Jh', 'Th', '9h', '8h'])

        Returns:
            Dict containing:
            - hand_score: Integer score (lower = better)
            - hand_rank: Rank class (1=Straight Flush, 8=High Card)
            - hand_description: Human readable description
            - strength_score: Percentile strength (0-100)
        """
        try:
            # Convert our card format to deuces format
            deuces_hole = self._convert_cards_to_deuces(hole_cards)
            deuces_board = self._convert_cards_to_deuces(board_cards)

            if len(deuces_hole) != 2:
                raise ValueError(
                    f"Expected 2 hole cards, got {
                        len(deuces_hole)}"
                )

            if len(deuces_board) < 3:
                raise ValueError(
                    f"Expected at least 3 board cards, got {
                        len(deuces_board)}"
                )

            # Evaluate hand using deuces
            hand_score = self.evaluator.evaluate(deuces_board, deuces_hole)
            hand_rank = self.evaluator.get_rank_class(hand_score)
            hand_description = self.evaluator.class_to_string(hand_rank)

            # Calculate strength score (percentile)
            strength_percentage = (
                1.0 - self.evaluator.get_five_card_rank_percentage(hand_score)
            )
            strength_score = strength_percentage * 100

            # Find the best 5-card combination
            all_cards = deuces_hole + deuces_board
            best_five_cards = self._find_best_five_cards(all_cards, hand_score)

            return {
                # Lower = better (for comparison)
                "hand_score": hand_score,
                "hand_rank": hand_rank,  # Rank class (1-8)
                "hand_description": hand_description,
                "strength_score": strength_score,  # 0-100 percentile
                "hole_cards": list(hole_cards),
                "board_cards": list(board_cards),
                "best_five_cards": best_five_cards,  # The actual 5 cards used
            }

        except Exception as e:
            # Fallback evaluation for invalid hands
            return {
                "hand_score": 9999,  # Worst possible score
                "hand_rank": 8,  # High card
                "hand_description": "Invalid Hand",
                "strength_score": 0.0,
                "hole_cards": list(hole_cards),
                "board_cards": list(board_cards),
                "error": str(e),
            }

    def _convert_cards_to_deuces(self, cards: List[str]) -> List[int]:
        """Convert our card format to deuces format."""
        deuces_cards = []
        for card_str in cards:
            try:
                # Convert our format (e.g., 'Ah') to deuces format
                deuces_card = Card.new(card_str)
                deuces_cards.append(deuces_card)
            except Exception:
                # Skip invalid cards
                continue
        return deuces_cards

    def _find_best_five_cards(
        self, all_cards: List[int], target_score: int
    ) -> List[str]:
        """Find the best 5-card combination that matches the given score."""
        from itertools import combinations

        # Generate all possible 5-card combinations
        for combo in combinations(all_cards, 5):
            combo_score = self.evaluator.evaluate([], list(combo))
            if combo_score == target_score:
                # Convert back to our string format
                return [Card.int_to_str(card) for card in combo]

        # Fallback: return first 5 cards if no exact match found
        if len(all_cards) >= 5:
            return [Card.int_to_str(card) for card in all_cards[:5]]
        return []

    def compare_hands(
        self, eval1: Dict[str, Any], eval2: Dict[str, Any]
    ) -> int:
        """
        Compare two hand evaluations.

        Returns:
            -1 if eval1 is better than eval2
             0 if they are equal (true tie)
             1 if eval2 is better than eval1
        """
        score1 = eval1.get("hand_score", 9999)
        score2 = eval2.get("hand_score", 9999)

        if score1 < score2:
            return -1
        elif score1 > score2:
            return 1
        else:
            return 0

    def determine_winners(
        self, player_evaluations: List[tuple]
    ) -> List[tuple]:
        """
        Determine winners from a list of (player, evaluation) tuples.

        Args:
            player_evaluations: List of (player_object, hand_evaluation_dict) tuples

        Returns:
            List of (player, evaluation) tuples for all winners (ties included)
        """
        if not player_evaluations:
            return []

        # Sort by hand score (lower = better)
        sorted_hands = sorted(
            player_evaluations, key=lambda x: x[1].get("hand_score", 9999)
        )

        # Find all players with the best (lowest) score
        best_score = sorted_hands[0][1].get("hand_score", 9999)
        winners = [
            item
            for item in sorted_hands
            if item[1].get("hand_score", 9999) == best_score
        ]

        return winners
```

---

### gto_decision_engine_adapter.py

**Path**: `backend/core/gto_decision_engine_adapter.py`

**Size**: 5.9 KB

```python
"""
GTO Decision Engine Adapter for PPSM Integration

This adapter bridges the GTODecisionEngine to the DecisionEngineProtocol
interface that PPSM expects, enabling GTO-based hand generation.
"""

from typing import Optional, Tuple
from .pure_poker_state_machine import DecisionEngineProtocol
from .poker_types import ActionType, GameState
from .decision_engine_v2 import GTODecisionEngine


class GTODecisionEngineAdapter(DecisionEngineProtocol):
    """
    Adapter that wraps GTODecisionEngine to implement DecisionEngineProtocol.
    
    This bridges the interface differences:
    - GTODecisionEngine: get_decision(player_index, game_state) -> Dict[str, Any]
    - DecisionEngineProtocol: get_decision(player_name, game_state) -> tuple(ActionType, amount)
    """
    
    def __init__(self, num_players: int = 6):
        """Initialize the GTO adapter with specified number of players."""
        self.gto_engine = GTODecisionEngine(num_players)
        self.num_players = num_players
        self.current_hand = 0
        
    def get_decision(self, player_name: str, game_state: GameState) -> Optional[Tuple[ActionType, Optional[float]]]:
        """
        Get GTO decision for a player, converting to PPSM format.
        
        Args:
            player_name: Name/UID of the player making the decision
            game_state: Current game state from PPSM
            
        Returns:
            Tuple of (ActionType, amount) or None if no decision available
        """
        try:
            # Convert game_state to dict format that GTODecisionEngine expects
            game_state_dict = self._convert_game_state_to_dict(game_state)
            
            # Find player index from player_name
            player_index = self._find_player_index(player_name, game_state)
            if player_index is None:
                print(f"‚ö†Ô∏è GTO Adapter: Player {player_name} not found in game state")
                return None
            
            # Get decision from GTO engine
            decision = self.gto_engine.get_decision(player_index, game_state_dict)
            if not decision:
                print(f"‚ö†Ô∏è GTO Adapter: No decision available for player {player_name}")
                return None
            
            # Convert GTO decision format to PPSM format
            action_type = self._convert_action_type(decision.get('action'))
            amount = decision.get('amount', 0.0)
            
            print(f"üéØ GTO Adapter: {player_name} -> {action_type} {amount if amount else ''}")
            return (action_type, amount if amount > 0 else None)
            
        except Exception as e:
            print(f"‚ùå GTO Adapter error: {e}")
            return None
    
    def has_decision_for_player(self, player_name: str) -> bool:
        """Check if GTO engine has a decision for the specified player."""
        # GTO engine always has decisions available
        return True
    
    def reset_for_new_hand(self) -> None:
        """Reset GTO engine state for a new hand."""
        self.gto_engine.reset()
        self.current_hand += 1
        print(f"üîÑ GTO Adapter: Reset for hand {self.current_hand}")
    
    def _convert_game_state_to_dict(self, game_state: GameState) -> dict:
        """Convert PPSM GameState to dict format for GTODecisionEngine."""
        try:
            # Extract relevant information from GameState
            return {
                'street': getattr(game_state, 'street', 'preflop'),
                'pot': getattr(game_state, 'pot', 0.0),
                'current_bet': getattr(game_state, 'current_bet', 0.0),
                'players': getattr(game_state, 'players', []),
                'board_cards': getattr(game_state, 'board_cards', []),
                'dealer_position': getattr(game_state, 'dealer_position', 0),
                'small_blind': getattr(game_state, 'small_blind', 1.0),
                'big_blind': getattr(game_state, 'big_blind', 2.0)
            }
        except Exception as e:
            print(f"‚ö†Ô∏è GTO Adapter: Error converting game state: {e}")
            return {}
    
    def _find_player_index(self, player_name: str, game_state: GameState) -> Optional[int]:
        """Find player index by name/UID in the game state."""
        try:
            players = getattr(game_state, 'players', [])
            for i, player in enumerate(players):
                if (hasattr(player, 'name') and player.name == player_name) or \
                   (hasattr(player, 'player_uid') and player.player_uid == player_name):
                    return i
            return None
        except Exception as e:
            print(f"‚ö†Ô∏è GTO Adapter: Error finding player index: {e}")
            return None
    
    def _convert_action_type(self, action) -> ActionType:
        """Convert action to PPSM ActionType enum."""
        try:
            # Handle both string and ActionType inputs
            if isinstance(action, ActionType):
                return action
            
            action_str = str(action or "").upper()
            if action_str == "FOLD":
                return ActionType.FOLD
            elif action_str == "CHECK":
                return ActionType.CHECK
            elif action_str == "CALL":
                return ActionType.CALL
            elif action_str == "BET":
                return ActionType.BET
            elif action_str == "RAISE":
                return ActionType.RAISE
            elif action_str == "ALL_IN":
                return ActionType.ALL_IN
            else:
                print(f"‚ö†Ô∏è GTO Adapter: Unknown action type: {action_str}, defaulting to CHECK")
                return ActionType.CHECK
        except Exception as e:
            print(f"‚ö†Ô∏è GTO Adapter: Error converting action type: {e}")
            return ActionType.CHECK


def create_gto_decision_engine(num_players: int = 6) -> GTODecisionEngineAdapter:
    """Factory function to create a GTO decision engine adapter."""
    return GTODecisionEngineAdapter(num_players)
```

---

### gto_to_hand_converter.py

**Path**: `backend/core/gto_to_hand_converter.py`

**Size**: 18.1 KB

```python
#!/usr/bin/env python3
"""
Converter from current GTO JSON format to comprehensive Hand model.

This module converts our existing GTO session data format into the new
standardized Hand model format, enabling:
- Precise action replay in Hands Review
- Advanced hand analysis capabilities  
- Statistical aggregation across sessions
- Future interoperability with other poker tools
"""

import json
from typing import Dict, List, Any, Optional
from datetime import datetime

import sys
import os
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..'))

from backend.core.hand_model import (
    Hand, HandMetadata, Seat, Street, StreetState, Action, ActionType, 
    PostingMeta, Pot, PotShare, ShowdownEntry, Variant
)

class GTOToHandConverter:
    """Converts GTO session data to standardized Hand model format."""
    
    @staticmethod
    def _normalize_player_id(name: str = None, index: int = None) -> str:
        """
        Canonical player ID normalizer.
        Always returns format: "Player1", "Player2", etc. (no spaces)
        """
        if name and name.startswith('Player'):
            # Extract number from existing player name
            import re
            match = re.search(r'(\d+)', name)
            if match:
                return f"Player{match.group(1)}"
        
        if index is not None:
            return f"Player{index + 1}"
        
        # Fallback
        return name or "Player1"
    
    @staticmethod
    def convert_gto_hand(gto_data: Dict[str, Any]) -> Hand:
        """
        Convert a single GTO hand from our current format to Hand model.
        
        Args:
            gto_data: Dictionary containing GTO hand data with keys:
                - id: Hand identifier
                - initial_state: Player and game setup
                - actions: List of actions taken
                - final_state: End results
                
        Returns:
            Hand object with complete standardized data
        """
        converter = GTOToHandConverter()
        return converter._convert_hand(gto_data)
    
    def _convert_hand(self, gto_data: Dict[str, Any]) -> Hand:
        """Internal conversion method."""
        
        # Extract basic data
        hand_id = gto_data.get('id', 'unknown')
        initial_state = gto_data.get('initial_state', {})
        actions = gto_data.get('actions', [])
        final_state = gto_data.get('final_state', {})
        
        # Create metadata
        metadata = self._create_metadata(hand_id, initial_state, gto_data)
        
        # Create seats from initial player data
        seats = self._create_seats(initial_state.get('players', []))
        
        # Convert actions to standardized format
        streets = self._convert_actions_to_streets(actions, initial_state)
        
        # Add RETURN_UNCALLED actions for proper pot accounting
        self._append_return_uncalled(streets, final_state)
        
        # Build pots from final state
        pots = self._create_pots(final_state, seats)
        
        # Create showdown entries (if any)
        showdown = self._create_showdown(final_state, seats)
        
        # Calculate final stacks
        final_stacks = self._calculate_final_stacks(final_state, seats)
        
        return Hand(
            metadata=metadata,
            seats=seats,
            hero_player_uid=seats[0].player_uid if seats else None,  # Fixed: use hero_player_uid
            streets=streets,
            pots=pots,
            showdown=showdown,
            final_stacks=final_stacks
        )
    
    def _create_metadata(self, hand_id: str, initial_state: Dict[str, Any], 
                        gto_data: Dict[str, Any]) -> HandMetadata:
        """Create hand metadata from GTO data."""
        
        # Extract hole cards from initial player data
        hole_cards = {}
        players_data = initial_state.get('players', [])
        
        for i, player_data in enumerate(players_data):
            player_id = self._normalize_player_id(name=player_data.get('name'), index=i)
            
            # Try different possible keys for hole cards
            cards = (player_data.get('hole_cards') or 
                    player_data.get('cards') or 
                    player_data.get('hand') or 
                    [])
            
            if cards and cards != ['**', '**']:
                hole_cards[player_id] = cards
                print(f"üÉè CONVERTER: Extracted hole cards for {player_id}: {cards}")
            else:
                print(f"‚ö†Ô∏è  CONVERTER: No hole cards found for {player_id}")
        
        return HandMetadata(
            table_id="GTO-Table-1",
            hand_id=hand_id,
            variant=Variant.NLHE,
            max_players=len(initial_state.get('players', [])),
            small_blind=initial_state.get('small_blind', 5),
            big_blind=initial_state.get('big_blind', 10),
            ante=0,  # GTO sessions don't use antes
            rake=0,  # GTO sessions don't have rake
            currency="CHIPS",
            hole_cards=hole_cards,  # Add hole cards to metadata
            started_at_utc=datetime.now().isoformat() + "Z",
            ended_at_utc=None,  # Will be set when complete
            run_count=1,
            session_type="gto",
            bot_strategy="gto_v1",
            analysis_tags=["gto_generated", "bot_vs_bot"]
        )
    
    def _create_seats(self, players_data: List[Dict[str, Any]]) -> List[Seat]:
        """Create seat information from player data."""
        seats = []
        
        for i, player_data in enumerate(players_data):
            # Use normalized player ID consistently
            player_id = GTOToHandConverter._normalize_player_id(
                name=player_data.get('name'), 
                index=i
            )
            seat = Seat(
                seat_no=i + 1,
                player_uid=player_id,  # Fixed: use player_uid instead of player_id
                display_name=player_data.get('name', f'Player {i+1}'),  # Display can have spaces
                starting_stack=int(player_data.get('stack', 1000)),
                is_button=(i == 0)  # First player as button for simplicity
            )
            seats.append(seat)
            
        return seats
    
    def _convert_actions_to_streets(self, actions: List[Dict[str, Any]], 
                                  initial_state: Dict[str, Any]) -> Dict[Street, StreetState]:
        """Convert action list to street-organized format."""
        
        streets = {
            Street.PREFLOP: StreetState(),
            Street.FLOP: StreetState(),
            Street.TURN: StreetState(),
            Street.RIVER: StreetState(),
        }
        
        # Add blind postings first
        self._add_blind_postings(streets[Street.PREFLOP], initial_state)
        
        # Sort actions by any order field, or use list order
        sorted_actions = sorted(actions, key=lambda a: a.get('order', actions.index(a)))
        
        action_order = len(streets[Street.PREFLOP].actions) + 1  # Continue from blind postings
        
        for action_data in sorted_actions:
            street_name = action_data.get('street', 'preflop').upper()
            
            # Map street names
            if street_name == 'PREFLOP_BETTING':
                street = Street.PREFLOP
            elif street_name == 'FLOP_BETTING':
                street = Street.FLOP
            elif street_name == 'TURN_BETTING':
                street = Street.TURN
            elif street_name == 'RIVER_BETTING':
                street = Street.RIVER
            else:
                street = Street.PREFLOP  # Default
            
            # Convert action
            action = self._convert_single_action(action_data, action_order)
            if action:
                streets[street].actions.append(action)
                action_order += 1
        
        return streets
    
    def _append_return_uncalled(self, streets: Dict[Street, StreetState], final_state: Dict[str, Any]):
        """Add RETURN_UNCALLED actions for proper pot accounting when hands end with uncalled bets."""
        
        # Find the last street with actions
        last_street = None
        for street in [Street.RIVER, Street.TURN, Street.FLOP, Street.PREFLOP]:
            if streets[street].actions:
                last_street = street
                break
        
        if not last_street:
            return
            
        last_street_actions = streets[last_street].actions
        if not last_street_actions:
            return
            
        # Look for pattern: bet/raise followed by only folds
        last_aggressor = None
        last_aggressor_amount = 0
        actions_after_aggression = []
        
        # Find the last aggressive action (bet/raise)
        for i, action in enumerate(last_street_actions):
            if action.action in [ActionType.BET, ActionType.RAISE]:
                last_aggressor = action.actor_id
                last_aggressor_amount = action.amount
                actions_after_aggression = last_street_actions[i+1:]
        
        # Check if all actions after aggression are folds
        if last_aggressor and actions_after_aggression:
            all_folds = all(action.action == ActionType.FOLD for action in actions_after_aggression)
            
            if all_folds and last_aggressor_amount > 0:
                # Add RETURN_UNCALLED action
                next_order = max(action.order for action in last_street_actions) + 1
                
                return_action = Action(
                    order=next_order,
                    street=last_street,
                    actor_uid=last_aggressor,  # Fixed: use actor_uid instead of actor_id
                    action=ActionType.RETURN_UNCALLED,
                    amount=last_aggressor_amount,
                    note=f"Uncalled bet of ${last_aggressor_amount} returned"
                )
                
                streets[last_street].actions.append(return_action)
    
    def _add_blind_postings(self, preflop_street: StreetState, initial_state: Dict[str, Any]):
        """Add blind posting actions to preflop."""
        
        sb_amount = initial_state.get('small_blind', 5)
        bb_amount = initial_state.get('big_blind', 10)
        players = initial_state.get('players', [])
        
        if len(players) >= 2:
            # In our GTO format, blinds are already posted in the initial state
            # We infer them from player current_bet values
            
            order = 1
            for i, player in enumerate(players):
                current_bet = player.get('current_bet', 0)
                
                if current_bet == sb_amount:
                    # Small blind
                    player_id = GTOToHandConverter._normalize_player_id(
                        name=player.get('name'), index=i
                    )
                    preflop_street.actions.append(Action(
                        order=order,
                        street=Street.PREFLOP,
                        actor_uid=player_id,  # Fixed: use actor_uid instead of actor_id
                        action=ActionType.POST_BLIND,
                        amount=sb_amount,
                        to_amount=sb_amount,
                        posting_meta=PostingMeta(blind_type="SB")
                    ))
                    order += 1
                    
                elif current_bet == bb_amount:
                    # Big blind
                    player_id = GTOToHandConverter._normalize_player_id(
                        name=player.get('name'), index=i
                    )
                    preflop_street.actions.append(Action(
                        order=order,
                        street=Street.PREFLOP,
                        actor_uid=player_id,  # Fixed: use actor_uid instead of actor_id
                        action=ActionType.POST_BLIND,
                        amount=bb_amount,
                        to_amount=bb_amount,
                        posting_meta=PostingMeta(blind_type="BB")
                    ))
                    order += 1
    
    def _convert_single_action(self, action_data: Dict[str, Any], order: int) -> Optional[Action]:
        """Convert a single action from GTO format to Hand model format."""
        
        try:
            # Extract action details
            player_index = action_data.get('player_index', 0)
            action_str = action_data.get('action', 'fold').lower()
            amount = action_data.get('amount', 0.0)
            street_name = action_data.get('street', 'preflop')
            explanation = action_data.get('explanation', '')
            
            # Map action types
            action_type_map = {
                'fold': ActionType.FOLD,
                'check': ActionType.CHECK,
                'call': ActionType.CALL,
                'bet': ActionType.BET,
                'raise': ActionType.RAISE
            }
            
            action_type = action_type_map.get(action_str, ActionType.FOLD)
            
            # Convert street name
            street_map = {
                'preflop': Street.PREFLOP,
                'flop': Street.FLOP, 
                'turn': Street.TURN,
                'river': Street.RIVER
            }
            street = street_map.get(street_name.lower(), Street.PREFLOP)
            
            # Use normalized player ID
            player_id = GTOToHandConverter._normalize_player_id(index=player_index)
            
            # Calculate to_amount for raises/bets
            to_amount = None
            if action_type in [ActionType.BET, ActionType.RAISE, ActionType.CALL]:
                to_amount = int(amount)
            
            return Action(
                order=order,
                street=street,
                actor_uid=player_id,  # Fixed: use actor_uid instead of actor_id
                action=action_type,
                amount=int(amount),
                to_amount=to_amount,
                all_in=False,  # We don't track all-ins in current GTO format
                note=f"GTO: {explanation}" if explanation else None
            )
            
        except Exception as e:
            print(f"Warning: Failed to convert action {action_data}: {e}")
            return None
    
    def _create_pots(self, final_state: Dict[str, Any], seats: List[Seat]) -> List[Pot]:
        """Create pot information from final state."""
        
        final_pot = final_state.get('pot', 0)
        if final_pot <= 0:
            return []
        
        # For GTO sessions, create a single main pot
        # All players are eligible (we don't track side pots in current format)
        eligible_players = [seat.player_uid for seat in seats]
        
        pot = Pot(
            amount=int(final_pot),
            eligible_player_uids=eligible_players,  # Fixed: use eligible_player_uids
            shares=[]  # Will be filled by showdown analysis
        )
        
        # Determine winner(s) from final state
        players_final = final_state.get('players', [])
        max_stack = 0
        winners = []
        
        for player_data in players_final:
            stack = player_data.get('stack', 0)
            if stack > max_stack:
                max_stack = stack
                winners = [player_data.get('name', 'Unknown')]
            elif stack == max_stack and stack > 0:
                winners.append(player_data.get('name', 'Unknown'))
        
        # Award pot to winner(s)
        if winners:
            share_amount = pot.amount // len(winners)
            remainder = pot.amount % len(winners)
            
            for i, winner in enumerate(winners):
                pot.shares.append(PotShare(
                    player_uid=winner,  # Fixed: use player_uid instead of player_id
                    amount=share_amount + (1 if i < remainder else 0)
                ))
        
        return [pot]
    
    def _create_showdown(self, final_state: Dict[str, Any], seats: List[Seat]) -> List[ShowdownEntry]:
        """Create showdown entries from final state."""
        
        # For GTO sessions, we don't typically have showdown info
        # Return empty list for now - could be enhanced later
        return []
    
    def _calculate_final_stacks(self, final_state: Dict[str, Any], seats: List[Seat]) -> Dict[str, int]:
        """Calculate final stack sizes."""
        
        final_stacks = {}
        players_final = final_state.get('players', [])
        
        # Map by name to get final stacks
        for player_data in players_final:
            name = player_data.get('name', 'Unknown')
            stack = int(player_data.get('stack', 0))
            final_stacks[name] = stack
        
        # Ensure all seats have entries
        for seat in seats:
            if seat.player_uid not in final_stacks:
                final_stacks[seat.player_uid] = seat.starting_stack
        
        return final_stacks

def convert_gto_file(input_path: str, output_path: str) -> None:
    """
    Convert a GTO JSON file to Hand model format.
    
    Args:
        input_path: Path to input GTO JSON file
        output_path: Path to write converted Hand JSON file
    """
    try:
        with open(input_path, 'r') as f:
            gto_data = json.load(f)
        
        hand = GTOToHandConverter.convert_gto_hand(gto_data)
        hand.save_json(output_path)
        
        print(f"‚úÖ Converted {input_path} -> {output_path}")
        print(f"   Hand ID: {hand.metadata.hand_id}")
        print(f"   Actions: {len(hand.get_all_actions())}")
        print(f"   Final pot: ${hand.get_total_pot()}")
        
    except Exception as e:
        print(f"‚ùå Conversion failed: {e}")
        raise

if __name__ == "__main__":
    # Test conversion with our existing GTO data
    test_files = [
        "cycle_test_hand.json",
        "gto_hand_for_verification.json"
    ]
    
    for test_file in test_files:
        try:
            output_file = test_file.replace('.json', '_hand_model.json')
            convert_gto_file(test_file, output_file)
        except FileNotFoundError:
            print(f"‚ö†Ô∏è  Test file {test_file} not found - skipping")
        except Exception as e:
            print(f"‚ùå Failed to convert {test_file}: {e}")
    
    print("‚úÖ GTO to Hand model conversion test complete!")
```

---

### gui_models.py

**Path**: `backend/core/gui_models.py`

**Size**: 32.4 KB

```python
# filename: gui_models.py
"""
Data Models and Structures for Strategy Development GUI

Contains all data classes and core business logic without UI dependencies.

REVISION HISTORY:
================
Version 1.0 (2025-07-29) - Initial Version
- Created as part of a major refactoring of the GUI.
- Centralizes all non-UI data structures like HandStrengthTier and StrategyData.
- Decouples the core application state from the view components.
Version 2.0 (2025-07-29) - Professional Theme Enhancement
- Updated with professional color scheme and improved visual hierarchy.
- Enhanced tier colors for better distinction and accessibility.
- Improved font definitions and theme consistency.
"""

import json
import os
from typing import List, Dict, Any, Optional, Set
from dataclasses import dataclass, field

# --- Professional Poker App Theme (User's Final Design) ---
THEME = {
    # Base Colors - User's final professional color scheme
    # Default: PokerStars Classic Pro (professional diamond weave)
    "table_felt": "#1B4D3A",
    "table_rail": "#2E4F76",  # Dark Steel Blue (table border)
    "primary_bg": "#191C22",  # Dark Charcoal (main app background)
    "secondary_bg": "#2E3C54",  # Deep Navy Slate (menu bar background)
    "widget_bg": "#191C22",  # Dark Charcoal (interactive elements)
    # Text Colors - User's final professional scheme
    "text": "#8A98A8",  # Light Slate Gray (player name text)
    "text_secondary": "#697287",  # Slate Gray (menu separator)
    "text_muted": "#80A7B5",  # Light Steel Blue (menu inactive item)
    "text_dark": "#25282D",  # Very Dark Gray (code file name text)
    "text_gold": "#FFD700",  # Gold (chips/money positive)
    "text_hover": "#A0BBCD",  # Pale Steel Blue (menu hover item)
    # Action Button Colors - Target image styling
    "button_call": "#1976D2",  # Blue for CALL (like target image)
    "button_call_hover": "#1565C0",  # Darker blue on hover
    "button_raise": "#D32F2F",  # Red for RAISE (like target image)
    "button_raise_hover": "#C62828",  # Darker red on hover
    "button_fold": "#616161",  # Gray for FOLD (like target image)
    "button_fold_hover": "#424242",  # Darker gray on hover
    "button_check": "#1976D2",  # Blue for CHECK (same as call)
    "button_check_hover": "#1565C0",  # Darker blue on hover
    "button_allin": "#FF6F00",  # Orange for ALL IN (like target image)
    "button_allin_hover": "#F57C00",  # Darker orange on hover
    # Card and Table Elements - User's final scheme
    "card_back": "#2E4F76",  # Dark Steel Blue (unified with border)
    "card_face": "#FFFFFF",  # White (clean, legible)
    "card_outline": "#191C22",  # Dark Charcoal (adds depth)
    "card_red": "#C0392B",  # Muted Crimson (softer on eyes)
    "card_black": "#2C3E50",  # Muted Black (matches theme darkness)
    # Menu Elements - User's final scheme
    "menu_active": "#3980A6",  # Teal Blue (selected menu highlight)
    "menu_inactive": "#80A7B5",  # Light Steel Blue (unselected menu text)
    "menu_hover": "#A0BBCD",  # Pale Steel Blue (on hover)
    "menu_separator": "#697287",  # Slate Gray (thin divider)
    "menu_alt_bg": "#95C1D2",  # Light Blue Background (alternative)
    "menu_alt_text": "#191C22",  # Dark Charcoal text on light background
    # Chip and Money Colors - User's final scheme
    "chip_gold": "#FFD700",  # Gold (high visibility)
    "chip_green": "#4CAF50",  # Medium Green (win/positive indicator)
    "chip_red": "#E53935",  # Bright Red (loss/negative indicator)
    "chip_black": "#424242",  # Black (high value chips)
    "chip_blue": "#2196F3",  # Blue (low value chips)
    "chip_white": "#FFFFFF",  # White (standard chips)
    "chip_purple": "#9C27B0",  # Purple (very high value chips)
    # Status and Feedback Colors
    "success": "#4CAF50",  # Success/positive actions
    "warning": "#FF9800",  # Warnings
    "error": "#F44336",  # Errors/negative actions
    "info": "#2196F3",  # Information
    # Betting and Pot Elements
    "pot_gold": "#FFD700",  # Gold pot display
    "bet_chip": "#4CAF50",  # Bet chip color
    "border_active": "#FFD700",  # Active player border (gold)
    "border_inactive": "#555555",  # Inactive elements
    # Legacy compatibility (maintain existing functionality)
    "bg": "#1a1a1a",
    "bg_dark": "#2a2a2a",
    "bg_light": "#3a3a3a",
    "fg": "#ffffff",
    "accent": "#4CAF50",
    "accent_primary": "#FFB366",  # Pale orange for GTO simulation buttons
    "accent_secondary": "#4CAF50",  # Legacy accent_secondary (green)
    "accent_danger": "#F44336",  # Legacy accent_danger (red)
    "border": "#555555",  # Legacy border color
    "font_family": "Arial",
    "font_size": 11,
    "tier_colors": {
        "Elite": "#D32F2F",  # Red for premium hands
        "Premium": "#2196F3",  # Blue for strong hands
        "Gold": "#FF9800",  # Orange for good hands
        "Silver": "#4CAF50",  # Green for playable hands
        "Bronze": "#9C27B0",  # Purple for speculative hands
    },
}

FONTS = {
    # Modern poker app fonts (clean, readable, professional)
    "main": ("Segoe UI", 12),
    "title": ("Segoe UI", 18, "bold"),
    "header": ("Segoe UI", 14, "bold"),
    "small": ("Segoe UI", 10),
    # Large text for placeholders and emphasis
    "large": ("Segoe UI", 16, "bold"),
    # Poker-specific fonts
    "player_name": ("Segoe UI", 13, "bold"),  # Player names
    "stack_amount": ("Segoe UI", 16, "bold"),  # Stack amounts
    "bet_amount": ("Segoe UI", 18, "bold"),  # Bet/pot amounts (prominent)
    "action_button": ("Segoe UI", 14, "bold"),  # Action button text
    "cards": ("Consolas", 14, "bold"),  # Monospace for cards
    "pot_display": ("Segoe UI", 20, "bold"),  # Large pot display
    # Legacy compatibility
    "stack_bet": ("Segoe UI", 16, "bold"),
}

# --- COMPREHENSIVE PREFLOP EQUITY TABLE ---
PREFLOP_EQUITY_TABLE = {
    "AA": 85,
    "KK": 82,
    "QQ": 80,
    "JJ": 77,
    "TT": 75,
    "99": 72,
    "88": 70,
    "77": 68,
    "66": 66,
    "55": 64,
    "44": 62,
    "33": 60,
    "22": 58,
    "AKs": 67,
    "AQs": 66,
    "AJs": 65,
    "ATs": 64,
    "A9s": 61,
    "A8s": 60,
    "A7s": 59,
    "A6s": 58,
    "A5s": 57,
    "A4s": 56,
    "A3s": 55,
    "A2s": 54,
    "AKo": 65,
    "AQo": 64,
    "AJo": 63,
    "ATo": 62,
    "A9o": 58,
    "A8o": 57,
    "A7o": 56,
    "A6o": 55,
    "A5o": 54,
    "A4o": 53,
    "A3o": 52,
    "A2o": 51,
    "KQs": 63,
    "KJs": 62,
    "KTs": 61,
    "K9s": 58,
    "K8s": 57,
    "K7s": 56,
    "K6s": 55,
    "K5s": 54,
    "K4s": 53,
    "K3s": 52,
    "K2s": 51,
    "KQo": 61,
    "KJo": 60,
    "KTo": 59,
    "K9o": 55,
    "K8o": 54,
    "K7o": 53,
    "K6o": 52,
    "K5o": 51,
    "K4o": 50,
    "K3o": 49,
    "K2o": 48,
    "QJs": 60,
    "QTs": 59,
    "Q9s": 57,
    "Q8s": 56,
    "Q7s": 55,
    "Q6s": 54,
    "Q5s": 53,
    "Q4s": 52,
    "Q3s": 51,
    "Q2s": 50,
    "QJo": 58,
    "QTo": 57,
    "Q9o": 54,
    "Q8o": 53,
    "Q7o": 52,
    "Q6o": 51,
    "Q5o": 50,
    "Q4o": 49,
    "Q3o": 48,
    "Q2o": 47,
    "JTs": 58,
    "J9s": 56,
    "J8s": 55,
    "J7s": 54,
    "J6s": 53,
    "J5s": 52,
    "J4s": 51,
    "J3s": 50,
    "J2s": 49,
    "JTo": 57,
    "J9o": 53,
    "J8o": 52,
    "J7o": 51,
    "J6o": 50,
    "J5o": 49,
    "J4o": 48,
    "J3o": 47,
    "J2o": 46,
    "T9s": 55,
    "T8s": 54,
    "T7s": 53,
    "T6s": 52,
    "T5s": 51,
    "T4s": 50,
    "T3s": 49,
    "T2s": 48,
    "T9o": 52,
    "T8o": 51,
    "T7o": 50,
    "T6o": 49,
    "T5o": 48,
    "T4o": 47,
    "T3o": 46,
    "T2o": 45,
    "98s": 54,
    "97s": 53,
    "96s": 52,
    "95s": 51,
    "94s": 50,
    "93s": 49,
    "92s": 48,
    "98o": 51,
    "97o": 50,
    "96o": 49,
    "95o": 48,
    "94o": 47,
    "93o": 46,
    "92o": 45,
    "87s": 53,
    "86s": 52,
    "85s": 51,
    "84s": 50,
    "83s": 49,
    "82s": 48,
    "87o": 50,
    "86o": 49,
    "85o": 48,
    "84o": 47,
    "83o": 46,
    "82o": 45,
    "76s": 52,
    "75s": 51,
    "74s": 50,
    "73s": 49,
    "72s": 48,
    "76o": 49,
    "75o": 48,
    "74o": 47,
    "73o": 46,
    "72o": 45,
    "65s": 51,
    "64s": 50,
    "63s": 49,
    "62s": 48,
    "65o": 48,
    "64o": 47,
    "63o": 46,
    "62o": 45,
    "54s": 50,
    "53s": 49,
    "52s": 48,
    "54o": 47,
    "53o": 46,
    "52o": 45,
    "43s": 49,
    "42s": 48,
    "43o": 46,
    "42o": 45,
    "32s": 48,
    "32o": 45,
}


@dataclass
class HandStrengthTier:
    """
    Represents a single tier of hands with a name, HS range, and color.

    REVISION HISTORY:
    ================
    Version 1.0 (2025-07-29) - Initial Version
    - Created to model a hand tier as a dataclass.
    - Stores name, HS range, color, and a list of associated poker hands.
    """

    name: str
    min_hs: int
    max_hs: int
    color: str
    hands: Set[str] = field(default_factory=set)


@dataclass
class StrategyData:
    """
    A central data model to hold the entire state of a strategy.

    REVISION HISTORY:
    ================
    Version 1.0 (2025-07-29) - Initial Version
    - Created to act as a single source of truth for the application's state.
    - Manages the list of tiers and the full strategy dictionary.
    Version 1.1 (2025-07-29) - Strategy File Support
    - Added support for loading strategy data from JSON files.
    - Added current strategy file tracking.
    Version 2.0 (2025-07-29) - Professional Theme Enhancement
    - Updated with professional color scheme and improved visual hierarchy.
    - Enhanced tier colors for better distinction and accessibility.
    """

    tiers: List[HandStrengthTier] = field(default_factory=list)
    strategy_dict: Dict[str, Any] = field(default_factory=dict)
    current_strategy_file: Optional[str] = None

    def add_tier(self, tier: HandStrengthTier):
        """Adds a new tier and sorts the list by strength."""
        self.tiers.append(tier)
        self.tiers.sort(key=lambda t: t.min_hs, reverse=True)

    def remove_tier(self, index: int):
        """Removes a tier by its index."""
        if 0 <= index < len(self.tiers):
            self.tiers.pop(index)

    def load_default_tiers(self):
        """Loads modern 5-tier system with memorable boundaries."""
        tier_colors = {
            "Premium": "#FF0000",  # Bright Red - The Monsters
            "Strong": "#FFA500",  # Orange - The Workhorses
            "Playable": "#FFD700",  # Gold - The Bread & Butter
            "Speculative": "#00FF00",  # Green - The Connectors
            "Marginal": "#87CEEB",  # Sky Blue - The Situational
        }

        self.tiers = [
            HandStrengthTier(
                "Premium",
                80,
                100,
                tier_colors["Premium"],
                {"AA", "KK", "QQ", "AKs", "JJ", "AKo", "AQs", "TT"},
            ),
            HandStrengthTier(
                "Strong",
                65,
                79,
                tier_colors["Strong"],
                {
                    "AQo",
                    "AJs",
                    "KQs",
                    "99",
                    "AJo",
                    "KJs",
                    "ATs",
                    "88",
                    "KQo",
                    "QJs",
                    "KTs",
                },
            ),
            HandStrengthTier(
                "Playable",
                50,
                64,
                tier_colors["Playable"],
                {
                    "77",
                    "A9s",
                    "A8s",
                    "JTs",
                    "66",
                    "KJo",
                    "QTs",
                    "A7s",
                    "A5s",
                    "55",
                    "A6s",
                    "A4s",
                    "T9s",
                },
            ),
            HandStrengthTier(
                "Speculative",
                35,
                49,
                tier_colors["Speculative"],
                {
                    "44",
                    "A3s",
                    "A2s",
                    "K9s",
                    "33",
                    "Q9s",
                    "J9s",
                    "98s",
                    "22",
                    "87s",
                },
            ),
            HandStrengthTier(
                "Marginal",
                20,
                34,
                tier_colors["Marginal"],
                {"K8s", "76s", "65s", "54s", "T8s"},
            ),
        ]
        self.current_strategy_file = None
        self.strategy_dict = self._create_strategy_from_tiers()

    def load_strategy_from_file(self, filename: str = None) -> bool:
        """Loads strategy data from a JSON file or generates and saves default strategy."""
        try:
            # If no filename provided or file doesn't exist, generate and save
            # default
            if filename is None or not os.path.exists(filename):
                print(
                    f"üìÅ Generating default strategy (file not found: {filename})"
                )
                self.load_default_tiers()

                # Save the default strategy to modern_strategy.json
                default_filename = "modern_strategy.json"
                self.save_strategy_to_file(default_filename)
                self.current_strategy_file = default_filename
                print(f"üíæ Saved default strategy to {default_filename}")
                return True

            with open(filename, "r") as f:
                strategy_data = json.load(f)

            self.strategy_dict = strategy_data
            self._create_tiers_from_strategy(strategy_data)
            self.current_strategy_file = filename
            return True
        except Exception as e:
            print(f"‚ö†Ô∏è Error loading strategy file, generating default: {e}")
            self.load_default_tiers()

            # Save the default strategy to modern_strategy.json
            default_filename = "modern_strategy.json"
            self.save_strategy_to_file(default_filename)
            self.current_strategy_file = default_filename
            print(f"üíæ Saved default strategy to {default_filename}")
            return True

    def _create_tiers_from_strategy(self, strategy_data: Dict[str, Any]):
        """Creates tiers from strategy data."""
        self.tiers.clear()
        hand_strength_table = strategy_data.get(
            "hand_strength_tables", {}
        ).get("preflop", {})
        if not hand_strength_table:
            self.load_default_tiers()
            return

        tier_colors = {
            "Premium": "#FF0000",
            "Strong": "#FFA500",
            "Playable": "#FFD700",
            "Speculative": "#00FF00",
            "Marginal": "#87CEEB",
        }
        strength_groups = {}
        for hand, strength in hand_strength_table.items():
            if strength >= 80:
                tier_name, min_hs, max_hs = "Premium", 80, 100
            elif strength >= 65:
                tier_name, min_hs, max_hs = "Strong", 65, 79
            elif strength >= 50:
                tier_name, min_hs, max_hs = "Playable", 50, 64
            elif strength >= 35:
                tier_name, min_hs, max_hs = "Speculative", 35, 49
            elif strength >= 20:
                tier_name, min_hs, max_hs = "Marginal", 20, 34
            else:
                continue  # Skip unplayable hands

            if tier_name not in strength_groups:
                strength_groups[tier_name] = {
                    "hands": set(),
                    "min_hs": min_hs,
                    "max_hs": max_hs,
                    "color": tier_colors[tier_name],
                }
            strength_groups[tier_name]["hands"].add(hand)

        for tier_name, data in strength_groups.items():
            self.tiers.append(HandStrengthTier(name=tier_name, **data))
        self.tiers.sort(key=lambda t: t.min_hs, reverse=True)

    def save_strategy_to_file(self, filename: str) -> bool:
        """Saves current strategy data to a JSON file."""
        try:
            strategy_data = self._create_strategy_from_tiers()
            with open(filename, "w") as f:
                json.dump(strategy_data, f, indent=2)
            self.current_strategy_file = filename
            return True
        except Exception:
            return False

    def _create_strategy_from_tiers(self) -> Dict[str, Any]:
        """Creates strategy data from tiers with improved GTO hand strength scores."""
        # Use improved GTO hand strength scores for default strategy
        improved_hand_strength = {
            "AA": 100,
            "KK": 95,
            "QQ": 90,
            "AKs": 85,
            "JJ": 80,
            "AKo": 80,
            "AQs": 80,
            "TT": 80,
            "AQo": 75,
            "AJs": 75,
            "KQs": 75,
            "99": 70,
            "AJo": 70,
            "KJs": 70,
            "ATs": 70,
            "88": 65,
            "KQo": 65,
            "QJs": 65,
            "KTs": 65,
            "77": 60,
            "A9s": 60,
            "A8s": 60,
            "JTs": 60,
            "66": 55,
            "KJo": 55,
            "QTs": 55,
            "A7s": 55,
            "A5s": 55,
            "55": 50,
            "A6s": 50,
            "A4s": 50,
            "T9s": 50,
            "44": 45,
            "A3s": 45,
            "A2s": 45,
            "K9s": 45,
            "33": 40,
            "Q9s": 40,
            "J9s": 40,
            "98s": 40,
            "22": 35,
            "87s": 35,
            "K8s": 30,
            "76s": 30,
            "65s": 25,
            "54s": 25,
            "T8s": 20,
        }

        hand_strength_table = {}

        # Use existing strategy data if available, otherwise use improved
        # scores
        existing_hand_strength = self.strategy_dict.get(
            "hand_strength_tables", {}
        ).get("preflop", {})

        for tier in self.tiers:
            for hand in tier.hands:
                # Use existing HS score if available, otherwise use improved
                # scores
                if hand in existing_hand_strength:
                    hand_strength_table[hand] = existing_hand_strength[hand]
                elif hand in improved_hand_strength:
                    hand_strength_table[hand] = improved_hand_strength[hand]
                elif hand in PREFLOP_EQUITY_TABLE:
                    hand_strength_table[hand] = PREFLOP_EQUITY_TABLE[hand]

        # Complete postflop strategy with all positions and streets
        postflop_strategy = {
            "pfa": {
                "flop": {
                    "UTG": {
                        "val_thresh": 35,
                        "check_thresh": 15,
                        "sizing": 0.75,
                    },
                    "MP": {
                        "val_thresh": 30,
                        "check_thresh": 15,
                        "sizing": 0.75,
                    },
                    "CO": {
                        "val_thresh": 25,
                        "check_thresh": 10,
                        "sizing": 0.75,
                    },
                    "BTN": {
                        "val_thresh": 20,
                        "check_thresh": 10,
                        "sizing": 0.75,
                    },
                    "SB": {
                        "val_thresh": 25,
                        "check_thresh": 15,
                        "sizing": 0.75,
                    },
                },
                "turn": {
                    "UTG": {
                        "val_thresh": 40,
                        "check_thresh": 20,
                        "sizing": 0.8,
                    },
                    "MP": {
                        "val_thresh": 35,
                        "check_thresh": 20,
                        "sizing": 0.8,
                    },
                    "CO": {
                        "val_thresh": 30,
                        "check_thresh": 15,
                        "sizing": 0.8,
                    },
                    "BTN": {
                        "val_thresh": 25,
                        "check_thresh": 15,
                        "sizing": 0.8,
                    },
                    "SB": {
                        "val_thresh": 30,
                        "check_thresh": 20,
                        "sizing": 0.8,
                    },
                },
                "river": {
                    "UTG": {
                        "val_thresh": 45,
                        "check_thresh": 25,
                        "sizing": 1.0,
                    },
                    "MP": {
                        "val_thresh": 40,
                        "check_thresh": 25,
                        "sizing": 1.0,
                    },
                    "CO": {
                        "val_thresh": 35,
                        "check_thresh": 20,
                        "sizing": 1.0,
                    },
                    "BTN": {
                        "val_thresh": 30,
                        "check_thresh": 20,
                        "sizing": 1.0,
                    },
                    "SB": {
                        "val_thresh": 35,
                        "check_thresh": 25,
                        "sizing": 1.0,
                    },
                },
            },
            "caller": {
                "flop": {
                    "UTG": {
                        "val_thresh": 25,
                        "check_thresh": 10,
                        "sizing": 0.75,
                    },
                    "MP": {
                        "val_thresh": 20,
                        "check_thresh": 10,
                        "sizing": 0.75,
                    },
                    "CO": {
                        "val_thresh": 15,
                        "check_thresh": 5,
                        "sizing": 0.75,
                    },
                    "BTN": {
                        "val_thresh": 15,
                        "check_thresh": 5,
                        "sizing": 0.75,
                    },
                    "SB": {
                        "val_thresh": 20,
                        "check_thresh": 10,
                        "sizing": 0.75,
                    },
                },
                "turn": {
                    "UTG": {
                        "val_thresh": 30,
                        "check_thresh": 15,
                        "sizing": 0.8,
                    },
                    "MP": {
                        "val_thresh": 25,
                        "check_thresh": 15,
                        "sizing": 0.8,
                    },
                    "CO": {
                        "val_thresh": 20,
                        "check_thresh": 10,
                        "sizing": 0.8,
                    },
                    "BTN": {
                        "val_thresh": 20,
                        "check_thresh": 10,
                        "sizing": 0.8,
                    },
                    "SB": {
                        "val_thresh": 25,
                        "check_thresh": 15,
                        "sizing": 0.8,
                    },
                },
                "river": {
                    "UTG": {
                        "val_thresh": 35,
                        "check_thresh": 20,
                        "sizing": 1.0,
                    },
                    "MP": {
                        "val_thresh": 30,
                        "check_thresh": 20,
                        "sizing": 1.0,
                    },
                    "CO": {
                        "val_thresh": 25,
                        "check_thresh": 15,
                        "sizing": 1.0,
                    },
                    "BTN": {
                        "val_thresh": 25,
                        "check_thresh": 15,
                        "sizing": 1.0,
                    },
                    "SB": {
                        "val_thresh": 30,
                        "check_thresh": 20,
                        "sizing": 1.0,
                    },
                },
            },
        }

        # Create complete strategy structure
        strategy_data = {
            "hand_strength_tables": {
                "preflop": hand_strength_table,
                "postflop": {
                    # Made Hands
                    "high_card": 5,
                    "pair": 15,
                    "top_pair": 30,
                    "over_pair": 35,
                    "two_pair": 45,
                    "set": 60,
                    "straight": 70,
                    "flush": 80,
                    "full_house": 90,
                    "quads": 100,
                    "straight_flush": 120,
                    # Draws
                    "gutshot_draw": 12,
                    "open_ended_draw": 18,
                    "flush_draw": 20,
                    "combo_draw": 35,
                    # Special Situations
                    "nut_flush_draw": 25,
                    "nut_straight_draw": 22,
                    "overcard_draw": 8,
                    "backdoor_flush": 3,
                    "backdoor_straight": 2,
                    "pair_plus_draw": 28,
                    "set_plus_draw": 65,
                },
            },
            "preflop": {
                "open_rules": {
                    # Tighter: Only plays hands like AJ+ / KQ / 77+
                    "UTG": {"threshold": 60, "sizing": 3.0},
                    # Opens up slightly to include hands like A8s+ / KJs / 55+
                    "MP": {"threshold": 55, "sizing": 3.0},
                    # Wider range, includes suited connectors and more
                    # broadways
                    "CO": {"threshold": 48, "sizing": 2.5},
                    # Very wide range, plays most suited hands and any pair
                    "BTN": {"threshold": 40, "sizing": 2.5},
                    # A bit tighter than the button due to being out of
                    # position
                    "SB": {"threshold": 50, "sizing": 3.0},
                },
                "vs_raise": {
                    # 3-bet only with premium hands like TT+ / AQ+
                    "UTG": {
                        "value_thresh": 75,
                        "call_thresh": 65,
                        "sizing": 3.0,
                    },
                    # Call with strong hands like AJ / KQ / 99
                    "MP": {
                        "value_thresh": 72,
                        "call_thresh": 62,
                        "sizing": 3.0,
                    },
                    # Can call with a wider range in position
                    "CO": {
                        "value_thresh": 70,
                        "call_thresh": 60,
                        "sizing": 2.5,
                    },
                    # Very wide calling range in position
                    "BTN": {
                        "value_thresh": 68,
                        "call_thresh": 55,
                        "sizing": 2.5,
                    },
                    # Balanced approach from small blind
                    "SB": {
                        "value_thresh": 70,
                        "call_thresh": 60,
                        "sizing": 3.0,
                    },
                },
            },
            "postflop": postflop_strategy,
        }

        return strategy_data

    def get_current_strategy_file(self) -> Optional[str]:
        """Returns the current strategy file name."""
        return self.current_strategy_file

    def get_strategy_file_display_name(self) -> str:
        """Returns a display name for the current strategy file."""
        if self.current_strategy_file:
            return os.path.basename(self.current_strategy_file)
        return "Default Strategy"

    def get_available_strategy_files(self) -> List[str]:
        """Returns a list of available strategy files in the current directory."""
        strategy_files = []
        for file in os.listdir("."):
            if file.endswith(".json") and "strategy" in file.lower():
                strategy_files.append(file)
        return sorted(strategy_files)


class GridSettings:
    """
    Static class to manage grid size configurations.

    REVISION HISTORY:
    ================
    Version 1.0 (2025-07-29) - Initial Version
    - Centralizes grid size settings to be accessible by any UI component.
    """

    _SIZES = ["1", "2", "3", "4", "5", "6", "7", "8"]
    _CONFIGS = {
        "1": {
            "font": ("Helvetica", 10),  # Was size 3
            "button_width": 35,
            "button_height": 35,
            "label_width": 10,
        },
        "2": {
            "font": ("Helvetica", 12),  # Was size 4
            "button_width": 40,
            "button_height": 40,
            "label_width": 11,
        },
        "3": {
            "font": ("Helvetica", 14),  # Was size 5
            "button_width": 45,
            "button_height": 45,
            "label_width": 12,
        },
        "4": {
            "font": ("Helvetica", 16),  # Was size 6
            "button_width": 60,
            "button_height": 60,
            "label_width": 13,
        },
        "5": {
            "font": ("Helvetica", 18),  # Was size 7
            "button_width": 65,
            "button_height": 65,
            "label_width": 14,
        },
        "6": {
            "font": ("Helvetica", 20),  # Was size 8
            "button_width": 70,
            "button_height": 70,
            "label_width": 15,
        },
        "7": {
            "font": ("Helvetica", 22),  # New larger size
            "button_width": 75,
            "button_height": 75,
            "label_width": 16,
        },
        "8": {
            "font": ("Helvetica", 24),  # New largest size
            "button_width": 80,
            "button_height": 80,
            "label_width": 17,
        },
    }
    HIGHLIGHT_COLORS = [
        "#FF4444",  # Red
        "#44AAFF",  # Blue
        "#FFAA44",  # Orange
        "#44FF44",  # Green
        "#FF8844",  # Orange-Red
    ]

    @staticmethod
    def get_all_sizes() -> List[str]:
        """Returns all available grid sizes."""
        return GridSettings._SIZES.copy()

    @staticmethod
    def get_size_config(size: str) -> Dict:
        """Returns the configuration for a given size."""
        return GridSettings._CONFIGS.get(size, GridSettings._CONFIGS["4"])

    @staticmethod
    def calculate_button_size_for_grid(
        grid_width: int, grid_height: int, size: str
    ) -> Dict:
        """Calculate optimal button size for a given grid size."""
        config = GridSettings.get_size_config(size)
        max_width = grid_width // 13  # 13 columns
        max_height = grid_height // 13  # 13 rows

        # Use the smaller of the calculated size or the config size
        button_width = min(config["button_width"], max_width)
        button_height = min(config["button_height"], max_height)

        return {
            "button_width": button_width,
            "button_height": button_height,
            "font": config["font"],
        }


class HandFormatHelper:
    """
    Helper class for hand format conversions and validations.
    """

    @staticmethod
    def get_alternative_formats(hand: str) -> List[str]:
        """Get alternative formats for a hand (e.g., AhKs -> AKs, AKs -> AhKs)."""
        if len(hand) == 4 and hand.endswith(("h", "d", "c", "s")):
            # Convert AhKs to AKs
            return [hand[0] + hand[2] + hand[3]]
        elif len(hand) == 3 and hand.endswith(("s", "o")):
            # Convert AKs to AhKs (example)
            return [hand[0] + "h" + hand[1] + hand[2]]
        return [hand]

    @staticmethod
    def normalize_hand_format(hand: str) -> str:
        """Normalize hand format to standard notation."""
        # Remove any extra spaces and convert to uppercase
        hand = hand.strip().upper()

        # Handle different input formats
        if len(hand) == 4 and hand.endswith(("H", "D", "C", "S")):
            # AhKs format
            return hand[0] + hand[2] + hand[3].lower()
        elif len(hand) == 3 and hand.endswith(("S", "O")):
            # AKs format
            return hand
        elif len(hand) == 2:
            # AA format (pocket pair)
            return hand
        else:
            # Unknown format, return as is
            return hand


class FileOperations:
    """
    Helper class for file operations.
    """

    @staticmethod
    def load_strategy(filename: str) -> Optional[Dict]:
        """Load strategy from file."""
        try:
            with open(filename, "r") as f:
                return json.load(f)
        except Exception:
            return None

    @staticmethod
    def save_strategy(strategy: Dict, filename: str) -> bool:
        """Save strategy to file."""
        try:
            with open(filename, "w") as f:
                json.dump(strategy, f, indent=2)
            return True
        except Exception:
            return False
```

---

### hand_model.py

**Path**: `backend/core/hand_model.py`

**Size**: 19.6 KB

```python
#!/usr/bin/env python3
"""
Production-ready NLHE hand data model with JSON serialization.

This module provides a comprehensive data structure for representing
No Limit Hold'em poker hands with complete action histories, side pots,
showdowns, and metadata. Supports 2-9 players with antes, straddles,
and all poker scenarios.

Key features:
- Complete action ordering for deterministic replay
- Side pot calculation and tracking  
- Robust JSON serialization with round-trip integrity
- Comprehensive metadata for analysis and statistics
- Fuzz-tested across all scenarios
"""

from __future__ import annotations
from dataclasses import dataclass, field, asdict
from enum import Enum
from typing import List, Dict, Optional, Any
import json

# =========================
# Basic card representation
# =========================

_RANKS = "23456789TJQKA"
_SUITS = "cdhs"  # clubs, diamonds, hearts, spades

def _validate_card_str(cs: str) -> None:
    """Validate card string format (e.g., 'As', 'Kh', '7c')."""
    if len(cs) != 2 or cs[0] not in _RANKS or cs[1] not in _SUITS:
        raise ValueError(f"Invalid card string: {cs}")

@dataclass(frozen=True)
class Card:
    """Card encoded as rank+suited char, e.g., 'As', 'Td', '7c'."""
    rank: str
    suit: str

    @staticmethod
    def from_str(s: str) -> "Card":
        """Create Card from string representation."""
        _validate_card_str(s)
        return Card(rank=s[0], suit=s[1])

    def to_str(self) -> str:
        """Convert Card to string representation."""
        return f"{self.rank}{self.suit}"

    def __str__(self) -> str:
        return self.to_str()

# =========================
# Enums
# =========================

class Variant(str, Enum):
    """Poker variant types."""
    NLHE = "NLHE"
    PLO = "PLO"  # Future extension
    STUD = "STUD"  # Future extension

class Street(str, Enum):
    """Betting street names."""
    PREFLOP = "PREFLOP"
    FLOP = "FLOP"
    TURN = "TURN"
    RIVER = "RIVER"

class ActionType(str, Enum):
    """All possible poker actions."""
    # Table setup / postings
    POST_ANTE = "POST_ANTE"
    POST_BLIND = "POST_BLIND"      # includes SB, BB, and dead blinds (see metadata fields)
    STRADDLE = "STRADDLE"
    POST_DEAD = "POST_DEAD"

    # Dealing markers (optional‚Äîuseful for complete replication)
    DEAL_HOLE = "DEAL_HOLE"
    DEAL_FLOP = "DEAL_FLOP"
    DEAL_TURN = "DEAL_TURN"
    DEAL_RIVER = "RIVER"

    # Betting actions
    CHECK = "CHECK"
    BET = "BET"
    CALL = "CALL"
    RAISE = "RAISE"
    FOLD = "FOLD"

    # Chips/cleanup
    RETURN_UNCALLED = "RETURN_UNCALLED"

    # Showdown
    SHOW = "SHOW"
    MUCK = "MUCK"

# =========================
# Core data structures
# =========================

@dataclass
class Seat:
    """Player seat information (canonical UID)."""
    seat_no: int
    player_uid: str
    display_name: Optional[str] = None
    starting_stack: int = 0  # in chips (or your base unit)
    is_button: bool = False

@dataclass
class PostingMeta:
    """Additional context for a POST_* action."""
    blind_type: Optional[str] = None  # "SB", "BB", "BB+Ante", "Dead", "Straddle", etc.

@dataclass
class Action:
    """One atomic action in order as it occurred."""
    order: int
    street: Street
    actor_uid: Optional[str]        # None for deal markers / system actions
    action: ActionType
    amount: int = 0                # Incremental chips put in with THIS action (0 for check/fold)
    to_amount: Optional[int] = None  # Player's total contribution on this street *after* this action
    all_in: bool = False
    note: Optional[str] = None     # free-form (e.g., "misdeal fix", "click raise", "timeout")
    posting_meta: Optional[PostingMeta] = None

@dataclass
class StreetState:
    """Holds board cards (as strings) and actions for a street."""
    board: List[str] = field(default_factory=list)   # e.g. FLOP: ["As","Kd","7c"], TURN append ["2h"]
    actions: List[Action] = field(default_factory=list)

@dataclass
class PotShare:
    """Distribution result for a single pot (main or side)."""
    player_uid: str
    amount: int          # chips collected from this pot

@dataclass
class Pot:
    """Pot information with eligibility and final distribution."""
    amount: int                  # total pot size before distribution (after rake taken if applicable)
    eligible_player_uids: List[str]   # who was eligible for this pot when it formed
    shares: List[PotShare] = field(default_factory=list)  # actual distribution at showdown

@dataclass
class ShowdownEntry:
    """Showdown information for a player."""
    player_uid: str
    hole_cards: Optional[List[str]] = None  # None if mucked unseen
    hand_rank: Optional[str] = None         # "Full House", "Two Pair", etc.
    hand_description: Optional[str] = None  # "Aces full of Kings", etc.
    spoke: Optional[bool] = None            # if table requires speech or reveal
    note: Optional[str] = None

@dataclass
class HandMetadata:
    """Complete hand metadata for analysis and tracking."""
    table_id: str
    hand_id: str
    variant: Variant = Variant.NLHE
    max_players: int = 9
    small_blind: int = 50    # chips
    big_blind: int = 100
    ante: int = 0            # per-player ante if any (can be 0)
    rake: int = 0            # total rake taken from table
    currency: str = "CHIPS"  # label only; no math
    started_at_utc: Optional[str] = None    # ISO timestamp
    ended_at_utc: Optional[str] = None      # ISO timestamp
    run_count: int = 1       # if you support "run it twice," increase and add boards
    
    # Extended metadata for our poker system
    session_type: Optional[str] = None  # "gto", "practice", "review"
    bot_strategy: Optional[str] = None   # "gto_v1", "loose_aggressive", etc.
    analysis_tags: List[str] = field(default_factory=list)  # ["premium_cards", "3bet_pot"]
    hole_cards: Dict[str, List[str]] = field(default_factory=dict)  # player_uid -> [card1, card2]

@dataclass
class Hand:
    """
    Full hand record, sufficient to reconstruct play exactly as recorded.
    
    This is the complete representation of a poker hand with all metadata,
    actions, board cards, and final results needed for analysis, replay,
    and statistical tracking.
    """
    metadata: HandMetadata
    seats: List[Seat]
    hero_player_uid: Optional[str] = None  # if you want to mark a perspective
    
    # Streets: store all actions and board per street for exact replay
    streets: Dict[Street, StreetState] = field(default_factory=lambda: {
        Street.PREFLOP: StreetState(),
        Street.FLOP: StreetState(),
        Street.TURN: StreetState(),
        Street.RIVER: StreetState(),
    })
    
    # Final state
    pots: List[Pot] = field(default_factory=list)
    showdown: List[ShowdownEntry] = field(default_factory=list)
    final_stacks: Dict[str, int] = field(default_factory=dict)  # player_uid -> ending stack

    # ------------- Serialization helpers -------------
    def to_dict(self) -> Dict[str, Any]:
        """Convert Hand to dictionary for JSON serialization."""
        def serialize(obj):
            if isinstance(obj, Enum):
                return obj.value
            if isinstance(obj, Card):
                return obj.to_str()
            if isinstance(obj, Hand):
                d = asdict(obj)
                # Fix Enums (Street keys) and nested enums
                d["streets"] = {
                    st.value: {
                        "board": s.board,
                        "actions": [
                            {
                                **{k: (v.value if isinstance(v, Enum) else v)
                                   for k, v in asdict(a).items()
                                   if k not in ("posting_meta", "street")},
                                "street": a.street.value,
                                "posting_meta": asdict(a.posting_meta) if a.posting_meta else None,
                            }
                            for a in s.actions
                        ]
                    } for st, s in obj.streets.items()
                }
                # Enums in metadata
                d["metadata"]["variant"] = obj.metadata.variant.value
                return d
            if _dataclass_isinstance(obj):
                return {k: serialize(v) for k, v in asdict(obj).items()}
            if isinstance(obj, list):
                return [serialize(x) for x in obj]
            if isinstance(obj, dict):
                return {serialize(k): serialize(v) for k, v in obj.items()}
            return obj

        return serialize(self)

    @staticmethod
    def from_dict(d: Dict[str, Any]) -> "Hand":
        """Create Hand from dictionary (JSON deserialization)."""
        # Metadata
        md = d["metadata"]
        metadata = HandMetadata(
            table_id=md["table_id"],
            hand_id=md["hand_id"],
            variant=Variant(md.get("variant", "NLHE")),
            max_players=md.get("max_players", 9),
            small_blind=md.get("small_blind", 50),
            big_blind=md.get("big_blind", 100),
            ante=md.get("ante", 0),
            rake=md.get("rake", 0),
            currency=md.get("currency", "CHIPS"),
            started_at_utc=md.get("started_at_utc"),
            ended_at_utc=md.get("ended_at_utc"),
            run_count=md.get("run_count", 1),
            session_type=md.get("session_type"),
            bot_strategy=md.get("bot_strategy"),
            analysis_tags=md.get("analysis_tags", []),
        )
        # Populate hole cards if present in serialized metadata
        if "hole_cards" in md and isinstance(md["hole_cards"], dict):
            try:
                metadata.hole_cards.update({
                    str(k): list(v) if isinstance(v, list) else v
                    for k, v in md["hole_cards"].items()
                })
            except Exception:
                pass
        # Add button seat if present (forward-compat)
        if "button_seat_no" in md:
            try:
                setattr(metadata, "button_seat_no", int(md["button_seat_no"]))
            except Exception:
                pass
        
        # Seats: accept either player_uid or legacy player_id; store as player_uid
        seats = []
        for s in d["seats"]:
            s2 = dict(s)
            if "player_id" in s2 and "player_uid" not in s2:
                s2["player_uid"] = s2.pop("player_id")
            seats.append(Seat(**s2))
        # Hero uid alias
        hero = d.get("hero_player_uid") or d.get("hero_player_id")
        
        # Streets
        streets: Dict[Street, StreetState] = {}
        streets_in = d.get("streets", {})
        for key, s in streets_in.items():
            st_enum = Street(key)
            actions_in: List[Dict[str, Any]] = s.get("actions", [])
            actions: List[Action] = []
            for a in actions_in:
                pm = a.get("posting_meta")
                a2 = dict(a)
                # actor id alias ‚Üí actor_uid
                if "actor_id" in a2 and "actor_uid" not in a2:
                    a2["actor_uid"] = a2.pop("actor_id")
                actions.append(Action(
                    order=a2["order"],
                    street=Street(a2["street"]),
                    actor_uid=a2.get("actor_uid"),
                    action=ActionType(a2["action"]),
                    amount=a2.get("amount", 0),
                    to_amount=a2.get("to_amount"),
                    all_in=a2.get("all_in", False),
                    note=a2.get("note"),
                    posting_meta=PostingMeta(**pm) if pm else None,
                ))
            streets[st_enum] = StreetState(board=s.get("board", []), actions=actions)

        # Pots
        pots = []
        for p in d.get("pots", []):
            p2 = dict(p)
            eligible = p2.get("eligible_player_uids") or p2.get("eligible_player_ids") or []
            shares_in = p2.get("shares", [])
            shares = []
            for ps in shares_in:
                ps2 = dict(ps)
                if "player_id" in ps2 and "player_uid" not in ps2:
                    ps2["player_uid"] = ps2.pop("player_id")
                shares.append(PotShare(**ps2))
            pots.append(Pot(
                amount=p2["amount"], 
                eligible_player_uids=eligible, 
                shares=shares
            ))

        # Showdown
        showdown = [ShowdownEntry(**sd) for sd in d.get("showdown", [])]
        final_stacks = d.get("final_stacks", {})

        return Hand(
            metadata=metadata,
            seats=seats,
            hero_player_uid=hero,
            streets=streets or {
                Street.PREFLOP: StreetState(),
                Street.FLOP: StreetState(),
                Street.TURN: StreetState(),
                Street.RIVER: StreetState(),
            },
            pots=pots,
            showdown=showdown,
            final_stacks=final_stacks,
        )

    # ------------- I/O convenience -------------
    def save_json(self, path: str) -> None:
        """Save Hand to JSON file."""
        with open(path, "w", encoding="utf-8") as f:
            json.dump(self.to_dict(), f, ensure_ascii=False, indent=2)

    @staticmethod
    def load_json(path: str) -> "Hand":
        """Load Hand from JSON file."""
        with open(path, "r", encoding="utf-8") as f:
            d = json.load(f)
        return Hand.from_dict(d)

    # ------------- Analysis helpers -------------
    def get_all_actions(self) -> List[Action]:
        """Get all actions across all streets in chronological order."""
        all_actions = []
        for street in [Street.PREFLOP, Street.FLOP, Street.TURN, Street.RIVER]:
            all_actions.extend(self.streets[street].actions)
        return sorted(all_actions, key=lambda a: a.order)

    def get_actions_for_player(self, player_id: str) -> List[Action]:
        """Get all actions for a specific player."""
        return [a for a in self.get_all_actions() if a.actor_id == player_id]

    def get_final_board(self) -> List[str]:
        """Get the final board cards (up to 5 cards)."""
        if self.streets[Street.RIVER].board:
            return self.streets[Street.RIVER].board
        elif self.streets[Street.TURN].board:
            return self.streets[Street.TURN].board
        elif self.streets[Street.FLOP].board:
            return self.streets[Street.FLOP].board
        else:
            return []

    def get_total_pot(self) -> int:
        """Get total pot size across all pots."""
        return sum(pot.amount for pot in self.pots)

    def get_player_total_investment(self, player_id: str) -> int:
        """Calculate total chips invested by a player across all streets."""
        total = 0
        for action in self.get_actions_for_player(player_id):
            if action.amount > 0:  # Only count chips put in, not folds/checks
                total += action.amount
        return total

    def get_player_winnings(self, player_id: str) -> int:
        """Get total winnings for a player from all pots."""
        total = 0
        for pot in self.pots:
            for share in pot.shares:
                if share.player_id == player_id:
                    total += share.amount
        return total

    def get_net_result(self, player_id: str) -> int:
        """Get net result (winnings - investment) for a player."""
        return self.get_player_winnings(player_id) - self.get_player_total_investment(player_id)

# ============
# Utilities
# ============

def _dataclass_isinstance(obj: Any) -> bool:
    """Check if object is a dataclass instance."""
    return hasattr(obj, "__dataclass_fields__")

# ============
# Example usage
# ============

if __name__ == "__main__":
    # Minimal illustrative example of a 3-handed hand
    hand = Hand(
        metadata=HandMetadata(
            table_id="Table-12", 
            hand_id="H#0001",
            small_blind=50, 
            big_blind=100, 
            ante=0, 
            rake=25,
            started_at_utc="2025-01-15T15:00:00Z",
            session_type="gto",
            bot_strategy="gto_v1",
            analysis_tags=["premium_cards", "3bet_pot"]
        ),
        seats=[
            Seat(seat_no=1, player_id="p1", display_name="Alice", starting_stack=10000, is_button=True),
            Seat(seat_no=2, player_id="p2", display_name="Bob",   starting_stack=12000),
            Seat(seat_no=3, player_id="p3", display_name="Cara",  starting_stack=8000),
        ],
        hero_player_id="p1",
    )

    # Preflop: blinds posted, hole cards dealt, actions
    hand.streets[Street.PREFLOP].actions.extend([
        Action(order=1, street=Street.PREFLOP, actor_id="p2", action=ActionType.POST_BLIND, amount=50,
               posting_meta=PostingMeta(blind_type="SB")),
        Action(order=2, street=Street.PREFLOP, actor_id="p3", action=ActionType.POST_BLIND, amount=100,
               posting_meta=PostingMeta(blind_type="BB")),
        Action(order=3, street=Street.PREFLOP, actor_id=None, action=ActionType.DEAL_HOLE, amount=0, 
               note="Dealt hole cards"),
        Action(order=4, street=Street.PREFLOP, actor_id="p1", action=ActionType.RAISE, amount=300, to_amount=300),
        Action(order=5, street=Street.PREFLOP, actor_id="p2", action=ActionType.CALL, amount=250, to_amount=300),
        Action(order=6, street=Street.PREFLOP, actor_id="p3", action=ActionType.CALL, amount=200, to_amount=300),
    ])

    # Flop board and actions
    hand.streets[Street.FLOP].board = ["As", "Kd", "7c"]
    hand.streets[Street.FLOP].actions.extend([
        Action(order=7, street=Street.FLOP, actor_id="p2", action=ActionType.CHECK),
        Action(order=8, street=Street.FLOP, actor_id="p3", action=ActionType.CHECK),
        Action(order=9, street=Street.FLOP, actor_id="p1", action=ActionType.BET, amount=400, to_amount=400),
        Action(order=10, street=Street.FLOP, actor_id="p2", action=ActionType.FOLD),
        Action(order=11, street=Street.FLOP, actor_id="p3", action=ActionType.CALL, amount=400, to_amount=400),
    ])

    # Turn
    hand.streets[Street.TURN].board = hand.streets[Street.FLOP].board + ["2h"]
    hand.streets[Street.TURN].actions.extend([
        Action(order=12, street=Street.TURN, actor_id="p3", action=ActionType.CHECK),
        Action(order=13, street=Street.TURN, actor_id="p1", action=ActionType.BET, amount=1000, to_amount=1000),
        Action(order=14, street=Street.TURN, actor_id="p3", action=ActionType.CALL, amount=1000, to_amount=1000),
    ])

    # River
    hand.streets[Street.RIVER].board = hand.streets[Street.TURN].board + ["Jh"]
    hand.streets[Street.RIVER].actions.extend([
        Action(order=15, street=Street.RIVER, actor_id="p3", action=ActionType.CHECK),
        Action(order=16, street=Street.RIVER, actor_id="p1", action=ActionType.BET, amount=2500, to_amount=2500),
        Action(order=17, street=Street.RIVER, actor_id="p3", action=ActionType.FOLD),
    ])

    # Pots & result
    hand.pots = [
        Pot(
            amount=5275,  # 900 preflop + 800 flop + 2000 turn + 2500 river - 25 rake
            eligible_player_ids=["p1", "p3"],  # p2 folded on flop
            shares=[PotShare(player_id="p1", amount=5275)]
        )
    ]

    hand.showdown = []  # Winner didn't need to show
    
    hand.final_stacks = {
        "p1": 10000 + 5275 - (300 + 400 + 1000 + 2500),  # won the pot
        "p2": 12000 - (50 + 250),  # folded flop
        "p3": 8000 - (100 + 200 + 400 + 1000),  # folded river
    }
    hand.metadata.ended_at_utc = "2025-01-15T15:03:12Z"

    # Test save & load
    hand.save_json("example_hand.json")
    loaded = Hand.load_json("example_hand.json")
    assert hand.to_dict() == loaded.to_dict()
    print("‚úÖ Hand model example: Saved and loaded successfully!")
    print(f"   Hand ID: {loaded.metadata.hand_id}")
    print(f"   Final pot: {loaded.get_total_pot()}")
    print(f"   Winner: p1 net result: +{loaded.get_net_result('p1')}")
```

---

### hand_model_decision_engine.py

**Path**: `backend/core/hand_model_decision_engine.py`

**Size**: 17.3 KB

```python
#!/usr/bin/env python3
"""
Decision engine based on the standardized Hand model format.

This replaces PreloadedDecisionEngine with a much more robust implementation
that uses the comprehensive Hand model for perfect action replay.
"""

import sys
import os
from typing import Dict, Any, Optional, List

# Add backend to path for imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', '..'))

from backend.core.hand_model import Hand, Street, ActionType, Action
from backend.core.decision_engine_v2 import DecisionEngine

class HandModelDecisionEngine(DecisionEngine):
    """
    Decision engine that replays actions from a standardized Hand model.
    
    This provides much more reliable action replay than PreloadedDecisionEngine
    by using the comprehensive Hand data structure with proper action ordering,
    street organization, and complete metadata.
    """
    
    @staticmethod
    def _canon(player_id: str) -> str:
        """Canonicalize player ID for matching. Handles both 'Player1' and 'Player 1' formats."""
        if not player_id:
            return ""
        # Remove spaces and convert to lowercase for comparison
        return player_id.replace(' ', '').lower()
    
    def __init__(self, hand: Hand, fpsm=None):
        """
        Initialize with a Hand model object.
        
        Args:
            hand: Complete Hand object with all actions and metadata
            fpsm: Optional FPSM reference for hands review street advancement
        """
        self.hand = hand
        self.fpsm = fpsm  # Optional FPSM reference for street advancement
        self.actions_by_street = self._organize_actions_by_street()
        self.current_action_index = 0
        self.current_street = Street.PREFLOP
        # Get all actions for replay (excluding system actions like DEAL_HOLE)
        self.actions_for_replay = self._get_player_actions()
        self.total_actions = len(self.actions_for_replay)
        
        print(f"üéØ HAND_MODEL_ENGINE: Initialized with {self.total_actions} player actions")
    
    def _get_player_actions(self) -> List[Action]:
        """Get all player actions (excluding system actions like DEAL_HOLE)."""
        player_actions = []
        
        # Get all actions from all streets
        all_actions = self.hand.get_all_actions()
        
        # Filter out system actions and blind actions (since blinds are posted automatically)
        # Keep only actual betting decisions
        betting_action_types = {
            ActionType.CHECK, ActionType.BET, 
            ActionType.CALL, ActionType.RAISE, ActionType.FOLD
        }
        
        for action in all_actions:
            if action.action in betting_action_types and action.actor_uid:
                player_actions.append(action)
            elif action.action == ActionType.POST_BLIND:
                print(f"üîÑ HAND_MODEL_ENGINE: Skipping POST_BLIND action (blinds already posted)")
        
        print(f"üéØ HAND_MODEL_ENGINE: Found {len(player_actions)} player actions out of {len(all_actions)} total actions")
        
        # Sort by street first (preflop, flop, turn, river), then by order within street
        street_order = {Street.PREFLOP: 0, Street.FLOP: 1, Street.TURN: 2, Street.RIVER: 3}
        sorted_actions = sorted(player_actions, key=lambda a: (street_order.get(a.street, 99), a.order))
        
        # Debug: Verify chronological order is correct
        print(f"üéØ HAND_MODEL_ENGINE: Actions now in chronological order (first 4):")
        for i, action in enumerate(sorted_actions[:4]):
            print(f"  {i}: {action.actor_uid} {action.action.value} {action.amount} (street: {action.street})")
        
        return sorted_actions
    
    def get_session_info(self) -> Dict[str, Any]:
        """Get information about the current decision session."""
        return {
            "hand_id": getattr(self.hand.metadata, 'hand_id', 'Unknown'),
            "total_actions": self.total_actions,
            "current_action": self.current_action_index,
            "current_street": self.current_street.name if hasattr(self.current_street, 'name') else str(self.current_street),
            "engine_type": "HandModelDecisionEngine",
            "session_complete": self.is_session_complete()
        }
        print(f"   Hand ID: {self.hand.metadata.hand_id}")
        print(f"   Players: {len(self.hand.seats)}")
        self._log_action_summary()
    
    def _organize_actions_by_street(self) -> Dict[Street, List[Action]]:
        """Organize actions by street for easy access."""
        return {
            street: street_state.actions
            for street, street_state in self.hand.streets.items()
        }
    
    def _get_betting_actions(self) -> List[Action]:
        """Get only the betting actions (exclude blind postings and deal markers)."""
        betting_actions = []
        
        for street in [Street.PREFLOP, Street.FLOP, Street.TURN, Street.RIVER]:
            for action in self.actions_by_street.get(street, []):
                # Include only actual betting decisions, not postings or deals
                if action.action in [ActionType.CHECK, ActionType.BET, ActionType.CALL, 
                                   ActionType.RAISE, ActionType.FOLD]:
                    betting_actions.append(action)
        
        # Sort by street first (preflop, flop, turn, river), then by order within street
        street_order = {Street.PREFLOP: 0, Street.FLOP: 1, Street.TURN: 2, Street.RIVER: 3}
        return sorted(betting_actions, key=lambda a: (street_order.get(a.street, 99), a.order))
    
    def _log_action_summary(self):
        """Log summary of actions for debugging."""
        street_counts = {}
        for action in self.actions_for_replay:
            street = action.street
            if street not in street_counts:
                street_counts[street] = 0
            street_counts[street] += 1
        
        print(f"üéØ ACTION_SUMMARY: {street_counts}")
    
    def get_decision(self, player_index: int, game_state: Dict[str, Any]) -> Dict[str, Any]:
        """
        Get the next decision for the specified player.
        
        Args:
            player_index: Index of player who needs to act
            game_state: Current game state
            
        Returns:
            Dictionary with action details
        """
        # Check if we've exhausted all actions
        if self.current_action_index >= self.total_actions:
            print(f"üõ°Ô∏è HAND_MODEL_ENGINE: No more actions ({self.current_action_index}/{self.total_actions})")
            return self._default_action(player_index)
        
        # Get current player's UID and street from game state
        current_player_uid = None
        current_street = None
        try:
            # game_state['players'] is a list of dicts, not Player objects
            players = game_state.get('players', [])
            if player_index < len(players):
                # Try to get player_uid from the dict, fallback to name/position
                player_dict = players[player_index]
                current_player_uid = (
                    player_dict.get('player_uid') or 
                    player_dict.get('name') or 
                    f"seat{player_dict.get('position', player_index + 1)}"
                )
            
            # Get current street from game state
            current_street = str(game_state.get('state', 'preflop')).lower()
            # Map FPSM state names to street names
            street_mapping = {
                'preflop': 'preflop',
                'preflop_betting': 'preflop',
                'flop': 'flop', 
                'flop_betting': 'flop',
                'turn': 'turn',
                'turn_betting': 'turn', 
                'river': 'river',
                'river_betting': 'river',
                'deal_flop': 'flop',
                'deal_turn': 'turn', 
                'deal_river': 'river'
            }
            current_street = street_mapping.get(current_street, current_street)
            
        except Exception as e:
            print(f"‚ùå HAND_MODEL_ENGINE: Error getting current player/street: {e}")
            pass
        
        # Find the next action for the current player on the current street
        original_index = self.current_action_index
        while self.current_action_index < self.total_actions:
            next_action = self.actions_for_replay[self.current_action_index]
            actor_uid = getattr(next_action, 'actor_uid', None)
            action_street = str(getattr(next_action, 'street', 'preflop')).lower()
            
            # Normalize action street names (handle Street.PREFLOP -> street.preflop)
            if action_street.startswith('street.'):
                action_street = action_street.replace('street.', '')
            elif '.' in action_street:
                action_street = action_street.split('.')[-1]
            
            print(f"üîç HAND_MODEL_ENGINE: Action {self.current_action_index + 1}/{self.total_actions}")
            print(f"   Action player: {actor_uid}")
            print(f"   Current player: {current_player_uid} (index {player_index})")
            print(f"   Action street: {action_street}")
            print(f"   Current street: {current_street}")
            print(f"   Action: {next_action.action.value}, Amount: {next_action.amount}")
            
            # Check if this action belongs to the current player AND current street
            player_match = str(actor_uid).lower() == str(current_player_uid).lower()
            street_match = action_street == current_street
            
            if player_match and street_match:
                # Found matching action
                decision = self._convert_action_to_decision(next_action, player_index)
                decision['actor_index'] = player_index
                decision['actor_uid'] = actor_uid
                
                # Advance to next action
                self.current_action_index += 1
                return decision
            else:
                # Skip this action, it's for a different player or street
                if not player_match:
                    print(f"üîÑ HAND_MODEL_ENGINE: Skipping action for {actor_uid}, looking for {current_player_uid}")
                elif not street_match:
                    print(f"üîÑ HAND_MODEL_ENGINE: Street mismatch - action is {action_street}, FPSM is on {current_street}")
                    
                    # HANDS REVIEW: Manually advance FPSM street if needed
                    if hasattr(self, '_advance_fpsm_street_if_needed'):
                        street_advanced = self._advance_fpsm_street_if_needed(current_street, action_street, game_state)
                        if street_advanced:
                            print(f"üîß HAND_MODEL_ENGINE: Advanced FPSM from {current_street} to {action_street}")
                            # Retry this action with the updated street
                            continue
                    
                    print(f"üîÑ HAND_MODEL_ENGINE: Skipping {action_street} action, currently on {current_street}")
                self.current_action_index += 1
        
        # No matching action found
        print(f"üõ°Ô∏è HAND_MODEL_ENGINE: No action found for player {current_player_uid} (index {player_index})")
        return self._default_action(player_index)
    
    def _convert_action_to_decision(self, action: Action, player_index: int) -> Dict[str, Any]:
        """Convert Hand model Action to decision engine format."""
        
        # Map ActionType to our decision format
        action_type_map = {
            ActionType.FOLD: 'fold',
            ActionType.CHECK: 'check', 
            ActionType.CALL: 'call',
            ActionType.BET: 'bet',
            ActionType.RAISE: 'raise'
        }
        
        action_str = action_type_map.get(action.action, 'fold')
        
        return {
            'action': action.action,  # Keep ActionType enum
            'amount': float(action.amount),
            'explanation': f"[Hand Model] {action_str.title()} from {getattr(action,'actor_uid',None)}. {action.note or 'Replaying recorded action.'}",
            'confidence': 1.0,
            'decision_number': self.current_action_index + 1,
            'street': action.street.value,
            'original_order': action.order
        }
    
    def _default_action(self, player_index: int) -> Dict[str, Any]:
        """Return a default action when no more actions available."""
        return {
            'action': ActionType.CHECK,
            'amount': 0.0,
            'explanation': f"[Hand Model] No more preloaded actions available for Player {str(player_index + 1)}",
            'confidence': 0.0,
            'decision_number': self.current_action_index + 1
        }
    
    def is_session_complete(self) -> bool:
        """Check if all actions have been replayed."""
        return self.current_action_index >= self.total_actions
    
    def get_progress(self) -> Dict[str, Any]:
        """Get replay progress information."""
        return {
            'current_action': self.current_action_index,
            'total_actions': self.total_actions,
            'progress_percent': (self.current_action_index / max(1, self.total_actions)) * 100,
            'actions_remaining': max(0, self.total_actions - self.current_action_index)
        }
    
    def reset(self):
        """Reset the engine to the beginning of the hand."""
        self.current_action_index = 0
        self.current_street = Street.PREFLOP
        print(f"üîÑ HAND_MODEL_ENGINE: Reset to beginning ({self.total_actions} actions available)")
    
    def _advance_fpsm_street_if_needed(self, current_street: str, target_street: str, game_state: dict) -> bool:
        """
        Manually advance FPSM street for hands review mode.
        
        Args:
            current_street: Current FPSM street (e.g., 'preflop')
            target_street: Target street from action (e.g., 'flop')
            game_state: Current game state
            
        Returns:
            True if street was advanced, False otherwise
        """
        if not self.fpsm:
            return False
            
        # Define street progression
        street_progression = ['preflop', 'flop', 'turn', 'river']
        
        try:
            current_idx = street_progression.index(current_street)
            target_idx = street_progression.index(target_street)
        except ValueError:
            print(f"‚ùå STREET_ADVANCE: Unknown street - current: {current_street}, target: {target_street}")
            return False
        
        # Only advance forward, not backward
        if target_idx <= current_idx:
            return False
            
        print(f"üîß STREET_ADVANCE: Advancing FPSM from {current_street} to {target_street}")
        
        # Manually update FPSM state for hands review
        try:
            # Update the street directly
            self.fpsm.game_state.street = target_street
            
            # Update the FPSM state to the appropriate betting state
            state_mapping = {
                'preflop': 'PREFLOP_BETTING',
                'flop': 'FLOP_BETTING', 
                'turn': 'TURN_BETTING',
                'river': 'RIVER_BETTING'
            }
            
            if target_street in state_mapping:
                from .poker_types import PokerState
                new_state = getattr(PokerState, state_mapping[target_street])
                self.fpsm.current_state = new_state
                print(f"üîß STREET_ADVANCE: Set FPSM state to {new_state}")
            
            # Reset betting for new street (but preserve pot)
            self.fpsm.game_state.current_bet = 0.0
            for player in self.fpsm.game_state.players:
                player.current_bet = 0.0
            
            print(f"üîß STREET_ADVANCE: Successfully advanced to {target_street}")
            return True
            
        except Exception as e:
            print(f"‚ùå STREET_ADVANCE: Failed to advance street: {e}")
            return False

# Test the engine with our converted data
if __name__ == "__main__":
    from backend.core.hand_model import Hand
    
    # Test with converted hand data
    test_files = [
        "cycle_test_hand_hand_model.json",
        "gto_hand_for_verification_hand_model.json"
    ]
    
    for test_file in test_files:
        try:
            print(f"\nüß™ Testing HandModelDecisionEngine with {test_file}")
            print("=" * 60)
            
            hand = Hand.load_json(test_file)
            engine = HandModelDecisionEngine(hand)
            
            print(f"Hand loaded: {hand.metadata.hand_id}")
            print(f"Total actions for replay: {engine.total_actions}")
            
            # Test getting a few decisions
            for i in range(min(3, engine.total_actions)):
                decision = engine.get_decision(0, {})  # Test with player 0
                print(f"Decision {i+1}: {decision['action'].value} ${decision['amount']:.2f}")
                
                if engine.is_session_complete():
                    break
            
            progress = engine.get_progress()
            print(f"Progress: {progress['current_action']}/{progress['total_actions']} ({progress['progress_percent']:.1f}%)")
            
        except FileNotFoundError:
            print(f"‚ö†Ô∏è  Test file {test_file} not found - run converter first")
        except Exception as e:
            print(f"‚ùå Test failed for {test_file}: {e}")
    
    print("\n‚úÖ HandModelDecisionEngine test complete!")
```

---

### json_hands_database.py

**Path**: `backend/core/json_hands_database.py`

**Size**: 7.0 KB

```python
#!/usr/bin/env python3
"""
JSON Hands Database Loader

A specialized loader for our tested and validated JSON hands database.
This ensures the GUI uses our latest 130-hand collection that passed
all comprehensive tests.
"""

import json
from pathlib import Path
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from enum import Enum

# Define needed classes directly (no longer dependent on hands_database module)


class HandCategory(Enum):
    """Hand categories for organization."""

    LEGENDARY = "legendary"
    PRACTICE = "practice"
    TAGGED = "tagged"


@dataclass
class HandMetadata:
    """Unified hand metadata for all hand types."""

    id: str
    name: str
    category: HandCategory
    subcategory: str
    source_file: str
    date: Optional[str] = None
    description: str = ""
    study_notes: str = ""
    difficulty_rating: int = 1


@dataclass
class ParsedHand:
    """Complete hand data with metadata and game information."""

    metadata: HandMetadata
    game_info: Dict[str, Any]
    players: List[Dict[str, Any]]
    actions: Dict[str, List[Dict[str, Any]]]
    board: Dict[str, Any]
    result: Dict[str, Any]
    raw_data: Dict[str, Any]


@dataclass
class JSONHandMetadata:
    """Metadata for JSON hands."""

    id: str
    name: str
    source: str = "json_database"
    created_at: str = "2024-01-01"
    hand_category: str = "legendary"
    description: str = ""
    lesson: str = ""


class JSONHandsDatabase:
    """Database loader for our validated JSON hands database."""

    def __init__(
        self, json_file_path: str = "data/clean_poker_hands_flat.json"
    ):
        self.json_file_path = Path(json_file_path)
        self.hands: List[ParsedHand] = []
        self.raw_data: Dict[str, Any] = {}

    def load_all_hands(self) -> Dict[HandCategory, List[ParsedHand]]:
        """Load all hands from the JSON database."""
        hands_by_category = {
            HandCategory.LEGENDARY: [],
            HandCategory.PRACTICE: [],
            HandCategory.TAGGED: [],
        }

        if not self.json_file_path.exists():
            print(f"‚ùå JSON hands database not found: {self.json_file_path}")
            return hands_by_category

        try:
            # Load JSON data
            with open(self.json_file_path, "r", encoding="utf-8") as f:
                self.raw_data = json.load(f)

            hands_data = self.raw_data.get("hands", [])
            print(f"üìö Loading {len(hands_data)} hands from JSON database...")

            # Convert each hand to ParsedHand format
            for hand_data in hands_data:
                parsed_hand = self._convert_json_hand(hand_data)
                if parsed_hand:
                    self.hands.append(parsed_hand)
                    hands_by_category[HandCategory.LEGENDARY].append(
                        parsed_hand
                    )

            print(
                f"‚úÖ Successfully loaded {len(self.hands)} legendary hands from JSON"
            )
            return hands_by_category

        except Exception as e:
            print(f"‚ùå Error loading JSON hands database: {e}")
            import traceback

            traceback.print_exc()
            return hands_by_category

    def _convert_json_hand(
        self, hand_data: Dict[str, Any]
    ) -> Optional[ParsedHand]:
        """Convert JSON hand data to ParsedHand format."""
        try:
            # Extract basic info
            hand_id = hand_data.get("id", "Unknown")
            hand_name = hand_data.get("name", "Unknown Hand")

            # Create metadata
            metadata_dict = hand_data.get("metadata", {})
            lesson = metadata_dict.get("lesson", "")
            if not lesson and "meta" in hand_data:
                lesson = hand_data["meta"].get("lesson", "")

            metadata = JSONHandMetadata(
                id=hand_id,
                name=hand_name,
                source="json_database",
                created_at=metadata_dict.get("created_at", "2024-01-01"),
                hand_category=metadata_dict.get("hand_category", "legendary"),
                description=metadata_dict.get(
                    "description", f"Hand {hand_id}: {hand_name}"
                ),
                lesson=lesson,
            )

            # Convert to HandMetadata for compatibility
            hand_metadata = HandMetadata(
                id=hand_id,
                name=hand_name,
                category=HandCategory.LEGENDARY,
                subcategory=metadata.hand_category,
                source_file="json_database",
                date=metadata.created_at,
                description=metadata.description,
                study_notes=lesson,
                difficulty_rating=1,
            )

            # Create ParsedHand
            parsed_hand = ParsedHand(
                metadata=hand_metadata,
                game_info=hand_data.get("game", {}),
                players=hand_data.get("players", []),
                actions=hand_data.get("actions", {}),
                board=hand_data.get("board", {}),
                result=hand_data.get("outcome", {}),
                raw_data=hand_data,
            )

            return parsed_hand

        except Exception as e:
            print(
                f"‚ùå Error converting hand {
                    hand_data.get(
                        'id',
                        'Unknown')}: {e}"
            )
            return None

    def get_hand_data(self, hand_id: str) -> Optional[Dict[str, Any]]:
        """Get raw hand data by ID."""
        for hand in self.hands:
            if hand.metadata.id == hand_id:
                return hand.raw_data
        return None

    def get_hands_by_category(
        self, category: HandCategory = None
    ) -> Dict[HandCategory, List[ParsedHand]]:
        """Get hands organized by category. If category is specified, returns only that category."""
        all_hands = self.load_all_hands()

        if category is None:
            return all_hands
        else:
            # Return hands for the specific category
            return all_hands.get(category, [])

    def get_database_info(self) -> Dict[str, Any]:
        """Get information about the database."""
        return {
            "file_path": str(self.json_file_path),
            "total_hands": len(self.hands),
            "format_version": self.raw_data.get("format_version", "2.0"),
            "created_at": self.raw_data.get("created_at", "2024-01-01"),
            "description": self.raw_data.get(
                "description", "JSON Hands Database"
            ),
            "supported_variants": self.raw_data.get(
                "supported_variants", ["No-Limit Hold'em"]
            ),
            "supported_formats": self.raw_data.get(
                "supported_formats", ["Cash Game", "Tournament"]
            ),
            "special_features": self.raw_data.get("special_features", []),
        }


# For backward compatibility
class ComprehensiveJSONHandsDatabase(JSONHandsDatabase):
    """Alias for JSONHandsDatabase with comprehensive interface."""

    pass
```

---

### legendary_to_hand_converter.py

**Path**: `backend/core/legendary_to_hand_converter.py`

**Size**: 14.7 KB

```python
#!/usr/bin/env python3
"""
Legendary ‚Üí Hand Model Converter

Purpose
-------
Convert the project's "legendary" hands JSON format (single file with
hands[...], players, board, and street-keyed actions) into the standardized
`Hand` model used everywhere else in the app for deterministic replay and
analysis.

Format detection
----------------
We treat an object as "legendary format" when all of the following are true:
- It has a `players` list of dicts (with at least name/seat/starting_stack)
- It has an `actions` dict with keys like `preflop`, `flop`, `turn`, `river`
- It optionally has a `board` dict with `flop/turn/river`

Result
------
Produces a `Hand` instance with populated `metadata`, `seats`, `streets`, and
optional `pots/showdown/final_stacks` (left empty unless future data suffices).

Notes
-----
- Canonical UIDs are lowercased: seat{seat_no}
- Blind postings are inferred from the `players[].position` field when present.
- Action `action_type` strings are mapped to the `ActionType` enum; unknowns
  such as "all-in", "reraise", "3bet", "4bet" are treated as `RAISE`.
"""

from __future__ import annotations

from typing import Dict, Any, List, Optional

# Internal imports (backend run-from-backend convention)
from core.hand_model import (
    Hand,
    HandMetadata,
    Seat,
    Street,
    StreetState,
    Action,
    ActionType,
    PostingMeta,
    Variant,
)


def is_legendary_hand_obj(obj: Dict[str, Any]) -> bool:
    """Return True if the given dict looks like a single legendary-format hand.

    Support both legacy shapes:
    - { players: [...], actions: {preflop:[...], flop:[...], ...}, board: {...} }
    - { players_involved: [...], setup: {...}, actions: [...], board: [...] }
    """
    if not isinstance(obj, dict):
        return False
    if "players" in obj and isinstance(obj.get("actions"), dict):
        return True
    # Support the source format present in backend/tests/legendary_hands.json
    if "players_involved" in obj and isinstance(obj.get("actions"), list):
        return True
    return False


class LegendaryToHandConverter:
    """Converter for a single legendary-format hand dict ‚Üí `Hand` object."""

    def __init__(self) -> None:
        # Map lowercase strings found in legendary file to ActionType
        self._action_type_map: Dict[str, ActionType] = {
            "fold": ActionType.FOLD,
            "check": ActionType.CHECK,
            "call": ActionType.CALL,
            "bet": ActionType.BET,
            "raise": ActionType.RAISE,
            # Common aliases ‚Üí treat as raise
            "all-in": ActionType.RAISE,
            "allin": ActionType.RAISE,
            "reraise": ActionType.RAISE,
            "3bet": ActionType.RAISE,
            "4bet": ActionType.RAISE,
            "5bet": ActionType.RAISE,
        }

    @staticmethod
    def _to_int_chips(value: Any) -> int:
        try:
            return int(round(float(value)))
        except Exception:
            return 0

    def _build_player_uid_map(self, players: List[Dict[str, Any]]) -> Dict[str, str]:
        """Create a mapping from either seat or name ‚Üí canonical player_uid (seatN)."""
        uid_by_seat: Dict[str, str] = {}
        uid_by_name: Dict[str, str] = {}
        for idx, p in enumerate(players):
            seat = str(p.get("seat", idx + 1))
            uid = f"seat{int(seat)}"
            name = str(p.get("name", uid))
            uid_by_seat[seat] = uid
            uid_by_name[name] = uid
        return {**uid_by_name, **uid_by_seat}

    def _infer_blinds(self, players: List[Dict[str, Any]]) -> Dict[str, str]:
        """Return a role mapping: {player_uid: 'SB'|'BB'} when positions provided."""
        roles: Dict[str, str] = {}
        uid_map = self._build_player_uid_map(players)
        for p in players:
            pos = str(p.get("position", "")).upper()
            seat_key = str(p.get("seat", ""))
            uid = uid_map.get(seat_key) or uid_map.get(p.get("name", ""))
            if not uid:
                continue
            if pos == "SB":
                roles[uid] = "SB"
            elif pos == "BB":
                roles[uid] = "BB"
        if not roles:
            # Fallback: derive two smallest seats as SB/BB
            seat_numbers = sorted(int(p.get("seat", i + 1)) for i, p in enumerate(players))
            if len(seat_numbers) >= 2:
                sb_uid = f"seat{seat_numbers[0] if len(seat_numbers)==2 else seat_numbers[1]}"
                bb_uid = f"seat{seat_numbers[1] if len(seat_numbers)==2 else seat_numbers[2]}"
                roles[sb_uid] = "SB"
                roles[bb_uid] = "BB"
        return roles

    def _create_metadata(self, src: Dict[str, Any], players_count: int) -> HandMetadata:
        game_cfg = src.get("game_config", {})
        small_blind = self._to_int_chips(game_cfg.get("small_blind", 5))
        big_blind = self._to_int_chips(game_cfg.get("big_blind", 10))

        md = HandMetadata(
            table_id=src.get("table", {}).get("name", "Legendary-Table-1"),
            hand_id=src.get("id", "LEG-UNKNOWN"),
            variant=Variant.NLHE,
            max_players=int(src.get("table", {}).get("max_players", players_count or 6)),
            small_blind=small_blind,
            big_blind=big_blind,
            ante=self._to_int_chips(game_cfg.get("ante", 0)),
            currency="CHIPS",
            session_type="review",
        )
        button_seat = src.get("table", {}).get("button_seat")
        if button_seat is not None:
            try:
                md.__dict__["button_seat_no"] = int(button_seat)
            except Exception:
                pass

        # Hole cards from players
        uid_map = self._build_player_uid_map(src.get("players", []))
        for p in src.get("players", []):
            uid = uid_map.get(str(p.get("seat", ""))) or uid_map.get(p.get("name", ""))
            cards = p.get("hole_cards") or []
            if uid and cards and cards != ["**", "**"]:
                md.hole_cards[uid] = list(cards)
        # Also support setup.player_cards
        setup = src.get("setup", {}) or {}
        pc_raw = setup.get("player_cards", {}) or {}
        if isinstance(pc_raw, list):
            for idx, v in enumerate(pc_raw):
                uid = f"seat{idx+1}"
                if isinstance(v, list) and len(v) == 2 and v != ["**","**"]:
                    md.hole_cards[uid] = list(v)
        elif isinstance(pc_raw, dict):
            for k, v in pc_raw.items():
                try:
                    idx = int(k)
                except Exception:
                    continue
                uid = f"seat{idx+1}"
                if isinstance(v, list) and len(v) == 2 and v != ["**","**"]:
                    md.hole_cards[uid] = list(v)

        return md

    def _create_seats(self, players: List[Dict[str, Any]], src: Dict[str, Any]) -> List[Seat]:
        seats: List[Seat] = []
        ordered = sorted(
            [(int(p.get("seat", i + 1)), i, p) for i, p in enumerate(players)],
            key=lambda x: x[0]
        )
        for real_seat, idx, p in ordered:
            uid = f"seat{int(real_seat)}"
            seats.append(
                Seat(
                    seat_no=int(real_seat),
                    player_uid=uid,
                    display_name=p.get("name", uid),
                    starting_stack=self._to_int_chips(p.get("starting_stack", p.get("stack", 1000))),
                    is_button=(int(real_seat) == int(src.get("table", {}).get("button_seat", 1))),
                )
            )
        return seats

    def _set_board(self, src: Dict[str, Any]) -> Dict[Street, StreetState]:
        streets: Dict[Street, StreetState] = {
            Street.PREFLOP: StreetState(),
            Street.FLOP: StreetState(),
            Street.TURN: StreetState(),
            Street.RIVER: StreetState(),
        }
        board = src.get("board", {})
        if isinstance(board, dict):
            flop = board.get("flop", [])
            turn = board.get("turn", [])
            river = board.get("river", [])
        else:
            cards = list(board) if isinstance(board, list) else []
            flop, turn, river = cards[:3], cards[3:4], cards[4:5]

        if flop:
            streets[Street.FLOP].board = list(flop)
        if turn:
            streets[Street.TURN].board = list(flop) + list(turn[:1])
        if river:
            base = streets[Street.TURN].board or (list(flop) + list(turn[:1]))
            streets[Street.RIVER].board = base + list(river[:1])
        return streets

    def _append_blind_postings(self, streets: Dict[Street, StreetState], roles: Dict[str, str], md: HandMetadata) -> int:
        order = 1
        for uid, blind_type in ([(k, v) for k, v in roles.items() if v == "SB"] + [(k, v) for k, v in roles.items() if v == "BB"]):
            amount = md.small_blind if blind_type == "SB" else md.big_blind
            streets[Street.PREFLOP].actions.append(
                Action(
                    order=order,
                    street=Street.PREFLOP,
                    actor_uid=uid,
                    action=ActionType.POST_BLIND,
                    amount=amount,
                    to_amount=amount,
                    posting_meta=PostingMeta(blind_type=blind_type),
                )
            )
            order += 1
        return order

    def _convert_street_actions(
        self,
        actions_in,
        streets: Dict[Street, StreetState],
        players: List[Dict[str, Any]],
        first_order: int,
    ) -> None:
        uid_map = {str(p.get("seat", i+1)): f"seat{int(p.get('seat', i+1))}" for i, p in enumerate(players)}
        for p in players:
            name = p.get("name")
            if name:
                uid_map[name] = f"seat{int(p.get('seat', 0) or (players.index(p)+1))}"
        order = first_order

        def map_street_key(key: str) -> Street:
            k = (key or "").lower()
            if k == "preflop":
                return Street.PREFLOP
            if k == "flop":
                return Street.FLOP
            if k == "turn":
                return Street.TURN
            if k == "river":
                return Street.RIVER
            return Street.PREFLOP
        if isinstance(actions_in, list):
            for a in actions_in:
                street = map_street_key(str(a.get("street", "preflop")))
                uid = None
                if "player_index" in a:
                    try:
                        idx = int(a["player_index"]) + 1
                        uid = f"seat{idx}"
                    except Exception:
                        pass
                if not uid:
                    seat_key = str(a.get("player_seat", ""))
                    name_key = a.get("player_name", "")
                    uid = uid_map.get(seat_key) or uid_map.get(name_key)
                atype_str = str(a.get("action", a.get("action_type", "fold"))).lower()
                atype = self._action_type_map.get(atype_str, ActionType.FOLD)
                amount = self._to_int_chips(a.get("amount", 0))
                streets[street].actions.append(
                    Action(
                        order=order,
                        street=street,
                        actor_uid=uid,
                        action=atype,
                        amount=amount,
                        to_amount=amount if atype in (ActionType.BET, ActionType.RAISE, ActionType.CALL) else None,
                        all_in=(atype_str in ("all-in", "allin")),
                        note=None,
                    )
                )
                order += 1
            return

        actions_by_street: Dict[str, List[Dict[str, Any]]] = actions_in or {}
        for street_key in ["preflop", "flop", "turn", "river"]:
            items = actions_by_street.get(street_key, []) or []
            street = map_street_key(street_key)
            for a in items:
                seat_key = str(a.get("player_seat", a.get("actor", "")))
                name_key = a.get("player_name", "")
                uid = uid_map.get(seat_key) or uid_map.get(name_key)
                atype_str = str(a.get("action_type", "fold")).lower()
                atype = self._action_type_map.get(atype_str, ActionType.FOLD)
                amount = self._to_int_chips(a.get("amount", 0))
                streets[street].actions.append(
                    Action(
                        order=order,
                        street=street,
                        actor_uid=uid,
                        action=atype,
                        amount=amount,
                        to_amount=amount if atype in (ActionType.BET, ActionType.RAISE, ActionType.CALL) else None,
                        all_in=(atype_str in ("all-in", "allin")),
                        note=None,
                    )
                )
                order += 1

    def convert_hand(self, src: Dict[str, Any]) -> Hand:
        if not is_legendary_hand_obj(src):
            raise ValueError("Input is not a legendary-format hand dict")

        if src.get("players"):
            players = list(src.get("players", []))
        else:
            players = []
            names = src.get("players_involved", []) or []
            setup = src.get("setup", {}) or {}
            stacks_raw = setup.get("player_stacks", {}) or {}
            seats_raw = setup.get("player_seats", {}) or {}
            stacks = {str(i): v for i, v in enumerate(stacks_raw)} if isinstance(stacks_raw, list) else dict(stacks_raw)
            seats = {str(i): v for i, v in enumerate(seats_raw)} if isinstance(seats_raw, list) else dict(seats_raw)
            for i, name in enumerate(names):
                seat_no = int(seats.get(str(i), i + 1))
                players.append({
                    "seat": seat_no,
                    "name": name,
                    "starting_stack": stacks.get(str(i), setup.get("starting_stack", 1000)),
                })
        md = self._create_metadata(src, len(players))
        seats = self._create_seats(players, src)
        streets = self._set_board(src)
        roles = self._infer_blinds(players)
        next_order = self._append_blind_postings(streets, roles, md)
        self._convert_street_actions(src.get("actions", {}), streets, players, next_order)

        return Hand(
            metadata=md,
            seats=seats,
            hero_player_uid=seats[0].player_uid if seats else None,
            streets=streets,
            pots=[],
            showdown=[],
            final_stacks={},
        )


def convert_legendary_collection(collection: Dict[str, Any]) -> List[Hand]:
    """Convert a top-level legendary file with `hands: [...]` into `List[Hand]`."""
    hands_in = collection.get("hands", []) or []
    conv = LegendaryToHandConverter()
    results: List[Hand] = []
    for item in hands_in:
        if is_legendary_hand_obj(item):
            results.append(conv.convert_hand(item))
    return results


```

---

### poker_types.py

**Path**: `backend/core/poker_types.py`

**Size**: 2.8 KB

```python
"""
Shared types for the poker state machine components.

This module contains the shared data structures and enums
to avoid circular imports between components.
"""

from enum import Enum
from dataclasses import dataclass, field
from typing import List, Optional, Set


class PokerState(Enum):
    """Poker game states following standard Texas Hold'em flow."""

    START_HAND = "start_hand"
    PREFLOP_BETTING = "preflop_betting"
    DEAL_FLOP = "deal_flop"
    FLOP_BETTING = "flop_betting"
    DEAL_TURN = "deal_turn"
    TURN_BETTING = "turn_betting"
    DEAL_RIVER = "deal_river"
    RIVER_BETTING = "river_betting"
    SHOWDOWN = "showdown"
    END_HAND = "end_hand"


class ActionType(Enum):
    """Valid poker actions."""

    FOLD = "FOLD"
    CHECK = "CHECK"
    CALL = "CALL"
    BET = "BET"
    RAISE = "RAISE"


@dataclass
class Player:
    """Enhanced Player data structure with all-in tracking."""

    name: str
    stack: float
    position: str
    is_human: bool
    is_active: bool
    cards: List[str]
    current_bet: float = 0.0
    has_acted_this_round: bool = False
    is_all_in: bool = False  # NEW: Track all-in state
    total_invested: float = 0.0  # NEW: Track total money put in pot
    has_folded: bool = False  # NEW: Track folded state for accurate counting
    # BUG FIX: Track partial calls for side pot calculations
    partial_call_amount: Optional[float] = None
    full_call_amount: Optional[float] = None


@dataclass
class RoundState:
    """Per-street betting state (reset on each street)."""
    last_full_raise_size: float = 0.0
    last_aggressor_idx: Optional[int] = None
    reopen_available: bool = True   # becomes False after short all-in that doesn't meet full-raise size
    # NEW: explicit driver for betting flow & termination
    need_action_from: Set[int] = field(default_factory=set)


@dataclass
class GameState:
    """Enhanced game state with proper pot accounting."""

    players: List[Player]
    board: List[str]
    # Pot accounting is split:
    # - committed_pot: sum of completed streets (finalized at street end)
    # - current_bet: highest per-player commitment on THIS street
    committed_pot: float = 0.0
    current_bet: float = 0.0
    street: str = "preflop"
    players_acted: Set[int] = field(default_factory=set)
    round_complete: bool = False
    deck: List[str] = field(default_factory=list)
    big_blind: float = 1.0
    _round_state: RoundState = field(default_factory=RoundState)

    def displayed_pot(self) -> float:
        """What the UI should show right now."""
        return self.committed_pot + sum(p.current_bet for p in self.players)

    @property
    def round_state(self) -> RoundState:
        return self._round_state

    @round_state.setter
    def round_state(self, rs: RoundState) -> None:
        self._round_state = rs
```

---

### practice_session_action_interface.py

**Path**: `backend/core/practice_session_action_interface.py`

**Size**: 15.7 KB

```python
#!/usr/bin/env python3
"""
Practice Session Action Interface

A clean interface layer that sits between the UI and state machine,
providing simplified action methods without exposing game logic to the UI.

This follows the clean architecture principle: UI should not contain game logic,
but should have a simple interface to request actions.
"""

from typing import Optional, Dict, Any, List

from .poker_types import ActionType
from .practice_session_poker_state_machine import (
    PracticeSessionPokerStateMachine,
)


class PracticeSessionActionInterface:
    """
    Clean interface between Practice Session UI and State Machine.

    This interface:
    - Provides simple action methods for UI
    - Handles all game logic internally
    - Validates actions before execution
    - Returns simple success/failure results
    - Maintains clean architectural separation
    """

    def __init__(
        self,
        state_machine: PracticeSessionPokerStateMachine,
        game_director=None,
    ):
        """Initialize with a state machine reference and optional game director."""
        self.state_machine = state_machine
        self.game_director = game_director
        self.logger = getattr(state_machine, "logger", None)

    def can_human_act(self) -> bool:
        """
        Check if the human player can currently take an action.

        Returns:
            bool: True if human can act, False otherwise
        """
        try:
            # Check if game is in valid state for human actions
            if not self._is_valid_action_state():
                return False

            # Check if it's human's turn
            current_player = self.state_machine.get_action_player()
            if not current_player or not hasattr(current_player, "is_human"):
                return False

            return current_player.is_human

        except Exception as e:
            if self.logger:
                self.logger.log_system(
                    "ERROR",
                    "ACTION_INTERFACE",
                    f"Error checking human action: {e}",
                )
            return False

    def get_available_actions(self) -> List[str]:
        """
        Get list of actions currently available to the human player.

        Returns:
            List of action strings: ['check_call', 'fold', 'bet_raise']
        """
        if not self.can_human_act():
            return []

        try:
            current_player = self.state_machine.get_action_player()
            if not current_player:
                return []

            available_actions = ["fold"]  # Can always fold

            # Check if can check or need to call
            current_bet = getattr(
                self.state_machine.game_state, "current_bet", 0
            )
            player_bet = getattr(current_player, "current_bet", 0)
            call_amount = current_bet - player_bet

            if call_amount <= current_player.stack:
                available_actions.append("check_call")

            # Check if can bet/raise
            min_raise = self._calculate_min_raise_amount()
            if min_raise <= current_player.stack:
                available_actions.append("bet_raise")

            return available_actions

        except Exception as e:
            if self.logger:
                self.logger.log_system(
                    "ERROR",
                    "ACTION_INTERFACE",
                    f"Error getting available actions: {e}",
                )
            return ["fold"]  # Safe fallback

    def get_action_button_text(self, action_key: str) -> str:
        """
        Get display text for an action button.

        Args:
            action_key: 'check_call', 'fold', or 'bet_raise'

        Returns:
            str: Display text for the button
        """
        try:
            if action_key == "fold":
                return "Fold"
            elif action_key == "check_call":
                call_amount = self._calculate_call_amount()
                return (
                    "Check"
                    if call_amount == 0
                    else f"Call ${
                    call_amount:.0f}"
                )
            elif action_key == "bet_raise":
                current_bet = getattr(
                    self.state_machine.game_state, "current_bet", 0
                )
                return "Bet" if current_bet == 0 else "Raise"
            else:
                return action_key.title()

        except Exception as e:
            if self.logger:
                self.logger.log_system(
                    "ERROR",
                    "ACTION_INTERFACE",
                    f"Error getting button text: {e}",
                )
            return action_key.title()

    def execute_check_call(self) -> bool:
        """
        Execute check or call action for the human player.

        Returns:
            bool: True if action executed successfully
        """
        try:
            if not self.can_human_act():
                return False

            current_player = self.state_machine.get_action_player()
            call_amount = self._calculate_call_amount()

            if call_amount == 0:
                action_type = ActionType.CHECK
                amount = 0.0
            else:
                action_type = ActionType.CALL
                amount = call_amount

            return self._execute_action(current_player, action_type, amount)

        except Exception as e:
            if self.logger:
                self.logger.log_system(
                    "ERROR",
                    "ACTION_INTERFACE",
                    f"Error executing check/call: {e}",
                )
            return False

    def execute_fold(self) -> bool:
        """
        Execute fold action for the human player.

        Returns:
            bool: True if action executed successfully
        """
        try:
            if not self.can_human_act():
                return False

            current_player = self.state_machine.get_action_player()
            return self._execute_action(current_player, ActionType.FOLD, 0.0)

        except Exception as e:
            if self.logger:
                self.logger.log_system(
                    "ERROR", "ACTION_INTERFACE", f"Error executing fold: {e}"
                )
            return False

    def execute_bet_raise(self, amount: Optional[float] = None) -> bool:
        """
        Execute bet or raise action for the human player.

        Args:
            amount: Bet/raise amount. If None, uses calculated amount.

        Returns:
            bool: True if action executed successfully
        """
        try:
            if not self.can_human_act():
                return False

            current_player = self.state_machine.get_action_player()
            current_bet = getattr(
                self.state_machine.game_state, "current_bet", 0
            )

            # Determine action type
            action_type = (
                ActionType.BET if current_bet == 0 else ActionType.RAISE
            )

            # Use provided amount or calculate default
            if amount is None:
                amount = self._calculate_default_bet_amount()

            # Validate amount
            if not self._is_valid_bet_amount(amount):
                if self.logger:
                    self.logger.log_system(
                        "WARNING",
                        "ACTION_INTERFACE",
                        f"Invalid bet amount: ${amount}",
                    )
                return False

            return self._execute_action(current_player, action_type, amount)

        except Exception as e:
            if self.logger:
                self.logger.log_system(
                    "ERROR",
                    "ACTION_INTERFACE",
                    f"Error executing bet/raise: {e}",
                )
            return False

    def get_quick_bet_amount(self, bet_type: str) -> float:
        """
        Calculate quick bet amount for preset buttons.

        Args:
            bet_type: 'pot', 'half_pot', 'all_in', etc.

        Returns:
            float: Calculated bet amount
        """
        try:
            # Delegate to state machine's calculation
            if hasattr(self.state_machine, "calculate_quick_bet_amount"):
                return self.state_machine.calculate_quick_bet_amount(bet_type)
            else:
                # Fallback calculation
                pot = getattr(self.state_machine.game_state, "pot", 0)
                current_player = self.state_machine.get_action_player()

                if bet_type == "pot":
                    return pot
                elif bet_type == "half_pot":
                    return pot * 0.5
                elif bet_type == "all_in" and current_player:
                    return current_player.stack
                else:
                    return self.state_machine.config.big_blind * 2

        except Exception as e:
            if self.logger:
                self.logger.log_system(
                    "ERROR",
                    "ACTION_INTERFACE",
                    f"Error calculating quick bet: {e}",
                )
            return 10.0  # Safe fallback

    def execute_quick_bet(self, bet_type: str) -> bool:
        """
        Execute a quick bet preset.

        Args:
            bet_type: 'pot', 'half_pot', 'all_in', etc.

        Returns:
            bool: True if action executed successfully
        """
        try:
            amount = self.get_quick_bet_amount(bet_type)
            return self.execute_bet_raise(amount)

        except Exception as e:
            if self.logger:
                self.logger.log_system(
                    "ERROR",
                    "ACTION_INTERFACE",
                    f"Error executing quick bet: {e}",
                )
            return False

    def can_execute_action(self, action_key: str) -> bool:
        """
        Check if a specific action can currently be executed.

        Args:
            action_key: 'check_call', 'fold', 'bet_raise', etc.

        Returns:
            bool: True if action can be executed
        """
        try:
            # Basic check - must be human's turn
            if not self.can_human_act():
                return False

            # Check specific action availability
            available_actions = self.get_available_actions()
            return action_key in available_actions

        except Exception as e:
            if self.logger:
                self.logger.log_system(
                    "ERROR",
                    "ACTION_INTERFACE",
                    f"Error checking action availability: {e}",
                )
            return False

    def get_board_info(self) -> Optional[Dict[str, Any]]:
        """
        Get current board information.

        Returns:
            Dict with board info: {'cards': [...], 'street': '...'}
        """
        try:
            game_state = getattr(self.state_machine, "game_state", None)
            if not game_state:
                return None

            board_cards = getattr(game_state, "board", [])
            street = getattr(game_state, "street", "PREFLOP")

            return {
                "cards": board_cards,
                "street": street,
                "num_cards": len(board_cards),
            }

        except Exception as e:
            if self.logger:
                self.logger.log_system(
                    "ERROR",
                    "ACTION_INTERFACE",
                    f"Error getting board info: {e}",
                )
            return None

    # ==============================
    # PRIVATE HELPER METHODS
    # ==============================

    def _is_valid_action_state(self) -> bool:
        """Check if game is in a state where actions can be taken."""
        if not hasattr(self.state_machine, "current_state"):
            return False

        # List of states where human actions are not allowed
        invalid_states = ["END_HAND", "SHOWDOWN", "START_HAND"]
        current_state_name = str(self.state_machine.current_state).split(".")[
            -1
        ]

        return current_state_name not in invalid_states

    def _calculate_call_amount(self) -> float:
        """Calculate the amount needed to call."""
        try:
            current_player = self.state_machine.get_action_player()
            if not current_player:
                return 0.0

            current_bet = getattr(
                self.state_machine.game_state, "current_bet", 0
            )
            player_bet = getattr(current_player, "current_bet", 0)
            call_amount = current_bet - player_bet

            return max(0.0, call_amount)

        except Exception:
            return 0.0

    def _calculate_min_raise_amount(self) -> float:
        """Calculate minimum raise amount."""
        try:
            current_bet = getattr(
                self.state_machine.game_state, "current_bet", 0
            )
            big_blind = self.state_machine.config.big_blind

            # Minimum raise is typically big blind or double current bet
            return (
                max(big_blind, current_bet * 2)
                if current_bet > 0
                else big_blind
            )

        except Exception:
            return 2.0  # Safe fallback

    def _calculate_default_bet_amount(self) -> float:
        """Calculate default bet amount."""
        try:
            pot = getattr(self.state_machine.game_state, "pot", 0)
            big_blind = self.state_machine.config.big_blind

            # Default to 2/3 pot or 2.5 big blinds, whichever is larger
            pot_based = pot * 0.67
            bb_based = big_blind * 2.5

            return max(pot_based, bb_based)

        except Exception:
            return 5.0  # Safe fallback

    def _is_valid_bet_amount(self, amount: float) -> bool:
        """Validate if bet amount is legal."""
        try:
            current_player = self.state_machine.get_action_player()
            if not current_player:
                return False

            # Amount must be positive and within stack
            if amount <= 0 or amount > current_player.stack:
                return False

            # Must meet minimum raise requirement
            min_raise = self._calculate_min_raise_amount()
            if amount < min_raise and amount < current_player.stack:
                return False

            return True

        except Exception:
            return False

    def _execute_action(
        self, player, action_type: ActionType, amount: float
    ) -> bool:
        """Execute an action through the GameDirector or state machine."""
        try:
            # Log the action attempt
            if self.logger:
                self.logger.log_system(
                    "INFO",
                    "ACTION_INTERFACE",
                    f"Executing {
                        action_type.value} for {
                        player.name}",
                    {"amount": amount},
                )

            # Use GameDirector if available (for sound coordination), otherwise
            # fallback to state machine
            if self.game_director:
                success = self.game_director.execute_player_action(
                    player, action_type, amount
                )
            else:
                success = self.state_machine.execute_action(
                    player, action_type, amount
                )

            if success and self.logger:
                self.logger.log_system(
                    "INFO",
                    "USER_ACTION",
                    f"Action completed: {
                        action_type.value}",
                    {"player": player.name, "amount": amount},
                )

            return success

        except Exception as e:
            if self.logger:
                self.logger.log_system(
                    "ERROR", "ACTION_INTERFACE", f"Error executing action: {e}"
                )
            return False
```

---

### __init__.py

**Path**: `backend/core/providers/__init__.py`

**Size**: 755 bytes

```python
"""
Provider implementations for the pure poker state machine.
"""

from .deck_providers import StandardDeck, DeterministicDeck, GTODeck
from .rules_providers import StandardRules, HandsReviewRules, TournamentRules
from .advancement_controllers import (
    AutoAdvancementController,
    HumanAdvancementController, 
    HandsReviewAdvancementController,
    LiveAdvancementController
)

__all__ = [
    # Deck providers
    'StandardDeck',
    'DeterministicDeck', 
    'GTODeck',
    
    # Rules providers
    'StandardRules',
    'HandsReviewRules',
    'TournamentRules',
    
    # Advancement controllers
    'AutoAdvancementController',
    'HumanAdvancementController',
    'HandsReviewAdvancementController',
    'LiveAdvancementController',
]
```

---

### advancement_controllers.py

**Path**: `backend/core/providers/advancement_controllers.py`

**Size**: 4.3 KB

```python
"""
Advancement Controller Implementations

Different advancement strategies for different session types.
"""

from typing import List
from ..pure_poker_state_machine import AdvancementController
from ..poker_types import Player, PokerState, GameState


class AutoAdvancementController(AdvancementController):
    """Auto-advance for all-bot sessions (GTO, HandsReview)."""
    
    def should_advance_automatically(self, current_state: PokerState, players: List[Player]) -> bool:
        """Always auto-advance for bot sessions."""
        return current_state in [
            PokerState.DEAL_FLOP,
            PokerState.DEAL_TURN, 
            PokerState.DEAL_RIVER
        ]
    
    def on_round_complete(self, street: str, game_state: GameState) -> None:
        """Handle round completion for auto-advance sessions."""
        print(f"ü§ñ AUTO_ADVANCE: Round complete on {street}, pot: ${game_state.displayed_pot()}")


class HumanAdvancementController(AdvancementController):
    """Manual advancement for sessions with human players."""
    
    def __init__(self, human_player_names: List[str] = None):
        self.human_player_names = set(human_player_names or [])
    
    def should_advance_automatically(self, current_state: PokerState, players: List[Player]) -> bool:
        """Only auto-advance if no human players are involved."""
        # Check if any human players are still active
        active_humans = [
            p for p in players 
            if (p.name in self.human_player_names and 
                not p.has_folded and p.is_active)
        ]
        
        # Auto-advance dealing states if no humans are active
        if current_state in [PokerState.DEAL_FLOP, PokerState.DEAL_TURN, PokerState.DEAL_RIVER]:
            return len(active_humans) == 0
        
        return False
    
    def on_round_complete(self, street: str, game_state: GameState) -> None:
        """Handle round completion for human sessions."""
        print(f"üë§ HUMAN_ADVANCE: Round complete on {street}, pot: ${game_state.displayed_pot()}")


class HandsReviewAdvancementController(AdvancementController):
    """Special advancement for hands review with deterministic replay."""
    
    def should_advance_automatically(self, current_state: PokerState, players: List[Player]) -> bool:
        """Always auto-advance for deterministic replay."""
        return current_state in [
            PokerState.DEAL_FLOP,
            PokerState.DEAL_TURN,
            PokerState.DEAL_RIVER
        ]
    
    def on_round_complete(self, street: str, game_state: GameState) -> None:
        """Handle round completion for hands review."""
        print(f"üìñ HANDS_REVIEW: Round complete on {street}, pot: ${game_state.displayed_pot()}")
        
        # Could add special logging or validation here for hands review


class LiveAdvancementController(AdvancementController):
    """Advancement for live play with mixed human/bot players."""
    
    def __init__(self, human_player_names: List[str] = None):
        self.human_player_names = set(human_player_names or [])
    
    def should_advance_automatically(self, current_state: PokerState, players: List[Player]) -> bool:
        """Smart advancement based on player types and game state."""
        if current_state in [PokerState.DEAL_FLOP, PokerState.DEAL_TURN, PokerState.DEAL_RIVER]:
            # Check if any human players are still in the hand
            active_humans = [
                p for p in players 
                if (p.name in self.human_player_names and 
                    not p.has_folded and p.is_active)
            ]
            
            # If no humans are active, auto-advance
            # If humans are active, they might want to see the cards being dealt
            return len(active_humans) == 0
        
        return False
    
    def on_round_complete(self, street: str, game_state: GameState) -> None:
        """Handle round completion for live play."""
        active_players = [p for p in game_state.players if not p.has_folded and p.is_active]
        human_count = len([p for p in active_players if p.name in self.human_player_names])
        bot_count = len(active_players) - human_count
        
        print(f"üéÆ LIVE_PLAY: Round complete on {street}, pot: ${game_state.displayed_pot()} ({human_count} humans, {bot_count} bots active)")
```

---

### deck_providers.py

**Path**: `backend/core/providers/deck_providers.py`

**Size**: 4.6 KB

```python
"""
Deck Provider Implementations

Different deck management strategies for different session types.
"""

import random
from typing import List
from ..pure_poker_state_machine import DeckProvider


class StandardDeck(DeckProvider):
    """Standard shuffled deck for live play."""
    
    def __init__(self, shuffle: bool = True):
        self.shuffle = shuffle
        self._deck = None
    
    def get_deck(self) -> List[str]:
        """Get a fresh shuffled deck."""
        suits = ["C", "D", "H", "S"]
        ranks = ["2", "3", "4", "5", "6", "7", "8", "9", "T", "J", "Q", "K", "A"]
        deck = [rank + suit for suit in suits for rank in ranks]
        
        if self.shuffle:
            random.shuffle(deck)
        
        self._deck = deck.copy()
        return deck
    
    def replace_deck(self, deck: List[str]) -> None:
        """Replace the current deck."""
        self._deck = deck.copy()


class DeterministicDeck(DeckProvider):
    """Deterministic deck for hands review with known board cards."""
    
    def __init__(self, board_cards: List[str] = None, hole_cards: dict = None):
        """
        Initialize with known cards.
        
        Args:
            board_cards: List of board cards in deal order [flop1, flop2, flop3, turn, river]
            hole_cards: Dict mapping player names to their hole cards
        """
        self.board_cards = board_cards or []
        self.hole_cards = hole_cards or {}
        self._deck = None
    
    def get_deck(self) -> List[str]:
        """Get deterministic deck with known cards on top."""
        # Create full deck
        suits = ["C", "D", "H", "S"]
        ranks = ["2", "3", "4", "5", "6", "7", "8", "9", "T", "J", "Q", "K", "A"]
        full_deck = [rank + suit for suit in suits for rank in ranks]
        
        # Collect all known cards
        used_cards = set()
        
        # Add hole cards (will be dealt first)
        hole_sequence = []
        for player_name in sorted(self.hole_cards.keys()):
            player_cards = self.hole_cards[player_name]
            for card in player_cards:
                normalized_card = self._normalize_card(card)
                hole_sequence.append(normalized_card)
                used_cards.add(normalized_card)
        
        # Add board cards (will be dealt after hole cards)
        board_sequence = []
        for card in self.board_cards:
            normalized_card = self._normalize_card(card)
            board_sequence.append(normalized_card)
            used_cards.add(normalized_card)
        
        # Create remaining deck
        remaining_cards = [card for card in full_deck if card not in used_cards]
        
        # Construct deterministic deck: hole cards, then board cards, then remaining
        deterministic_deck = hole_sequence + board_sequence + remaining_cards
        
        self._deck = deterministic_deck.copy()
        print(f"üÉè DETERMINISTIC_DECK: Created with {len(hole_sequence)} hole + {len(board_sequence)} board + {len(remaining_cards)} remaining")
        print(f"üÉè DETERMINISTIC_DECK: First 10 cards: {deterministic_deck[:10]}")
        
        return deterministic_deck
    
    def replace_deck(self, deck: List[str]) -> None:
        """Replace the current deck."""
        self._deck = deck.copy()
    
    def _normalize_card(self, card: str) -> str:
        """Normalize card representation (handle 10 -> T)."""
        return str(card).upper().replace("10", "T")
    
    def set_board_cards(self, board_cards: List[str]):
        """Update board cards and regenerate deck."""
        self.board_cards = board_cards
    
    def set_hole_cards(self, hole_cards: dict):
        """Update hole cards and regenerate deck."""
        self.hole_cards = hole_cards


class GTODeck(DeckProvider):
    """Shuffled deck for GTO sessions (random but can be seeded for reproducibility)."""
    
    def __init__(self, seed: int = None):
        self.seed = seed
        self._deck = None
    
    def get_deck(self) -> List[str]:
        """Get a shuffled deck with optional seed."""
        if self.seed is not None:
            random.seed(self.seed)
        
        suits = ["C", "D", "H", "S"]
        ranks = ["2", "3", "4", "5", "6", "7", "8", "9", "T", "J", "Q", "K", "A"]
        deck = [rank + suit for suit in suits for rank in ranks]
        
        random.shuffle(deck)
        self._deck = deck.copy()
        
        if self.seed is not None:
            print(f"üÉè GTO_DECK: Seeded shuffle with seed {self.seed}")
        
        return deck
    
    def replace_deck(self, deck: List[str]) -> None:
        """Replace the current deck."""
        self._deck = deck.copy()
```

---

### rules_providers.py

**Path**: `backend/core/providers/rules_providers.py`

**Size**: 4.3 KB

```python
"""
Rules Provider Implementations

Different poker rules for different game types and situations.
"""

from typing import List
from ..pure_poker_state_machine import RulesProvider
from ..poker_types import Player


class StandardRules(RulesProvider):
    """Standard poker rules for most sessions."""
    
    def get_first_to_act_preflop(self, dealer_pos: int, num_players: int) -> int:
        """Get first player to act preflop."""
        if num_players == 2:
            # Heads-up: small blind (dealer) acts first preflop
            return dealer_pos
        else:
            # Multi-way: UTG (left of big blind) acts first
            big_blind_pos = (dealer_pos + 2) % num_players
            return (big_blind_pos + 1) % num_players
    
    def get_first_to_act_postflop(self, dealer_pos: int, players: List[Player]) -> int:
        """Get first active player to act postflop."""
        # Heads-up: small blind (dealer) acts first postflop
        # Multi-way: first active player left of dealer acts first
        if len(players) == 2:
            # Heads-up: dealer/small blind acts first postflop
            dealer_player = players[dealer_pos]
            if not dealer_player.has_folded and dealer_player.is_active and dealer_player.stack > 0:
                return dealer_pos
            # If dealer is out, other player acts
            other_idx = (dealer_pos + 1) % 2
            other_player = players[other_idx]
            if not other_player.has_folded and other_player.is_active and other_player.stack > 0:
                return other_idx
            return -1
        else:
            # Multi-way: first active player left of dealer
            for i in range(1, len(players) + 1):
                idx = (dealer_pos + i) % len(players)
                player = players[idx]
                if not player.has_folded and player.is_active and player.stack > 0:
                    return idx
            return -1  # No active players


class HandsReviewRules(RulesProvider):
    """Rules for hands review - may need special handling for replaying actions."""
    
    def get_first_to_act_preflop(self, dealer_pos: int, num_players: int) -> int:
        """Get first player to act preflop (same as standard for now)."""
        if num_players == 2:
            return dealer_pos
        else:
            big_blind_pos = (dealer_pos + 2) % num_players
            return (big_blind_pos + 1) % num_players
    
    def get_first_to_act_postflop(self, dealer_pos: int, players: List[Player]) -> int:
        """Get first active player to act postflop."""
        # Same logic as StandardRules - heads-up special case
        if len(players) == 2:
            # Heads-up: dealer/small blind acts first postflop
            dealer_player = players[dealer_pos]
            if not dealer_player.has_folded and dealer_player.is_active:
                return dealer_pos
            # If dealer is out, other player acts
            other_idx = (dealer_pos + 1) % 2
            other_player = players[other_idx]
            if not other_player.has_folded and other_player.is_active:
                return other_idx
            return -1
        else:
            # Multi-way: first active player left of dealer
            for i in range(1, len(players) + 1):
                idx = (dealer_pos + i) % len(players)
                player = players[idx]
                if not player.has_folded and player.is_active:
                    return idx
            return -1


class TournamentRules(RulesProvider):
    """Tournament rules with antes and special blind structures."""
    
    def __init__(self, ante: float = 0.0):
        self.ante = ante
    
    def get_first_to_act_preflop(self, dealer_pos: int, num_players: int) -> int:
        """Tournament preflop action (same as standard for now)."""
        if num_players == 2:
            return dealer_pos
        else:
            big_blind_pos = (dealer_pos + 2) % num_players
            return (big_blind_pos + 1) % num_players
    
    def get_first_to_act_postflop(self, dealer_pos: int, players: List[Player]) -> int:
        """Tournament postflop action."""
        for i in range(1, len(players) + 1):
            idx = (dealer_pos + i) % len(players)
            player = players[idx]
            if not player.has_folded and player.is_active and player.stack > 0:
                return idx
        return -1
```

---

### pure_poker_state_machine.py

**Path**: `backend/core/pure_poker_state_machine.py`

**Size**: 63.0 KB

```python
"""
Pure Poker State Machine - Clean Architecture

This is a pure poker rules engine that:
- Manages only poker state transitions
- Has no knowledge of human vs bot players
- Has no application-specific logic
- Uses dependency injection for all external concerns
"""

from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional, Protocol, Set
from enum import Enum
import time

from .poker_types import Player, PokerState, GameState
from .hand_model import ActionType
from .session_logger import get_session_logger
from .deuces_hand_evaluator import DeucesHandEvaluator


class DeckProvider(Protocol):
    """Protocol for deck management."""
    def get_deck(self) -> List[str]:
        """Get a fresh deck of cards."""
        pass
    
    def replace_deck(self, deck: List[str]) -> None:
        """Replace the current deck."""
        pass


class RulesProvider(Protocol):
    """Protocol for poker rules."""
    def get_first_to_act_preflop(self, dealer_pos: int, num_players: int) -> int:
        """Get first player to act preflop."""
        pass
    
    def get_first_to_act_postflop(self, dealer_pos: int, players: List[Player]) -> int:
        """Get first active player to act postflop."""
        pass


class AdvancementController(Protocol):
    """Protocol for controlling game advancement."""
    def should_advance_automatically(self, current_state: PokerState, players: List[Player]) -> bool:
        """Determine if the game should advance automatically."""
        pass
    
    def on_round_complete(self, street: str, game_state: GameState) -> None:
        """Handle round completion."""
        pass


class DecisionEngineProtocol(Protocol):
    """Protocol for decision engines that can provide actions for players."""
    
    def get_decision(self, player_name: str, game_state: GameState) -> tuple:
        """
        Get the decision for a player in the current game state.
        
        Returns:
            tuple: (ActionType, amount) or None if no decision available
        """
        pass
    
    def has_decision_for_player(self, player_name: str) -> bool:
        """Check if engine has a decision for the specified player."""
        pass
    
    def reset_for_new_hand(self) -> None:
        """Reset engine state for a new hand."""
        pass


@dataclass
class GameConfig:
    """Pure game configuration without application context."""
    num_players: int = 2
    small_blind: float = 1.0
    big_blind: float = 2.0
    starting_stack: float = 200.0


class PurePokerStateMachine:
    """
    Pure poker state machine that only handles poker rules and state transitions.
    
    All application-specific concerns (human vs bot, auto-advance, deck management)
    are handled through injected providers and controllers.
    """
    
    # Valid state transitions (pure poker rules)
    STATE_TRANSITIONS = {
        PokerState.START_HAND: [PokerState.PREFLOP_BETTING],
        PokerState.PREFLOP_BETTING: [PokerState.DEAL_FLOP, PokerState.END_HAND],
        PokerState.DEAL_FLOP: [PokerState.FLOP_BETTING, PokerState.END_HAND],
        PokerState.FLOP_BETTING: [PokerState.DEAL_TURN, PokerState.END_HAND],
        PokerState.DEAL_TURN: [PokerState.TURN_BETTING, PokerState.END_HAND],
        PokerState.TURN_BETTING: [PokerState.DEAL_RIVER, PokerState.END_HAND],
        PokerState.DEAL_RIVER: [PokerState.RIVER_BETTING, PokerState.END_HAND],
        PokerState.RIVER_BETTING: [PokerState.SHOWDOWN, PokerState.END_HAND],
        PokerState.SHOWDOWN: [PokerState.END_HAND],
        PokerState.END_HAND: [PokerState.START_HAND],
    }
    
    def __init__(
        self, 
        config: GameConfig,
        deck_provider: Optional[DeckProvider] = None,
        rules_provider: Optional[RulesProvider] = None,
        advancement_controller: Optional[AdvancementController] = None,
        decision_engine: Optional[DecisionEngineProtocol] = None
    ):
        """Initialize pure poker state machine with injected dependencies."""
        self.config = config
        self.deck_provider = deck_provider
        self.rules_provider = rules_provider
        self.advancement_controller = advancement_controller
        self.decision_engine = decision_engine
        
        # Pure poker state
        self.game_state = GameState(
            players=[],
            board=[],
            committed_pot=0.0,
            current_bet=0.0,
            street="preflop",
            big_blind=config.big_blind
        )
        self.current_state = PokerState.START_HAND
        self.hand_number = 0
        self.action_player_index = 0
        self.dealer_position = 0
        self.small_blind_position = 0
        self.big_blind_position = 1
        
        # Round tracking - FIXED: Better tracking
        self.actions_this_round = 0
        self.players_acted_this_round: set = set()
        self.last_raiser_name: Optional[str] = None  # Track who made the last raise
        self.last_bet_size = 0.0  # Track last bet/raise size for min raise
        
        # Logging
        self.session_logger = get_session_logger()
        
        # Hand evaluation using proven deuces library
        self.hand_evaluator = DeucesHandEvaluator()
        
        # Initialize players
        self._initialize_players()
        
        print(f"üîß FIXED_PPSM: Initialized with {config.num_players} players")
    
    def _initialize_players(self):
        """Initialize players with pure poker data (no human/bot distinction)."""
        self.game_state.players = []
        for i in range(self.config.num_players):
            player = Player(
                name=f"Seat{i + 1}",
                stack=self.config.starting_stack,
                position="",
                is_human=False,  # Pure FPSM doesn't care about this
                is_active=True,
                cards=[],
            )
            self.game_state.players.append(player)
        
        # Assign positions
        self._assign_positions()
    
    def _active_indices(self) -> List[int]:
        """Get indices of active (not folded) players."""
        return [i for i, p in enumerate(self.game_state.players) if p.is_active and not p.has_folded]

    def _seed_round_state_for_street(self, street: str):
        """Seed the round state for a new street with proper need_action_from tracking."""
        from .poker_types import RoundState
        rs = RoundState()
        active = set(self._active_indices())
        
        if street == "preflop":
            # BB is the implicit aggressor from posting blinds.
            rs.last_full_raise_size = self.config.big_blind
            rs.last_aggressor_idx = self.big_blind_position
            rs.reopen_available = True
            rs.need_action_from = active - {self.big_blind_position}
            self.game_state.current_bet = self.config.big_blind
        else:
            # No wager yet; everyone must act at least once (check/bet).
            rs.last_full_raise_size = 0.0
            rs.last_aggressor_idx = None
            rs.reopen_available = True
            rs.need_action_from = active
            self.game_state.current_bet = 0.0
        
        self.game_state.round_state = rs
    
    def _assign_positions(self):
        """Assign poker positions relative to dealer."""
        num_players = len(self.game_state.players)
        if num_players == 2:
            # Heads-up: dealer is small blind
            positions = ["SB", "BB"]
        else:
            # Multi-way: standard positions
            positions = self._get_standard_positions(num_players)
        
        for i, player in enumerate(self.game_state.players):
            position_offset = (i - self.dealer_position) % num_players
            if position_offset < len(positions):
                player.position = positions[position_offset]
            else:
                player.position = f"Seat{i + 1}"
    
    def _get_standard_positions(self, num_players: int) -> List[str]:
        """Get standard poker position names."""
        if num_players <= 2:
            return ["SB", "BB"]
        elif num_players <= 6:
            return ["SB", "BB", "UTG", "MP", "CO", "BTN"][:num_players]
        else:
            # For larger games, add MP positions
            positions = ["SB", "BB", "UTG"]
            mp_count = num_players - 5  # Subtract SB, BB, UTG, CO, BTN
            for i in range(1, mp_count + 1):
                positions.append(f"MP{i}")
            positions.extend(["CO", "BTN"])
            return positions
    
    def start_hand(self, existing_players: Optional[List[Player]] = None):
        """Start a new hand with pure poker logic."""
        self.hand_number += 1
        self.current_state = PokerState.START_HAND
        
        # --- NEW: rotate dealer starting on the 2nd hand ---
        if self.hand_number > 1:
            self.dealer_position = (self.dealer_position + 1) % self.config.num_players

        # Reset game state for the new hand
        self.game_state.board = []
        self.game_state.committed_pot = 0.0
        self.game_state.current_bet = 0.0
        self.game_state.street = "preflop"
        # Reset round state for new hand
        from .poker_types import RoundState
        self.game_state.round_state = RoundState()
        
        # Use existing players if provided, otherwise the initialized ones
        if existing_players:
            self.game_state.players = existing_players
            if len(self.game_state.players) != self.config.num_players:
                raise ValueError(
                    f"Expected {self.config.num_players} players, got {len(self.game_state.players)}"
                )
        
        # Reset per-player state
        for player in self.game_state.players:
            player.current_bet = 0.0
            player.has_folded = False
            player.is_active = True
            player.cards = []
        
        # --- NEW: compute blind seats from current dealer ---
        if self.config.num_players == 2:
            # Heads-up: dealer is SB
            self.small_blind_position = self.dealer_position
            self.big_blind_position = (self.dealer_position + 1) % self.config.num_players
        else:
            # 3+ players: SB is next seat; BB is the one after
            self.small_blind_position = (self.dealer_position + 1) % self.config.num_players
            self.big_blind_position = (self.dealer_position + 2) % self.config.num_players

        # --- NEW: update human-readable positions relative to dealer each hand ---
        self._assign_positions()

        # Initialize/refresh deck
        if self.deck_provider:
            self.game_state.deck = self.deck_provider.get_deck()
        else:
            self.game_state.deck = self._create_standard_deck()
        
        # Deal hole cards, post blinds, and set first to act (your existing logic)
        self._deal_hole_cards()
        self._post_blinds()
        
        # Seed preflop round state based on blinds
        self._seed_round_state_for_street("preflop")
        
        if self.rules_provider:
            self.action_player_index = self.rules_provider.get_first_to_act_preflop(
                self.dealer_position, self.config.num_players
            )
        else:
            if self.config.num_players == 2:
                self.action_player_index = self.small_blind_position
            else:
                self.action_player_index = (self.big_blind_position + 1) % self.config.num_players
        
        self.transition_to(PokerState.PREFLOP_BETTING)
        print(f"üÉè FIXED_PPSM: Hand {self.hand_number} started, action on {self.game_state.players[self.action_player_index].name}")
    
    def replay_hand_model(self, hand_model) -> Dict[str, Any]:
        """
        Replay a Hand Model object through PPSM using HandModelDecisionEngine.
        
        This is the ultimate interface for external hand compatibility.
        Creates a HandModelDecisionEngine and uses the DecisionEngine interface.
        
        Args:
            hand_model: Hand model object with standardized format
            
        Returns:
            Dict with replay results and validation metrics
        """
        print(f"üéØ PPSM: Replaying Hand Model {hand_model.metadata.hand_id}")
        
        # Setup PPSM to match hand model
        self._setup_for_hand_model(hand_model)
        
        # Create HandModelDecisionEngine adapter for this replay
        hand_decision_engine = HandModelDecisionEngineAdapter(hand_model)
        
        # Use the decision engine interface
        return self.play_hand_with_decision_engine(hand_decision_engine, hand_model)
    
    def play_hand_with_decision_engine(self, decision_engine: DecisionEngineProtocol, hand_model=None) -> Dict[str, Any]:
        """
        Play a hand using any DecisionEngine implementation.
        
        This is the core interface for bot play, hand replay, etc.
        
        Args:
            decision_engine: Any decision engine implementing DecisionEngineProtocol
            hand_model: Optional hand model for result comparison
            
        Returns:
            Dict with play results and validation metrics
        """
        # Set the decision engine
        self.decision_engine = decision_engine
        
        # Reset decision engine for new hand
        if self.decision_engine:
            self.decision_engine.reset_for_new_hand()
        
        # Start the hand
        self.start_hand()
        
        # Play results tracking
        play_results = {
            'hand_id': hand_model.metadata.hand_id if hand_model else f"hand_{self.hand_number}",
            'total_actions': 0,
            'successful_actions': 0,
            'failed_actions': 0,
            'final_pot': 0.0,
            'expected_pot': 0.0,
            'pot_match': True,  # Default true for non-replay scenarios
            'errors': []
        }
        
        # Calculate expected pot if we have a hand model
        if hand_model:
            play_results['expected_pot'] = self._calculate_expected_pot_from_hand_model(hand_model)
        
        # Game loop: continue until hand ends
        MAX_STEPS_PER_STREET = 200
        MAX_STEPS_PER_HAND = 800
        
        steps_this_street = 0
        steps_this_hand = 0
        last_street = self.game_state.street
        action_count = 0
        
        while (self.current_state not in [PokerState.END_HAND, PokerState.SHOWDOWN] and 
               action_count < MAX_STEPS_PER_HAND):
            
            # Track street changes and reset counters
            if self.game_state.street != last_street:
                last_street = self.game_state.street
                steps_this_street = 0
            
            steps_this_street += 1
            steps_this_hand += 1
            
            # Loop guard: break with detailed state if exceeded
            if steps_this_street > MAX_STEPS_PER_STREET or steps_this_hand > MAX_STEPS_PER_HAND:
                info = self.get_game_info()
                error_msg = (
                    f"Loop guard tripped.\n"
                    f"street={info['street']} state={info['current_state']} pot={info['pot']}\n"
                    f"dealer={info['dealer_position']} action_idx={info['action_player_index']}\n"
                    f"need_action_from={info.get('need_action_from', 'N/A')}\n"
                    f"steps_this_street={steps_this_street} steps_this_hand={steps_this_hand}\n"
                    f"players={info['players']}"
                )
                play_results['errors'].append(f"INFINITE_LOOP_DETECTED: {error_msg}")
                break
            
            # Check if we need a player action
            if self.action_player_index >= 0 and self.action_player_index < len(self.game_state.players):
                current_player = self.game_state.players[self.action_player_index]
                
                # Always ask the adapter; let it return None if it has nothing.
                if self.decision_engine:
                    try:
                        decision = self.decision_engine.get_decision(current_player.name, self.game_state)
                        if decision:
                            ppsm_action_type, ppsm_amount = decision
                            
                            # Convert and execute the action
                            if self._is_valid_action(current_player, ppsm_action_type, ppsm_amount):
                                success = self.execute_action(current_player, ppsm_action_type, ppsm_amount)
                                if success:
                                    play_results['successful_actions'] += 1
                                else:
                                    play_results['failed_actions'] += 1
                                    play_results['errors'].append(f"Failed to execute {ppsm_action_type.value}")
                            else:
                                play_results['failed_actions'] += 1
                                play_results['errors'].append(f"Invalid action: {ppsm_action_type.value} {ppsm_amount}")
                            
                            play_results['total_actions'] += 1
                            action_count += 1
                        else:
                            self._advance_to_next_player()
                            continue
                    except Exception as e:
                        play_results['failed_actions'] += 1
                        play_results['errors'].append(f"Exception getting decision: {str(e)}")
                        action_count += 1
                else:
                    self._advance_to_next_player()
                    continue
            else:
                # Auto-advance for non-action states (deal cards, etc.)
                if self.current_state in [PokerState.DEAL_FLOP, PokerState.DEAL_TURN, PokerState.DEAL_RIVER]:
                    # Always auto-advance card dealing states
                    self._advance_to_betting_round()
                elif (self.advancement_controller and 
                      self.advancement_controller.should_advance_automatically(self.current_state, self.game_state.players)):
                    self._advance_to_betting_round()
                else:
                    # No more automatic advancement, but check if more decisions available
                    if (self.decision_engine and 
                        hasattr(self.decision_engine, 'current_action_index') and
                        hasattr(self.decision_engine, 'actions_for_replay')):
                        # Check if more actions available from decision engine
                        if self.decision_engine.current_action_index < len(self.decision_engine.actions_for_replay):
                            # Force advance to next betting state to continue action sequence
                            if self.current_state == PokerState.DEAL_FLOP:
                                self.transition_to(PokerState.FLOP_BETTING)
                                self._set_first_to_act_postflop()
                            elif self.current_state == PokerState.DEAL_TURN:
                                self.transition_to(PokerState.TURN_BETTING)
                                self._set_first_to_act_postflop()
                            elif self.current_state == PokerState.DEAL_RIVER:
                                self.transition_to(PokerState.RIVER_BETTING)
                                self._set_first_to_act_postflop()
                        else:
                            break
                    else:
                        break
        
        # Calculate final pot
        final_pot = self.game_state.displayed_pot()
        
        play_results['final_pot'] = final_pot
        if hand_model:
            play_results['pot_match'] = abs(final_pot - play_results['expected_pot']) < 0.01
        
        print(f"üéØ PPSM: Hand complete - {play_results['successful_actions']}/{play_results['total_actions']} actions successful")
        if hand_model:
            print(f"üéØ PPSM: Pot: ${final_pot:.2f} (expected: ${play_results['expected_pot']:.2f})")
        else:
            print(f"üéØ PPSM: Final Pot: ${final_pot:.2f}")
        
        return play_results
    
    def _setup_for_hand_model(self, hand_model):
        """Setup PPSM to match hand model configuration."""
        # Update config to match hand model
        self.config.num_players = len(hand_model.seats)
        self.config.small_blind = hand_model.metadata.small_blind
        self.config.big_blind = hand_model.metadata.big_blind
        
        # Clear and recreate players from hand model seats
        self.game_state.players = []
        
        # Find button position
        button_seat_no = getattr(hand_model.metadata, 'button_seat_no', 1)
        button_pos = 0
        for i, seat in enumerate(hand_model.seats):
            if seat.seat_no == button_seat_no:
                button_pos = i
                break
        
        # Set dealer position  
        self.dealer_position = button_pos
        
        # Reset hand number for independent hand validation
        # This prevents dealer rotation between different hand validations
        self.hand_number = 0
        
        # Create players from hand model seats
        hole_cards = getattr(hand_model.metadata, 'hole_cards', {})
        for seat in hand_model.seats:
            player_cards = hole_cards.get(seat.player_uid, [])
            player = Player(
                name=seat.player_uid,
                stack=seat.starting_stack,
                position=f"seat_{seat.seat_no}",
                is_human=False,
                current_bet=0.0,
                has_folded=False,
                is_active=True,
                cards=player_cards
            )
            self.game_state.players.append(player)
        
        # CRITICAL: Create deterministic deck from hand model
        self._setup_deterministic_deck(hand_model)
    
    def _setup_deterministic_deck(self, hand_model):
        """Setup deterministic deck with exact cards from hand model."""
        from core.hand_model import Street
        
        # Extract all cards that will be dealt
        dealt_cards = []
        
        # 1. Hole cards from metadata (in correct deal order)
        hole_cards = getattr(hand_model.metadata, 'hole_cards', {})
        for seat in hand_model.seats:
            player_cards = hole_cards.get(seat.player_uid, [])
            if player_cards:
                dealt_cards.extend(player_cards)
        
        # 2. Board cards from final street (most complete board)
        board_cards = []
        if Street.RIVER in hand_model.streets and hand_model.streets[Street.RIVER].board:
            board_cards = hand_model.streets[Street.RIVER].board
        elif Street.TURN in hand_model.streets and hand_model.streets[Street.TURN].board:
            board_cards = hand_model.streets[Street.TURN].board
        elif Street.FLOP in hand_model.streets and hand_model.streets[Street.FLOP].board:
            board_cards = hand_model.streets[Street.FLOP].board
        
        dealt_cards.extend(board_cards)
        
        # Create deterministic deck
        suits = ["C", "D", "H", "S"]
        ranks = ["2", "3", "4", "5", "6", "7", "8", "9", "T", "J", "Q", "K", "A"]
        full_deck = [rank + suit for suit in suits for rank in ranks]
        
        # Remove dealt cards from deck
        remaining_cards = [card for card in full_deck if card not in dealt_cards]
        
        # Create deck: dealt cards first (will be dealt in order), then remaining
        deterministic_deck = dealt_cards + remaining_cards
        self.game_state.deck = deterministic_deck
        
        print(f"üéØ PPSM: Deterministic deck created with {len(dealt_cards)} predetermined cards: {dealt_cards}")
    
    def _find_player_by_name(self, name: str) -> Optional[Player]:
        """Find player by name in current game state."""
        for player in self.game_state.players:
            if player.name == name:
                return player
        return None
    
    def _calculate_expected_pot_from_hand_model(self, hand_model) -> float:
        """Calculate expected final pot from hand model actions."""
        from core.hand_model import ActionType as HandModelActionType
        
        total_pot = 0.0
        all_actions = hand_model.get_all_actions()
        
        # Sum all betting action amounts (these are total contribution amounts)
        betting_actions = {
            HandModelActionType.POST_BLIND, HandModelActionType.BET, 
            HandModelActionType.CALL, HandModelActionType.RAISE
        }
        
        for action in all_actions:
            if action.action in betting_actions:
                total_pot += action.amount
        
        return total_pot
    
    def _convert_hand_model_action_with_translation(self, action, actor: Player, street_contributions: Dict[str, float]) -> tuple:
        """
        Convert hand model action to PPSM action with bet amount translation.
        
        CRITICAL CONCEPT:
        - Hand Model: amount = "total chips contributed in this specific action"
        - PPSM: amount = "player's total bet amount for the street"
        
        Example: Player with $5 SB does RAISE $30 in hand model
        - Hand Model: Player contributes $30 MORE chips (total street contribution becomes $35)
        - PPSM: Player's total bet should become $35
        """
        from core.hand_model import ActionType as HandModelActionType
        
        action_type = action.action
        amount = action.amount
        
        if action_type == HandModelActionType.CHECK:
            return ActionType.CHECK, 0.0
            
        elif action_type == HandModelActionType.FOLD:
            return ActionType.FOLD, 0.0
            
        elif action_type == HandModelActionType.CALL:
            # CALL: Player contributes enough to match current_bet
            # PPSM handles the calculation internally
            return ActionType.CALL, 0.0
            
        elif action_type == HandModelActionType.BET:
            # BET: First wager on a street
            # Hand Model amount = total contribution = PPSM target
            return ActionType.BET, amount
            
        elif action_type == HandModelActionType.RAISE:
            # RAISE: Player already has some money in the pot this street
            # Hand Model amount = additional contribution in this action
            # PPSM needs: current_bet + additional_amount = new total bet
            current_bet_amount = actor.current_bet
            new_total_bet = current_bet_amount + amount
            return ActionType.RAISE, new_total_bet
        
        # Default fallback
        return None, 0.0
    
    def _create_standard_deck(self) -> List[str]:
        """Create a standard 52-card deck."""
        suits = ["C", "D", "H", "S"]
        ranks = ["2", "3", "4", "5", "6", "7", "8", "9", "T", "J", "Q", "K", "A"]
        return [rank + suit for suit in suits for rank in ranks]
    
    def _deal_hole_cards(self):
        """Deal 2 hole cards to each player."""
        for player in self.game_state.players:
            player.cards = self._deal_cards(2)
    
    def _deal_cards(self, num_cards: int) -> List[str]:
        """Deal cards from the deck."""
        if len(self.game_state.deck) < num_cards:
            raise ValueError(f"Not enough cards in deck: need {num_cards}, have {len(self.game_state.deck)}")
        
        cards = self.game_state.deck[:num_cards]
        self.game_state.deck = self.game_state.deck[num_cards:]
        return cards
    
    def _deal_flop(self):
        """Deal the flop (3 cards)."""
        flop_cards = self._deal_cards(3)
        self.game_state.board.extend(flop_cards)
        return flop_cards
    
    def _deal_turn(self):
        """Deal the turn (1 card)."""
        turn_card = self._deal_cards(1)
        self.game_state.board.extend(turn_card)
        return turn_card
    
    def _deal_river(self):
        """Deal the river (1 card)."""
        river_card = self._deal_cards(1)
        self.game_state.board.extend(river_card)
        return river_card
    
    def _post_blinds(self):
        """Post small and big blinds."""
        # Small blind
        sb_player = self.game_state.players[self.small_blind_position]
        sb_amount = min(self.config.small_blind, sb_player.stack)
        sb_player.stack -= sb_amount
        sb_player.current_bet = sb_amount
        # Note: Blind amounts stay in current_bet until round completes
        
        # Big blind
        bb_player = self.game_state.players[self.big_blind_position]
        bb_amount = min(self.config.big_blind, bb_player.stack)
        bb_player.stack -= bb_amount
        bb_player.current_bet = bb_amount
        # Note: Blind amounts stay in current_bet until round completes
        self.game_state.current_bet = bb_amount
        
        print(f"üÉè PURE_FPSM: Posted blinds - SB: ${sb_amount}, BB: ${bb_amount}")
    
    def execute_action(self, player: Player, action_type: ActionType, to_amount: Optional[float] = None) -> bool:
        """Execute a poker action with new need_action_from tracking."""
        actor_idx = self._get_player_index(player)
        if actor_idx == -1:
            return False
            
        if not self._is_valid_action(player, action_type, to_amount):
            return False
        
        rs = self.game_state.round_state
        prev_current_bet = self.game_state.current_bet
        bb = self.config.big_blind
        
        def _pay_to(to_amt: float):
            pay = max(0.0, to_amt - player.current_bet)
            pay = min(pay, player.stack)
            player.stack -= pay
            player.current_bet += pay
            return pay
        
        if action_type == ActionType.CHECK:
            # At current_bet == 0, a check consumes this player's turn.
            rs.need_action_from.discard(actor_idx)
        
        elif action_type == ActionType.FOLD:
            player.has_folded = True
            player.is_active = False
            rs.need_action_from.discard(actor_idx)
            # If only one active player remains, the hand ends
            if len(self._active_indices()) <= 1:
                self.current_state = PokerState.SHOWDOWN
                self._resolve_showdown()
                return True
        
        elif action_type == ActionType.CALL:
            _pay_to(self.game_state.current_bet)
            # Caller has now matched; they no longer need to act this street
            rs.need_action_from.discard(actor_idx)
        
        elif action_type == ActionType.BET:
            _pay_to(to_amount)
            self.game_state.current_bet = to_amount
            rs.last_full_raise_size = to_amount            # first wager sets "full raise" base
            rs.last_aggressor_idx = actor_idx
            rs.reopen_available = True
            # All *other* active players now must respond
            rs.need_action_from = set(self._active_indices()) - {actor_idx}
        
        elif action_type == ActionType.RAISE:
            _pay_to(to_amount)
            self.game_state.current_bet = to_amount
            raise_size = to_amount - prev_current_bet
            min_full = rs.last_full_raise_size if rs.last_full_raise_size > 0 else bb
            rs.last_aggressor_idx = actor_idx
            rs.reopen_available = (raise_size + 1e-9 >= min_full)
            if rs.reopen_available:
                rs.last_full_raise_size = raise_size
            # After a (full or short) raise, everyone else must act again
            rs.need_action_from = set(self._active_indices()) - {actor_idx}
        
        print(f"üÉè FIXED_PPSM: {player.name} {action_type.value} ${to_amount or 0} (pot: ${self.game_state.displayed_pot()})")
        
        # If no one needs to act anymore, close the street
        if len(rs.need_action_from) == 0:
            self._end_street()
            self._advance_street()
        else:
            self._advance_to_next_player()
        return True
    
    def _end_street(self):
        """Commit this street's bets into the pot and reset per-street state."""
        # Commit all current bets to the pot
        self.game_state.committed_pot += sum(p.current_bet for p in self.game_state.players)
        
        # Reset per-player street state
        for p in self.game_state.players:
            p.current_bet = 0.0
        
        # Reset per-street game state
        self.game_state.current_bet = 0.0
        # Next street will re-seed round_state via _seed_round_state_for_street()
        
        print(f"üÉè FIXED_PPSM: Street ended, pot now: ${self.game_state.displayed_pot()}")
    
    def _advance_street(self):
        """Advance to the next street after a betting round has completed."""
        if self.game_state.street == "preflop":
            self.game_state.street = "flop"
            self._deal_flop()
            self._seed_round_state_for_street("flop")
            self.current_state = PokerState.FLOP_BETTING
            self._set_first_to_act_postflop()
        elif self.game_state.street == "flop":
            self.game_state.street = "turn"
            self._deal_turn()
            self._seed_round_state_for_street("turn")
            self.current_state = PokerState.TURN_BETTING
            self._set_first_to_act_postflop()
        elif self.game_state.street == "turn":
            self.game_state.street = "river"
            self._deal_river()
            self._seed_round_state_for_street("river")
            self.current_state = PokerState.RIVER_BETTING
            self._set_first_to_act_postflop()
        else:
            self.current_state = PokerState.SHOWDOWN
            self._resolve_showdown()
    
    def _is_valid_action(self, player: Player, action_type: ActionType, to_amount: Optional[float] = None) -> bool:
        """Validate if an action is legal using to-amount semantics."""
        
        if player.has_folded or not player.is_active:
            return False
        
        # All-in players cannot act
        if player.stack == 0:
            return False
        
        # CHECK: only if already matched (with defensive None handling)
        if action_type == ActionType.CHECK:
            current_bet = player.current_bet if player.current_bet is not None else 0.0
            game_current_bet = self.game_state.current_bet if self.game_state.current_bet is not None else 0.0
            return current_bet == game_current_bet
        
        # FOLD: always allowed when facing action
        if action_type == ActionType.FOLD:
            return True

        # CALL: ignore to_amount; legal if player is behind the current_bet (with defensive None handling)
        if action_type == ActionType.CALL:
            # Allow all-in calls (engine will clamp payment to stack)
            current_bet = player.current_bet if player.current_bet is not None else 0.0
            game_current_bet = self.game_state.current_bet if self.game_state.current_bet is not None else 0.0
            return current_bet < game_current_bet
        
        # For BET/RAISE only: require a to-amount (CALL is handled above)
        if action_type in (ActionType.BET, ActionType.RAISE):
            if to_amount is None:
                return False
            # Defensive None handling for player.current_bet
            current_bet = player.current_bet if player.current_bet is not None else 0.0
            if to_amount <= current_bet:
                return False
            addl = to_amount - current_bet
        else:
            # For other action types, addl is not used
            addl = 0.0
            current_bet = player.current_bet if player.current_bet is not None else 0.0
        
        # Defensive None handling for player.stack
        stack = player.stack if player.stack is not None else 0.0
        if addl > stack + 1e-9:  # allow for tiny float noise
            return False
        
        bb = self.config.big_blind
        rs = self.game_state.round_state
        
        if action_type == ActionType.BET:
            # First wager of street only
            if self.game_state.current_bet != 0:
                return False
            min_bet = bb if self.rules_provider is None else getattr(self.rules_provider, "min_bet", lambda b: b)(bb)
            return to_amount >= min_bet
        
        if action_type == ActionType.RAISE:
            # Must be raising an existing bet
            if self.game_state.current_bet == 0:
                return False
            # Must exceed current_bet
            if to_amount <= self.game_state.current_bet + 1e-9:
                return False
            # Enforce minimum raise UNLESS this action is all-in.
            min_full = rs.last_full_raise_size if rs.last_full_raise_size > 0 else bb
            additional_needed = to_amount - player.current_bet
            is_all_in = abs(additional_needed - player.stack) <= 1e-9
            raise_size = to_amount - self.game_state.current_bet
            if not is_all_in and (raise_size + 1e-9) < min_full:
                return False
            # If table is "not reopened" (e.g., previous short all-in), disallow further raises
            if not rs.reopen_available and not is_all_in:
                return False
            return True
        
        return False
    
    def _apply_action(self, player: Player, action_type: ActionType, to_amount: Optional[float] = None) -> bool:
        """Apply the action to game state using to-amount semantics."""
        rs = self.game_state.round_state
        prev_current_bet = self.game_state.current_bet
        bb = self.config.big_blind
        
        def _pay_to(to_amt: float):
            pay = max(0.0, to_amt - player.current_bet)
            pay = min(pay, player.stack)  # all-in if insufficient
            player.stack -= pay
            player.current_bet += pay
            return pay
        
        if action_type == ActionType.CHECK:
            # nothing to pay
            pass
        
        elif action_type == ActionType.FOLD:
            player.has_folded = True
            player.is_active = False
        
        elif action_type == ActionType.CALL:
            _pay_to(self.game_state.current_bet)
        
        elif action_type == ActionType.BET:
            _pay_to(to_amount)
            self.game_state.current_bet = to_amount
            # First wager defines full-raise size base
            rs.last_full_raise_size = to_amount
            rs.last_aggressor_idx = self._get_player_index(player)
            rs.reopen_available = True
        
        elif action_type == ActionType.RAISE:
            _pay_to(to_amount)
            self.game_state.current_bet = to_amount
            raise_size = to_amount - prev_current_bet
            min_full = rs.last_full_raise_size if rs.last_full_raise_size > 0 else bb
            rs.last_aggressor_idx = self._get_player_index(player)
            # Short all-in allowed but doesn't reopen
            rs.reopen_available = raise_size + 1e-9 >= min_full
            if rs.reopen_available:
                rs.last_full_raise_size = raise_size
        
        print(f"üÉè FIXED_PPSM: {player.name} {action_type.value} ${to_amount or 0} (pot: ${self.game_state.displayed_pot()})")
        return True
    
    def _get_player_index(self, player: Player) -> int:
        """Get the index of a player in the players list."""
        for i, p in enumerate(self.game_state.players):
            if p.name == player.name:
                return i
        return -1
    
    def _is_round_complete(self) -> bool:
        """Check if the current betting round is complete - FIXED version."""
        active_players = [p for p in self.game_state.players if not p.has_folded and p.is_active]
        
        # If only one player left, round is complete
        if len(active_players) <= 1:
            return True
        
        # Get players who can still act (not all-in)
        actionable_players = [p for p in active_players if p.stack > 0]
        
        # If no one can act (all players all-in or folded), round is complete
        if len(actionable_players) == 0:
            return True
        
        # Check if all active players have matched the current bet
        for player in active_players:
            # Skip all-in players (they've contributed all they can)
            if player.stack == 0:
                continue
            # If someone hasn't matched the bet, round continues
            if player.current_bet < self.game_state.current_bet:
                return False
        
        # Special case: if there was a raise, everyone needs to act after it
        if self.last_raiser_name:
            # Everyone after the raiser must have acted
            for player in actionable_players:
                if player.name == self.last_raiser_name:
                    continue
                if player.name not in self.players_acted_this_round:
                    return False
        else:
            # No raises - just check everyone has acted at least once
            for player in actionable_players:
                if player.name not in self.players_acted_this_round:
                    # Exception: BB preflop gets option even if no raise
                    if (self.game_state.street == "preflop" and 
                        player == self.game_state.players[self.big_blind_position] and
                        self.game_state.current_bet == self.config.big_blind):
                        # BB hasn't acted yet but needs option
                        return False
                    # Otherwise, if they match current bet, they don't need to act
                    if player.current_bet != self.game_state.current_bet:
                        return False
        
        return True
    
    def _handle_round_complete(self):
        """Handle completion of a betting round - FIXED version."""
        print(f"üÉè FIXED_PPSM: Round complete on {self.game_state.street}")
        
        # Reset round tracking
        self.actions_this_round = 0
        self.players_acted_this_round.clear()
        self.last_raiser_name = None
        self.last_bet_size = 0.0
        
        # Notify advancement controller
        if self.advancement_controller:
            self.advancement_controller.on_round_complete(self.game_state.street, self.game_state)
        
        # Determine next state
        if self.current_state == PokerState.PREFLOP_BETTING:
            self.transition_to(PokerState.DEAL_FLOP)
            # Reset action player for dealing state
            self.action_player_index = -1
        elif self.current_state == PokerState.FLOP_BETTING:
            self.transition_to(PokerState.DEAL_TURN)
            # Reset action player for dealing state
            self.action_player_index = -1
        elif self.current_state == PokerState.TURN_BETTING:
            self.transition_to(PokerState.DEAL_RIVER)
            # Reset action player for dealing state
            self.action_player_index = -1
        elif self.current_state == PokerState.RIVER_BETTING:
            self.transition_to(PokerState.SHOWDOWN)
        else:
            self.transition_to(PokerState.END_HAND)
    
    def _advance_to_next_player(self):
        """Advance to the next player who still needs to act."""
        rs = self.game_state.round_state
        if not rs.need_action_from:
            return
        n = self.config.num_players
        i = self.action_player_index
        for _ in range(n):
            i = (i + 1) % n
            if i in rs.need_action_from:
                self.action_player_index = i
                print(f"üÉè FIXED_PPSM: Action advances to {self.game_state.players[i].name}")
                return
        # If we somehow didn't find one, fail safe by closing street
        self._end_street()
        self._advance_street()
    
    def transition_to(self, new_state: PokerState):
        """Transition to a new poker state."""
        if new_state not in self.STATE_TRANSITIONS.get(self.current_state, []):
            raise ValueError(f"Invalid transition from {self.current_state} to {new_state}")
        
        old_state = self.current_state
        self.current_state = new_state
        
        print(f"üÉè PURE_FPSM: {old_state} ‚Üí {new_state}")
        
        # Handle state-specific logic
        if new_state == PokerState.DEAL_FLOP:
            self.game_state.board.extend(self._deal_cards(3))
            self.game_state.street = "flop"
            self._reset_bets_for_new_round()
            self._set_first_to_act_postflop()
            
        elif new_state == PokerState.DEAL_TURN:
            self.game_state.board.extend(self._deal_cards(1))
            self.game_state.street = "turn"
            self._reset_bets_for_new_round()
            self._set_first_to_act_postflop()
            
        elif new_state == PokerState.DEAL_RIVER:
            self.game_state.board.extend(self._deal_cards(1))
            self.game_state.street = "river"
            self._reset_bets_for_new_round()
            self._set_first_to_act_postflop()
        
        # Check if advancement controller wants to auto-advance
        if (self.advancement_controller and 
            self.advancement_controller.should_advance_automatically(new_state, self.game_state.players)):
            
            if new_state in [PokerState.DEAL_FLOP, PokerState.DEAL_TURN, PokerState.DEAL_RIVER]:
                # Auto-advance to betting round with proper setup
                self._advance_to_betting_round()
    
    def _reset_bets_for_new_round(self):
        """Reset bets for a new betting round."""
        # First, collect all current bets into the pot
        for player in self.game_state.players:
            self.game_state.committed_pot += player.current_bet
            player.current_bet = 0.0
        self.game_state.current_bet = 0.0
    
    def _set_first_to_act_postflop(self):
        """Set first to act for postflop rounds."""
        if self.rules_provider:
            self.action_player_index = self.rules_provider.get_first_to_act_postflop(
                self.dealer_position, self.game_state.players
            )
        else:
            # Default: first active player after dealer
            self.action_player_index = self._find_first_active_after_dealer()
    
    def _find_first_active_after_dealer(self) -> int:
        """Find first active player after dealer."""
        for i in range(1, len(self.game_state.players) + 1):
            idx = (self.dealer_position + i) % len(self.game_state.players)
            player = self.game_state.players[idx]
            if not player.has_folded and player.is_active:
                return idx
        return -1  # No active players
    
    def get_game_info(self) -> Dict[str, Any]:
        """Get current game information with proper pot accounting."""
        return {
            "players": [
                {
                    "name": p.name,
                    "stack": p.stack,
                    "current_bet": p.current_bet,
                    "is_active": p.is_active,
                    "has_folded": p.has_folded,
                    "position": p.position,
                    "cards": p.cards,
                }
                for p in self.game_state.players
            ],
            "committed_pot": self.game_state.committed_pot,
            "street_commit_sum": sum(p.current_bet for p in self.game_state.players),
            "pot": self.game_state.displayed_pot(),
            "current_bet": self.game_state.current_bet,
            "board": self.game_state.board,
            "street": self.game_state.street,
            "current_state": self.current_state.value,
            "action_player_index": self.action_player_index,
            "hand_number": self.hand_number,
            "dealer_position": self.dealer_position,
            "need_action_from": list(self.game_state.round_state.need_action_from),
        }
    
    def _advance_to_betting_round(self):
        """Advance from dealing states to betting states."""
        if self.current_state == PokerState.DEAL_FLOP:
            # Deal flop cards
            flop_cards = self._deal_cards(3)
            self.game_state.board.extend(flop_cards)
            self.game_state.street = "flop"
            self._seed_round_state_for_street("flop")
            # Transition to flop betting
            self.transition_to(PokerState.FLOP_BETTING)
            self._set_first_to_act_postflop()
            print(f"üÉè PPSM: Dealing flop: {flop_cards}, transitioning to FLOP_BETTING")
            
        elif self.current_state == PokerState.DEAL_TURN:
            # Deal turn card
            turn_card = self._deal_cards(1)
            self.game_state.board.extend(turn_card)
            self.game_state.street = "turn"
            self._seed_round_state_for_street("turn")
            # Transition to turn betting
            self.transition_to(PokerState.TURN_BETTING)
            self._set_first_to_act_postflop()
            print(f"üÉè PPSM: Dealing turn: {turn_card}, transitioning to TURN_BETTING")
            
        elif self.current_state == PokerState.DEAL_RIVER:
            # Deal river card
            river_card = self._deal_cards(1)
            self.game_state.board.extend(river_card)
            self.game_state.street = "river"
            self._seed_round_state_for_street("river")
            # Transition to river betting
            self.transition_to(PokerState.RIVER_BETTING)
            self._set_first_to_act_postflop()
            print(f"üÉè PPSM: Dealing river: {river_card}, transitioning to RIVER_BETTING")
    
    def _resolve_showdown(self):
        """Resolve the showdown and determine winners using deuces library."""
        # Before finalizing, roll any outstanding street bets into the pot
        residual = sum(p.current_bet for p in self.game_state.players)
        if residual:
            self.game_state.committed_pot += residual
            for p in self.game_state.players:
                p.current_bet = 0.0

        print(f"üÉè PPSM: Resolving showdown, final pot: ${self.game_state.displayed_pot()}")
        self.current_state = PokerState.SHOWDOWN
        
        # Determine active players (not folded)
        active_players = [p for p in self.game_state.players if not p.has_folded and p.is_active]
        
        if len(active_players) == 0:
            # No active players - shouldn't happen but handle gracefully
            print("üÉè PPSM: No active players at showdown")
            self.current_state = PokerState.END_HAND
            return
        elif len(active_players) == 1:
            # Single winner (all others folded)
            winner = active_players[0]
            pot_amount = self.game_state.displayed_pot()
            winner.stack += pot_amount
            print(f"üèÜ PPSM: {winner.name} wins ${pot_amount:.2f} (all others folded)")
            self.current_state = PokerState.END_HAND
            return
        
        # Multiple players - evaluate hands using deuces
        winners = self._determine_winners(active_players)
        
        if winners:
            pot_amount = self.game_state.displayed_pot()
            pot_per_winner = pot_amount / len(winners)
            
            for winner in winners:
                winner.stack += pot_per_winner
            
            if len(winners) == 1:
                print(f"üèÜ PPSM: {winners[0].name} wins ${pot_amount:.2f}")
            else:
                winner_names = [w.name for w in winners]
                print(f"üèÜ PPSM: Split pot - {', '.join(winner_names)} each win ${pot_per_winner:.2f}")
        
        self.current_state = PokerState.END_HAND
    
    def _determine_winners(self, active_players: List[Player]) -> List[Player]:
        """Determine winners using deuces hand evaluation."""
        if not active_players:
            return []
        
        if len(active_players) == 1:
            return active_players
        
        # Evaluate hands for all active players
        player_evaluations = []
        for player in active_players:
            if hasattr(player, 'hole_cards') and len(player.hole_cards) == 2:
                # Use hole_cards if available
                hole_cards = player.hole_cards
            elif hasattr(player, 'cards') and len(player.cards) == 2:
                # Fallback to cards attribute
                hole_cards = player.cards
            else:
                # Skip players without valid hole cards
                print(f"üÉè PPSM: Skipping {player.name} - no valid hole cards")
                continue
            
            if len(self.game_state.board) >= 3:
                # Evaluate hand using deuces
                hand_eval = self.hand_evaluator.evaluate_hand(hole_cards, self.game_state.board)
                player_evaluations.append((player, hand_eval))
                
                # Log hand evaluation for transparency
                score = hand_eval.get("hand_score", 9999)
                description = hand_eval.get("hand_description", "Unknown")
                strength = hand_eval.get("strength_score", 0)
                print(f"üÉè PPSM: {player.name} ({hole_cards}) + {self.game_state.board} = {description} (score={score}, strength={strength:.1f}%)")
            else:
                print(f"üÉè PPSM: Insufficient board cards ({len(self.game_state.board)}) for evaluation")
                return active_players  # Return all players if can't evaluate
        
        # Handle case where no hands could be evaluated
        if not player_evaluations:
            print("üÉè PPSM: No hands could be evaluated - returning all active players")
            return active_players
        
        # Use deuces evaluator to determine winners
        winners_with_evals = self.hand_evaluator.determine_winners(player_evaluations)
        winners = [player for player, eval_data in winners_with_evals]
        
        # Log winner determination
        if len(winners) == 1:
            winner_eval = winners_with_evals[0][1]
            description = winner_eval.get("hand_description", "Unknown")
            best_five = winner_eval.get("best_five_cards", [])
            cards_str = f" [{', '.join(best_five)}]" if best_five else ""
            print(f"üèÜ PPSM: Winner {winners[0].name} with {description}{cards_str}")
        else:
            winner_names = [w.name for w in winners]
            winner_eval = winners_with_evals[0][1]
            description = winner_eval.get("hand_description", "Unknown")
            print(f"üèÜ PPSM: Tie between {', '.join(winner_names)} with {description}")
        
        return winners


class HandModelDecisionEngineAdapter:
    """
    Adapter that wraps HandModelDecisionEngine to implement DecisionEngineProtocol.
    
    This bridges the existing HandModelDecisionEngine to the new DecisionEngine interface,
    allowing PPSM to use any decision engine polymorphically.
    """
    
    def __init__(self, hand_model):
        from core.hand_model_decision_engine import HandModelDecisionEngine
        self.hand_engine = HandModelDecisionEngine(hand_model)
        self.actions_for_replay = self.hand_engine.actions_for_replay
        self.current_action_index = 0
    
    def has_decision_for_player(self, player_name: str) -> bool:
        """
        Return True while there are hand-model actions remaining. We may also
        inject implicit checks (without consuming the model pointer), so this
        must be True as long as we haven't exhausted actions.
        """
        return self.current_action_index < len(self.actions_for_replay)

    def _to_float(self, x, default=0.0) -> float:
        """Defensive float conversion that handles None/empty strings."""
        try:
            if x is None or x == "":
                return float(default)
            return float(x)
        except Exception:
            return float(default)

    def _need_set(self, game_state):
        """Get the set of seats that need to act."""
        rs = getattr(game_state, "round_state", None)
        return set(getattr(rs, "need_action_from", set()) or set())

    def _seat_index(self, game_state, player_name):
        for i, pl in enumerate(game_state.players):
            if pl.name == player_name:
                return i
        return None

    def _can_inject_check(self, player_name, game_state) -> bool:
        """True iff it's legal/needed to inject a CHECK for player_name now."""
        street = (str(getattr(game_state, "street", "")) or "").lower()
        idx = self._seat_index(game_state, player_name)
        if idx is None:
            return False
        need = self._need_set(game_state)
        curr = self._to_float(getattr(game_state, "current_bet", 0.0))
        # Postflop: if no wager yet, any seat that owes action may CHECK
        if street in ("flop", "turn", "river"):
            return curr == 0.0 and idx in need
        # Preflop "BB option" when limped: BB can CHECK if still owes action and no raise
        if street == "preflop":
            bb_amt = self._to_float(getattr(game_state, "big_blind", 0.0))
            pos = getattr(game_state.players[idx], "position", "")
            return pos == "BB" and idx in need and abs(curr - bb_amt) < 1e-9
        return False

    def _should_inject_fold(self, player_name, game_state) -> bool:
        """True iff player_name faces a bet and still owes action (omitted FOLD)."""
        idx = self._seat_index(game_state, player_name)
        if idx is None:
            return False
        pl = game_state.players[idx]
        if not pl.is_active or pl.has_folded:
            return False
        curr = self._to_float(getattr(game_state, "current_bet", 0.0))
        if curr <= self._to_float(pl.current_bet):
            return False  # not facing a wager
        return idx in self._need_set(game_state)

    def _is_noise(self, act) -> bool:
        """True for non-betting noise lines that should be skipped."""
        n = str(getattr(act, "action", "")).upper()
        return n in {"SHOW", "SHOWHAND", "MUCK", "COLLECT", "WIN", "RESULT", "SUMMARY"}
        
    def get_decision(self, player_name: str, game_state):
        """
        BULLETPROOF Hand-Model adapter for PPSM integration.
        Return (ActionType, to_amount_or_None) for the engine seat to act.
        Uses to-amount semantics, never consumes wrong player's log, injects implied CHECK/FOLD.
        """
        # Import HM with a local alias to avoid enum name collisions
        from core.hand_model import ActionType as HM
        from core.poker_types import ActionType

        # If we're out of logged actions, we might still need to close the street.
        if self.current_action_index >= len(self.actions_for_replay):
            if self._can_inject_check(player_name, game_state):
                return ActionType.CHECK, None
            if self._should_inject_fold(player_name, game_state):
                return ActionType.FOLD, None
            return None

        act = self.actions_for_replay[self.current_action_index]

        # Skip any non-betting "noise" lines by consuming them and re-evaluating
        if self._is_noise(act):
            self.current_action_index += 1
            return self.get_decision(player_name, game_state)

        # If the next logged action is for a different player,
        # inject the implied action for THIS actor (do NOT consume the log).
        if act.actor_uid != player_name:
            if self._can_inject_check(player_name, game_state):
                return ActionType.CHECK, None
            if self._should_inject_fold(player_name, game_state):
                return ActionType.FOLD, None
            return None

        # From here, the log line IS for this player ‚Äî consume it.
        self.current_action_index += 1

        curr = self._to_float(getattr(game_state, "current_bet", 0.0))
        bb   = self._to_float(getattr(game_state, "big_blind", 10.0))
        p    = next((pl for pl in game_state.players if pl.name == player_name), None)
        p_cb = self._to_float(getattr(p, "current_bet", 0.0)) if p else 0.0
        p_st = self._to_float(getattr(p, "stack", 0.0)) if p else float("inf")
        stack_room = p_cb + p_st

        a = self._to_float(getattr(act, "amount", 0.0))

        # Normalize HM ‚Üí PPSM with "to-amount" semantics
        if act.action == HM.CHECK:
            return ActionType.CHECK, None
        if act.action == HM.FOLD:
            return ActionType.FOLD, None

        if act.action == HM.CALL:
            # Some logs encode CALL 0 when curr==0 ‚Üí treat as CHECK
            if curr == 0.0 and a == 0.0:
                return ActionType.CHECK, None
            return ActionType.CALL, None  # engine computes pay-to

        if act.action == HM.BET:
            if a <= 1e-9 and curr == 0.0:
                return ActionType.CHECK, None  # "BET 0" ‚Üí CHECK
            if curr == 0.0:
                return ActionType.BET, a
            # Mislabelled raise: accept either delta or total
            to_total = max(a, curr + a)
            if to_total > curr and to_total <= stack_room:
                return ActionType.RAISE, to_total
            return None  # let the validator print a snapshot

        if act.action == HM.RAISE:
            candidates = []
            t1 = curr + a   # as delta
            t2 = a          # as total
            if t1 > curr and t1 <= stack_room:
                candidates.append(('delta', t1))
            if t2 > curr and t2 <= stack_room:
                candidates.append(('total', t2))
            
            # Prefer 'total' interpretation over 'delta' when both are valid
            # This handles most hand-log formats better
            chosen = None
            for interpretation, t in candidates:
                if (t - curr) + 1e-9 >= bb:  # meets minimum raise
                    if interpretation == 'total':  # prefer total over delta
                        chosen = t
                        break
                    elif chosen is None:  # accept delta only if no total found
                        chosen = t
            
            if chosen is None and candidates:
                # Fallback: prefer total, then largest
                for interpretation, t in candidates:
                    if interpretation == 'total':
                        chosen = t
                        break
                if chosen is None:
                    chosen = max(candidates, key=lambda x: x[1])[1]
            
            return (ActionType.RAISE, chosen) if chosen else None

        # Optional explicit ALL_IN in some logs
        if getattr(HM, "ALL_IN", None) and act.action == HM.ALL_IN:
            to_allin = stack_room  # current_bet + stack
            if curr == 0.0:
                return ActionType.BET, to_allin
            return ActionType.RAISE, to_allin

        # Unknown action ‚Äî return None and let the engine move on
        return None
    

    
    def reset_for_new_hand(self) -> None:
        """Reset engine state for a new hand."""
        self.current_action_index = 0
        
        
# Factory functions for creating different decision engines

def create_hand_replay_engine(hand_model):
    """Create a decision engine for replaying a specific hand."""
    return HandModelDecisionEngineAdapter(hand_model)

def create_gto_decision_engine(config):
    """Create a GTO decision engine using the new adapter."""
    try:
        from .gto_decision_engine_adapter import create_gto_decision_engine as create_gto_adapter
        num_players = getattr(config, 'num_players', 6)
        return create_gto_adapter(num_players)
    except ImportError as e:
        print(f"‚ö†Ô∏è GTO decision engine not available: {e}")
        raise NotImplementedError("GTO decision engine not yet implemented")

def create_custom_decision_engine(strategy_function):
    """Create a custom decision engine from a strategy function (placeholder)."""
    # TODO: Implement custom decision engine wrapper
    raise NotImplementedError("Custom decision engine not yet implemented")
```

---

### session_logger.py

**Path**: `backend/core/session_logger.py`

**Size**: 33.1 KB

```python
#!/usr/bin/env python3
"""
Comprehensive Session Logger for Poker Training System

This module provides detailed JSON logging for:
- Complete session tracking
- Hand-by-hand analysis
- Player action logging
- System debugging
- Performance analytics
- Research data collection

All data is stored in structured JSON format for easy analysis.
"""

import json
import time
import uuid
import signal
import atexit
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, asdict, field

# Define debug_print locally to avoid circular import


def debug_print(*args, **kwargs):
    """Debug print function that flushes immediately."""
    print(*args, **kwargs, flush=True)


@dataclass
class ActionLog:
    """Single player action within a hand."""

    timestamp: float
    hand_id: str
    player_name: str
    player_index: int
    action: str  # FOLD, CALL, BET, RAISE, CHECK
    amount: float
    stack_before: float
    stack_after: float
    pot_before: float
    pot_after: float
    current_bet: float
    street: str  # preflop, flop, turn, river
    position: str
    is_human: bool
    decision_time_ms: Optional[int] = None
    pot_odds: Optional[float] = None
    stack_pot_ratio: Optional[float] = None


@dataclass
class HandLog:
    """Complete data for a single hand."""

    hand_id: str
    session_id: str
    timestamp: float
    hand_number: int

    # Pre-hand setup
    dealer_button: int
    small_blind: int
    big_blind: int
    sb_amount: float
    bb_amount: float

    # Player data at hand start
    players: List[Dict[str, Any]]

    # Cards
    hole_cards: Dict[str, List[str]]  # player_name -> [card1, card2]
    board_cards: List[str]

    # Actions by street
    preflop_actions: List[ActionLog] = field(default_factory=list)
    flop_actions: List[ActionLog] = field(default_factory=list)
    turn_actions: List[ActionLog] = field(default_factory=list)
    river_actions: List[ActionLog] = field(default_factory=list)

    # Hand results
    winner: Optional[str] = None
    winning_hand: Optional[str] = None
    pot_size: float = 0.0
    showdown: bool = False
    hand_complete: bool = False

    # Timing
    hand_duration_ms: Optional[int] = None
    streets_reached: List[str] = field(default_factory=list)


@dataclass
class SystemLog:
    """System-level debug and performance data."""

    timestamp: float
    session_id: str
    level: str  # DEBUG, INFO, WARNING, ERROR
    category: str  # UI, STATE_MACHINE, SOUND, ANIMATION, etc.
    message: str
    data: Optional[Dict[str, Any]] = None


@dataclass
class UserActivityLog:
    """Log user activities for analytics and features."""

    timestamp: float
    session_id: str
    activity_type: (
        str  # PRACTICE_DECISION, HANDS_REVIEW, STRATEGY_USAGE, UI_INTERACTION
    )
    activity_data: Dict[str, Any] = field(default_factory=dict)


@dataclass
class StrategyPerformanceLog:
    """Track strategy usage and performance."""

    timestamp: float
    session_id: str
    hand_id: str
    strategy_name: str
    gto_recommendation: str
    user_action: str
    # AGGRESSIVE, PASSIVE, BLUFF, FOLD_EQUITY
    deviation_type: Optional[str] = None
    situation_context: Dict[str, Any] = field(default_factory=dict)
    # EXCELLENT, GOOD, QUESTIONABLE, POOR
    outcome_quality: Optional[str] = None


@dataclass
class LearningProgressLog:
    """Track user learning and improvement over time."""

    timestamp: float
    session_id: str
    skill_area: str  # PREFLOP, POSTFLOP, BLUFFING, VALUE_BETTING, etc.
    performance_metric: str
    current_value: float
    previous_value: Optional[float] = None
    improvement_trend: Optional[str] = None  # IMPROVING, STABLE, DECLINING
    confidence_level: Optional[float] = None


@dataclass
class SessionLog:
    """Complete session data."""

    session_id: str
    start_time: float
    end_time: Optional[float] = None

    # Session setup
    num_players: int = 6
    starting_stack: float = 100.0
    blinds: Dict[str, float] = field(
        default_factory=lambda: {"small": 0.5, "big": 1.0}
    )

    # Player information
    human_player: str = "Player 1"
    bot_players: List[str] = field(default_factory=list)

    # Session results
    hands_played: int = 0
    session_duration_ms: Optional[int] = None

    # Data collections
    hands: List[HandLog] = field(default_factory=list)
    system_logs: List[SystemLog] = field(default_factory=list)

    # Enhanced user analytics
    user_activities: List[UserActivityLog] = field(default_factory=list)
    strategy_performance: List[StrategyPerformanceLog] = field(
        default_factory=list
    )
    learning_progress: List[LearningProgressLog] = field(default_factory=list)

    # Statistics
    human_stats: Dict[str, Any] = field(default_factory=dict)
    bot_stats: Dict[str, List[Dict[str, Any]]] = field(default_factory=dict)


class SessionLogger:
    """
    Comprehensive logging system for poker training sessions.

    Features:
    - Real-time JSON logging
    - Structured data capture
    - Performance tracking
    - Debug message logging
    - Analysis-ready output
    """

    def __init__(self, log_directory: str = "logs"):
        self.log_directory = Path(log_directory)
        self.log_directory.mkdir(exist_ok=True)

        # Generate unique session ID and start session immediately
        self.session_id = str(uuid.uuid4())
        self.session_start_time = time.time()

        # Initialize session data immediately
        self.session = SessionLog(
            session_id=self.session_id,
            start_time=self.session_start_time,
            num_players=6,  # Default, can be updated later
            starting_stack=100.0,  # Default, can be updated later
            # Default 6 players
            bot_players=[f"Player {i + 2}" for i in range(5)],
        )

        self.current_hand: Optional[HandLog] = None
        self.hand_start_time: Optional[float] = None

        # Timing tracking
        self.action_start_times: Dict[str, float] = {}

        # Initialize log files immediately
        session_datetime = datetime.fromtimestamp(
            self.session_start_time
        ).strftime("%Y%m%d_%H%M%S")
        self.session_file = (
            self.log_directory
            / f"session_{self.session_id}_{session_datetime}.json"
        )
        self.system_log_file = (
            self.log_directory
            / f"system_{self.session_id}_{session_datetime}.log"
        )

        # Initialize graceful shutdown BEFORE any logging
        self._shutdown_handlers_registered = False
        self._register_shutdown_handlers()

        # Now safe to log - session is initialized
        self._write_session_header()

    def _write_session_header(self):
        """Write session header to log files."""
        # Write minimal session header - detailed logs will be in system log
        try:
            with open(self.session_file, "w") as f:
                header_data = {
                    "session_id": self.session_id,
                    "start_time": datetime.fromtimestamp(
                        self.session_start_time
                    ).isoformat(),
                    "log_type": "session_header",
                }
                json.dump(header_data, f, indent=2)
                f.write("\n")
        except Exception as e:
            print(f"Error writing session header: {e}")

    # PHH export functionality removed - using JSON-based hands database

    def start_session(
        self, num_players: int = 6, starting_stack: float = 100.0
    ) -> str:
        """Start a new logging session."""
        session_id = str(uuid.uuid4())
        timestamp = time.time()

        self.session = SessionLog(
            session_id=session_id,
            start_time=timestamp,
            num_players=num_players,
            starting_stack=starting_stack,
            bot_players=[f"Player {i + 2}" for i in range(num_players - 1)],
        )

        # Create session files
        session_datetime = datetime.fromtimestamp(timestamp).strftime(
            "%Y%m%d_%H%M%S"
        )
        self.session_file = (
            self.log_directory
            / f"session_{session_datetime}_{session_id[:8]}.json"
        )
        self.system_log_file = (
            self.log_directory
            / f"system_{session_datetime}_{session_id[:8]}.json"
        )

        self.log_system(
            "INFO",
            "SESSION",
            f"Started new session {session_id}",
            {"num_players": num_players, "starting_stack": starting_stack},
        )

        return session_id

    def end_session(self):
        """End the current session and save final data."""
        if not self.session:
            return

        self.session.end_time = time.time()
        if self.session.start_time:
            self.session.session_duration_ms = int(
                (self.session.end_time - self.session.start_time) * 1000
            )

        self.log_system(
            "INFO",
            "SESSION",
            "Session ended",
            {
                "hands_played": self.session.hands_played,
                "duration_ms": self.session.session_duration_ms,
            },
        )

        # Session data ready for analysis

        self._save_session()

    # PHH export functionality removed - using JSON-based hands database

    def start_hand(
        self,
        hand_number: int,
        players: List[Dict],
        dealer_button: int,
        small_blind: int,
        big_blind: int,
        sb_amount: float = 0.5,
        bb_amount: float = 1.0,
    ) -> str:
        """Start logging a new hand."""
        import sys

        print(f"üêõ DEBUG: start_hand called for hand {hand_number}")
        sys.stdout.flush()
        print(f"üêõ DEBUG: session = {self.session}")
        sys.stdout.flush()

        if not self.session:
            print("‚ùå DEBUG: No active session!")
            sys.stdout.flush()
            raise ValueError("No active session")

        hand_id = f"{self.session.session_id}_{hand_number}"
        self.hand_start_time = time.time()

        print(f"üêõ DEBUG: Creating new HandLog with hand_id = {hand_id}")
        sys.stdout.flush()

        self.current_hand = HandLog(
            hand_id=hand_id,
            session_id=self.session.session_id,
            timestamp=self.hand_start_time,
            hand_number=hand_number,
            dealer_button=dealer_button,
            small_blind=small_blind,
            big_blind=big_blind,
            sb_amount=sb_amount,
            bb_amount=bb_amount,
            players=[dict(p) for p in players],  # Deep copy
            hole_cards={},  # Initialize empty, will be populated by log_hole_cards
            board_cards=[],  # Initialize empty, will be populated by log_board_cards
        )

        print(f"‚úÖ DEBUG: current_hand created: {self.current_hand}")
        sys.stdout.flush()

        self.log_system(
            "INFO",
            "HAND",
            f"Started hand {hand_number}",
            {
                "hand_id": hand_id,
                "dealer_button": dealer_button,
                "blinds": {"sb": sb_amount, "bb": bb_amount},
            },
        )

        print(f"‚úÖ DEBUG: Hand {hand_number} logging started successfully")
        sys.stdout.flush()
        return hand_id

    def log_hole_cards(self, player_cards: Dict[str, List[str]]):
        """Log hole cards for all players."""
        import sys

        print(
            f"üêõ DEBUG: log_hole_cards called with {
                len(player_cards)} players"
        )
        sys.stdout.flush()
        print(f"üêõ DEBUG: current_hand = {self.current_hand}")
        sys.stdout.flush()
        print(f"üêõ DEBUG: session = {self.session}")
        sys.stdout.flush()

        if not self.current_hand:
            print("‚ùå DEBUG: No current_hand, cannot log hole cards!")
            sys.stdout.flush()
            return

        self.current_hand.hole_cards = dict(player_cards)
        print("‚úÖ DEBUG: Hole cards stored in current_hand")
        sys.stdout.flush()

        self.log_system(
            "INFO",
            "CARDS",
            "Hole cards dealt",
            {
                "hand_id": self.current_hand.hand_id,
                "cards_dealt": len(player_cards),
            },
        )
        print("‚úÖ DEBUG: Hole cards system log completed")
        sys.stdout.flush()

    def log_board_cards(self, board: List[str], street: str):
        """Log community cards for current street."""
        if not self.current_hand:
            return

        self.current_hand.board_cards = list(board)
        if street not in self.current_hand.streets_reached:
            self.current_hand.streets_reached.append(street)

        self.log_system(
            "INFO",
            "CARDS",
            f"Board cards - {street}",
            {
                "hand_id": self.current_hand.hand_id,
                "board": board,
                "street": street,
            },
        )

    def start_player_action(self, player_name: str):
        """Mark the start of a player's decision time."""
        self.action_start_times[player_name] = time.time()

        # Log thinking time start for human players
        if self.session and player_name == self.session.human_player:
            self.log_user_activity(
                "DECISION_THINKING_START",
                {
                    "player_name": player_name,
                    "hand_id": (
                        self.current_hand.hand_id
                        if self.current_hand
                        else None
                    ),
                    "street": (
                        getattr(self.current_hand, "street", "unknown")
                        if self.current_hand
                        else "unknown"
                    ),
                },
            )

    def log_action(
        self,
        player_name: str,
        player_index: int,
        action: str,
        amount: float,
        stack_before: float,
        stack_after: float,
        pot_before: float,
        pot_after: float,
        current_bet: float,
        street: str,
        position: str,
        is_human: bool,
    ):
        """Log a player action."""
        if not self.current_hand:
            return

        # Calculate decision time
        decision_time_ms = None
        if player_name in self.action_start_times:
            decision_time_ms = int(
                (time.time() - self.action_start_times[player_name]) * 1000
            )
            del self.action_start_times[player_name]

        # Calculate pot odds and ratios
        pot_odds = None
        stack_pot_ratio = None
        if amount > 0 and pot_before > 0:
            pot_odds = amount / (pot_before + amount)
            stack_pot_ratio = stack_before / pot_before

        action_log = ActionLog(
            timestamp=time.time(),
            hand_id=self.current_hand.hand_id,
            player_name=player_name,
            player_index=player_index,
            action=action,
            amount=amount,
            stack_before=stack_before,
            stack_after=stack_after,
            pot_before=pot_before,
            pot_after=pot_after,
            current_bet=current_bet,
            street=street,
            position=position,
            is_human=is_human,
            decision_time_ms=decision_time_ms,
            pot_odds=pot_odds,
            stack_pot_ratio=stack_pot_ratio,
        )

        # Add to appropriate street
        if street == "preflop":
            self.current_hand.preflop_actions.append(action_log)
        elif street == "flop":
            self.current_hand.flop_actions.append(action_log)
        elif street == "turn":
            self.current_hand.turn_actions.append(action_log)
        elif street == "river":
            self.current_hand.river_actions.append(action_log)

        self.log_system(
            "INFO",
            "ACTION",
            f"{player_name} {action}",
            {
                "hand_id": self.current_hand.hand_id,
                "action": action,
                "amount": amount,
                "street": street,
                "decision_time_ms": decision_time_ms,
            },
        )

    def end_hand(
        self,
        winner: str,
        winning_hand: str,
        pot_size: float,
        showdown: bool = False,
    ):
        """Complete the current hand logging."""
        if not self.current_hand:
            debug_print("‚ùå DEBUG: No current hand to end")
            return

        debug_print(
            f"üîÑ DEBUG: Ending hand with winner={winner}, hand={winning_hand}, pot=${
                pot_size:.2f}"
        )

        self.current_hand.winner = winner
        self.current_hand.winning_hand = winning_hand
        self.current_hand.pot_size = pot_size
        self.current_hand.showdown = showdown
        self.current_hand.hand_complete = True

        if self.hand_start_time:
            self.current_hand.hand_duration_ms = int(
                (time.time() - self.hand_start_time) * 1000
            )

        # Add to session
        if self.session:
            self.session.hands.append(self.current_hand)
            self.session.hands_played += 1
            debug_print(
                f"‚úÖ DEBUG: Hand added to session, total hands = {
                    self.session.hands_played}"
            )
        else:
            debug_print("‚ùå ERROR: No session available for hand completion")

        self.log_system(
            "INFO",
            "HAND",
            "Hand completed",
            {
                "hand_id": self.current_hand.hand_id,
                "winner": winner,
                "pot_size": pot_size,
                "showdown": showdown,
                "duration_ms": self.current_hand.hand_duration_ms,
                "hand_complete": True,
            },
        )

        # Save session data incrementally
        self._save_session()

        self.current_hand = None
        self.hand_start_time = None
        debug_print("‚úÖ DEBUG: Hand completion successful")

    def end_session_with_termination(
        self, termination_reason: str = "User quit"
    ):
        """End session with termination note for incomplete hands."""
        debug_print(
            f"üîÑ DEBUG: Ending session with termination: {termination_reason}"
        )

        # Complete current hand if it exists
        if self.current_hand:
            debug_print(
                "üîÑ DEBUG: Completing incomplete hand due to termination"
            )

            # Mark hand as incomplete
            self.current_hand.winner = "Session terminated"
            self.current_hand.winning_hand = (
                f"Session terminated - {termination_reason}"
            )
            self.current_hand.hand_complete = False  # Mark as incomplete
            self.current_hand.showdown = False

            if self.hand_start_time:
                self.current_hand.hand_duration_ms = int(
                    (time.time() - self.hand_start_time) * 1000
                )

            # Add to session
            if self.session:
                self.session.hands.append(self.current_hand)
                self.session.hands_played += 1
                debug_print("‚úÖ DEBUG: Incomplete hand added to session")

            # Log the termination
            self.log_system(
                "WARNING",
                "SESSION",
                f"Session terminated: {termination_reason}",
                {
                    "hand_id": self.current_hand.hand_id,
                    "termination_reason": termination_reason,
                    "hand_complete": False,
                    "pot_size": self.current_hand.pot_size,
                },
            )

            self.current_hand = None
            self.hand_start_time = None

        # End the session
        self.end_session()

        # Add final termination note
        self.log_system(
            "INFO",
            "SESSION",
            f"Session ended by user: {termination_reason}",
            {
                "hands_played": (
                    self.session.hands_played if self.session else 0
                ),
                "session_duration": (
                    time.time() - self.session.start_time
                    if self.session
                    else 0
                ),
                "termination_reason": termination_reason,
            },
        )

        debug_print("‚úÖ DEBUG: Session terminated successfully")

    def log_system(
        self,
        level: str,
        category: str,
        message: str,
        data: Optional[Dict] = None,
    ):
        """Log system-level messages with strict console policy and full file logging.

        Policy:
        - Always write all levels/categories to the file for full traceability
        - Console is reserved for critical/alert messages only (ERROR, CRITICAL)
        """
        timestamp_str = datetime.now().isoformat()

        # Console visibility per user policy: CRITICAL/ALERT only
        show_in_console = level in ["ERROR", "CRITICAL"]

        if show_in_console:
            console_msg = f"[{timestamp_str}] {level} | {category} | {message}"
            if data:
                console_msg += f" | {json.dumps(data, default=str)}"
            debug_print(console_msg)

        if not self.session:
            if show_in_console:
                debug_print("WARNING: No session available for logging")
            return

        system_log = SystemLog(
            timestamp=time.time(),
            session_id=self.session.session_id,
            level=level,
            category=category,
            message=message,
            data=data,
        )

        self.session.system_logs.append(system_log)

        # Write to system log file immediately (all messages go here)
        self._write_system_log_entry(system_log)

        # Only flush frequently for errors/warnings
        if level in ["ERROR", "WARNING"]:
            self._force_flush_all()

    def _write_system_log_entry(self, log_entry: SystemLog):
        """Write a single system log entry to file."""
        try:
            log_line = f"[{datetime.fromtimestamp(log_entry.timestamp).isoformat()}] {log_entry.level} | {log_entry.category} | {log_entry.message}"
            if log_entry.data:
                log_line += f" | {json.dumps(log_entry.data, default=str)}"

            with open(self.system_log_file, "a") as f:
                f.write(log_line + "\n")
                f.flush()
        except Exception as e:
            debug_print(f"Error writing system log: {e}")

    def _save_session(self):
        """Save session data to JSON file."""
        if not self.session or not self.session_file:
            return

        try:
            with open(self.session_file, "w") as f:
                json.dump(asdict(self.session), f, indent=2, default=str)
        except Exception as e:
            print(f"Error saving session: {e}")

    def _save_system_logs(self):
        """Persist a JSON snapshot of system logs without overwriting the stream log file.

        Writes to a sibling JSON file, preserving the line-oriented .log file intact.
        """
        if not self.session or not self.system_log_file:
            return

        try:
            system_data = {
                "session_id": self.session.session_id,
                "logs": [asdict(log) for log in self.session.system_logs],
            }
            snapshot_path = self.system_log_file.with_suffix(".json")
            with open(snapshot_path, "w") as f:
                json.dump(system_data, f, indent=2, default=str)
        except Exception as e:
            print(f"Error saving system logs: {e}")

    def get_session_summary(self) -> Dict[str, Any]:
        """Get a summary of the current session."""
        if not self.session:
            return {}

        return {
            "session_id": self.session.session_id,
            "hands_played": self.session.hands_played,
            "duration_ms": self.session.session_duration_ms,
            "players": self.session.num_players,
            "log_files": {
                "session": (
                    str(self.session_file) if self.session_file else None
                ),
                "system": (
                    str(self.system_log_file) if self.system_log_file else None
                ),
            },
        }

    def _register_shutdown_handlers(self):
        """Register signal handlers for graceful shutdown."""
        if self._shutdown_handlers_registered:
            return

        try:
            # Register signal handlers for Ctrl+C and other termination signals
            signal.signal(signal.SIGINT, self._signal_handler)  # Ctrl+C
            signal.signal(signal.SIGTERM, self._signal_handler)  # Termination

            # Register atexit handler for normal program exit (including Cmd+Q)
            atexit.register(self._cleanup_on_exit)

            self._shutdown_handlers_registered = True
            debug_print("‚úÖ Shutdown handlers registered successfully")

        except Exception as e:
            debug_print(
                f"‚ö†Ô∏è Warning: Could not register shutdown handlers: {e}"
            )

    def _signal_handler(self, signum, frame):
        """Handle shutdown signals (Ctrl+C, etc.)."""
        signal_names = {
            signal.SIGINT: "SIGINT (Ctrl+C)",
            signal.SIGTERM: "SIGTERM",
        }
        signal_name = signal_names.get(signum, f"Signal {signum}")

        print(f"\nüîÑ Received {signal_name} - Gracefully shutting down...")
        print("üíæ Saving session data...")

        # Save all pending data
        self._emergency_save()

        print("‚úÖ Session data saved successfully!")
        print("üëã Goodbye!")

        # Exit cleanly
        exit(0)

    def _cleanup_on_exit(self):
        """Cleanup function called on normal program exit (including Cmd+Q)."""
        try:
            if self.session:
                debug_print(
                    "üîÑ Normal exit detected - saving final session data..."
                )
                self.log_system(
                    "INFO",
                    "SHUTDOWN",
                    "Normal application exit - saving session data",
                    {},
                )
                self._save_final_session_data()
                debug_print("‚úÖ Final session data saved!")
        except Exception as e:
            debug_print(f"‚ö†Ô∏è Warning: Error during exit cleanup: {e}")

    def _save_final_session_data(self):
        """Save all session data immediately."""
        if not self.session:
            return

        # Update session end time
        self.session.end_time = time.time()
        if self.session.start_time:
            self.session.session_duration_ms = int(
                (self.session.end_time - self.session.start_time) * 1000
            )

        # Save all data
        self._save_session()
        self._save_system_logs()
        self._force_flush_all()

    def _force_flush_all(self):
        """Force immediate flush of all log files."""
        try:
            import sys

            # Flush stdout/stderr for debug messages
            sys.stdout.flush()
            sys.stderr.flush()

            # Force save session and system logs
            self._save_session()
            self._save_system_logs()

        except Exception as e:
            print(f"Warning: Could not force flush: {e}")

    def _emergency_save(self):
        """Emergency save of all session data."""
        try:
            # Complete current hand if it's in progress
            if self.current_hand and not self.current_hand.hand_complete:
                self.current_hand.hand_complete = True
                self.current_hand.winner = "Unknown (Emergency Exit)"
                self.current_hand.winning_hand = "Session terminated"

                if self.hand_start_time:
                    self.current_hand.hand_duration_ms = int(
                        (time.time() - self.hand_start_time) * 1000
                    )

                # Add to session if not already added
                if (
                    self.session
                    and self.current_hand not in self.session.hands
                ):
                    self.session.hands.append(self.current_hand)
                    self.session.hands_played += 1

            # End session properly
            if self.session:
                self.session.end_time = time.time()
                if self.session.start_time:
                    self.session.session_duration_ms = int(
                        (self.session.end_time - self.session.start_time)
                        * 1000
                    )

                # Log emergency shutdown
                self.log_system(
                    "WARNING",
                    "SESSION",
                    "Emergency shutdown - session terminated by user",
                    {
                        "hands_completed": self.session.hands_played,
                        "session_duration_ms": self.session.session_duration_ms,
                        "shutdown_reason": "SIGINT/Ctrl+C",
                    },
                )

                # Force save
                self._save_session()
                self._save_system_logs()
                self._force_flush_all()

        except Exception as e:
            print(f"Error during emergency save: {e}")
            # Try to at least save what we can
            try:
                if self.session:
                    self._save_session()
                    self._force_flush_all()
            except BaseException:
                print("Failed to save session data")

    # Enhanced User Activity Logging Methods
    def log_user_activity(
        self, activity_type: str, activity_data: Dict[str, Any] = None
    ):
        """Log user activities for analytics and feature development."""
        if activity_data is None:
            activity_data = {}

        activity_log = UserActivityLog(
            timestamp=time.time(),
            session_id=self.session_id,
            activity_type=activity_type,
            activity_data=activity_data,
        )

        if self.session:
            self.session.user_activities.append(activity_log)

        # Also log to system for immediate access
        self.log_system(
            "INFO",
            "USER_ACTIVITY",
            f"User activity: {activity_type}",
            {"activity_type": activity_type, "activity_data": activity_data},
        )

    def log_strategy_performance(
        self,
        hand_id: str,
        strategy_name: str,
        gto_recommendation: str,
        user_action: str,
        situation_context: Dict[str, Any] = None,
        deviation_type: str = None,
        outcome_quality: str = None,
    ):
        """Log strategy usage and performance for learning analytics."""
        if situation_context is None:
            situation_context = {}

        strategy_log = StrategyPerformanceLog(
            timestamp=time.time(),
            session_id=self.session_id,
            hand_id=hand_id,
            strategy_name=strategy_name,
            gto_recommendation=gto_recommendation,
            user_action=user_action,
            deviation_type=deviation_type,
            situation_context=situation_context,
            outcome_quality=outcome_quality,
        )

        if self.session:
            self.session.strategy_performance.append(strategy_log)

        self.log_system(
            "INFO",
            "STRATEGY_PERFORMANCE",
            f"Strategy analysis: {strategy_name}",
            {
                "strategy_name": strategy_name,
                "gto_vs_user": f"{gto_recommendation} vs {user_action}",
                "deviation_type": deviation_type,
                "outcome_quality": outcome_quality,
            },
        )

    def log_learning_progress(
        self,
        skill_area: str,
        performance_metric: str,
        current_value: float,
        previous_value: float = None,
        improvement_trend: str = None,
        confidence_level: float = None,
    ):
        """Log learning progress and skill development over time."""
        progress_log = LearningProgressLog(
            timestamp=time.time(),
            session_id=self.session_id,
            skill_area=skill_area,
            performance_metric=performance_metric,
            current_value=current_value,
            previous_value=previous_value,
            improvement_trend=improvement_trend,
            confidence_level=confidence_level,
        )

        if self.session:
            self.session.learning_progress.append(progress_log)

        self.log_system(
            "INFO",
            "LEARNING_PROGRESS",
            f"Progress in {skill_area}: {performance_metric}",
            {
                "skill_area": skill_area,
                "metric": performance_metric,
                "current_value": current_value,
                "previous_value": previous_value,
                "trend": improvement_trend,
            },
        )


# Global logger instance
_session_logger: Optional[SessionLogger] = None


def get_session_logger() -> SessionLogger:
    """Get the global session logger instance."""
    global _session_logger
    if _session_logger is None:
        _session_logger = SessionLogger()
    return _session_logger


def initialize_logging(log_directory: str = "logs") -> SessionLogger:
    """Initialize the global logging system."""
    global _session_logger
    _session_logger = SessionLogger(log_directory)
    return _session_logger
```

---

### session_manager.py

**Path**: `backend/core/session_manager.py`

**Size**: 13.8 KB

```python
"""
Session Manager for Poker State Machine

This module handles session tracking, logging, and statistics collection
for the poker game sessions.
"""

from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional
import time
import uuid
import json

# Import shared types
from .session_logger import SessionLogger
# from .types import Player, GameState  # Not used in this module
# PHH functionality removed - users can add hands through practice sessions


@dataclass
class SessionMetadata:
    """Complete session information and metadata."""
    session_id: str
    start_time: float
    end_time: Optional[float] = None
    total_hands: int = 0
    total_players: int = 0
    initial_stacks: Dict[str, float] = field(default_factory=dict)
    final_stacks: Dict[str, float] = field(default_factory=dict)
    big_blind_amount: float = 1.0
    strategy_data: Optional[Dict] = None
    session_notes: str = ""


@dataclass
class HandHistoryLog:
    """A snapshot of the game state at a specific action."""
    timestamp: float
    street: str
    player_name: str
    action: str
    amount: float
    pot_size: float
    board: List[str]
    player_states: List[dict]  # Store a simplified dict of each player's state


@dataclass
class HandResult:
    """Complete information about a hand's outcome."""
    hand_number: int
    start_time: float
    end_time: float
    players_at_start: List[Dict[str, Any]]
    players_at_end: List[Dict[str, Any]]
    board_cards: List[str]
    pot_amount: float
    winners: List[Dict[str, Any]]
    side_pots: List[Dict[str, Any]]
    action_history: List[HandHistoryLog]
    showdown_cards: Dict[str, List[str]] = field(default_factory=dict)


@dataclass
class SessionState:
    """Complete session state for replay and debugging."""
    session_metadata: SessionMetadata
    current_hand_number: int
    hands_played: List[HandResult]
    current_hand_state: Optional[Dict[str, Any]] = None
    current_hand_history: List[HandHistoryLog] = field(default_factory=list)
    session_log: List[str] = field(default_factory=list)


class SessionManager:
    """Manages session tracking, logging, and statistics."""

    def __init__(self, num_players: int, big_blind: float = 1.0,
                 logger: Optional[SessionLogger] = None):
        self.logger = logger or SessionLogger()
        self.session_state: Optional[SessionState] = None
        self.num_players = num_players
        self.big_blind = big_blind
        self.session_id: Optional[str] = None
        # PHH functionality removed - users can add hands through practice sessions

    def start_session(self) -> str:
        """Start a new session and return session ID."""
        session_id = str(uuid.uuid4())
        self.session_id = session_id
        
        self.session_state = SessionState(
            session_metadata=SessionMetadata(
                session_id=session_id,
                start_time=time.time(),
                total_players=self.num_players,
                big_blind_amount=self.big_blind
            ),
            current_hand_number=0,
            hands_played=[]
        )
        
        self._log_session_event("Session started")
        return session_id

    def end_session(self) -> Dict[str, Any]:
        """End the current session and return final statistics."""
        if not self.session_state:
            return {}
        
        self.session_state.session_metadata.end_time = time.time()
        self.session_state.session_metadata.total_hands = len(self.session_state.hands_played)
        
        self._log_session_event("Session ended")
        
        # Session completed - data available for analysis
        
        return self.get_session_info()
    
    # PHH export functionality removed - focus on JSON-based hands database

    def _log_session_event(self, event: str) -> None:
        """Log a session event."""
        if self.logger:
            try:
                self.logger.log_system("INFO", "SESSION", event)
            except Exception as e:
                print(f"Warning: Could not log session event: {e}")

    def capture_hand_start(self, hand_number: int, players: List[Dict[str, Any]], 
                          dealer_button: int, blinds: Dict[str, float]) -> None:
        """Capture the start of a new hand."""
        if not self.session_state:
            return
        
        self.session_state.current_hand_number = hand_number
        self.session_state.current_hand_history.clear()
        
        # Log hand start
        if self.logger:
            try:
                self.logger.log_system("INFO", "HAND", "Started hand", {
                    "hand_number": hand_number,
                    "dealer_button": dealer_button,
                    "blinds": blinds
                })
            except Exception as e:
                print(f"Warning: Could not log hand start: {e}")

    def capture_hand_end(self, hand_result: HandResult) -> None:
        """Capture the end of a hand."""
        if not self.session_state:
            return
        
        self.session_state.hands_played.append(hand_result)
        
        # Log hand completion
        if self.logger:
            try:
                self.logger.log_system("INFO", "HAND", "Hand completed", {
                    "hand_number": hand_result.hand_number,
                    "winner": hand_result.winners[0]["name"] if hand_result.winners else "None",
                    "pot_size": hand_result.pot_amount,
                    "duration_ms": int((hand_result.end_time - hand_result.start_time) * 1000)
                })
            except Exception as e:
                print(f"Warning: Could not log hand completion: {e}")

    def log_player_action(self, player_name: str, action: str, amount: float, 
                         pot_before: float, pot_after: float, street: str, 
                         board: List[str], player_states: List[Dict[str, Any]]) -> None:
        """Log a player action."""
        if not self.session_state:
            return
        
        action_log = HandHistoryLog(
            timestamp=time.time(),
            street=street,
            player_name=player_name,
            action=action,
            amount=amount,
            pot_size=pot_after,
            board=board.copy(),
            player_states=player_states
        )
        
        self.session_state.current_hand_history.append(action_log)
        
        # Log to system logger
        if self.logger:
            try:
                self.logger.log_system("INFO", "ACTION", f"{player_name} {action}", {
                    "amount": amount,
                    "pot_before": pot_before,
                    "pot_after": pot_after,
                    "street": street
                })
            except Exception as e:
                print(f"Warning: Could not log player action: {e}")

    def get_session_info(self) -> Dict[str, Any]:
        """Get comprehensive session information."""
        if not self.session_state:
            return {}
        
        metadata = self.session_state.session_metadata
        duration = (metadata.end_time or time.time()) - metadata.start_time
        
        return {
            "session_id": metadata.session_id,
            "start_time": metadata.start_time,
            "end_time": metadata.end_time,
            "duration_seconds": duration,
            "total_hands": metadata.total_hands,
            "total_players": metadata.total_players,
            "big_blind_amount": metadata.big_blind_amount,
            "hands_played": len(self.session_state.hands_played),
            "current_hand": self.session_state.current_hand_number
        }

    def get_session_statistics(self) -> Dict[str, Any]:
        """Get detailed session statistics."""
        if not self.session_state or not self.session_state.hands_played:
            return {}
        
        hands = self.session_state.hands_played
        total_duration = sum(h.end_time - h.start_time for h in hands)
        avg_hand_duration = total_duration / len(hands) if hands else 0
        
        # Calculate pot statistics
        pot_sizes = [h.pot_amount for h in hands]
        avg_pot_size = sum(pot_sizes) / len(pot_sizes) if pot_sizes else 0
        max_pot_size = max(pot_sizes) if pot_sizes else 0
        
        # Calculate winner statistics
        winner_counts: Dict[str, int] = {}
        for hand in hands:
            for winner in hand.winners:
                winner_name = winner["name"]
                winner_counts[winner_name] = winner_counts.get(winner_name, 0) + 1
        
        return {
            "total_hands": len(hands),
            "avg_hand_duration_seconds": avg_hand_duration,
            "total_session_duration_seconds": total_duration,
            "avg_pot_size": avg_pot_size,
            "max_pot_size": max_pot_size,
            "winner_distribution": winner_counts,
            "hands_per_hour": len(hands) / (total_duration / 3600) if total_duration > 0 else 0
        }

    def export_session(self, filepath: str) -> bool:
        """Export session data to JSON file."""
        if not self.session_state:
            return False
        
        try:
            session_data = {
                "session_info": self.get_session_info(),
                "statistics": self.get_session_statistics(),
                "hands": [
                    {
                        "hand_number": h.hand_number,
                        "start_time": h.start_time,
                        "end_time": h.end_time,
                        "board_cards": h.board_cards,
                        "pot_amount": h.pot_amount,
                        "winners": h.winners,
                        "action_history": [
                            {
                                "timestamp": a.timestamp,
                                "street": a.street,
                                "player_name": a.player_name,
                                "action": a.action,
                                "amount": a.amount,
                                "pot_size": a.pot_size,
                                "board": a.board
                            }
                            for a in h.action_history
                        ]
                    }
                    for h in self.session_state.hands_played
                ]
            }
            
            with open(filepath, 'w') as f:
                json.dump(session_data, f, indent=2)
            
            return True
        except Exception as e:
            print(f"Error exporting session: {e}")
            return False

    def import_session(self, filepath: str) -> bool:
        """Import session data from JSON file."""
        try:
            with open(filepath, 'r') as f:
                session_data = json.load(f)
            
            # Reconstruct session state from imported data
            # This is a simplified import - you might want to add more validation
            metadata = SessionMetadata(
                session_id=session_data["session_info"]["session_id"],
                start_time=session_data["session_info"]["start_time"],
                end_time=session_data["session_info"]["end_time"],
                total_hands=session_data["session_info"]["total_hands"],
                total_players=session_data["session_info"]["total_players"],
                big_blind_amount=session_data["session_info"]["big_blind_amount"]
            )
            
            # Reconstruct hands (simplified)
            hands = []
            for hand_data in session_data["hands"]:
                hand = HandResult(
                    hand_number=hand_data["hand_number"],
                    start_time=hand_data["start_time"],
                    end_time=hand_data["end_time"],
                    players_at_start=[],  # Would need to reconstruct
                    players_at_end=[],    # Would need to reconstruct
                    board_cards=hand_data["board_cards"],
                    pot_amount=hand_data["pot_amount"],
                    winners=hand_data["winners"],
                    side_pots=[],  # Would need to reconstruct
                    action_history=[]  # Would need to reconstruct
                )
                hands.append(hand)
            
            self.session_state = SessionState(
                session_metadata=metadata,
                current_hand_number=0,
                hands_played=hands
            )
            
            return True
        except Exception as e:
            print(f"Error importing session: {e}")
            return False

    def get_hand_history(self) -> List[HandHistoryLog]:
        """Get the current hand's action history."""
        if not self.session_state:
            return []
        return self.session_state.current_hand_history.copy()

    def get_comprehensive_session_data(self) -> Dict[str, Any]:
        """Get all session data for analysis."""
        if not self.session_state:
            return {}
        
        return {
            "session_info": self.get_session_info(),
            "statistics": self.get_session_statistics(),
            "current_hand_history": [
                {
                    "timestamp": a.timestamp,
                    "street": a.street,
                    "player_name": a.player_name,
                    "action": a.action,
                    "amount": a.amount,
                    "pot_size": a.pot_size,
                    "board": a.board
                }
                for a in self.session_state.current_hand_history
            ],
            "hands_played": [
                {
                    "hand_number": h.hand_number,
                    "start_time": h.start_time,
                    "end_time": h.end_time,
                    "board_cards": h.board_cards,
                    "pot_amount": h.pot_amount,
                    "winners": h.winners
                }
                for h in self.session_state.hands_played
            ]
        }
```

---

### __init__.py

**Path**: `backend/core/sessions/__init__.py`

**Size**: 560 bytes

```python
"""
Session Controllers for Clean Poker Architecture

This module provides session controllers that orchestrate different types of poker sessions
using the pure poker state machine core with dependency injection.
"""

from .base_session import BasePokerSession
from .hands_review_session import HandsReviewSession
from .gto_session import GTOSession
from .practice_session import PracticeSession
from .live_session import LiveSession

__all__ = [
    'BasePokerSession',
    'HandsReviewSession',
    'GTOSession', 
    'PracticeSession',
    'LiveSession',
]
```

---

### base_session.py

**Path**: `backend/core/sessions/base_session.py`

**Size**: 2.8 KB

```python
"""
Base Session Controller

Abstract base class for all poker session types.
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional
from ..pure_poker_state_machine import PurePokerStateMachine, GameConfig
from ..poker_types import Player
from ..hand_model import ActionType


class BasePokerSession(ABC):
    """
    Abstract base class for poker sessions.
    
    Each session type (Practice, GTO, HandsReview, Live) inherits from this
    and implements its own specific logic while using the pure FPSM core.
    """
    
    def __init__(self, config: GameConfig):
        self.config = config
        self.fpsm: Optional[PurePokerStateMachine] = None
        self.session_active = False
        self.session_type = self.__class__.__name__
        
    @abstractmethod
    def initialize_session(self) -> bool:
        """Initialize the session with appropriate providers."""
        pass
    
    @abstractmethod
    def start_hand(self, **kwargs) -> bool:
        """Start a new hand."""
        pass
    
    @abstractmethod
    def execute_action(self, player: Player, action_type: ActionType, amount: float = 0.0) -> bool:
        """Execute a player action."""
        pass
    
    @abstractmethod
    def get_valid_actions_for_player(self, player: Player) -> List[Dict[str, Any]]:
        """Get valid actions for a player."""
        pass
    
    def get_game_info(self) -> Dict[str, Any]:
        """Get current game information."""
        if not self.fpsm:
            return {}
        
        game_info = self.fpsm.get_game_info()
        game_info['session_type'] = self.session_type
        game_info['session_active'] = self.session_active
        return game_info
    
    def get_action_player(self) -> Optional[Player]:
        """Get the current action player."""
        if not self.fpsm or not self.fpsm.game_state.players:
            return None
        
        if 0 <= self.fpsm.action_player_index < len(self.fpsm.game_state.players):
            return self.fpsm.game_state.players[self.fpsm.action_player_index]
        
        return None
    
    def is_session_complete(self) -> bool:
        """Check if the session is complete."""
        return not self.session_active
    
    def end_session(self):
        """End the current session."""
        self.session_active = False
        print(f"üèÅ {self.session_type}: Session ended")
    
    def get_display_state(self) -> Dict[str, Any]:
        """Get display state for UI."""
        game_info = self.get_game_info()
        
        # Add session-specific display information
        game_info.update({
            'action_player_highlight': [
                i == self.fpsm.action_player_index if self.fpsm else False
                for i in range(len(game_info.get('players', [])))
            ]
        })
        
        return game_info
```

---

### gto_session.py

**Path**: `backend/core/sessions/gto_session.py`

**Size**: 8.4 KB

```python
"""
GTO Session Controller

Specialized session for GTO (Game Theory Optimal) poker with all bot players.
"""

from typing import Dict, Any, List, Optional
from .base_session import BasePokerSession
from ..pure_poker_state_machine import PurePokerStateMachine, GameConfig
from ..poker_types import Player
from ..hand_model import ActionType
from ..providers import GTODeck, StandardRules, AutoAdvancementController


class GTOSession(BasePokerSession):
    """
    Session controller for GTO poker with all bot players.
    
    Features:
    - All players are bots (no human interaction)
    - Auto-advancement through all game states
    - Seeded randomness for reproducible results
    - Integration with GTO decision engines
    """
    
    def __init__(self, config: GameConfig, decision_engines: Dict[str, Any] = None, seed: int = None):
        super().__init__(config)
        self.decision_engines = decision_engines or {}
        self.seed = seed
        self.hand_count = 0
        
    def initialize_session(self) -> bool:
        """Initialize GTO session with auto-advance providers."""
        try:
            # Create providers for GTO play
            deck_provider = GTODeck(seed=self.seed)
            rules_provider = StandardRules()
            advancement_controller = AutoAdvancementController()
            
            # Create pure FPSM with injected dependencies
            self.fpsm = PurePokerStateMachine(
                config=self.config,
                deck_provider=deck_provider,
                rules_provider=rules_provider,
                advancement_controller=advancement_controller
            )
            
            self.session_active = True
            print(f"ü§ñ GTO_SESSION: Initialized with {self.config.num_players} bot players")
            if self.seed is not None:
                print(f"ü§ñ GTO_SESSION: Using seed {self.seed} for reproducible results")
            return True
            
        except Exception as e:
            print(f"‚ùå GTO_SESSION: Failed to initialize: {e}")
            return False
    
    def start_hand(self, **kwargs) -> bool:
        """Start a new GTO hand."""
        try:
            if not self.fpsm:
                return False
            
            self.hand_count += 1
            
            # Create bot players
            bot_players = []
            for i in range(self.config.num_players):
                player = Player(
                    name=f"GTO_Bot_{i+1}",
                    stack=self.config.starting_stack,
                    position="",
                    is_human=False,  # All bots
                    is_active=True,
                    cards=[],
                )
                bot_players.append(player)
            
            # Start hand with bot players
            self.fpsm.start_hand(existing_players=bot_players)
            
            print(f"ü§ñ GTO_SESSION: Hand {self.hand_count} started with {len(bot_players)} bots")
            return True
            
        except Exception as e:
            print(f"‚ùå GTO_SESSION: Failed to start hand: {e}")
            return False
    
    def execute_action(self, player: Player, action_type: ActionType, amount: float = 0.0) -> bool:
        """Execute action through pure FPSM."""
        if not self.fpsm:
            return False
        
        print(f"ü§ñ GTO_SESSION: {player.name} {action_type.value} ${amount}")
        return self.fpsm.execute_action(player, action_type, amount)
    
    def get_valid_actions_for_player(self, player: Player) -> List[Dict[str, Any]]:
        """Get valid actions for a bot player."""
        if not self.fpsm:
            return []
        
        valid_actions = []
        
        # Fold is always valid (except when already folded)
        if not player.has_folded:
            valid_actions.append({"action": "fold", "amount": 0})
        
        # Check if player can check
        if player.current_bet == self.fpsm.game_state.current_bet:
            valid_actions.append({"action": "check", "amount": 0})
        
        # Call if there's a bet to call
        call_amount = max(0, self.fpsm.game_state.current_bet - player.current_bet)
        if call_amount > 0 and call_amount <= player.stack:
            valid_actions.append({"action": "call", "amount": call_amount})
        
        # Bet/Raise options
        min_bet = max(self.config.big_blind, self.fpsm.game_state.current_bet * 2)
        if player.stack >= min_bet:
            valid_actions.append({"action": "bet", "amount": min_bet})
            valid_actions.append({"action": "bet", "amount": player.stack})  # All-in
        
        return valid_actions
    
    def execute_next_bot_action(self) -> bool:
        """Execute the next bot action automatically."""
        try:
            action_player = self.get_action_player()
            if not action_player:
                return False
            
            # Get decision from appropriate decision engine
            decision_engine = self.decision_engines.get(action_player.name)
            if not decision_engine:
                # Use default GTO strategy (simplified)
                decision = self._get_default_gto_decision(action_player)
            else:
                game_state = self.fpsm.get_game_info()
                decision = decision_engine.get_decision(
                    self.fpsm.action_player_index,
                    game_state
                )
            
            if not decision or 'action' not in decision:
                return False
            
            # Execute the decision
            action_type = decision['action']
            amount = decision.get('amount', 0.0)
            
            return self.execute_action(action_player, action_type, amount)
            
        except Exception as e:
            print(f"‚ùå GTO_SESSION: Error executing bot action: {e}")
            return False
    
    def _get_default_gto_decision(self, player: Player) -> Dict[str, Any]:
        """Get a default GTO decision (simplified strategy)."""
        valid_actions = self.get_valid_actions_for_player(player)
        
        if not valid_actions:
            return {"action": ActionType.FOLD, "amount": 0}
        
        # Simple strategy: mostly call/check, occasionally bet
        import random
        
        # Check if we can check
        check_actions = [a for a in valid_actions if a["action"] == "check"]
        if check_actions and random.random() < 0.6:
            return {"action": ActionType.CHECK, "amount": 0}
        
        # Check if we can call
        call_actions = [a for a in valid_actions if a["action"] == "call"]
        if call_actions and random.random() < 0.7:
            return {"action": ActionType.CALL, "amount": call_actions[0]["amount"]}
        
        # Sometimes bet
        bet_actions = [a for a in valid_actions if a["action"] == "bet"]
        if bet_actions and random.random() < 0.3:
            return {"action": ActionType.BET, "amount": bet_actions[0]["amount"]}
        
        # Default to fold
        return {"action": ActionType.FOLD, "amount": 0}
    
    def run_hand_automatically(self) -> bool:
        """Run an entire hand automatically with bot decisions."""
        try:
            if not self.start_hand():
                return False
            
            max_actions = 100  # Safety limit
            actions_taken = 0
            
            while (not self.is_hand_complete() and 
                   actions_taken < max_actions and 
                   self.session_active):
                
                if not self.execute_next_bot_action():
                    break
                
                actions_taken += 1
            
            print(f"ü§ñ GTO_SESSION: Hand completed after {actions_taken} actions")
            return True
            
        except Exception as e:
            print(f"‚ùå GTO_SESSION: Error running automatic hand: {e}")
            return False
    
    def is_hand_complete(self) -> bool:
        """Check if the current hand is complete."""
        if not self.fpsm:
            return True
        
        from ..poker_types import PokerState
        return self.fpsm.current_state == PokerState.END_HAND
    
    def get_session_stats(self) -> Dict[str, Any]:
        """Get GTO session statistics."""
        return {
            "hands_played": self.hand_count,
            "session_type": "GTO",
            "seed": self.seed,
            "players": self.config.num_players,
        }
```

---

### hands_review_session.py

**Path**: `backend/core/sessions/hands_review_session.py`

**Size**: 8.5 KB

```python
"""
Hands Review Session Controller

Specialized session for reviewing historical hands with deterministic replay.
"""

from typing import Dict, Any, List, Optional
from .base_session import BasePokerSession
from ..pure_poker_state_machine import PurePokerStateMachine, GameConfig
from ..poker_types import Player
from ..hand_model import ActionType
from ..providers import DeterministicDeck, HandsReviewRules, HandsReviewAdvancementController
from ..hand_model_decision_engine import HandModelDecisionEngine


class HandsReviewSession(BasePokerSession):
    """
    Session controller for hands review with deterministic replay.
    
    Features:
    - Deterministic deck with known board/hole cards
    - Auto-advancement through all streets
    - Integration with HandModelDecisionEngine for action replay
    - No human interaction required
    """
    
    def __init__(self, config: GameConfig, decision_engine: HandModelDecisionEngine = None):
        super().__init__(config)
        self.decision_engine = decision_engine
        self.preloaded_hand_data: Optional[Dict[str, Any]] = None
        
    def initialize_session(self) -> bool:
        """Initialize hands review session with deterministic providers."""
        try:
            # Create providers for deterministic replay
            deck_provider = DeterministicDeck()
            rules_provider = HandsReviewRules()
            advancement_controller = HandsReviewAdvancementController()
            
            # Create pure FPSM with injected dependencies
            self.fpsm = PurePokerStateMachine(
                config=self.config,
                deck_provider=deck_provider,
                rules_provider=rules_provider,
                advancement_controller=advancement_controller
            )
            
            # Link decision engine to FPSM if provided
            if self.decision_engine:
                self.decision_engine.fpsm = self.fpsm
            
            self.session_active = True
            print(f"üîß HANDS_REVIEW: Session initialized with deterministic providers")
            return True
            
        except Exception as e:
            print(f"‚ùå HANDS_REVIEW: Failed to initialize session: {e}")
            return False
    
    def load_hand_for_review(self, hand_data: Dict[str, Any]) -> bool:
        """
        Load a specific hand for review.
        
        Args:
            hand_data: Hand data with initial_state containing players, board, etc.
        """
        try:
            if not self.fpsm:
                print(f"‚ùå HANDS_REVIEW: Session not initialized")
                return False
            
            self.preloaded_hand_data = hand_data
            initial_state = hand_data.get('initial_state', {})
            
            # Extract board cards and hole cards for deterministic deck
            board_cards = initial_state.get('board', [])
            
            # Extract hole cards from players
            hole_cards = {}
            players_data = initial_state.get('players', [])
            for player_data in players_data:
                player_name = player_data.get('name', '')
                player_cards = player_data.get('cards', [])
                if player_name and player_cards:
                    hole_cards[player_name] = player_cards
            
            # Update deck provider with known cards
            if hasattr(self.fpsm.deck_provider, 'set_board_cards'):
                self.fpsm.deck_provider.set_board_cards(board_cards)
            if hasattr(self.fpsm.deck_provider, 'set_hole_cards'):
                self.fpsm.deck_provider.set_hole_cards(hole_cards)
            
            print(f"üÉè HANDS_REVIEW: Loaded hand with {len(players_data)} players, board: {board_cards}")
            return True
            
        except Exception as e:
            print(f"‚ùå HANDS_REVIEW: Failed to load hand: {e}")
            return False
    
    def start_hand(self, **kwargs) -> bool:
        """Start hand with preloaded data."""
        try:
            if not self.fpsm or not self.preloaded_hand_data:
                print(f"‚ùå HANDS_REVIEW: No hand data loaded")
                return False
            
            initial_state = self.preloaded_hand_data['initial_state']
            players_data = initial_state.get('players', [])
            
            # Create players with exact data from hand
            loaded_players = []
            for i, player_data in enumerate(players_data):
                player = Player(
                    name=player_data.get('name', f'Player{i+1}'),
                    stack=player_data.get('stack', 1000.0),
                    position=player_data.get('position', 'UTG'),
                    is_human=False,  # All players are bots in review mode
                    is_active=player_data.get('is_active', True),
                    cards=player_data.get('cards', []),
                    current_bet=player_data.get('current_bet', 0.0),
                )
                loaded_players.append(player)
            
            # Start hand with preloaded players
            self.fpsm.start_hand(existing_players=loaded_players)
            
            # Set additional game state from preloaded data
            self.fpsm.game_state.pot = initial_state.get('pot', 0.0)
            self.fpsm.game_state.current_bet = initial_state.get('current_bet', 0.0)
            self.fpsm.game_state.street = initial_state.get('street', 'preflop')
            self.fpsm.game_state.board = initial_state.get('board', [])
            
            # Set positions
            if 'dealer_position' in initial_state:
                self.fpsm.dealer_position = initial_state['dealer_position']
            
            print(f"üÉè HANDS_REVIEW: Hand started with preloaded state")
            return True
            
        except Exception as e:
            print(f"‚ùå HANDS_REVIEW: Failed to start hand: {e}")
            return False
    
    def execute_action(self, player: Player, action_type: ActionType, amount: float = 0.0) -> bool:
        """Execute action through pure FPSM."""
        if not self.fpsm:
            return False
        
        return self.fpsm.execute_action(player, action_type, amount)
    
    def get_valid_actions_for_player(self, player: Player) -> List[Dict[str, Any]]:
        """Get valid actions (simplified for review mode)."""
        if not self.fpsm:
            return []
        
        # In review mode, actions are determined by the decision engine
        # This is mainly for compatibility
        return [
            {"action": "fold", "amount": 0},
            {"action": "check", "amount": 0}, 
            {"action": "call", "amount": max(0, self.fpsm.game_state.current_bet - player.current_bet)},
            {"action": "bet", "amount": player.stack},
        ]
    
    def step_forward(self) -> bool:
        """Step forward to the next action in the replay."""
        try:
            if not self.decision_engine or not self.fpsm:
                return False
            
            # Get current action player
            action_player = self.get_action_player()
            if not action_player:
                print(f"üõ°Ô∏è HANDS_REVIEW: No action player available")
                return False
            
            # Get decision from engine
            game_state = self.fpsm.get_game_info()
            decision = self.decision_engine.get_decision(
                self.fpsm.action_player_index, 
                game_state
            )
            
            if not decision or 'action' not in decision:
                print(f"üõ°Ô∏è HANDS_REVIEW: No valid decision available")
                return False
            
            # Execute the action
            action_type = decision['action']
            amount = decision.get('amount', 0.0)
            
            success = self.execute_action(action_player, action_type, amount)
            if success:
                print(f"üéØ HANDS_REVIEW: Executed {action_type.value} ${amount} for {action_player.name}")
            
            return success
            
        except Exception as e:
            print(f"‚ùå HANDS_REVIEW: Error stepping forward: {e}")
            return False
    
    def is_replay_complete(self) -> bool:
        """Check if the hand replay is complete."""
        if not self.decision_engine:
            return True
        
        return self.decision_engine.is_session_complete()
    
    def set_preloaded_hand_data(self, hand_data: Dict[str, Any]):
        """Set preloaded hand data for the session."""
        self.preloaded_hand_data = hand_data
```

---

### live_session.py

**Path**: `backend/core/sessions/live_session.py`

**Size**: 12.2 KB

```python
"""
Live Session Controller

Specialized session for live poker with mixed human and bot players.
"""

from typing import Dict, Any, List, Optional, Set
from .base_session import BasePokerSession
from ..pure_poker_state_machine import PurePokerStateMachine, GameConfig
from ..poker_types import Player
from ..hand_model import ActionType
from ..providers import StandardDeck, StandardRules, LiveAdvancementController


class LiveSession(BasePokerSession):
    """
    Session controller for live poker with mixed human/bot players.
    
    Features:
    - Configurable mix of human and bot players
    - Smart advancement based on player types
    - Real-time action handling
    - Spectator support
    - Chat and social features
    """
    
    def __init__(
        self, 
        config: GameConfig, 
        human_player_names: List[str] = None,
        bot_engines: Dict[str, Any] = None,
        allow_spectators: bool = True
    ):
        super().__init__(config)
        self.human_player_names: Set[str] = set(human_player_names or [])
        self.bot_engines = bot_engines or {}
        self.allow_spectators = allow_spectators
        self.spectators: Set[str] = set()
        self.hand_count = 0
        self.action_timeout_seconds = 30  # Default action timeout
        
    def initialize_session(self) -> bool:
        """Initialize live session with mixed player support."""
        try:
            # Create providers for live play
            deck_provider = StandardDeck(shuffle=True)
            rules_provider = StandardRules()
            advancement_controller = LiveAdvancementController(
                human_player_names=list(self.human_player_names)
            )
            
            # Create pure FPSM with injected dependencies
            self.fpsm = PurePokerStateMachine(
                config=self.config,
                deck_provider=deck_provider,
                rules_provider=rules_provider,
                advancement_controller=advancement_controller
            )
            
            self.session_active = True
            print(f"üéÆ LIVE_SESSION: Initialized with {len(self.human_player_names)} humans, {self.config.num_players - len(self.human_player_names)} bots")
            return True
            
        except Exception as e:
            print(f"‚ùå LIVE_SESSION: Failed to initialize: {e}")
            return False
    
    def start_hand(self, **kwargs) -> bool:
        """Start a new live hand."""
        try:
            if not self.fpsm:
                return False
            
            self.hand_count += 1
            
            # Create mixed players
            players = []
            human_names = list(self.human_player_names)
            
            for i in range(self.config.num_players):
                if i < len(human_names):
                    # Human player
                    player = Player(
                        name=human_names[i],
                        stack=self.config.starting_stack,
                        position="",
                        is_human=True,
                        is_active=True,
                        cards=[],
                    )
                else:
                    # Bot player
                    player = Player(
                        name=f"Bot_{i - len(human_names) + 1}",
                        stack=self.config.starting_stack,
                        position="",
                        is_human=False,
                        is_active=True,
                        cards=[],
                    )
                
                players.append(player)
            
            # Start hand
            self.fpsm.start_hand(existing_players=players)
            
            print(f"üéÆ LIVE_SESSION: Hand {self.hand_count} started")
            self._log_action_required()
            
            return True
            
        except Exception as e:
            print(f"‚ùå LIVE_SESSION: Failed to start hand: {e}")
            return False
    
    def execute_action(self, player: Player, action_type: ActionType, amount: float = 0.0) -> bool:
        """Execute action with live session handling."""
        if not self.fpsm:
            return False
        
        # Validate that it's this player's turn
        action_player = self.get_action_player()
        if not action_player or action_player.name != player.name:
            print(f"‚ùå LIVE_SESSION: Not {player.name}'s turn to act")
            return False
        
        # Execute through pure FPSM
        success = self.fpsm.execute_action(player, action_type, amount)
        
        if success:
            player_type = "Human" if player.is_human else "Bot"
            print(f"üéÆ LIVE_SESSION: {player.name} ({player_type}) {action_type.value} ${amount}")
            
            # Broadcast action to spectators
            self._broadcast_action(player, action_type, amount)
            
            # Handle next action
            self._handle_next_action()
        
        return success
    
    def _handle_next_action(self):
        """Handle the next action in the sequence."""
        action_player = self.get_action_player()
        
        if not action_player:
            return
        
        if action_player.is_human:
            # Human player - wait for input
            print(f"üéÆ LIVE_SESSION: Waiting for {action_player.name} to act")
            self._start_action_timer(action_player)
        else:
            # Bot player - execute automatically
            self._execute_bot_action_after_delay(action_player)
    
    def _execute_bot_action_after_delay(self, bot_player: Player):
        """Execute bot action after a realistic delay."""
        # In a real implementation, this would use a timer
        # For now, execute with a small delay simulation
        print(f"ü§ñ LIVE_SESSION: {bot_player.name} is thinking...")
        self.execute_next_bot_action()
    
    def execute_next_bot_action(self) -> bool:
        """Execute the next bot action."""
        try:
            action_player = self.get_action_player()
            if not action_player or action_player.is_human:
                return False
            
            # Get decision from bot engine
            bot_engine = self.bot_engines.get(action_player.name)
            if not bot_engine:
                decision = self._get_default_live_bot_decision(action_player)
            else:
                game_state = self.fpsm.get_game_info()
                decision = bot_engine.get_decision(
                    self.fpsm.action_player_index,
                    game_state
                )
            
            if not decision or 'action' not in decision:
                return False
            
            # Execute the bot decision
            action_type = decision['action']
            amount = decision.get('amount', 0.0)
            
            return self.execute_action(action_player, action_type, amount)
            
        except Exception as e:
            print(f"‚ùå LIVE_SESSION: Error executing bot action: {e}")
            return False
    
    def _get_default_live_bot_decision(self, player: Player) -> Dict[str, Any]:
        """Get a default bot decision for live play."""
        valid_actions = self.get_valid_actions_for_player(player)
        
        if not valid_actions:
            return {"action": ActionType.FOLD, "amount": 0}
        
        # More aggressive strategy for live play
        import random
        
        # Sometimes bet aggressively
        bet_actions = [a for a in valid_actions if a["action"] == "bet"]
        if bet_actions and random.random() < 0.4:
            return {"action": ActionType.BET, "amount": bet_actions[0]["amount"]}
        
        # Check when possible
        check_actions = [a for a in valid_actions if a["action"] == "check"]
        if check_actions and random.random() < 0.5:
            return {"action": ActionType.CHECK, "amount": 0}
        
        # Call moderately
        call_actions = [a for a in valid_actions if a["action"] == "call"]
        if call_actions and random.random() < 0.6:
            return {"action": ActionType.CALL, "amount": call_actions[0]["amount"]}
        
        # Fold as backup
        return {"action": ActionType.FOLD, "amount": 0}
    
    def get_valid_actions_for_player(self, player: Player) -> List[Dict[str, Any]]:
        """Get valid actions for live play."""
        if not self.fpsm:
            return []
        
        valid_actions = []
        
        # Standard actions
        if not player.has_folded:
            valid_actions.append({"action": "fold", "amount": 0})
        
        if player.current_bet == self.fpsm.game_state.current_bet:
            valid_actions.append({"action": "check", "amount": 0})
        
        call_amount = max(0, self.fpsm.game_state.current_bet - player.current_bet)
        if call_amount > 0 and call_amount <= player.stack:
            valid_actions.append({"action": "call", "amount": call_amount})
        
        # Betting options
        min_bet = max(self.config.big_blind, self.fpsm.game_state.current_bet * 2)
        if player.stack >= min_bet:
            # Minimum bet
            valid_actions.append({"action": "bet", "amount": min_bet})
            
            # Half pot
            half_pot = min(self.fpsm.game_state.pot // 2, player.stack)
            if half_pot >= min_bet:
                valid_actions.append({"action": "bet", "amount": half_pot})
            
            # Pot bet
            pot_bet = min(self.fpsm.game_state.pot, player.stack)
            if pot_bet >= min_bet:
                valid_actions.append({"action": "bet", "amount": pot_bet})
            
            # All-in
            if player.stack > min_bet:
                valid_actions.append({"action": "bet", "amount": player.stack})
        
        return valid_actions
    
    def add_spectator(self, spectator_name: str) -> bool:
        """Add a spectator to the session."""
        if not self.allow_spectators:
            return False
        
        self.spectators.add(spectator_name)
        print(f"üëÅÔ∏è LIVE_SESSION: {spectator_name} joined as spectator")
        return True
    
    def remove_spectator(self, spectator_name: str) -> bool:
        """Remove a spectator from the session."""
        if spectator_name in self.spectators:
            self.spectators.remove(spectator_name)
            print(f"üëÅÔ∏è LIVE_SESSION: {spectator_name} left as spectator")
            return True
        return False
    
    def _broadcast_action(self, player: Player, action_type: ActionType, amount: float):
        """Broadcast action to all spectators."""
        if self.spectators:
            action_msg = f"{player.name} {action_type.value} ${amount}"
            print(f"üì¢ BROADCAST: {action_msg} (to {len(self.spectators)} spectators)")
    
    def _start_action_timer(self, player: Player):
        """Start action timer for human player."""
        # In a real implementation, this would start a countdown timer
        print(f"‚è∞ LIVE_SESSION: {player.name} has {self.action_timeout_seconds} seconds to act")
    
    def _log_action_required(self):
        """Log which player needs to act."""
        action_player = self.get_action_player()
        if action_player:
            player_type = "Human" if action_player.is_human else "Bot"
            print(f"üéÆ LIVE_SESSION: Action required from {action_player.name} ({player_type})")
    
    def get_session_stats(self) -> Dict[str, Any]:
        """Get live session statistics."""
        human_players = [p for p in self.fpsm.game_state.players if p.is_human] if self.fpsm else []
        bot_players = [p for p in self.fpsm.game_state.players if not p.is_human] if self.fpsm else []
        
        return {
            "hands_played": self.hand_count,
            "session_type": "Live",
            "human_players": len(human_players),
            "bot_players": len(bot_players),
            "spectators": len(self.spectators),
            "human_stacks": {p.name: p.stack for p in human_players},
            "bot_stacks": {p.name: p.stack for p in bot_players},
        }
    
    def is_human_action_required(self) -> bool:
        """Check if a human player needs to act."""
        action_player = self.get_action_player()
        return action_player is not None and action_player.is_human
```

---

### practice_session.py

**Path**: `backend/core/sessions/practice_session.py`

**Size**: 11.0 KB

```python
"""
Practice Session Controller

Specialized session for practice play with one human player and bot opponents.
"""

from typing import Dict, Any, List, Optional
from .base_session import BasePokerSession
from ..pure_poker_state_machine import PurePokerStateMachine, GameConfig
from ..poker_types import Player
from ..hand_model import ActionType
from ..providers import StandardDeck, StandardRules, HumanAdvancementController


class PracticeSession(BasePokerSession):
    """
    Session controller for practice poker with human + bot players.
    
    Features:
    - One human player (usually position 0)
    - Bot opponents with configurable difficulty
    - Manual advancement when human is involved
    - Educational feedback and hints
    """
    
    def __init__(self, config: GameConfig, human_player_name: str = "Player1", bot_engines: Dict[str, Any] = None):
        super().__init__(config)
        self.human_player_name = human_player_name
        self.bot_engines = bot_engines or {}
        self.hand_count = 0
        self.human_action_pending = False
        
    def initialize_session(self) -> bool:
        """Initialize practice session with human-aware providers."""
        try:
            # Create providers for practice play
            deck_provider = StandardDeck(shuffle=True)
            rules_provider = StandardRules()
            advancement_controller = HumanAdvancementController(
                human_player_names=[self.human_player_name]
            )
            
            # Create pure FPSM with injected dependencies
            self.fpsm = PurePokerStateMachine(
                config=self.config,
                deck_provider=deck_provider,
                rules_provider=rules_provider,
                advancement_controller=advancement_controller
            )
            
            self.session_active = True
            print(f"üë§ PRACTICE_SESSION: Initialized with human player '{self.human_player_name}'")
            return True
            
        except Exception as e:
            print(f"‚ùå PRACTICE_SESSION: Failed to initialize: {e}")
            return False
    
    def start_hand(self, **kwargs) -> bool:
        """Start a new practice hand."""
        try:
            if not self.fpsm:
                return False
            
            self.hand_count += 1
            
            # Create players (human + bots)
            players = []
            for i in range(self.config.num_players):
                is_human = (i == 0)  # First player is human
                player_name = self.human_player_name if is_human else f"Bot_{i}"
                
                player = Player(
                    name=player_name,
                    stack=self.config.starting_stack,
                    position="",
                    is_human=is_human,
                    is_active=True,
                    cards=[],
                )
                players.append(player)
            
            # Start hand
            self.fpsm.start_hand(existing_players=players)
            
            # Check if human needs to act first
            action_player = self.get_action_player()
            self.human_action_pending = (action_player and action_player.is_human)
            
            print(f"üë§ PRACTICE_SESSION: Hand {self.hand_count} started")
            if self.human_action_pending:
                print(f"üë§ PRACTICE_SESSION: Waiting for human action from {action_player.name}")
            
            return True
            
        except Exception as e:
            print(f"‚ùå PRACTICE_SESSION: Failed to start hand: {e}")
            return False
    
    def execute_action(self, player: Player, action_type: ActionType, amount: float = 0.0) -> bool:
        """Execute action and handle human/bot flow."""
        if not self.fpsm:
            return False
        
        # Execute through pure FPSM
        success = self.fpsm.execute_action(player, action_type, amount)
        
        if success:
            print(f"üë§ PRACTICE_SESSION: {player.name} {'(Human)' if player.is_human else '(Bot)'} {action_type.value} ${amount}")
            
            # Update human action pending status
            next_action_player = self.get_action_player()
            self.human_action_pending = (next_action_player and next_action_player.is_human)
            
            # If next player is a bot, execute their action automatically
            if next_action_player and not next_action_player.is_human:
                self._execute_bot_action_after_delay()
        
        return success
    
    def _execute_bot_action_after_delay(self):
        """Execute bot action after a short delay for realism."""
        # In a real implementation, this might use a timer
        # For now, execute immediately
        self.execute_next_bot_action()
    
    def execute_next_bot_action(self) -> bool:
        """Execute the next bot action automatically."""
        try:
            action_player = self.get_action_player()
            if not action_player or action_player.is_human:
                return False
            
            # Get decision from bot engine
            bot_engine = self.bot_engines.get(action_player.name)
            if not bot_engine:
                decision = self._get_default_bot_decision(action_player)
            else:
                game_state = self.fpsm.get_game_info()
                decision = bot_engine.get_decision(
                    self.fpsm.action_player_index,
                    game_state
                )
            
            if not decision or 'action' not in decision:
                return False
            
            # Execute the bot decision
            action_type = decision['action']
            amount = decision.get('amount', 0.0)
            
            return self.execute_action(action_player, action_type, amount)
            
        except Exception as e:
            print(f"‚ùå PRACTICE_SESSION: Error executing bot action: {e}")
            return False
    
    def _get_default_bot_decision(self, player: Player) -> Dict[str, Any]:
        """Get a default bot decision for practice opponents."""
        valid_actions = self.get_valid_actions_for_player(player)
        
        if not valid_actions:
            return {"action": ActionType.FOLD, "amount": 0}
        
        # Simple practice bot strategy
        import random
        
        # Mostly passive for practice
        check_actions = [a for a in valid_actions if a["action"] == "check"]
        if check_actions and random.random() < 0.7:
            return {"action": ActionType.CHECK, "amount": 0}
        
        call_actions = [a for a in valid_actions if a["action"] == "call"]
        if call_actions and random.random() < 0.8:
            return {"action": ActionType.CALL, "amount": call_actions[0]["amount"]}
        
        # Occasionally fold to give human wins
        if random.random() < 0.3:
            return {"action": ActionType.FOLD, "amount": 0}
        
        # Rarely bet
        bet_actions = [a for a in valid_actions if a["action"] == "bet"]
        if bet_actions and random.random() < 0.2:
            return {"action": ActionType.BET, "amount": bet_actions[0]["amount"]}
        
        return {"action": ActionType.FOLD, "amount": 0}
    
    def get_valid_actions_for_player(self, player: Player) -> List[Dict[str, Any]]:
        """Get valid actions with educational context."""
        if not self.fpsm:
            return []
        
        valid_actions = []
        
        # Fold (always available unless already folded)
        if not player.has_folded:
            valid_actions.append({
                "action": "fold",
                "amount": 0,
                "description": "Give up your hand"
            })
        
        # Check (if no bet to call)
        if player.current_bet == self.fpsm.game_state.current_bet:
            valid_actions.append({
                "action": "check", 
                "amount": 0,
                "description": "Pass the action without betting"
            })
        
        # Call (if there's a bet to call)
        call_amount = max(0, self.fpsm.game_state.current_bet - player.current_bet)
        if call_amount > 0 and call_amount <= player.stack:
            valid_actions.append({
                "action": "call",
                "amount": call_amount,
                "description": f"Match the current bet of ${call_amount}"
            })
        
        # Bet/Raise options
        min_bet = max(self.config.big_blind, self.fpsm.game_state.current_bet * 2)
        if player.stack >= min_bet:
            valid_actions.append({
                "action": "bet",
                "amount": min_bet,
                "description": f"Bet ${min_bet} (minimum)"
            })
            
            # Pot-sized bet
            pot_bet = min(self.fpsm.game_state.pot, player.stack)
            if pot_bet >= min_bet:
                valid_actions.append({
                    "action": "bet",
                    "amount": pot_bet,
                    "description": f"Bet ${pot_bet} (pot-sized)"
                })
            
            # All-in
            if player.stack > min_bet:
                valid_actions.append({
                    "action": "bet",
                    "amount": player.stack,
                    "description": f"All-in ${player.stack}"
                })
        
        return valid_actions
    
    def get_human_player(self) -> Optional[Player]:
        """Get the human player."""
        if not self.fpsm:
            return None
        
        for player in self.fpsm.game_state.players:
            if player.is_human:
                return player
        
        return None
    
    def is_human_action_required(self) -> bool:
        """Check if human action is required."""
        return self.human_action_pending
    
    def get_educational_hint(self) -> str:
        """Get an educational hint for the current situation."""
        if not self.fpsm:
            return ""
        
        human_player = self.get_human_player()
        if not human_player:
            return ""
        
        # Simple hints based on game state
        pot_odds = self.fpsm.game_state.pot / max(1, self.fpsm.game_state.current_bet - human_player.current_bet)
        
        if pot_odds > 3:
            return "üí° Good pot odds - consider calling with marginal hands"
        elif self.fpsm.game_state.street == "preflop":
            return "üí° Preflop: Play tight, focus on premium hands"
        elif len(self.fpsm.game_state.board) >= 3:
            return "üí° Consider your hand strength relative to the board"
        
        return "üí° Think about your position and opponents' actions"
    
    def get_session_stats(self) -> Dict[str, Any]:
        """Get practice session statistics."""
        human_player = self.get_human_player()
        
        return {
            "hands_played": self.hand_count,
            "session_type": "Practice",
            "human_player": self.human_player_name,
            "human_stack": human_player.stack if human_player else 0,
            "starting_stack": self.config.starting_stack,
        }
```

---

### strategy_engine.py

**Path**: `backend/core/strategy_engine.py`

**Size**: 23.7 KB

```python
"""
GTO Strategy Engine for Poker State Machine

This module contains the GTO (Game Theory Optimal) strategy implementation,
including preflop ranges, hand strength evaluation, and bot action logic.
"""

from typing import Tuple, Optional, Dict, List, Any
import random

# Import shared types from types module
from .poker_types import ActionType, Player, GameState


class GTOStrategyEngine:
    """Handles GTO strategy decisions, ranges, and hand evaluations."""

    def __init__(self, num_players: int, strategy_data: Optional[dict] = None):
        self.num_players = num_players
        self.strategy_data = strategy_data
        self.gto_preflop_ranges = {}
        self._initialize_gto_ranges()

    def _initialize_gto_ranges(self):
        """Initialize GTO preflop ranges for 6-max poker."""
        self.gto_preflop_ranges = {
            "UTG": {
                "rfi": {
                    "range": ["AA-88", "AKs-AJs", "KQs", "AJo+", "KQo"],
                    "freq": 1.0,
                },
                "vs_rfi": {
                    "range": ["AA-99", "AKs-AQs", "AJo+", "KQo"],
                    "freq": 0.8,
                },
                "vs_three_bet": {
                    "range": ["AA-JJ", "AKs", "AKo"],
                    "freq": 0.8,
                },
            },
            "MP": {
                "rfi": {
                    "range": [
                        "AA-77",
                        "AKs-ATs",
                        "KQs-KJs",
                        "AJo+",
                        "KQo",
                        "KJo",
                    ],
                    "freq": 1.0,
                },
                "vs_rfi": {
                    "range": ["AA-88", "AKs-AJs", "AJo+", "KQo"],
                    "freq": 0.7,
                },
                "vs_three_bet": {
                    "range": ["AA-QQ", "AKs", "AKo"],
                    "freq": 0.8,
                },
            },
            "CO": {
                "rfi": {
                    "range": [
                        "AA-66",
                        "AKs-ATs",
                        "KQs-KTs",
                        "QJs",
                        "ATo+",
                        "KQo",
                        "KJo",
                        "QJo",
                    ],
                    "freq": 1.0,
                },
                "vs_rfi": {
                    "range": ["AA-77", "AKs-AJs", "AJo+", "KQo"],
                    "freq": 0.6,
                },
                "vs_three_bet": {
                    "range": ["AA-JJ", "AKs", "AKo"],
                    "freq": 0.8,
                },
            },
            "BTN": {
                "rfi": {
                    "range": [
                        "AA-55",
                        "AKs-ATs",
                        "KQs-KTs",
                        "QJs-QTs",
                        "JTs",
                        "T9s",
                        "AJo+",
                        "KQo",
                        "KJo",
                        "QJo",
                    ],
                    "freq": 1.0,
                },
                "vs_rfi": {
                    "range": ["AA-66", "AKs-AJs", "AJo+", "KQo"],
                    "freq": 0.5,
                },
                "vs_three_bet": {
                    "range": ["AA-QQ", "AKs", "AKo"],
                    "freq": 0.8,
                },
            },
            "SB": {
                "rfi": {
                    "range": [
                        "AA-22",
                        "AKs-A2s",
                        "KQs-K2s",
                        "QJs-Q2s",
                        "JTs-J2s",
                        "T9s",
                        "AJo+",
                        "KQo",
                        "KJo",
                        "QJo",
                        "JTo",
                    ],
                    "freq": 1.0,
                },
                "vs_rfi": {
                    "range": ["AA-44", "AKs-AJs", "AJo+", "KQo"],
                    "freq": 0.4,
                },
                "vs_three_bet": {
                    "range": ["AA-99", "AKs", "AKo"],
                    "freq": 0.8,
                },
            },
            "BB": {
                "rfi": {
                    "range": [
                        "AA-22",
                        "AKs-A2s",
                        "KQs-K2s",
                        "QJs-Q2s",
                        "JTs-J2s",
                        "T9s-T8s",
                        "98s",
                        "AJo+",
                        "KQo",
                        "KJo",
                        "QJo",
                        "JTo",
                        "T9o",
                    ],
                    "freq": 1.0,
                },
                "vs_rfi": {
                    "range": ["AA-33", "AKs-AJs", "AJo+", "KQo"],
                    # FIXED: Loosened from 0.3 to 0.6 for wider BB defense (GTO
                    # standard vs min-raise)
                    "freq": 0.6,
                },
                "vs_three_bet": {
                    "range": ["AA-88", "AKs", "AKo"],
                    "freq": 0.8,
                },
            },
        }

    def get_gto_bot_action(
        self, player: Player, game_state: GameState
    ) -> Tuple[ActionType, float]:
        """
        Get GTO bot action for a player.

        Args:
            player: The player making the decision
            game_state: Current game state

        Returns:
            Tuple of (action_type, amount)
        """
        street = game_state.street
        call_amount = game_state.current_bet - player.current_bet
        pot_odds = (
            call_amount / (game_state.pot + call_amount)
            if call_amount > 0
            else 0.0
        )

        # Preflop logic
        if street == "preflop" and not game_state.board:
            action, amount = self._get_gto_preflop_action(
                player, game_state, call_amount
            )
        # Postflop logic
        else:
            action, amount = self._get_gto_postflop_action(
                player, game_state, call_amount, pot_odds
            )

        # NEW: Comprehensive stack validation
        return self._validate_stack_limits(player, action, amount, call_amount)

    def _validate_stack_limits(
        self,
        player: Player,
        action: ActionType,
        amount: float,
        call_amount: float,
    ) -> Tuple[ActionType, float]:
        """Validate that action amount doesn't exceed stack and handle all-in scenarios."""
        if amount > player.stack:
            # Can't afford the action - need to handle all-in or fold
            if call_amount > 0:
                # Facing a bet - can all-in call or fold
                if player.stack >= call_amount:
                    return ActionType.CALL, player.stack  # All-in call
                else:
                    return ActionType.FOLD, 0.0  # Can't afford to call
            else:
                # No bet to call - can all-in bet or check
                if player.stack >= 2.0:  # Minimum bet amount
                    return ActionType.BET, player.stack  # All-in bet
                else:
                    return ActionType.CHECK, 0.0  # Can't afford to bet
        return action, amount  # Amount is valid

    def _get_gto_preflop_action(
        self, player: Player, game_state: GameState, call_amount: float
    ) -> Tuple[ActionType, float]:
        """Get GTO preflop action with FIXED validation."""
        hand = self.get_hand_notation(player.cards)
        position = player.position
        strength = self.get_preflop_hand_strength(player.cards)

        # FIXED: Calculate minimum raise properly
        min_raise_total = game_state.current_bet + game_state.min_raise

        # Short stack all-in logic
        if player.stack <= 2.0:
            if strength >= 70:
                return ActionType.RAISE, player.stack
            else:
                return ActionType.FOLD, 0.0

        # Determine context
        facing_bet = call_amount > 0

        # Get position ranges
        if position not in self.gto_preflop_ranges:
            return ActionType.FOLD, 0.0

        position_ranges = self.gto_preflop_ranges[position]

        # FIXED: RFI (Raise First In) - Check if pot is unopened
        if game_state.current_bet <= game_state.big_blind:
            # FIXED: For unchecked pots (call_amount == 0), always check (GTO:
            # no limp-raise weak)
            if call_amount == 0:
                return ActionType.CHECK, 0.0
            # For facing a bet, use range logic
            elif self.is_hand_in_range(hand, position_ranges["rfi"]["range"]):
                if random.random() <= position_ranges["rfi"]["freq"]:
                    # FIXED: Ensure raise meets minimum requirement
                    raise_amount = max(
                        min_raise_total, game_state.big_blind * 3
                    )
                    # Ensure integer bet sizes
                    raise_amount = int(round(raise_amount))
                    if raise_amount <= player.stack:
                        return ActionType.RAISE, raise_amount
                    else:
                        return ActionType.CALL, call_amount
                else:
                    return ActionType.FOLD, 0.0
            else:
                return ActionType.FOLD, 0.0

        # vs RFI
        elif facing_bet and game_state.current_bet <= game_state.big_blind * 3:
            # FIXED: BB-specific defense logic - defend 60% vs raise (GTO
            # standard)
            if position == "BB" and call_amount > 0:
                if random.random() < 0.6:  # Defend 60% vs raise
                    return ActionType.CALL, call_amount
                else:
                    return ActionType.FOLD, 0.0
            elif self.is_hand_in_range(
                hand, position_ranges["vs_rfi"]["range"]
            ):
                if random.random() <= position_ranges["vs_rfi"]["freq"]:
                    if strength >= 80:
                        # FIXED: Ensure raise meets minimum requirement
                        raise_amount = max(
                            min_raise_total, game_state.current_bet * 3
                        )
                        raise_amount = int(
                            round(raise_amount)
                        )  # Ensure integer bet sizes
                        if raise_amount <= player.stack:
                            return ActionType.RAISE, raise_amount
                        else:
                            return ActionType.CALL, call_amount
                    else:
                        return ActionType.CALL, call_amount
                else:
                    return ActionType.FOLD, 0.0
            else:
                return ActionType.FOLD, 0.0

        # vs 3-bet
        else:
            if self.is_hand_in_range(
                hand, position_ranges["vs_three_bet"]["range"]
            ):
                if random.random() <= position_ranges["vs_three_bet"]["freq"]:
                    if strength >= 80:  # Lower threshold for 3-bet defense
                        # FIXED: Ensure raise meets minimum requirement
                        raise_amount = max(
                            min_raise_total, game_state.current_bet * 2.5
                        )
                        raise_amount = int(
                            round(raise_amount)
                        )  # Ensure integer bet sizes
                        if raise_amount <= player.stack:
                            return ActionType.RAISE, raise_amount
                        else:
                            return ActionType.CALL, call_amount
                    else:
                        return ActionType.CALL, call_amount
                else:
                    return ActionType.FOLD, 0.0
            else:
                return ActionType.FOLD, 0.0

    def _get_gto_postflop_action(
        self,
        player: Player,
        game_state: GameState,
        call_amount: float,
        pot_odds: float,
    ) -> Tuple[ActionType, float]:
        """Get GTO postflop action with FIXED validation."""
        strength = self.get_postflop_hand_strength(
            player.cards, game_state.board
        )
        facing_bet = call_amount > 0

        # FIXED: Calculate minimum raise properly
        min_raise_total = game_state.current_bet + game_state.min_raise

        # Calculate SPR (Stack-to-Pot Ratio)
        spr = (
            player.stack / game_state.pot
            if game_state.pot > 0
            else float("inf")
        )

        # Board texture analysis
        texture = self.classify_board_texture(game_state.board)

        # Bet sizing based on board texture
        if texture["type"] == "dry":
            bet_size = game_state.pot * 0.6
        elif texture["type"] == "wet":
            bet_size = game_state.pot * 0.75
        else:  # medium
            bet_size = game_state.pot * 0.67

        # Stack depth adjustment
        stack_mult = min(1.0, max(0.3, spr / 5))
        bet_size *= stack_mult

        # POKER FIX: Round bet sizes to proper poker amounts (integers, BB
        # multiples)
        big_blind = game_state.big_blind

        def round_to_poker_bet(amount):
            """Round amount to proper poker bet size (integer, BB multiples)."""
            if amount < big_blind:
                return int(big_blind)
            # Round to nearest big blind for bets > 2BB, otherwise round to
            # nearest integer
            if amount >= 2 * big_blind:
                return int(round(amount / big_blind)) * int(big_blind)
            else:
                return int(round(amount))

        if facing_bet:
            # Facing a bet
            value_thresh = 70  # Raise nuts only
            call_thresh = pot_odds * 100
            if strength >= value_thresh:
                # FIXED: Ensure raise meets minimum requirement and round to
                # proper poker bet
                raise_amount = max(min_raise_total, bet_size)
                raise_amount = round_to_poker_bet(raise_amount)
                if raise_amount <= player.stack:
                    return ActionType.RAISE, raise_amount
                else:
                    return ActionType.CALL, call_amount
            elif strength > call_thresh and strength > 30:  # Call medium
                return ActionType.CALL, call_amount
            elif call_amount == 0:
                return ActionType.CHECK, 0.0
            else:
                return ActionType.FOLD, 0.0
        else:
            # No bet to call
            if strength >= 70:
                # FIXED: Ensure bet meets minimum requirement and round to
                # proper poker bet
                bet_amount = max(game_state.min_raise, bet_size)
                bet_amount = round_to_poker_bet(bet_amount)
                if bet_amount <= player.stack:
                    return ActionType.BET, bet_amount
                else:
                    return ActionType.CHECK, 0.0
            elif strength >= 50:
                return ActionType.CHECK, 0.0
            else:
                return ActionType.CHECK, 0.0

    def get_preflop_hand_strength(self, cards: List[str]) -> int:
        """Get preflop hand strength (0-100)."""
        if len(cards) != 2:
            return 0

        rank1, rank2 = cards[0][0], cards[1][0]
        suited = cards[0][1] == cards[1][1]

        # High card values
        rank_values = {
            "2": 2,
            "3": 3,
            "4": 4,
            "5": 5,
            "6": 6,
            "7": 7,
            "8": 8,
            "9": 9,
            "T": 10,
            "J": 11,
            "Q": 12,
            "K": 13,
            "A": 14,
        }

        val1, val2 = rank_values[rank1], rank_values[rank2]

        # Pairs
        if val1 == val2:
            if val1 >= 14:
                return 95  # AA
            elif val1 >= 12:
                return 90  # KK
            elif val1 >= 10:
                return 85  # QQ
            elif val1 >= 8:
                return 80  # JJ
            elif val1 >= 6:
                return 75  # TT
            else:
                return 70 + val1  # 99-22

        # Suited
        if suited:
            if val1 == 14 or val2 == 14:  # AKs, AQs, etc.
                if max(val1, val2) >= 12:
                    return 85
                elif max(val1, val2) >= 10:
                    return 80
                else:
                    return 75
            elif val1 >= 12 or val2 >= 12:  # KQs, KJs, etc.
                return 70 + min(val1, val2)
            else:
                return 60 + min(val1, val2)

        # Offsuit
        else:
            if val1 == 14 or val2 == 14:  # AKo, AQo, etc.
                if max(val1, val2) >= 12:
                    return 80
                elif max(val1, val2) >= 10:
                    return 75
                else:
                    return 70
            elif val1 >= 12 or val2 >= 12:  # KQo, KJo, etc.
                return 65 + min(val1, val2)
            else:
                return 55 + min(val1, val2)

    def get_postflop_hand_strength(
        self, cards: List[str], board: List[str]
    ) -> int:
        """Get postflop hand strength (0-100)."""
        if not board or len(cards) != 2:
            return 0

        # Simple hand strength calculation
        all_cards = cards + board
        ranks = [card[0] for card in all_cards]
        suits = [card[1] for card in all_cards]

        # Count ranks and suits
        rank_counts = {}
        suit_counts = {}

        for rank in ranks:
            rank_counts[rank] = rank_counts.get(rank, 0) + 1
        for suit in suits:
            suit_counts[suit] = suit_counts.get(suit, 0) + 1

        # Evaluate hand strength
        max_rank_count = max(rank_counts.values()) if rank_counts else 0
        max_suit_count = max(suit_counts.values()) if suit_counts else 0

        if max_rank_count >= 4:
            return 95  # Four of a kind
        elif max_rank_count == 3 and len(rank_counts) == 2:
            return 90  # Full house
        elif max_suit_count >= 5:
            return 85  # Flush
        elif max_rank_count == 3:
            return 80  # Three of a kind
        elif len([c for c in rank_counts.values() if c == 2]) == 2:
            return 75  # Two pair
        elif max_rank_count == 2:
            return 70  # One pair
        else:
            return 60  # High card

    def classify_board_texture(self, board: List[str]) -> Dict[str, Any]:
        """Classify board texture for postflop strategy."""
        if not board:
            return {"type": "dry", "dynamism": 0.0, "wetness": 0.0}

        ranks = [card[0] for card in board]
        suits = [card[1] for card in board]

        # Count suits
        suit_counts = {}
        for suit in suits:
            suit_counts[suit] = suit_counts.get(suit, 0) + 1

        # Calculate wetness (flush potential)
        max_suit = max(suit_counts.values()) if suit_counts else 0
        wetness = max_suit / len(board)

        # Calculate dynamism (straight potential)
        rank_values = {
            "2": 2,
            "3": 3,
            "4": 4,
            "5": 5,
            "6": 6,
            "7": 7,
            "8": 8,
            "9": 9,
            "T": 10,
            "J": 11,
            "Q": 12,
            "K": 13,
            "A": 14,
        }
        values = [rank_values[r] for r in ranks]
        values.sort()

        # Check for connected cards
        connected = 0
        for i in range(len(values) - 1):
            if values[i + 1] - values[i] <= 2:
                connected += 1

        dynamism = connected / (len(values) - 1) if len(values) > 1 else 0.0

        # Determine board type
        if wetness >= 0.6 or dynamism >= 0.7:
            board_type = "wet"
        elif wetness <= 0.4 and dynamism <= 0.3:
            board_type = "dry"
        else:
            board_type = "medium"

        return {"type": board_type, "wetness": wetness, "dynamism": dynamism}

    def get_hand_notation(self, cards: List[str]) -> str:
        """Convert cards to hand notation (e.g., 'AKs', 'TT')."""
        if len(cards) != 2:
            return ""

        rank1, rank2 = cards[0][0], cards[1][0]
        suited = cards[0][1] == cards[1][1]

        if rank1 == rank2:
            return rank1 + rank1  # e.g., "TT"
        else:
            # Order by rank value
            rank_values = {
                "2": 2,
                "3": 3,
                "4": 4,
                "5": 5,
                "6": 6,
                "7": 7,
                "8": 8,
                "9": 9,
                "T": 10,
                "J": 11,
                "Q": 12,
                "K": 13,
                "A": 14,
            }

            if rank_values[rank1] > rank_values[rank2]:
                high, low = rank1, rank2
            else:
                high, low = rank2, rank1

            suffix = "s" if suited else "o"
            return high + low + suffix  # e.g., "AKs", "AJo"

    def is_hand_in_range(self, hand: str, range_list: List[str]) -> bool:
        """Check if hand is in the given range."""
        for range_entry in range_list:
            if self._hand_matches_range_entry(hand, range_entry):
                return True
        return False

    def _hand_matches_range_entry(self, hand: str, range_entry: str) -> bool:
        """Check if hand matches a specific range entry."""
        if not hand or not range_entry:
            return False

        # Handle pairs
        if len(range_entry) == 2 and range_entry[0] == range_entry[1]:
            return hand[:2] == range_entry

        # Handle suited/offsuit
        if len(range_entry) == 3:
            if range_entry.endswith("s"):
                return hand == range_entry
            elif range_entry.endswith("o"):
                return hand == range_entry

        # Handle ranges like "AA-88"
        if "-" in range_entry:
            return self._hand_in_range(
                hand, range_entry.split("-")[0], range_entry.split("-")[1]
            )

        # Handle plus ranges like "AJo+"
        if range_entry.endswith("+"):
            return self._hand_stronger_than_or_equal(hand, range_entry[:-1])

        return hand == range_entry

    def _hand_in_range(
        self, hand: str, start_hand: str, end_hand: str
    ) -> bool:
        """Check if hand is in range between start and end hands."""
        hand_value = self._get_hand_strength_value(hand)
        start_value = self._get_hand_strength_value(start_hand)
        end_value = self._get_hand_strength_value(end_hand)

        return start_value >= hand_value >= end_value

    def _hand_stronger_than_or_equal(self, hand: str, base_hand: str) -> bool:
        """Check if hand is stronger than or equal to base hand."""
        hand_value = self._get_hand_strength_value(hand)
        base_value = self._get_hand_strength_value(base_hand)

        return hand_value >= base_value

    def _get_hand_strength_value(self, hand: str) -> int:
        """Get numeric strength value for hand comparison."""
        if not hand or len(hand) < 2:
            return 0

        rank_values = {
            "2": 2,
            "3": 3,
            "4": 4,
            "5": 5,
            "6": 6,
            "7": 7,
            "8": 8,
            "9": 9,
            "T": 10,
            "J": 11,
            "Q": 12,
            "K": 13,
            "A": 14,
        }

        # Pairs
        if len(hand) == 2 and hand[0] == hand[1]:
            return rank_values[hand[0]] * 100

        # Suited/offsuit
        if len(hand) == 3:
            high_rank = hand[0]
            low_rank = hand[1]
            suited = hand[2] == "s"

            high_val = rank_values[high_rank]
            low_val = rank_values[low_rank]

            # Suited hands are worth more
            multiplier = 10 if suited else 1
            return (high_val * 10 + low_val) * multiplier

        return 0
```

---

### table_felt_styles.py

**Path**: `backend/core/table_felt_styles.py`

**Size**: 9.0 KB

```python
"""
Table Felt Styles for Casino-Grade Poker Tables

This module provides 10 distinct casino-grade poker table felt styles
with authentic colors, patterns, and textures for digital poker applications.
"""

from typing import Dict, List, Tuple


class TableScheme:
    """Represents a complete table color scheme with felt, rail, border, background, and texture."""

    def __init__(
        self,
        name: str,
        felt_color: str,
        rail_color: str,
        border_color: str,
        background_color: str,
        pattern: str,
        notes: str,
        texture_type: str = "solid",
        gradient_colors: List[str] = None,
        has_gold_inlay: bool = False,
        lighting_effect: str = "none",
    ):
        self.name = name
        self.felt_color = felt_color  # Main playing surface
        self.rail_color = rail_color  # Table edge/border
        self.border_color = border_color  # Outer border/trim
        self.background_color = background_color  # Area around table
        self.pattern = pattern
        self.notes = notes

        # Texture and lighting properties
        # "solid", "gradient", "suede", "diamond", "microfiber", "velvet", "satin"
        self.texture_type = texture_type
        self.gradient_colors = gradient_colors or [
            felt_color
        ]  # For gradient effects
        self.has_gold_inlay = has_gold_inlay  # Gold thread borders
        # "none", "vignette", "center_glow", "frosted_edge"
        self.lighting_effect = lighting_effect

        # Legacy compatibility
        self.hex_color = felt_color  # For backward compatibility
        self.rgb = self._hex_to_rgb(felt_color)

    def _hex_to_rgb(self, hex_color: str) -> Tuple[int, int, int]:
        """Convert hex color to RGB tuple."""
        hex_color = hex_color.lstrip("#")
        return tuple(int(hex_color[i : i + 2], 16) for i in (0, 2, 4))

    def __str__(self):
        return f"{self.name} ({self.hex_color})"


class TableSchemeManager:
    """Manages complete table color schemes and provides switching functionality."""

    # Elite Professional Table Schemes (5 exceptional options) - Inspired by
    # PokerStars, WSOP, and premium casino software
    TABLE_SCHEMES = {
        1: TableScheme(
            name="PokerStars Classic Pro",
            felt_color="#1B4D3A",
            rail_color="#8B4513",
            border_color="#2F4F4F",
            background_color="#0A1A0A",
            pattern="Professional diamond weave with subtle card suit watermarks",
            notes="Inspired by PokerStars tournament tables - diamond pattern with embedded suit symbols for premium feel",
            texture_type="diamond_weave_pro",
            gradient_colors=["#1B4D3A", "#2A5D4A"],
            has_gold_inlay=True,
            lighting_effect="center_glow",
        ),
        2: TableScheme(
            name="WSOP Championship",
            felt_color="#8B1538",
            rail_color="#DAA520",
            border_color="#FFD700",
            background_color="#1A0A0A",
            pattern="Premium burgundy with gold accents and radial focus gradient",
            notes="World Series of Poker inspired - championship burgundy with gold trim and tournament lighting",
            texture_type="championship_luxury",
            gradient_colors=["#8B1538", "#9B2548", "#7B0A28"],
            has_gold_inlay=True,
            lighting_effect="tournament_spotlight",
        ),
        3: TableScheme(
            name="Carbon Fiber Elite",
            felt_color="#1C1C1C",
            rail_color="#2F2F2F",
            border_color="#4A4A4A",
            background_color="#0A0A0A",
            pattern="High-tech carbon fiber weave with subtle geometric patterns",
            notes="Modern high-stakes room - carbon fiber texture with geometric precision for tech-savvy players",
            texture_type="carbon_fiber_tech",
            gradient_colors=["#1C1C1C", "#2C2C2C"],
            lighting_effect="tech_glow",
        ),
        4: TableScheme(
            name="Royal Casino Sapphire",
            felt_color="#0F2A44",
            rail_color="#1E3A5F",
            border_color="#C0C0C0",
            background_color="#050F1A",
            pattern="Deep sapphire with silver accents and luxury crosshatch texture",
            notes="High-roller exclusive - deep blue with silver trim and luxury crosshatch for VIP experience",
            texture_type="luxury_crosshatch",
            gradient_colors=["#0F2A44", "#1F3A54", "#2F4A64"],
            has_gold_inlay=False,
            lighting_effect="vip_ambience",
        ),
        5: TableScheme(
            name="Emerald Professional",
            felt_color="#2E5D4A",
            rail_color="#654321",
            border_color="#228B22",
            background_color="#0F1F0F",
            pattern="Traditional emerald with modern speed cloth technology and suit symbol emboss",
            notes="Classic casino perfection - emerald green with speed cloth surface and subtle suit symbol embossing",
            texture_type="speed_cloth_pro",
            gradient_colors=["#2E5D4A", "#3E6D5A"],
            has_gold_inlay=False,
            lighting_effect="classic_vignette",
        ),
    }

    # Default scheme (PokerStars Classic Pro - professional diamond weave with
    # suit watermarks)
    DEFAULT_SCHEME_ID = 1

    def __init__(self):
        self.current_scheme_id = self.DEFAULT_SCHEME_ID

    def get_current_scheme(self) -> TableScheme:
        """Get the currently selected table scheme."""
        return self.TABLE_SCHEMES[self.current_scheme_id]

    def get_scheme_by_id(self, scheme_id: int) -> TableScheme:
        """Get a specific table scheme by ID."""
        if scheme_id in self.TABLE_SCHEMES:
            return self.TABLE_SCHEMES[scheme_id]
        return self.TABLE_SCHEMES[self.DEFAULT_SCHEME_ID]

    def set_scheme(self, scheme_id: int) -> bool:
        """Set the current table scheme. Returns True if successful."""
        if scheme_id in self.TABLE_SCHEMES:
            self.current_scheme_id = scheme_id
            return True
        return False

    def get_all_schemes(self) -> Dict[int, TableScheme]:
        """Get all available table schemes."""
        return self.TABLE_SCHEMES.copy()

    def get_scheme_names(self) -> List[str]:
        """Get a list of all scheme names for UI display."""
        return [scheme.name for scheme in self.TABLE_SCHEMES.values()]

    def get_current_felt_color(self) -> str:
        """Get the felt color of the current scheme."""
        return self.get_current_scheme().felt_color

    def get_current_rail_color(self) -> str:
        """Get the rail color of the current scheme."""
        return self.get_current_scheme().rail_color

    def get_current_border_color(self) -> str:
        """Get the border color of the current scheme."""
        return self.get_current_scheme().border_color

    def get_current_background_color(self) -> str:
        """Get the background color of the current scheme."""
        return self.get_current_scheme().background_color

    # Legacy compatibility methods
    def get_current_style(self) -> TableScheme:
        """Legacy compatibility - returns current scheme."""
        return self.get_current_scheme()

    def get_current_hex_color(self) -> str:
        """Legacy compatibility - returns felt color."""
        return self.get_current_felt_color()

    def set_style(self, style_id: int) -> bool:
        """Legacy compatibility - sets scheme."""
        return self.set_scheme(style_id)

    def get_all_styles(self) -> Dict[int, TableScheme]:
        """Legacy compatibility - returns all schemes."""
        return self.get_all_schemes()

    @property
    def current_style_id(self) -> int:
        """Legacy compatibility property."""
        return self.current_scheme_id

    def apply_scheme_to_widget(
        self, widget, element_type: str = "felt"
    ) -> None:
        """Apply the current scheme color to a Tkinter widget."""
        current_scheme = self.get_current_scheme()
        try:
            if hasattr(widget, "config"):
                if element_type == "felt":
                    widget.config(bg=current_scheme.felt_color)
                elif element_type == "rail":
                    widget.config(bg=current_scheme.rail_color)
                elif element_type == "border":
                    widget.config(bg=current_scheme.border_color)
                elif element_type == "background":
                    widget.config(bg=current_scheme.background_color)
        except Exception:
            pass  # Widget may not support background color

    def apply_style_to_widget(self, widget) -> None:
        """Legacy compatibility - apply felt color to widget."""
        self.apply_scheme_to_widget(widget, "felt")


# Global instance for easy access
scheme_manager = TableSchemeManager()

# Legacy compatibility
felt_manager = scheme_manager


def get_felt_manager() -> TableSchemeManager:
    """Get the global scheme manager instance (legacy compatibility)."""
    return scheme_manager


def get_scheme_manager() -> TableSchemeManager:
    """Get the global scheme manager instance."""
    return scheme_manager
```

---

### ui_renderer.py

**Path**: `backend/core/ui_renderer.py`

**Size**: 10.3 KB

```python
"""
UI Display Renderer for Poker State Machine

This module handles UI-ready display state generation and rendering logic
for the poker game interface.
"""

from dataclasses import dataclass
from typing import Dict, Any, List, Tuple
import math

# Import shared types
from .poker_types import GameState, PokerState, ActionType


@dataclass
class DisplayState:
    """UI-ready display state with pre-computed visual data."""

    valid_actions: Dict[str, Dict[str, Any]]  # Button states and labels
    player_highlights: List[bool]  # Index-based list for highlighting
    card_visibilities: List[bool]  # Per-player: True if cards should be shown
    chip_representations: Dict[str, str]  # Chip symbols for stacks and pots
    layout_positions: Dict[str, Tuple[int, int]]  # UI positions
    # Current board cards (preserved during showdown)
    community_cards: List[str]
    pot_amount: float  # Current pot amount
    current_bet: float  # Current bet amount
    action_player_index: int  # Index of current action player
    game_state: str  # Current game state string
    last_action_details: str  # Last action for UI feedback


class UIDisplayRenderer:
    """Handles UI-ready display state generation."""

    def __init__(self, width: int = 800, height: int = 600):
        self.width = width
        self.height = height

    def get_display_state(
        self,
        game_state: GameState,
        current_state: PokerState,
        action_player_index: int,
        last_action_details: str = "",
    ) -> DisplayState:
        """
        Generate UI-ready display state.

        Args:
            game_state: Current game state
            current_state: Current poker state
            action_player_index: Index of current action player
            last_action_details: Details of last action for UI feedback

        Returns:
            DisplayState object with all UI data
        """
        # Generate valid actions for each player
        valid_actions = self._generate_valid_actions(
            game_state, action_player_index
        )

        # Generate player highlights
        player_highlights = [
            i == action_player_index for i in range(len(game_state.players))
        ]

        # Generate card visibilities
        card_visibilities = self._generate_card_visibilities(
            game_state, current_state
        )

        # Generate chip representations
        chip_representations = self._generate_chip_representations(game_state)

        # Generate layout positions
        layout_positions = self._compute_layout_positions(
            len(game_state.players)
        )

        return DisplayState(
            valid_actions=valid_actions,
            player_highlights=player_highlights,
            card_visibilities=card_visibilities,
            chip_representations=chip_representations,
            layout_positions=layout_positions,
            community_cards=game_state.board.copy(),
            pot_amount=game_state.pot,
            current_bet=game_state.current_bet,
            action_player_index=action_player_index,
            game_state=current_state.value,
            last_action_details=last_action_details,
        )

    def _generate_valid_actions(
        self, game_state: GameState, action_player_index: int
    ) -> Dict[str, Dict[str, Any]]:
        """Generate valid actions for each player."""
        valid_actions = {}

        for i, player in enumerate(game_state.players):
            if not player.is_active:
                valid_actions[player.name] = {
                    "fold": False,
                    "check": False,
                    "call": False,
                    "bet": False,
                    "raise": False,
                }
                continue

            # Only show actions for current action player
            if i != action_player_index:
                valid_actions[player.name] = {
                    "fold": False,
                    "check": False,
                    "call": False,
                    "bet": False,
                    "raise": False,
                }
                continue

            # Calculate call amount
            call_amount = game_state.current_bet - player.current_bet

            # Determine valid actions
            actions = {
                "fold": True,  # Always available
                "check": call_amount == 0,
                "call": call_amount > 0 and call_amount <= player.stack,
                "bet": call_amount == 0 and player.stack > 0,
                "raise": call_amount > 0 and player.stack > call_amount,
            }

            valid_actions[player.name] = actions

        return valid_actions

    def _generate_card_visibilities(
        self, game_state: GameState, current_state: PokerState
    ) -> List[bool]:
        """Generate card visibility flags for each player."""
        visibilities = []

        for player in game_state.players:
            # Show cards if player is human or if we're in showdown/end_hand
            should_show = player.is_human or current_state in [
                PokerState.SHOWDOWN,
                PokerState.END_HAND,
            ]
            visibilities.append(should_show)

        return visibilities

    def _generate_chip_representations(
        self, game_state: GameState
    ) -> Dict[str, str]:
        """Generate chip symbol representations for stacks and pots."""
        representations = {}

        # Player stacks
        for player in game_state.players:
            representations[f"{player.name}_stack"] = self._get_chip_symbols(
                player.stack
            )
            if player.current_bet > 0:
                representations[f"{player.name}_bet"] = self._get_chip_symbols(
                    player.current_bet
                )

        # Pot
        representations["pot"] = self._get_pot_chip_symbols(game_state.pot)

        return representations

    def _get_chip_symbols(self, amount: float) -> str:
        """Convert amount to chip symbol representation."""
        if amount <= 0:
            return ""

        # Simple chip representation
        chip_count = self._calculate_chip_count(amount)
        if chip_count <= 5:
            return "üü°" * chip_count
        elif chip_count <= 10:
            return "üü°" * 5 + "üî¥" * (chip_count - 5)
        else:
            return "üü°" * 5 + "üî¥" * 5 + "üü¢" * (chip_count - 10)

    def _get_pot_chip_symbols(self, amount: float) -> str:
        """Convert pot amount to chip symbol representation."""
        if amount <= 0:
            return ""

        chip_count = self._calculate_pot_chip_count(amount)
        if chip_count <= 3:
            return "üü°" * chip_count
        elif chip_count <= 8:
            return "üü°" * 3 + "üî¥" * (chip_count - 3)
        else:
            return "üü°" * 3 + "üî¥" * 5 + "üü¢" * (chip_count - 8)

    def _calculate_chip_count(self, amount: float) -> int:
        """Calculate number of chips to represent an amount."""
        if amount <= 0:
            return 0

        # Simple scaling: 1 chip per $1, max 20 chips
        chip_count = min(20, max(1, int(amount)))
        return chip_count

    def _calculate_pot_chip_count(self, amount: float) -> int:
        """Calculate number of chips to represent pot amount."""
        if amount <= 0:
            return 0

        # Pot chips scale differently: 1 chip per $2, max 15 chips
        chip_count = min(15, max(1, int(amount / 2)))
        return chip_count

    def _compute_layout_positions(
        self, num_players: int
    ) -> Dict[str, Tuple[int, int]]:
        """
        Compute UI positions for players around the poker table.

        Args:
            num_players: Number of players in the game

        Returns:
            Dictionary mapping player names to (x, y) positions
        """
        positions = {}

        # Table dimensions
        table_width = self.width * 0.8
        table_height = self.height * 0.6
        center_x = self.width / 2
        center_y = self.height / 2

        # Player positions around oval table
        for i in range(num_players):
            # Calculate angle for this player
            angle = (
                2 * math.pi * i
            ) / num_players - math.pi / 2  # Start from top

            # Calculate position on oval
            radius_x = table_width / 2 * 0.8
            radius_y = table_height / 2 * 0.8

            x = center_x + radius_x * math.cos(angle)
            y = center_y + radius_y * math.sin(angle)

            # Store position
            positions[f"Player {i + 1}"] = (int(x), int(y))

        return positions

    def get_player_position_name(self, index: int, num_players: int) -> str:
        """Get position name for player index."""
        if num_players == 6:
            positions = ["BTN", "SB", "BB", "UTG", "MP", "CO"]
        elif num_players == 5:
            positions = ["BTN", "SB", "BB", "UTG", "MP"]
        elif num_players == 4:
            positions = ["BTN", "SB", "BB", "UTG"]
        else:
            positions = ["BTN", "SB", "BB"]

        return positions[index] if index < len(positions) else f"P{index}"

    def format_action_label(self, action: ActionType, amount: float) -> str:
        """Format action for UI display."""
        if action == ActionType.FOLD:
            return "Fold"
        elif action == ActionType.CHECK:
            return "Check"
        elif action == ActionType.CALL:
            return f"Call ${amount:.2f}"
        elif action == ActionType.BET:
            return f"Bet ${amount:.2f}"
        elif action == ActionType.RAISE:
            return f"Raise ${amount:.2f}"
        else:
            return str(action.value).title()

    def get_game_state_display_name(self, state: PokerState) -> str:
        """Get human-readable game state name."""
        state_names = {
            PokerState.START_HAND: "Starting Hand",
            PokerState.PREFLOP_BETTING: "Preflop Betting",
            PokerState.DEAL_FLOP: "Dealing Flop",
            PokerState.FLOP_BETTING: "Flop Betting",
            PokerState.DEAL_TURN: "Dealing Turn",
            PokerState.TURN_BETTING: "Turn Betting",
            PokerState.DEAL_RIVER: "Dealing River",
            PokerState.RIVER_BETTING: "River Betting",
            PokerState.SHOWDOWN: "Showdown",
            PokerState.END_HAND: "Hand Complete",
        }
        return state_names.get(state, state.value.replace("_", " ").title())
```

---

### __init__.py

**Path**: `backend/ui/__init__.py`

**Size**: 241 bytes

```python
"""
UI module for poker strategy practice system.

New UI architecture using EventBus/Store pattern.
"""

# For new UI architecture, AppShell is the main entry point
# Legacy components can be imported individually when needed

__all__ = [] 
```

---

### app_shell.py

**Path**: `backend/ui/app_shell.py`

**Size**: 14.8 KB

```python
import tkinter as tk
from tkinter import ttk
import uuid

from .services.event_bus import EventBus
from .services.service_container import ServiceContainer
from .services.timer_manager import TimerManager
from .services.theme_manager import ThemeManager
from .services.hands_repository import HandsRepository, StudyMode
from .state.store import Store
from .state.reducers import root_reducer
from .mvu.hands_review_integrated import MVUHandsReviewTabIntegrated
from .tabs.practice_session_tab import PracticeSessionTab
from .tabs.gto_session_tab import GTOSessionTab

from .menu_integration import add_theme_manager_to_menu


class AppShell(ttk.Frame):
    def __init__(self, root):
        super().__init__(root)
        self.root = root  # Store root reference for menu integration
        self.pack(fill="both", expand=True)
        self.notebook = ttk.Notebook(self)
        self.notebook.pack(fill="both", expand=True)

        # app-scoped services
        self.services = ServiceContainer()
        self.services.provide_app("event_bus", EventBus())
        self.services.provide_app("theme", ThemeManager())
        self.services.provide_app("hands_repository", HandsRepository())
        
        # Create global GameDirector for action sequencing
        from .services.game_director import GameDirector
        game_director = GameDirector(event_bus=self.services.get_app("event_bus"))
        self.services.provide_app("game_director", game_director)
        
        # Create global EffectBus service for sound management
        from .services.effect_bus import EffectBus
        effect_bus = EffectBus(
            game_director=game_director,
            event_bus=self.services.get_app("event_bus")
        )
        self.services.provide_app("effect_bus", effect_bus)
        
        # Create architecture compliant hands review controller
        from .services.hands_review_event_controller import HandsReviewEventController
        
        # Initialize Store with initial state and reducer
        initial_state = {
            "table": {"dim": {"width": 800, "height": 600}},
            "seats": [],
            "board": [],
            "pot": {"amount": 0},
            "dealer": {},
            "review": {},
            "enhanced_rpgw": {},
            "event_bus": self.services.get_app("event_bus")
        }
        store = Store(initial_state, root_reducer)
        self.services.provide_app("store", store)
        
        hands_review_controller = HandsReviewEventController(
            event_bus=self.services.get_app("event_bus"),
            store=store,
            services=self.services
        )
        self.services.provide_app("hands_review_controller", hands_review_controller)
        
        # Subscribe to voice events to keep architecture event-driven
        def _on_voice(payload):
            try:
                action = (payload or {}).get("action")
                vm = getattr(effect_bus, "voice_manager", None)
                if not (vm and action):
                    return
                cfg = getattr(effect_bus, "config", {}) or {}
                voice_type = getattr(effect_bus, "voice_type", "")
                table = (cfg.get("voice_sounds", {}) or {}).get(voice_type, {})
                rel = table.get(action)
                if rel:
                    vm.play(rel)
            except Exception:
                pass
        self.services.get_app("event_bus").subscribe("effect_bus:voice", _on_voice)
        
        # Create shared store for poker game state (per architecture doc)
        initial_state = {
            "table": {"dim": (0, 0)},
            "pot": {"amount": 0},
            "seats": [],
            "board": [],
            "dealer": 0,
            "active_tab": "",
            "review": {
                "hands": [],
                "filter": {},
                "loaded_hand": None,
                "study_mode": StudyMode.REPLAY.value,
                "collection": None
            }
        }
        self.services.provide_app("store", Store(initial_state, root_reducer))

        # Create menu system
        self._create_menu_system()
        
        # tabs (order: Practice, GTO, Hands Review - main product features only)
        self._add_tab("Practice Session", PracticeSessionTab)
        self._add_tab("GTO Session", GTOSessionTab)
        self._add_tab("Hands Review (MVU)", MVUHandsReviewTabIntegrated)
        # Bind global font size shortcuts (Cmd/Ctrl - and =)
        self._bind_font_shortcuts(root)

    def _add_tab(self, title: str, TabClass):
        session_id = str(uuid.uuid4())
        timers = TimerManager(self)
        self.services.provide_session(session_id, "timers", timers)

        # Update active tab in shared store
        store = self.services.get_app("store")
        store.dispatch({"type": "SET_ACTIVE_TAB", "name": title})
        
        # Create tab with services
        tab = TabClass(self.notebook, self.services)
        self.notebook.add(tab, text=title)
        
        # Call on_show if available
        if hasattr(tab, "on_show"):
            tab.on_show()

    def _create_menu_system(self):
        """Create the application menu system."""
        # Create menu bar
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)
        
        # File menu
        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="File", menu=file_menu)
        file_menu.add_command(label="New Session", command=self._new_session)
        file_menu.add_separator()
        file_menu.add_command(label="Exit", command=self.root.quit)
        
        # View menu
        view_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="View", menu=view_menu)
        view_menu.add_command(label="Zoom In", accelerator="Cmd+=", command=lambda: self._increase_font(None))
        view_menu.add_command(label="Zoom Out", accelerator="Cmd+-", command=lambda: self._decrease_font(None))
        view_menu.add_command(label="Reset Zoom", accelerator="Cmd+0", command=lambda: self._reset_font(None))
        
        # Settings menu
        settings_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Settings", menu=settings_menu)
        
        # Theme management
        settings_menu.add_command(label="Theme Editor", command=self._open_theme_editor)
        settings_menu.add_command(label="Sound Settings", command=self._open_sound_settings)
        settings_menu.add_separator()
        
        # Add Theme Manager to Settings menu using our integration helper
        add_theme_manager_to_menu(settings_menu, self.root, self._on_theme_changed)
        
        # Help menu
        help_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Help", menu=help_menu)
        help_menu.add_command(label="About", command=self._show_about)
        
    def _new_session(self):
        """Start a new session."""
        print("üîÑ New session requested")
        # TODO: Implement session reset
        
    def _on_theme_changed(self):
        """Called when theme is changed via Theme Manager."""
        print("üé® Theme changed - refreshing UI...")
        
        try:
            # Reload theme manager to get latest changes
            theme_manager = self.services.get_app("theme")
            if hasattr(theme_manager, 'reload'):
                theme_manager.reload()
            
            # Force rebuild themes to pick up any live changes
            try:
                from .services.theme_factory import build_all_themes
                themes = build_all_themes()
                # Register updated themes
                for name, tokens in themes.items():
                    theme_manager.register(name, tokens)
                print(f"üîÑ Rebuilt and registered {len(themes)} themes")
            except Exception as e:
                print(f"‚ö†Ô∏è Theme rebuild warning: {e}")
            
            # Refresh all tabs with new theme
            for i in range(self.notebook.index("end")):
                try:
                    tab = self.notebook.nametowidget(self.notebook.tabs()[i])
                    
                    # Try multiple refresh methods
                    if hasattr(tab, '_refresh_ui_colors'):
                        tab._refresh_ui_colors()
                        print(f"‚úÖ Refreshed tab {i} via _refresh_ui_colors")
                    elif hasattr(tab, 'refresh_theme'):
                        tab.refresh_theme()
                        print(f"‚úÖ Refreshed tab {i} via refresh_theme")
                    elif hasattr(tab, '_on_theme_changed'):
                        tab._on_theme_changed()
                        print(f"‚úÖ Refreshed tab {i} via _on_theme_changed")
                    else:
                        print(f"‚ÑπÔ∏è Tab {i} has no theme refresh method")
                        
                except Exception as e:
                    print(f"‚ö†Ô∏è Error refreshing tab {i}: {e}")
            
            print("‚úÖ Live theme refresh completed")
            
        except Exception as e:
            print(f"‚ùå Theme refresh error: {e}")
            import traceback
            traceback.print_exc()
        
    def _show_about(self):
        """Show about dialog."""
        from tkinter import messagebox
        messagebox.showinfo(
            "About Poker Pro Trainer",
            "Poker Pro Trainer\n\n"
            "Advanced poker training with luxury themes\n"
            "and professional game analysis.\n\n"
            "üé® Theme Manager integrated\n"
            "üÉè 16 luxury themes available\n"
            "üìä Comprehensive hand review\n"
            "ü§ñ AI-powered training"
        )

    def _bind_font_shortcuts(self, root):
        # macOS Command key bindings (Cmd - decreases, Cmd = increases)
        root.bind_all("<Command-minus>", self._decrease_font)
        root.bind_all("<Command-equal>", self._increase_font)  # This is Cmd = (increase)
        root.bind_all("<Command-0>", self._reset_font)
        
        # Additional symbols that might work
        root.bind_all("<Command-plus>", self._increase_font)   # Shift+= gives +
        
        # Numpad variants
        root.bind_all("<Command-KP_Subtract>", self._decrease_font)
        root.bind_all("<Command-KP_Add>", self._increase_font)
        
        # Windows/Linux Control variants  
        root.bind_all("<Control-minus>", self._decrease_font)
        root.bind_all("<Control-equal>", self._increase_font)
        root.bind_all("<Control-plus>", self._increase_font)
        root.bind_all("<Control-0>", self._reset_font)
        
        print("üîß Font shortcuts bound successfully")

    def _set_global_font_scale(self, delta: int | None):
        print(f"üîß Font scale called with delta: {delta}")
        theme: ThemeManager = self.services.get_app("theme")
        fonts = dict(theme.get_fonts())
        base = list(fonts.get("main", ("Arial", 20, "normal")))
        print(f"üîß Current base font: {base}")
        
        if delta is None:
            new_base_size = 20  # Default 20px size for readability
        else:
            new_base_size = max(10, min(40, int(base[1]) + delta))
        
        print(f"üîß New base size: {new_base_size}")
        
        # Scale all fonts proportionally from 20px base
        fonts["main"] = (base[0], new_base_size, base[2] if len(base) > 2 else "normal")
        fonts["pot_display"] = (base[0], new_base_size + 8, "bold")  # +8 for pot display
        fonts["bet_amount"] = (base[0], new_base_size + 4, "bold")   # +4 for bet amounts
        fonts["body"] = ("Consolas", max(new_base_size, 12))         # Same as main for body text
        fonts["small"] = ("Consolas", max(new_base_size - 4, 10))    # -4 for smaller text
        fonts["header"] = (base[0], max(new_base_size + 2, 14), "bold") # +2 for headers
        
        print(f"üîß Updated fonts: {fonts}")
        theme.set_fonts(fonts)
        
        # Force all tabs to re-render with new fonts
        for idx in range(self.notebook.index("end")):
            tab_widget = self.notebook.nametowidget(self.notebook.tabs()[idx])
            if hasattr(tab_widget, "on_show"):
                tab_widget.on_show()
            # Also force font refresh if the widget has that method
            if hasattr(tab_widget, "_refresh_fonts"):
                tab_widget._refresh_fonts()
        print("üîß Font scaling complete")

    def _increase_font(self, event=None):
        print("üîß Increase font called!")
        self._set_global_font_scale(+1)

    def _decrease_font(self, event=None):
        print("üîß Decrease font called!")
        self._set_global_font_scale(-1)

    def _reset_font(self, event=None):
        print("üîß Reset font called!")
        self._set_global_font_scale(None)

    def _open_theme_editor(self):
        """Open the Theme Editor in a new window."""
        try:
            from .tabs.theme_editor_tab import ThemeEditorTab
            # Create a new toplevel window for the theme editor
            theme_window = tk.Toplevel(self.root)
            theme_window.title("Theme Editor - Poker Pro Trainer")
            theme_window.geometry("900x700")
            theme_window.resizable(True, True)
            
            # Center the window on screen
            theme_window.update_idletasks()
            x = (theme_window.winfo_screenwidth() // 2) - (900 // 2)
            y = (theme_window.winfo_screenheight() // 2) - (700 // 2)
            theme_window.geometry(f"900x700+{x}+{y}")
            
            # Create the theme editor tab in the new window
            theme_editor = ThemeEditorTab(theme_window, self.services)
            theme_editor.pack(fill=tk.BOTH, expand=True)
            
            print("üé® Theme Editor opened in new window")
        except Exception as e:
            print(f"‚ùå Error opening Theme Editor: {e}")
            import traceback
            traceback.print_exc()

    def _open_sound_settings(self):
        """Open the Sound Settings in a new window."""
        try:
            from .tabs.sound_settings_tab import SoundSettingsTab
            # Create a new toplevel window for the sound settings
            sound_window = tk.Toplevel(self.root)
            sound_window.title("Sound Settings - Poker Pro Trainer")
            sound_window.geometry("1200x800")
            sound_window.resizable(True, True)
            
            # Center the window on screen
            sound_window.update_idletasks()
            x = (sound_window.winfo_screenwidth() // 2) - (1200 // 2)
            y = (sound_window.winfo_screenheight() // 2) - (800 // 2)
            sound_window.geometry(f"1200x800+{x}+{y}")
            
            # Create the sound settings tab in the new window
            sound_settings = SoundSettingsTab(sound_window, self.services)
            sound_settings.pack(fill=tk.BOTH, expand=True)
            
            print("üîä Sound Settings opened in new window")
        except Exception as e:
            print(f"‚ùå Error opening Sound Settings: {e}")
            import traceback
            traceback.print_exc()


```

---

### __init__.py

**Path**: `backend/ui/components/__init__.py`

**Size**: 605 bytes

```python
"""
UI Components module for poker strategy practice system.

New UI architecture - only import existing components.
"""

# Only import components that actually exist
from .card_widget import CardWidget
from .modern_poker_widgets import ChipStackDisplay

# These can be imported individually when needed for legacy compatibility
# from .dialogs import *
# from .bot_session_widget import *
# from .practice_session_poker_widget import *
# from .gto_poker_game_widget import *
# from .hands_review_panel_unified_legacy import HandsReviewPanelUnified

__all__ = [
    'CardWidget',
    'ChipStackDisplay'
] 
```

---

### action_banner.py

**Path**: `backend/ui/components/action_banner.py`

**Size**: 9.8 KB

```python
#!/usr/bin/env python3
"""
ActionBanner - Visual notifications for poker actions
===================================================

This component displays banners and notifications for poker actions,
integrating with the EffectBus to show visual feedback for:
- Player actions (BET, CALL, CHECK, FOLD, etc.)
- Important events (SHOWDOWN, ALL_IN)
- Game state changes
"""

import tkinter as tk
from tkinter import ttk
import time
from typing import Dict, Any, Optional


class ActionBanner(tk.Frame):
    """
    ActionBanner displays visual notifications for poker actions.
    
    Features:
    - Animated banners for different action types
    - Color-coded by action importance
    - Auto-dismiss after configurable duration
    - Stacking multiple banners
    """
    
    def __init__(self, parent, **kwargs):
        super().__init__(parent, **kwargs)
        
        # Banner configuration
        self.banner_duration = 3000  # milliseconds
        self.banner_height = 60
        self.banner_width = 300
        self.animation_duration = 300  # milliseconds
        
        # Active banners
        self.active_banners = []
        self.banner_counter = 0
        
        # Banner styles by type
        self.banner_styles = {
            "info": {
                "bg": "#3B82F6",  # Blue
                "fg": "white",
                "icon": "‚ÑπÔ∏è"
            },
            "success": {
                "bg": "#10B981",  # Green
                "fg": "white",
                "icon": "‚úÖ"
            },
            "warning": {
                "bg": "#F59E0B",  # Yellow
                "fg": "black",
                "icon": "‚ö†Ô∏è"
            },
            "highlight": {
                "bg": "#EF4444",  # Red
                "fg": "white",
                "icon": "üî•"
            },
            "action": {
                "bg": "#8B5CF6",  # Purple
                "fg": "white",
                "icon": "üéØ"
            }
        }
        
        # Setup the banner container
        self._setup_banner_container()
        
        print("üé≠ ActionBanner: Initialized")
    
    def _setup_banner_container(self):
        """Setup the banner container frame."""
        # Create a frame to hold banners (positioned at top-center)
        self.banner_container = tk.Frame(self)
        self.banner_container.pack(fill="x", padx=10, pady=5)
        
        # Configure grid for banner positioning
        self.banner_container.grid_columnconfigure(0, weight=1)
        self.banner_container.grid_columnconfigure(1, weight=0)
        self.banner_container.grid_columnconfigure(2, weight=1)
    
    def show_banner(self, message: str, banner_type: str = "info", duration_ms: Optional[int] = None):
        """
        Show a banner notification.
        
        Args:
            message: Banner message text
            banner_type: Type of banner (info, success, warning, highlight, action)
            duration_ms: Duration in milliseconds (None for default)
        """
        if banner_type not in self.banner_styles:
            banner_type = "info"
        
        # Create banner ID
        banner_id = f"banner_{self.banner_counter}"
        self.banner_counter += 1
        
        # Get banner style
        style = self.banner_styles[banner_type]
        
        # Create banner frame
        banner_frame = tk.Frame(
            self.banner_container,
            bg=style["bg"],
            relief="raised",
            borderwidth=2
        )
        
        # Position banner (center horizontally, stack vertically)
        row = len(self.active_banners)
        banner_frame.grid(row=row, column=1, pady=(5, 0), sticky="ew")
        
        # Create banner content
        icon_label = tk.Label(
            banner_frame,
            text=style["icon"],
            font=("Arial", 16),
            bg=style["bg"],
            fg=style["fg"]
        )
        icon_label.pack(side="left", padx=(10, 5))
        
        message_label = tk.Label(
            banner_frame,
            text=message,
            font=("Arial", 12, "bold"),
            bg=style["bg"],
            fg=style["fg"],
            wraplength=self.banner_width - 60
        )
        message_label.pack(side="left", padx=5, fill="x", expand=True)
        
        # Add close button
        close_button = tk.Label(
            banner_frame,
            text="‚úï",
            font=("Arial", 12, "bold"),
            bg=style["bg"],
            fg=style["fg"],
            cursor="hand2"
        )
        close_button.pack(side="right", padx=(5, 10))
        
        # Bind close button
        close_button.bind("<Button-1>", lambda e: self._dismiss_banner(banner_id))
        
        # Store banner info
        banner_info = {
            "id": banner_id,
            "frame": banner_frame,
            "type": banner_type,
            "message": message,
            "created_at": time.time(),
            "duration": duration_ms or self.banner_duration
        }
        
        self.active_banners.append(banner_info)
        
        # Animate banner in
        self._animate_banner_in(banner_frame)
        
        # Schedule auto-dismiss
        self.after(banner_info["duration"], lambda: self._dismiss_banner(banner_id))
        
        print(f"üé≠ ActionBanner: Showing {banner_type} banner: {message}")
        return banner_id
    
    def _animate_banner_in(self, banner_frame):
        """Animate banner sliding in from top."""
        # Start with banner above visible area
        banner_frame.grid_configure(row=len(self.active_banners) - 1)
        
        # Animate slide-in effect
        def slide_in(step=0, total_steps=10):
            if step <= total_steps:
                # Calculate position (slide down from top)
                progress = step / total_steps
                banner_frame.grid_configure(row=len(self.active_banners) - 1)
                
                if step < total_steps:
                    self.after(self.animation_duration // total_steps, 
                              lambda: slide_in(step + 1, total_steps))
        
        slide_in()
    
    def _dismiss_banner(self, banner_id: str):
        """Dismiss a banner by ID."""
        for i, banner_info in enumerate(self.active_banners):
            if banner_info["id"] == banner_id:
                # Animate banner out
                self._animate_banner_out(banner_info["frame"], i)
                break
    
    def _animate_banner_out(self, banner_frame, banner_index: int):
        """Animate banner sliding out."""
        def slide_out(step=0, total_steps=10):
            if step <= total_steps:
                # Calculate position (slide up and fade)
                progress = step / total_steps
                alpha = 1.0 - progress
                
                # Apply transparency effect
                try:
                    banner_frame.attributes = ("-alpha", alpha)
                except:
                    pass  # Some platforms don't support transparency
                
                if step < total_steps:
                    self.after(self.animation_duration // total_steps, 
                              lambda: slide_out(step + 1, total_steps))
                else:
                    # Remove banner completely
                    banner_frame.destroy()
                    
                    # Remove from active banners
                    self.active_banners = [b for b in self.active_banners 
                                         if b["frame"] != banner_frame]
                    
                    # Reposition remaining banners
                    self._reposition_banners()
        
        slide_out()
    
    def _reposition_banners(self):
        """Reposition remaining banners after one is dismissed."""
        for i, banner_info in enumerate(self.active_banners):
            banner_info["frame"].grid_configure(row=i)
    
    def show_poker_action(self, action_type: str, player_name: str = None, amount: int = None):
        """
        Show a banner for a poker action.
        
        Args:
            action_type: Type of poker action (BET, CALL, CHECK, FOLD, etc.)
            player_name: Name of the player performing the action
            amount: Amount involved in the action (if applicable)
        """
        # Determine banner type based on action
        if action_type in ["SHOWDOWN", "ALL_IN"]:
            banner_type = "highlight"
        elif action_type in ["BET", "RAISE"]:
            banner_type = "action"
        elif action_type in ["CALL", "CHECK"]:
            banner_type = "success"
        elif action_type == "FOLD":
            banner_type = "warning"
        else:
            banner_type = "info"
        
        # Build message
        if player_name:
            if amount:
                message = f"{player_name}: {action_type} {amount}"
            else:
                message = f"{player_name}: {action_type}"
        else:
            if amount:
                message = f"{action_type} {amount}"
            else:
                message = action_type
        
        # Show banner
        return self.show_banner(message, banner_type)
    
    def clear_all_banners(self):
        """Clear all active banners."""
        for banner_info in self.active_banners[:]:
            self._dismiss_banner(banner_info["id"])
        print("üé≠ ActionBanner: All banners cleared")
    
    def get_active_banner_count(self) -> int:
        """Get the number of active banners."""
        return len(self.active_banners)


class NoopActionBanner:
    """No-op action banner for testing or when banners are not needed."""
    
    def __init__(self, *args, **kwargs):
        pass
    
    def show_banner(self, *args, **kwargs) -> str: return "noop"
    def show_poker_action(self, *args, **kwargs) -> str: return "noop"
    def clear_all_banners(self) -> None: pass
    def get_active_banner_count(self) -> int: return 0
```

---

### card_widget.py

**Path**: `backend/ui/components/card_widget.py`

**Size**: 6.7 KB

```python
#!/usr/bin/env python3
"""
Card Widget

A standalone card widget for displaying playing cards.
Moved to separate module to avoid circular imports.
"""

import tkinter as tk

# Handle theme import with fallback
try:
    from ...core.gui_models import THEME
except ImportError:
    try:
        from core.gui_models import THEME
    except ImportError:
        # Fallback theme for when core module is not available
        THEME = {
            "card_bg": "#F8FAFC",
            "card_border": "#E2E8F0", 
            "text": "#1A202C",
            "table_felt": "#0F5132"
        }


def debug_log(message: str, category: str = "CARD_WIDGET"):
    """Log debug messages to file instead of console."""
    try:
        try:
            from ...core.session_logger import get_session_logger
        except ImportError:
            from core.session_logger import get_session_logger
        logger = get_session_logger()
        logger.log_system("DEBUG", category, message, {})
    except:
        # Fallback to silent operation if logger not available
        pass


class CardWidget(tk.Canvas):
    """A custom widget to display a single, styled playing card."""
    def __init__(self, parent, width=50, height=70):
        # Get theme-aware colors for card widget
        try:
            from ui.services.theme_manager import ThemeManager
            theme_manager = ThemeManager()
            theme_colors = theme_manager.get()
            card_bg = theme_colors.get("card.bg", "#FFFFFF")
            card_border = theme_colors.get("card.border", "#000000")
        except Exception:
            card_bg = "white"
            card_border = "black"
            
        super().__init__(parent, width=width, height=height, highlightthickness=1, highlightbackground=card_border, bg=card_bg)
        self.width, self.height = width, height
        
        # Ensure canvas is properly configured for drawing
        self.config(width=width, height=height)
        
        # Initialize with card back
        self._draw_card_back()

    def set_card(self, card_str, is_folded=False):
        # Store the current card string
        self.current_card_str = card_str
        
        # Card display updates are too verbose for logging
        
        self.delete("all") # Clear previous drawing
        
        # Handle different card states
        if is_folded:
            # Player has folded - show dark folded card back
            self._draw_card_back(is_folded=True)
        elif card_str == "**":
            # Card is hidden - show card back (red for active, gray for folded)
            self._draw_card_back(is_folded=is_folded)
        elif not card_str:
            # Card is empty - show transparent/empty space
            self._draw_empty_card()
        else:
            # Valid card - show the actual card with theme-aware background
            try:
                from ui.services.theme_manager import ThemeManager
                theme_manager = ThemeManager()
                theme_colors = theme_manager.get()
                card_bg = theme_colors.get("card.bg", "#FFFFFF")
            except Exception:
                card_bg = "white"
            self.config(bg=card_bg)
            self._draw_card_content(card_str)
        
        # Force update to ensure the drawing is applied
        self.update()

    def _draw_card_content(self, card_str):
        """Draw the card content (rank and suit) on the canvas."""
        if not card_str or len(card_str) < 2:
            # Skipping invalid card debug - too verbose
            return
            
        rank, suit = card_str[0], card_str[1]
        suit_symbols = {'h': '‚ô•', 'd': '‚ô¶', 'c': '‚ô£', 's': '‚ô†'}
        suit_colors = {'h': THEME['card_red'], 'd': THEME['card_red'], 'c': THEME['card_black'], 's': THEME['card_black']}
        color = suit_colors.get(suit, "black")
        
        # Card drawing debug removed to reduce log spam
        
        # Use larger, clearer fonts
        self.create_text(self.width / 2, self.height / 2 - 5, text=rank, font=("Helvetica", 22, "bold"), fill=color)
        self.create_text(self.width / 2, self.height / 2 + 18, text=suit_symbols.get(suit, ""), font=("Helvetica", 16), fill=color)

    def _draw_card_back(self, is_folded=False):
        """Draws a professional-looking checkerboard pattern for the card back."""
        # Clear any existing content
        self.delete("all")
        
        if is_folded:
            # Draw folded card back - dark gray with no border
            dark_gray = THEME["button_fold"]  # Gray for folded cards
            self.config(bg=dark_gray)
            
            # Draw a simple dark gray card with no border
            self.create_rectangle(0, 0, self.width, self.height, 
                                fill=dark_gray, outline="")
        else:
            # Define colors for regular card back - restore original red style
            dark_red = "#a51d2d"
            light_red = "#c0392b"
            border_color = "#8b0000"
            
            # Set the background color
            self.config(bg=dark_red)
            
            # Draw the border first
            self.create_rectangle(2, 2, self.width-2, self.height-2, 
                                fill=dark_red, outline=border_color, width=2)
            
            # Draw the checkerboard pattern with larger squares for better visibility
            square_size = 8
            for y in range(4, self.height-4, square_size):
                for x in range(4, self.width-4, square_size):
                    # Create alternating pattern
                    color = light_red if (x // square_size + y // square_size) % 2 == 0 else dark_red
                    self.create_rectangle(x, y, x + square_size, y + square_size, 
                                       fill=color, outline="")
            
            # Add a subtle center design element
            center_x, center_y = self.width // 2, self.height // 2
            self.create_oval(center_x-8, center_y-8, center_x+8, center_y+8, 
                            fill=light_red, outline=border_color, width=1)
    
    def _draw_empty_card(self):
        """Draw an empty/transparent card space (no visible card)."""
        # Clear any existing content
        self.delete("all")
        
        # Set transparent/matching background
        parent_bg = THEME["primary_bg"]  # Dark Charcoal background
        self.config(bg=parent_bg)
        
        # Draw a subtle dashed border to indicate card space exists
        self.create_rectangle(2, 2, self.width-2, self.height-2, 
                            fill="", outline=THEME["menu_separator"], width=1, dash=(3, 3))
    

    def set_folded(self):
        """Shows the card as folded (empty)."""
        self.set_card("", is_folded=True)
```

---

### dialogs.py

**Path**: `backend/ui/components/dialogs.py`

**Size**: 16.2 KB

```python
# filename: dialogs.py
"""
Dialog Windows for Strategy Development GUI

Contains all dialog windows for tier editing, file operations, etc.

REVISION HISTORY:
================
Version 1.0 (2025-07-29) - Initial Version
- Created to consolidate all pop-up dialog windows into one module.
- Includes TierEditDialog, FileDialogs, and the AboutDialog.
- Promotes code reuse and separates dialog logic from main components.
"""

import tkinter as tk
from tkinter import ttk, messagebox, filedialog, colorchooser
from typing import Optional, Dict
from core.gui_models import HandStrengthTier, FileOperations, THEME


class TierEditDialog:
    """
    A modal dialog window for creating or editing a HandStrengthTier.

    REVISION HISTORY:
    ================
    Version 1.0 (2025-07-29) - Initial Version
    - Provides a form for creating and editing HandStrengthTier objects.
    - Returns result dictionary upon successful completion.
    """

    def __init__(
        self, parent, title: str, tier: Optional[HandStrengthTier] = None
    ):
        self.result = None
        self.dialog = tk.Toplevel(parent)
        self.dialog.title(title)
        self.dialog.transient(parent)
        self.dialog.grab_set()
        self.dialog.configure(bg=THEME["bg"])

        # Center the dialog
        self._center_dialog()

        # Setup form
        self.setup_form(tier)

        # Make dialog modal
        self.dialog.wait_window()

    def _center_dialog(self):
        """Center dialog on screen."""
        self.dialog.update_idletasks()
        x = (self.dialog.winfo_screenwidth() // 2) - (500 // 2)
        y = (self.dialog.winfo_screenheight() // 2) - (600 // 2)
        self.dialog.geometry(f"500x600+{x}+{y}")
        self.dialog.resizable(True, True)
        # Set minimum size to ensure buttons are visible
        self.dialog.minsize(500, 600)

    def setup_form(self, tier: Optional[HandStrengthTier]):
        """Creates and lays out the form widgets."""
        main_frame = ttk.Frame(self.dialog, padding="15", style="Dark.TFrame")
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Name field
        ttk.Label(main_frame, text="Tier Name:", style="Dark.TLabel").pack(
            anchor="w", pady=(0, 5)
        )
        # Ensure tier name is properly displayed - show current tier name or
        # "New Tier" for new tiers
        tier_name = tier.name if tier and tier.name else "New Tier"
        self.name_var = tk.StringVar(value=tier_name)
        # Use ttk.Entry with style for better consistency
        name_entry = ttk.Entry(
            main_frame,
            textvariable=self.name_var,
            width=30,
            style="SkyBlue.TEntry",
        )
        name_entry.pack(fill=tk.X, pady=(0, 15))
        name_entry.focus()
        name_entry.select_range(0, tk.END)

        # HS range slider
        range_frame = ttk.LabelFrame(
            main_frame, text="Hand Strength Range (1-45)", padding="10"
        )
        range_frame.pack(fill=tk.X, pady=(0, 15))

        # Range slider container
        slider_frame = ttk.Frame(range_frame)
        slider_frame.pack(fill=tk.X, pady=(0, 10))

        # Initialize range values
        initial_min = tier.min_hs if tier else 1
        initial_max = tier.max_hs if tier else 10

        # Create range slider using Scale widgets
        self.min_hs_var = tk.IntVar(value=initial_min)
        self.max_hs_var = tk.IntVar(value=initial_max)

        # Min HS slider
        min_frame = ttk.Frame(slider_frame)
        min_frame.pack(fill=tk.X, pady=(0, 5))
        ttk.Label(min_frame, text="Min HS:", width=8).pack(side=tk.LEFT)
        self.min_slider = ttk.Scale(
            min_frame,
            from_=1,
            to=45,
            orient=tk.HORIZONTAL,
            variable=self.min_hs_var,
        )
        self.min_slider.pack(side=tk.LEFT, fill=tk.X, expand=True)
        self.min_label = ttk.Label(min_frame, text=str(initial_min), width=4)
        self.min_label.pack(side=tk.RIGHT, padx=(5, 0))

        # Max HS slider
        max_frame = ttk.Frame(slider_frame)
        max_frame.pack(fill=tk.X, pady=(0, 5))
        ttk.Label(max_frame, text="Max HS:", width=8).pack(side=tk.LEFT)
        self.max_slider = ttk.Scale(
            max_frame,
            from_=1,
            to=45,
            orient=tk.HORIZONTAL,
            variable=self.max_hs_var,
        )
        self.max_slider.pack(side=tk.LEFT, fill=tk.X, expand=True)
        self.max_label = ttk.Label(max_frame, text=str(initial_max), width=4)
        self.max_label.pack(side=tk.RIGHT, padx=(5, 0))

        # Bind slider updates to labels
        self.min_hs_var.trace("w", self._update_min_label)
        self.max_hs_var.trace("w", self._update_max_label)

        # Add helpful info about auto-detection
        info_label = ttk.Label(
            range_frame,
            text="Note: Hands will be auto-detected based on HS range",
            style="Dark.TLabel",
            foreground=THEME["text_muted"],
        )
        info_label.pack(pady=(5, 0))

        # Color selection with preset options
        color_frame = ttk.LabelFrame(
            main_frame, text="Tier Color", padding="10"
        )
        color_frame.pack(fill=tk.X, pady=(0, 15))

        # Preset color buttons
        preset_frame = ttk.Frame(color_frame)
        preset_frame.pack(fill=tk.X, pady=(0, 10))

        ttk.Label(preset_frame, text="Quick Colors:").pack(side=tk.LEFT)

        # Define preset colors
        preset_colors = [
            ("Crimson", THEME["card_red"]),
            ("Steel Blue", THEME["card_back"]),
            ("Green", THEME["chip_green"]),
            ("Orange", THEME["button_allin"]),
            ("Call Blue", THEME["button_call"]),
            ("Gold", THEME["text_gold"]),
            ("Raise Red", THEME["button_raise"]),
            ("Fold Gray", THEME["button_fold"]),
            ("Emerald", THEME["table_felt"]),
        ]

        color_buttons_frame = ttk.Frame(preset_frame)
        color_buttons_frame.pack(side=tk.LEFT, padx=(10, 0))

        for color_name, color_hex in preset_colors:
            # Use Label with binding for better color display on macOS
            color_swatch = tk.Label(
                color_buttons_frame,
                text="",
                width=3,
                height=1,
                bg=color_hex,
                relief=tk.RAISED,
                bd=2,
            )
            color_swatch.pack(side=tk.LEFT, padx=1)
            color_swatch.bind(
                "<Button-1>", lambda e, c=color_hex: self._set_color(c)
            )
            # Add hover effect
            color_swatch.bind(
                "<Enter>",
                lambda e, swatch=color_swatch: swatch.configure(
                    relief=tk.SUNKEN
                ),
            )
            color_swatch.bind(
                "<Leave>",
                lambda e, swatch=color_swatch: swatch.configure(
                    relief=tk.RAISED
                ),
            )

        # Custom color section
        custom_frame = ttk.Frame(color_frame)
        custom_frame.pack(fill=tk.X, pady=(5, 0))

        self.color_var = tk.StringVar(value=tier.color if tier else "#FF4444")

        # Custom color button - use system colors for better macOS
        # compatibility
        custom_btn = tk.Button(
            custom_frame,
            text="Custom Color",
            command=self.choose_color,
            bg="#f0f0f0",
            fg="black",
            relief=tk.RAISED,
            bd=3,
            font=("Arial", 10, "bold"),
            width=14,
            height=2,
        )
        custom_btn.pack(side=tk.LEFT)

        # Color preview
        self.color_preview = tk.Label(
            custom_frame,
            text="",
            width=4,
            height=2,
            bg=self.color_var.get(),
            relief=tk.RAISED,
            borderwidth=2,
        )
        self.color_preview.pack(side=tk.LEFT, padx=(10, 0))

        # Buttons - make them more prominent and ensure they're visible
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(side=tk.BOTTOM, fill=tk.X, pady=(20, 10))

        # Use regular tk.Button for better visibility with larger size - same
        # style for both
        cancel_btn = tk.Button(
            button_frame,
            text="Cancel",
            command=self.cancel_clicked,
            bg="#f0f0f0",
            fg="black",
            relief=tk.RAISED,
            bd=3,
            font=("Arial", 12, "bold"),
            width=12,
            height=2,
        )
        cancel_btn.pack(side=tk.RIGHT, padx=(15, 0))

        ok_btn = tk.Button(
            button_frame,
            text="OK",
            command=self.ok_clicked,
            bg="#f0f0f0",
            fg="black",
            relief=tk.RAISED,
            bd=3,
            font=("Arial", 12, "bold"),
            width=12,
            height=2,
        )
        ok_btn.pack(side=tk.RIGHT)

        # Bind keys
        self.dialog.bind("<Return>", lambda e: self.ok_clicked())
        self.dialog.bind("<Escape>", lambda e: self.cancel_clicked())

    def choose_color(self):
        """Open color chooser dialog."""
        try:
            # Store current focus to restore it after color selection
            current_focus = self.dialog.focus_get()

            color = colorchooser.askcolor(color=self.color_var.get())
            if color[1]:  # If user didn't cancel
                self.color_var.set(color[1])
                # Update the color preview immediately
                self.color_preview.configure(bg=color[1])

            # Restore focus to prevent interference with other fields
            if current_focus:
                current_focus.focus_set()
        except ImportError:
            messagebox.showinfo(
                "Info",
                "Color chooser not available. Please enter hex color manually.",
            )

    def _set_color(self, color_hex: str):
        """Set color from preset button."""
        self.color_var.set(color_hex)
        self.color_preview.configure(bg=color_hex)

    def _update_color_preview(self, *args):
        """Update color preview when color changes."""
        try:
            color = self.color_var.get().strip()
            if color.startswith("#") and len(color) == 7:
                self.color_preview.configure(bg=color)
            else:
                # Set to default red if invalid
                self.color_preview.configure(bg="#FF0000")
        except tk.TclError:
            # Set to default red if error
            self.color_preview.configure(bg="#FF0000")

    def _update_min_label(self, *args):
        """Update min HS label when slider changes."""
        try:
            value = self.min_hs_var.get()
            self.min_label.configure(text=str(value))
        except tk.TclError:
            pass

    def _update_max_label(self, *args):
        """Update max HS label when slider changes."""
        try:
            value = self.max_hs_var.get()
            self.max_label.configure(text=str(value))
        except tk.TclError:
            pass

    def ok_clicked(self):
        """Validates form data and closes the dialog."""
        try:
            name = self.name_var.get().strip()
            min_hs = (
                self.min_hs_var.get()
            )  # Now IntVar, no need for int() conversion
            max_hs = (
                self.max_hs_var.get()
            )  # Now IntVar, no need for int() conversion
            color = self.color_var.get().strip()

            # Validation
            if not name:
                messagebox.showerror(
                    "Error", "Please enter a tier name.", parent=self.dialog
                )
                return

            if min_hs >= max_hs:
                messagebox.showerror(
                    "Error",
                    "Minimum HS must be less than Maximum HS.",
                    parent=self.dialog,
                )
                return

            if min_hs < 1 or max_hs > 45:
                messagebox.showerror(
                    "Error",
                    "HS range must be between 1 and 45.",
                    parent=self.dialog,
                )
                return

            if not self._is_valid_color(color):
                messagebox.showerror(
                    "Error",
                    "Please enter a valid hex color (e.g., #FF0000).",
                    parent=self.dialog,
                )
                return

            self.result = {
                "name": name,
                "min_hs": min_hs,
                "max_hs": max_hs,
                "color": color,
            }

            self.dialog.destroy()

        except Exception as e:
            messagebox.showerror(
                "Error",
                f"Please enter valid values: {
                    str(e)}",
                parent=self.dialog,
            )

    def cancel_clicked(self):
        """Handle Cancel button click."""
        self.dialog.destroy()

    def _is_valid_color(self, color: str) -> bool:
        """Check if color is valid hex format."""
        if not color.startswith("#") or len(color) != 7:
            return False

        try:
            int(color[1:], 16)
            return True
        except ValueError:
            return False


class FileDialog:
    """
    A static class to wrap file dialog functionality.

    REVISION HISTORY:
    ================
    Version 1.0 (2025-07-29) - Initial Version
    - Provides static methods for opening and saving strategy files.
    """

    @staticmethod
    def load_strategy() -> Optional[Dict]:
        filename = filedialog.askopenfilename(
            title="Load Strategy", filetypes=[("JSON files", "*.json")]
        )
        if filename:
            strategy = FileOperations.load_strategy(filename)
            if strategy:
                messagebox.showinfo(
                    "Success", f"Loaded strategy from {filename}"
                )
                return strategy
            else:
                messagebox.showerror(
                    "Error", f"Failed to load strategy from {filename}"
                )
        return None

    @staticmethod
    def save_strategy(strategy: Dict) -> bool:
        filename = filedialog.asksaveasfilename(
            title="Save Strategy",
            defaultextension=".json",
            filetypes=[("JSON files", "*.json")],
        )
        if filename:
            if FileOperations.save_strategy(strategy, filename):
                messagebox.showinfo("Success", f"Saved strategy to {filename}")
                return True
            else:
                messagebox.showerror(
                    "Error", f"Failed to save strategy to {filename}"
                )
        return False


class AboutDialog:
    """
    The 'About' dialog window for the application.

    REVISION HISTORY:
    ================
    Version 1.0 (2025-07-29) - Initial Version
    - A simple, static dialog to display application info.
    """

    def __init__(self, parent):
        dialog = tk.Toplevel(parent)
        dialog.title("About Strategy Development GUI")
        dialog.geometry("450x350")
        dialog.transient(parent)
        dialog.grab_set()

        # Center dialog
        dialog.update_idletasks()
        x = (dialog.winfo_screenwidth() // 2) - (450 // 2)
        y = (dialog.winfo_screenheight() // 2) - (350 // 2)
        dialog.geometry(f"450x350+{x}+{y}")

        # Content
        main_frame = ttk.Frame(dialog, padding="20")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Title
        title_label = ttk.Label(
            main_frame,
            text="Advanced Poker Strategy Development GUI",
            font=("Arial", 14, "bold"),
        )
        title_label.pack(pady=(0, 20))

        # Version info
        info_text = """Version 2.0 - Modular Edition

A comprehensive tool for developing and testing poker strategies:

‚úì Visual hand strength tier management
‚úì Interactive decision table editing
‚úì Strategy simulation and testing
‚úì Human-executable optimization
‚úì Statistical analysis and validation
‚úì Modular architecture for maintainability

Each module is focused and under 250 lines of code."""

        info_label = ttk.Label(main_frame, text=info_text, justify=tk.LEFT)
        info_label.pack(pady=(0, 20))

        # Close button
        ttk.Button(main_frame, text="Close", command=dialog.destroy).pack()
```

---

### enhanced_button.py

**Path**: `backend/ui/components/enhanced_button.py`

**Size**: 7.9 KB

```python
"""
Enhanced Button Component with Casino-style Design
Based on the working old UI approach with direct color application
"""

import tkinter as tk
from typing import Callable, Optional


class EnhancedButton(tk.Label):
    """
    Casino-style button using tk.Label to avoid macOS system color overrides.
    Uses click bindings and hover effects like the old UI approach.
    """
    
    def __init__(self, parent, text: str, command: Optional[Callable] = None, 
                 theme_manager=None, button_type: str = "primary", **kwargs):
        
        self.theme_manager = theme_manager
        self.button_type = button_type
        self.is_disabled = False  # Track disabled state manually
        
        # Get theme colors
        theme = theme_manager.get_theme() if theme_manager else {}
        fonts = theme_manager.get_fonts() if theme_manager else {}
        
        # Determine button colors based on type - prefer per-type tokens, fall back to generic
        if button_type == "primary":
            btn_key = "primary"
        elif button_type == "danger":
            btn_key = "danger"
        else:
            btn_key = "secondary"

        self.default_bg = theme.get(f'btn.{btn_key}.bg', theme.get('btn.default.bg', '#1E1E1E'))
        self.default_fg = theme.get(f'btn.{btn_key}.fg', theme.get('btn.default.fg', '#E0E0E0'))
        self.hover_bg = theme.get(f'btn.{btn_key}.hoverBg', theme.get('btn.hover.bg', '#2D5A3D'))
        self.hover_fg = theme.get(f'btn.{btn_key}.hoverFg', theme.get('btn.hover.fg', '#E6C76E'))
        self.active_bg = theme.get(f'btn.{btn_key}.activeBg', theme.get('btn.active.bg', '#008F4C'))
        self.active_fg = theme.get(f'btn.{btn_key}.activeFg', theme.get('btn.active.fg', '#FFD700'))
        self.disabled_bg = theme.get(f'btn.{btn_key}.disabledBg', theme.get('btn.disabled.bg', '#2B2B2B'))
        self.disabled_fg = theme.get(f'btn.{btn_key}.disabledFg', theme.get('btn.disabled.fg', '#777777'))

        # Optional borders for premium look
        self.border_color = theme.get(f'btn.{btn_key}.border', theme.get('btn.default.border', '#A0A0A0'))
        self.hover_border_color = theme.get(f'btn.{btn_key}.hoverBorder', self.border_color)
        self.active_border_color = theme.get(f'btn.{btn_key}.activeBorder', self.hover_border_color)
        self.disabled_border_color = theme.get(f'btn.{btn_key}.disabledBorder', theme.get('divider', '#2A2622'))
        
        # Store the command for click binding
        self.command = command
        
        # Label configuration - Using tk.Label to avoid macOS color overrides
        config = {
            'text': text,
            'font': fonts.get('body', ('Segoe UI', 14, 'bold')),
            'relief': 'raised',  # Button-like appearance
            'borderwidth': 2,    # Button border
            'cursor': 'hand2',
            'pady': 12 if button_type == "primary" else 8,
            'padx': 20 if button_type == "primary" else 16,
            # Direct color application - Works with tk.Label!
            'bg': self.default_bg,
            'fg': self.default_fg,
        }
        
        config.update(kwargs)
        
        # Initialize label as button
        super().__init__(parent, **config)
        
        # Store colors for hover effects
        self.colors = {
            "normal": self.default_bg,
            "hover": self.hover_bg
        }
        
        # Bind events - Label approach
        self.bind('<Button-1>', self._on_click)  # Click event
        self.bind('<Enter>', self._on_enter)     # Hover enter
        self.bind('<Leave>', self._on_leave)     # Hover leave
        
        # Apply initial border
        self._apply_border(self.border_color)
    
    def _apply_border(self, color):
        """Apply border color for premium visual feedback"""
        # Simple 1px border via highlight; for a thicker look, wrap in a Frame
        self.config(highlightthickness=1, highlightbackground=color)
    
    def _on_click(self, event):
        """Handle click event with premium visual feedback"""
        if not self.is_disabled and self.command:
            # Visual feedback - press effect with border
            self._apply_border(self.active_border_color)
            self.config(bg=self.active_bg, fg=self.active_fg, relief='sunken')
            # Restore normal state after brief delay
            self.after(100, lambda: (
                self._apply_border(self.border_color),
                self.config(bg=self.colors["normal"], fg=self.default_fg, relief='raised')
            ))
            # Execute command
            self.command()
    
    def _on_enter(self, event):
        """Handle mouse enter (hover) with premium border effects"""
        if not self.is_disabled:
            self._apply_border(self.hover_border_color)
            self.config(bg=self.colors["hover"], fg=self.hover_fg)
    
    def _on_leave(self, event):
        """Handle mouse leave with border restoration"""
        if not self.is_disabled:
            self._apply_border(self.border_color)
            self.config(bg=self.colors["normal"], fg=self.default_fg)
    
    def refresh_theme(self):
        """Refresh colors when theme changes - EXACT old UI pattern"""
        if not self.theme_manager:
            return
            
        # Reload theme colors
        theme = self.theme_manager.get_theme()
        
        # Update color properties using per-type tokens
        if self.button_type == "primary":
            btn_key = "primary"
        elif self.button_type == "danger":
            btn_key = "danger"
        else:
            btn_key = "secondary"

        self.default_bg = theme.get(f'btn.{btn_key}.bg', theme.get('btn.default.bg', '#1E1E1E'))
        self.default_fg = theme.get(f'btn.{btn_key}.fg', theme.get('btn.default.fg', '#E0E0E0'))
        self.hover_bg = theme.get(f'btn.{btn_key}.hoverBg', theme.get('btn.hover.bg', '#2D5A3D'))
        self.hover_fg = theme.get(f'btn.{btn_key}.hoverFg', theme.get('btn.hover.fg', '#E6C76E'))
        self.active_bg = theme.get(f'btn.{btn_key}.activeBg', theme.get('btn.active.bg', '#008F4C'))
        self.active_fg = theme.get(f'btn.{btn_key}.activeFg', theme.get('btn.active.fg', '#FFD700'))
        self.disabled_bg = theme.get(f'btn.{btn_key}.disabledBg', theme.get('btn.disabled.bg', '#2B2B2B'))
        self.disabled_fg = theme.get(f'btn.{btn_key}.disabledFg', theme.get('btn.disabled.fg', '#777777'))

        # Update border colors
        self.border_color = theme.get(f'btn.{btn_key}.border', theme.get('btn.default.border', '#A0A0A0'))
        self.hover_border_color = theme.get(f'btn.{btn_key}.hoverBorder', self.border_color)
        self.active_border_color = theme.get(f'btn.{btn_key}.activeBorder', self.hover_border_color)
        self.disabled_border_color = theme.get(f'btn.{btn_key}.disabledBorder', theme.get('divider', '#2A2622'))
        
        # Update colors dict for hover effects
        self.colors = {
            "normal": self.default_bg,
            "hover": self.hover_bg
        }
        
        # Apply current colors and border
        self.config(
            bg=self.default_bg,
            fg=self.default_fg,
            activebackground=self.active_bg,
            activeforeground=self.active_fg
        )
        self._apply_border(self.border_color)

        
        print(f"üé® Enhanced button refreshed: {self.button_type} -> bg:{self.default_bg}, hover:{self.hover_bg}")


class PrimaryButton(EnhancedButton):
    """Primary action button (Load Hand, etc.) - Prominent casino styling"""
    def __init__(self, parent, text: str, command: Optional[Callable] = None, 
                 theme_manager=None, **kwargs):
        super().__init__(parent, text, command, theme_manager, "primary", **kwargs)


class SecondaryButton(EnhancedButton):
    """Secondary action button (Next, Auto, Reset, etc.) - Subtle casino styling"""
    def __init__(self, parent, text: str, command: Optional[Callable] = None, 
                 theme_manager=None, **kwargs):
        super().__init__(parent, text, command, theme_manager, "secondary", **kwargs)
```

---

### modern_poker_widgets.py

**Path**: `backend/ui/components/modern_poker_widgets.py`

**Size**: 18.0 KB

```python
#!/usr/bin/env python3
"""
Modern Poker UI Widgets

Professional poker app style widgets including bet sliders, chip displays,
and modern action buttons based on current industry standards.
"""

import tkinter as tk
import math
from typing import Callable, Optional

# Handle theme import with fallback
try:
    from ...core.gui_models import THEME, FONTS
except ImportError:
    try:
        from core.gui_models import THEME, FONTS
    except ImportError:
        # Fallback theme and fonts for when core module is not available
        THEME = {
            "table_felt": "#0F5132",
            "secondary_bg": "#4A5568", 
            "text": "#E2E8F0",
            "chip_gold": "#F6E05E",
            "card_bg": "#F8FAFC",
            "card_border": "#E2E8F0"
        }
        FONTS = {
            "main": ("Arial", 12),
            "small": ("Arial", 10),
            "large": ("Arial", 16, "bold")
        }


class BetSliderWidget(tk.Frame):
    """
    Professional bet slider widget inspired by modern poker apps.
    Features a circular slider with chip-style visual feedback.
    """

    def __init__(
        self,
        parent,
        min_bet: float = 0,
        max_bet: float = 1000,
        current_bet: float = 0,
        on_change: Optional[Callable] = None,
        **kwargs,
    ):
        super().__init__(parent, bg=THEME["secondary_bg"], **kwargs)

        self.min_bet = min_bet
        self.max_bet = max_bet
        self.current_bet = current_bet
        self.on_change = on_change

        self.canvas_size = 200
        self.center_x = self.canvas_size // 2
        self.center_y = self.canvas_size // 2
        self.radius = 70
        self.knob_radius = 15

        self._create_widgets()
        self._update_display()

    def _create_widgets(self):
        """Create the slider components."""
        # Title
        title_label = tk.Label(
            self,
            text="Bet Amount",
            font=FONTS["header"],
            fg=THEME["text"],
            bg=THEME["secondary_bg"],
        )
        title_label.pack(pady=(10, 5))

        # Canvas for circular slider
        self.canvas = tk.Canvas(
            self,
            width=self.canvas_size,
            height=self.canvas_size,
            bg=THEME["secondary_bg"],
            highlightthickness=0,
        )
        self.canvas.pack(pady=10)

        # Bet amount display
        self.amount_label = tk.Label(
            self,
            text=f"${self.current_bet:.0f}",
            font=FONTS["bet_amount"],
            fg=THEME["text_gold"],
            bg=THEME["secondary_bg"],
        )
        self.amount_label.pack(pady=5)

        # Quick bet buttons
        self._create_quick_buttons()

        # Bind mouse events
        self.canvas.bind("<Button-1>", self._on_click)
        self.canvas.bind("<B1-Motion>", self._on_drag)

        self._draw_slider()

    def _create_quick_buttons(self):
        """Create quick bet amount buttons."""
        button_frame = tk.Frame(self, bg=THEME["secondary_bg"])
        button_frame.pack(pady=10)

        # Quick bet percentages
        quick_bets = [
            ("1/4 Pot", 0.25),
            ("1/2 Pot", 0.5),
            ("3/4 Pot", 0.75),
            ("Pot", 1.0),
            ("All-In", 1.0),  # Will be handled specially
        ]

        for i, (text, multiplier) in enumerate(quick_bets):
            btn = tk.Button(
                button_frame,
                text=text,
                font=FONTS["small"],
                bg=THEME["widget_bg"],
                fg=THEME["text"],
                activebackground=THEME["button_call"],
                activeforeground=THEME["text"],
                border=1,
                relief="solid",
                command=lambda m=multiplier, t=text: self._quick_bet(m, t),
            )
            btn.pack(side=tk.LEFT, padx=2)

    def _draw_slider(self):
        """Draw the circular slider interface."""
        self.canvas.delete("all")

        # Draw outer ring (track)
        self.canvas.create_oval(
            self.center_x - self.radius,
            self.center_y - self.radius,
            self.center_x + self.radius,
            self.center_y + self.radius,
            outline=THEME["border_inactive"],
            width=3,
            fill=THEME["widget_bg"],
        )

        # Draw progress arc
        extent = self._get_angle_from_bet()
        if extent > 0:
            self.canvas.create_arc(
                self.center_x - self.radius,
                self.center_y - self.radius,
                self.center_x + self.radius,
                self.center_y + self.radius,
                start=90,  # Start from top
                extent=-extent,  # Clockwise
                outline=THEME["chip_green"],
                width=6,
                style="arc",
            )

        # Draw knob
        knob_x, knob_y = self._get_knob_position()
        self.canvas.create_oval(
            knob_x - self.knob_radius,
            knob_y - self.knob_radius,
            knob_x + self.knob_radius,
            knob_y + self.knob_radius,
            fill=THEME["chip_gold"],
            outline=THEME["border_active"],
            width=2,
        )

        # Draw center circle with min/max labels
        self.canvas.create_oval(
            self.center_x - 25,
            self.center_y - 25,
            self.center_x + 25,
            self.center_y + 25,
            fill=THEME["widget_bg"],
            outline=THEME["border_inactive"],
        )

        # Min/Max labels
        self.canvas.create_text(
            self.center_x - self.radius + 15,
            self.center_y + 5,
            text=f"${self.min_bet:.0f}",
            fill=THEME["text_muted"],
            font=FONTS["small"],
        )
        self.canvas.create_text(
            self.center_x + self.radius - 15,
            self.center_y + 5,
            text=f"${self.max_bet:.0f}",
            fill=THEME["text_muted"],
            font=FONTS["small"],
        )

    def _get_angle_from_bet(self) -> float:
        """Convert bet amount to angle (0-270 degrees)."""
        if self.max_bet <= self.min_bet:
            return 0

        progress = (self.current_bet - self.min_bet) / (
            self.max_bet - self.min_bet
        )
        return progress * 270  # 270 degrees for 3/4 circle

    def _get_knob_position(self) -> tuple:
        """Get knob position based on current bet."""
        angle = self._get_angle_from_bet()
        # Convert to radians and adjust for starting position (top)
        rad = math.radians(angle - 90)  # -90 to start from top

        knob_x = self.center_x + (self.radius * math.cos(rad))
        knob_y = self.center_y + (self.radius * math.sin(rad))

        return knob_x, knob_y

    def _get_bet_from_position(self, x: int, y: int) -> float:
        """Convert mouse position to bet amount."""
        # Calculate angle from center
        dx = x - self.center_x
        dy = y - self.center_y

        angle = math.degrees(math.atan2(dy, dx))
        angle = (angle + 90) % 360  # Adjust for starting position

        # Limit to 270 degrees
        if angle > 270:
            angle = 270

        # Convert to bet amount
        progress = angle / 270
        bet_amount = self.min_bet + (progress * (self.max_bet - self.min_bet))

        return max(self.min_bet, min(self.max_bet, bet_amount))

    def _on_click(self, event):
        """Handle mouse click on slider."""
        self._update_bet_from_mouse(event.x, event.y)

    def _on_drag(self, event):
        """Handle mouse drag on slider."""
        self._update_bet_from_mouse(event.x, event.y)

    def _update_bet_from_mouse(self, x: int, y: int):
        """Update bet amount from mouse position."""
        new_bet = self._get_bet_from_position(x, y)
        self.set_bet_amount(new_bet)

    def _quick_bet(self, multiplier: float, text: str):
        """Handle quick bet button clicks."""
        if text == "All-In":
            new_bet = self.max_bet
        else:
            # For pot-based bets, we'd need the current pot size
            # For now, use a percentage of max bet
            new_bet = self.min_bet + (
                multiplier * (self.max_bet - self.min_bet)
            )

        self.set_bet_amount(new_bet)

    def set_bet_amount(self, amount: float):
        """Set the bet amount and update display."""
        self.current_bet = max(self.min_bet, min(self.max_bet, amount))
        self._update_display()

        if self.on_change:
            self.on_change(self.current_bet)

    def set_limits(self, min_bet: float, max_bet: float):
        """Update the betting limits."""
        self.min_bet = min_bet
        self.max_bet = max_bet
        self.current_bet = max(min_bet, min(max_bet, self.current_bet))
        self._update_display()

    def _update_display(self):
        """Update the visual display."""
        self._draw_slider()
        self.amount_label.config(text=f"${self.current_bet:.0f}")


class ModernActionButton(tk.Button):
    """
    Modern poker action button with professional styling and hover effects.
    """

    def __init__(self, parent, action_type: str, text: str = None, **kwargs):
        # Get colors based on action type
        colors = self._get_action_colors(action_type)

        # Set default styling
        default_kwargs = {
            "font": FONTS["action_button"],
            "bg": colors["normal"],
            "fg": THEME["text"],
            "activebackground": colors["hover"],
            "activeforeground": THEME["text"],
            "relief": "flat",
            "border": 0,
            "cursor": "hand2",
            "pady": 12,
            "padx": 20,
        }

        # Merge with provided kwargs
        default_kwargs.update(kwargs)

        super().__init__(
            parent, text=text or action_type.title(), **default_kwargs
        )

        self.action_type = action_type
        self.colors = colors

        # Bind hover effects
        self.bind("<Enter>", self._on_enter)
        self.bind("<Leave>", self._on_leave)

    def _get_action_colors(self, action_type: str) -> dict:
        """Get color scheme for action type."""
        color_map = {
            "call": {
                "normal": THEME["button_call"],
                "hover": THEME["button_call_hover"],
            },
            "raise": {
                "normal": THEME["button_raise"],
                "hover": THEME["button_raise_hover"],
            },
            "bet": {
                "normal": THEME["button_raise"],
                "hover": THEME["button_raise_hover"],
            },
            "fold": {
                "normal": THEME["button_fold"],
                "hover": THEME["button_fold_hover"],
            },
            "check": {
                "normal": THEME["button_check"],
                "hover": THEME["button_check_hover"],
            },
            "all_in": {
                "normal": THEME["button_allin"],
                "hover": THEME["button_allin_hover"],
            },
        }

        return color_map.get(
            action_type.lower(),
            {"normal": THEME["widget_bg"], "hover": THEME["border_active"]},
        )

    def _on_enter(self, event):
        """Handle mouse enter (hover)."""
        self.config(bg=self.colors["hover"])

    def _on_leave(self, event):
        """Handle mouse leave."""
        self.config(bg=self.colors["normal"])

    def set_enabled(self, enabled: bool):
        """Enable or disable the button with visual feedback."""
        if enabled:
            self.config(state="normal", bg=self.colors["normal"])
        else:
            self.config(state="disabled", bg=THEME["border_inactive"])


class ChipStackDisplay(tk.Frame):
    """
    Professional chip stack visualization for bet and pot displays.
    """

    def __init__(
        self, parent, amount: float = 0, title: str = "Chips", **kwargs
    ):
        super().__init__(parent, bg=THEME["table_felt"], **kwargs)

        self.amount = amount
        self.title = title

        self._create_widgets()
        self._update_display()

    def _create_widgets(self):
        """Create the chip display components."""
        # Title label
        self.title_label = tk.Label(
            self,
            text=self.title,
            font=FONTS["small"],
            fg=THEME["text_secondary"],
            bg=THEME["table_felt"],
        )
        self.title_label.pack(pady=(5, 2))

        # Chip stack canvas
        self.chip_canvas = tk.Canvas(
            self,
            width=80,
            height=60,
            bg=THEME["table_felt"],
            highlightthickness=0,
        )
        self.chip_canvas.pack()

        # Amount label
        self.amount_label = tk.Label(
            self,
            text=f"${self.amount:,.0f}",
            font=FONTS["bet_amount"],
            fg=THEME["text_gold"],
            bg=THEME["table_felt"],
        )
        self.amount_label.pack(pady=(2, 5))

    def _draw_chip_stack(self):
        """Draw visual chip stack based on amount."""
        self.chip_canvas.delete("all")

        if self.amount <= 0:
            # Draw a visible placeholder for empty pot/bet display
            self.chip_canvas.create_oval(
                15, 15, 65, 45,
                fill="#FFB366",  # Pale orange - clearly visible
                outline="#000000",  # Black outline
                width=3
            )
            # Add text to make it obvious
            self.chip_canvas.create_text(
                40, 30,
                text="$0",
                font=("Arial", 12, "bold"),
                fill="#000000"
            )
            return

        # Calculate chip distribution
        chips = self._get_chip_breakdown(self.amount)

        x_center = 40
        y_bottom = 55
        chip_height = 4

        current_y = y_bottom

        # Draw chips from bottom up
        for chip_value, count in chips:
            color = self._get_chip_color(chip_value)

            for i in range(
                min(count, 10)
            ):  # Max 10 chips per stack for display
                # Draw chip
                self.chip_canvas.create_oval(
                    x_center - 15,
                    current_y - chip_height,
                    x_center + 15,
                    current_y,
                    fill=color,
                    outline=THEME["border_inactive"],
                    width=1,
                )
                current_y -= chip_height

                if current_y < 10:  # Don't stack too high
                    break

    def _get_chip_breakdown(self, amount: float) -> list:
        """Break down amount into chip denominations."""
        # Standard poker chip values
        chip_values = [100, 25, 5, 1]
        chips = []

        remaining = amount
        for value in chip_values:
            count = int(remaining // value)
            if count > 0:
                chips.append((value, count))
                remaining -= count * value

        return chips

    def _get_chip_color(self, value: float) -> str:
        """Get chip color based on value."""
        if value >= 100:
            return THEME["chip_black"]
        elif value >= 25:
            return THEME["chip_green"]
        elif value >= 5:
            return THEME["chip_red"]
        else:
            return THEME["chip_blue"]

    def set_amount(self, amount: float):
        """Update the displayed amount."""
        self.amount = amount
        self._update_display()

    def set_title(self, title: str):
        """Update the title."""
        self.title = title
        self.title_label.config(text=title)

    def _update_display(self):
        """Update the visual display."""
        self._draw_chip_stack()
        self.amount_label.config(text=f"${self.amount:,.0f}")


class PlayerSeatWidget(tk.Frame):
    """
    Modern player seat display with professional card room aesthetics.
    """

    def __init__(
        self,
        parent,
        player_name: str = "Player",
        stack: float = 0,
        is_active: bool = False,
        **kwargs,
    ):
        super().__init__(parent, **kwargs)

        self.player_name = player_name
        self.stack = stack
        self.is_active = is_active

        self._create_widgets()
        self._update_display()

    def _create_widgets(self):
        """Create the player seat components."""
        # Main seat frame
        self.seat_frame = tk.Frame(
            self, bg=THEME["secondary_bg"], relief="solid", border=2
        )
        self.seat_frame.pack(padx=5, pady=5, fill="both", expand=True)

        # Player name
        self.name_label = tk.Label(
            self.seat_frame,
            text=self.player_name,
            font=FONTS["player_name"],
            fg=THEME["text"],
            bg=THEME["secondary_bg"],
        )
        self.name_label.pack(pady=(8, 2))

        # Stack amount
        self.stack_label = tk.Label(
            self.seat_frame,
            text=f"${self.stack:.0f}",
            font=FONTS["stack_amount"],
            fg=THEME["text_gold"],
            bg=THEME["secondary_bg"],
        )
        self.stack_label.pack(pady=(2, 8))

        # Card display area (placeholder)
        self.card_frame = tk.Frame(
            self.seat_frame, bg=THEME["secondary_bg"], height=30
        )
        self.card_frame.pack(fill="x", padx=10, pady=5)

    def set_active(self, active: bool):
        """Set the active state of the player seat."""
        self.is_active = active
        self._update_display()

    def set_stack(self, stack: float):
        """Update the player's stack."""
        self.stack = stack
        self.stack_label.config(text=f"${stack:.0f}")

    def set_name(self, name: str):
        """Update the player's name."""
        self.player_name = name
        self.name_label.config(text=name)

    def _update_display(self):
        """Update the visual appearance based on state."""
        if self.is_active:
            border_color = THEME["border_active"]
            self.seat_frame.config(
                highlightbackground=border_color, highlightthickness=3
            )
        else:
            border_color = THEME["border_inactive"]
            self.seat_frame.config(
                highlightbackground=border_color, highlightthickness=1
            )
```

---

### menu_integration.py

**Path**: `backend/ui/menu_integration.py`

**Size**: 4.1 KB

```python
"""
Menu integration for Theme Manager.
Simple hook to open Theme Manager from Settings ‚Üí Appearance menu.
"""

from typing import Optional, Callable
import tkinter as tk

from .theme_manager import ThemeManager


def open_theme_manager(parent: tk.Tk, on_theme_change: Optional[Callable] = None):
    """
    Open Theme Manager dialog.
    
    Args:
        parent: Parent window
        on_theme_change: Callback when theme is saved/changed
    """
    def on_close():
        """Handle theme manager close - trigger theme refresh if needed."""
        if on_theme_change:
            on_theme_change()
    
    # Create and show theme manager
    theme_manager = ThemeManager(parent, on_theme_change=on_close)
    
    # The dialog is modal and will block until closed
    parent.wait_window(theme_manager)


def add_theme_manager_to_menu(menu_bar: tk.Menu, parent: tk.Tk, on_theme_change: Optional[Callable] = None):
    """
    Add Theme Manager to an existing menu bar.
    
    Args:
        menu_bar: Menu bar to add to
        parent: Parent window
        on_theme_change: Callback when theme is changed
    """
    # Look for existing Settings menu
    settings_menu = None
    try:
        menu_end = menu_bar.index("end")
        if menu_end is not None:
            for i in range(menu_end + 1):
                try:
                    menu_label = menu_bar.entrycget(i, "label")
                    if "Settings" in menu_label or "Preferences" in menu_label:
                        settings_menu = menu_bar.nametowidget(menu_bar.entrycget(i, "menu"))
                        break
                except:
                    continue
    except:
        # Menu is empty or doesn't support index("end")
        pass
    
    # Create Settings menu if it doesn't exist
    if settings_menu is None:
        settings_menu = tk.Menu(menu_bar, tearoff=0)
        menu_bar.add_cascade(label="Settings", menu=settings_menu)
    
    # Look for existing Appearance submenu
    appearance_menu = None
    if settings_menu:
        try:
            submenu_end = settings_menu.index("end")
            if submenu_end is not None:
                for i in range(submenu_end + 1):
                    try:
                        submenu_label = settings_menu.entrycget(i, "label")
                        if "Appearance" in submenu_label:
                            appearance_menu = settings_menu.nametowidget(settings_menu.entrycget(i, "menu"))
                            break
                    except:
                        continue
        except:
            pass
    
    # Create Appearance submenu if it doesn't exist
    if appearance_menu is None:
        appearance_menu = tk.Menu(settings_menu, tearoff=0)
        settings_menu.add_cascade(label="Appearance", menu=appearance_menu)
    
    # Add Theme Manager option
    appearance_menu.add_command(
        label="üé® Theme Manager...",
        command=lambda: open_theme_manager(parent, on_theme_change)
    )


# Example usage for integrating into existing app:
def example_integration():
    """Example of how to integrate Theme Manager into an existing app."""
    
    root = tk.Tk()
    root.title("Poker Pro Trainer")
    
    # Create menu bar
    menu_bar = tk.Menu(root)
    root.config(menu=menu_bar)
    
    # Your existing menus...
    file_menu = tk.Menu(menu_bar, tearoff=0)
    menu_bar.add_cascade(label="File", menu=file_menu)
    file_menu.add_command(label="New Game")
    file_menu.add_command(label="Exit", command=root.quit)
    
    # Theme change callback
    def on_theme_changed():
        """Called when user saves theme changes."""
        print("üé® Theme changed - refreshing UI...")
        # Here you would refresh your UI with new theme
        # For example:
        # your_theme_manager.reload()
        # your_ui.refresh_colors()
        # your_poker_table.re_render()
    
    # Add Theme Manager to menu
    add_theme_manager_to_menu(menu_bar, root, on_theme_changed)
    
    # Your app content...
    tk.Label(root, text="Your poker app content here").pack(pady=20)
    
    root.mainloop()


if __name__ == "__main__":
    example_integration()
```

---

### __init__.py

**Path**: `backend/ui/mvu/__init__.py`

**Size**: 1.9 KB

```python
"""
MVU (Model-View-Update) Architecture Package - PPSM Integrated
Based on PokerPro UI Implementation Handbook v2

This package implements a clean, testable MVU architecture for the poker table UI
with complete integration to PurePokerStateMachine.
All timing, state management, and effects are handled through pure reducers and command execution.
"""

from .types_integrated import (
    Model, SeatState, Action, GtoHint, Banner,
    Msg, NextPressed, AutoPlayToggled, UserChose, DecisionReady, LoadHand,
    AppliedAction, StreetAdvanced, HandFinished, AnimationFinished,
    ReviewSeek, ReviewPlayStep, ThemeChanged,
    Cmd, PlaySound, Speak, Animate, AskDriverForDecision, ApplyPPSM,
    ScheduleTimer, PublishEvent, GetReviewEvent,
    SessionDriver, IntentHandler, TableRendererProps
)

from .update_integrated import update

from .store_integrated import MVUStore, MVUIntentHandler

from .view import MVUPokerTableRenderer

from .drivers import ReviewDriver, PracticeDriver, GTODriver, create_driver

from .hands_review_integrated import MVUHandsReviewTabIntegrated

__all__ = [
    # Core types
    "Model", "SeatState", "Action", "GtoHint", "Banner",
    "Msg", "NextPressed", "AutoPlayToggled", "UserChose", "DecisionReady", "LoadHand",
    "AppliedAction", "StreetAdvanced", "HandFinished", "AnimationFinished",
    "ReviewSeek", "ReviewPlayStep", "ThemeChanged",
    "Cmd", "PlaySound", "Speak", "Animate", "AskDriverForDecision", "ApplyPPSM",
    "ScheduleTimer", "PublishEvent", "GetReviewEvent",
    "SessionDriver", "IntentHandler", "TableRendererProps",
    
    # Core functions
    "update",
    
    # Store and handlers
    "MVUStore", "MVUIntentHandler",
    
    # View components
    "MVUPokerTableRenderer",
    
    # Session drivers
    "ReviewDriver", "PracticeDriver", "GTODriver", "create_driver",
    
    # Complete implementations
    "MVUHandsReviewTabIntegrated"
]
```

---

### drivers.py

**Path**: `backend/ui/mvu/drivers.py`

**Size**: 4.2 KB

```python
"""
MVU Session Drivers - Pluggable session behavior
Based on PokerPro UI Implementation Handbook v2
"""

from typing import List, Dict, Any, Optional, Callable
import threading
import time

from .types_integrated import Model, Msg, DecisionReady, AppliedAction, StreetAdvanced, HandFinished


class ReviewDriver:
    """
    Driver for REVIEW sessions - serves pre-recorded events
    """
    
    def __init__(self, hand_data: Dict[str, Any]):
        self.hand_data = hand_data
        self.events: List[Msg] = []
        self._parse_hand_events()
    
    def review_event_at(self, index: int) -> Optional[Msg]:
        """Get review event at specific index"""
        return self.events[index] if 0 <= index < len(self.events) else None
    
    def review_length(self) -> int:
        """Get total number of review events"""
        return len(self.events)
    
    def _parse_hand_events(self) -> None:
        """Parse hand data into review events"""
        actions = self.hand_data.get("actions", [])
        for i, action_data in enumerate(actions):
            # Create AppliedAction event for each action
            self.events.append(AppliedAction(
                seat=action_data.get("seat", 0),
                action=action_data.get("action", "CHECK"),
                amount=action_data.get("amount"),
                ppsm_state={}  # This would be the state *after* this action
            ))
            
            # TODO: Generate StreetAdvanced and HandFinished events
            # based on action progression
    
    def decide(self, model: Model, seat: int, callback: Callable[[DecisionReady], None]) -> None:
        """Not used in review mode"""
        pass


class PracticeDriver:
    """
    Driver for PRACTICE sessions - handles bot decisions
    """
    
    def __init__(self, **kwargs):
        pass
    
    def decide(self, model: Model, seat: int, callback: Callable[[DecisionReady], None]) -> None:
        """Make a bot decision for practice mode"""
        # Simple bot logic - just check or fold randomly
        import random
        
        def make_decision():
            time.sleep(0.5)  # Simulate thinking
            if random.random() < 0.7:
                action = "CHECK" if "CHECK" in model.legal_actions else "CALL"
            else:
                action = "FOLD"
            
            decision = DecisionReady(seat=seat, action=action, amount=None)
            callback(decision)
        
        # Make decision in background thread
        threading.Thread(target=make_decision, daemon=True).start()
    
    def review_event_at(self, index: int) -> Optional[Msg]:
        """Not used in practice mode"""
        return None
    
    def review_length(self) -> int:
        """Not used in practice mode"""
        return 0


class GTODriver:
    """
    Driver for GTO sessions - provides optimal decisions
    """
    
    def __init__(self, **kwargs):
        pass
    
    def decide(self, model: Model, seat: int, callback: Callable[[DecisionReady], None]) -> None:
        """Make a GTO-optimal decision"""
        # Simple GTO logic - prefer checking/calling
        def make_decision():
            time.sleep(1.0)  # Simulate GTO calculation
            
            if "CHECK" in model.legal_actions:
                action = "CHECK"
            elif "CALL" in model.legal_actions:
                action = "CALL"
            else:
                action = "FOLD"
            
            decision = DecisionReady(seat=seat, action=action, amount=None)
            callback(decision)
        
        # Make decision in background thread
        threading.Thread(target=make_decision, daemon=True).start()
    
    def review_event_at(self, index: int) -> Optional[Msg]:
        """Not used in GTO mode"""
        return None
    
    def review_length(self) -> int:
        """Not used in GTO mode"""
        return 0


def create_driver(session_mode: str, **kwargs) -> Any:
    """Factory function to create appropriate session driver"""
    if session_mode == "REVIEW":
        return ReviewDriver(kwargs.get("hand_data", {}))
    elif session_mode == "PRACTICE":
        return PracticeDriver(**kwargs)
    elif session_mode == "GTO":
        return GTODriver(**kwargs)
    else:
        raise ValueError(f"Unknown session mode: {session_mode}")
```

---

### hands_review_integrated.py

**Path**: `backend/ui/mvu/hands_review_integrated.py`

**Size**: 41.5 KB

```python
"""
MVU-based Hands Review Tab - PPSM Integrated
Complete integration with PurePokerStateMachine and existing services
"""

import tkinter as tk
from tkinter import ttk
from typing import Optional, Dict, Any, List, Callable
import json
import os

from .types_integrated import Model, TableRendererProps, LoadHand
from .store_integrated import MVUStore, MVUIntentHandler
from .view import MVUPokerTableRenderer
from .drivers import create_driver

# Import the real PPSM and related classes
import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..', '..'))
# Add the backend directory to sys.path for the converters
sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))

from backend.core.pure_poker_state_machine import PurePokerStateMachine, GameConfig
from backend.core.poker_types import Player


class MVUHandsReviewTabIntegrated(ttk.Frame):
    """
    MVU-based Hands Review Tab with complete PPSM integration
    """
    
    def __init__(self, parent: tk.Widget, services: Any = None, **kwargs):
        super().__init__(parent, **kwargs)
        
        # Store services reference
        self.services = services
        
        # Extract services
        self.effect_bus = services.get_app("effect_bus") if services else None
        self.game_director = services.get_app("game_director") if services else None
        self.event_bus = services.get_app("event_bus") if services else None
        self.theme_manager = services.get_app("theme") if services else None
        
        # Hand data
        self.hands_data: List[Dict[str, Any]] = []
        
        # MVU initialization flags
        self._mvu_initialized = False
        self._first_render_complete = False
        
        # Setup UI and initialize MVU
        self._setup_ui()
        self._initialize_mvu()
        self._load_hands_data()
        
        # Populate UI after everything is set up
        self._populate_ui_with_hands()
    
    def _setup_ui(self) -> None:
        """Setup the UI structure with left-right pane layout"""
        # Two-column layout: Controls (20%) | Poker Table (80%)
        self.grid_columnconfigure(0, weight=1)  # Left pane (20%)
        self.grid_columnconfigure(1, weight=4)  # Right pane (80%)
        self.grid_rowconfigure(0, weight=1)
        
        # Create the two main sections
        self._create_left_pane()
        # Right pane (poker table) will be created in _initialize_mvu()

    def _create_left_pane(self) -> None:
        """Create the left pane with hands library and controls"""
        # Main left frame
        left_frame = ttk.Frame(self)
        left_frame.grid(row=0, column=0, sticky="nsew", padx=(5, 2.5), pady=5)
        left_frame.grid_columnconfigure(0, weight=1)
        left_frame.grid_rowconfigure(0, weight=60)  # Hands library gets 60%
        left_frame.grid_rowconfigure(1, weight=40)  # Controls get 40%

        # Create library section at top
        self._create_library_section(left_frame)

        # Create filters/controls section at bottom
        self._create_controls_section(left_frame)

    def _create_library_section(self, parent):
        """Create the Library section exactly like the original"""
        # Get theme colors
        theme = self.theme_manager.get_theme() if self.theme_manager else {}
        
        library_frame = ttk.LabelFrame(parent, text="üìö Hands Library", padding=10)
        library_frame.grid(row=0, column=0, sticky="nsew", pady=(0, 2.5))
        
        # Apply theme colors to the frame
        try:
            library_frame.configure(
                background=theme.get("panel.bg", "#111827"),
                foreground=theme.get("panel.sectionTitle", "#C7D2FE"),
            )
        except Exception:
            pass  # Fallback to default colors if theming fails
        library_frame.grid_columnconfigure(0, weight=1)
        library_frame.grid_rowconfigure(
            5, weight=1
        )  # Hands list gets most space (shifted down due to additional components)

        # Theme selector (at top) - Professional Casino Schemes
        theme_frame = ttk.LabelFrame(
            library_frame, text="üé® Professional Casino Themes", padding=5
        )
        theme_frame.grid(row=0, column=0, sticky="ew", pady=(0, 10))
        theme_frame.grid_columnconfigure(0, weight=1)

        theme_controls = ttk.Frame(theme_frame)
        theme_controls.grid(row=0, column=0, sticky="ew")

        current_theme = self.theme_manager.current_profile_name() if self.theme_manager else "Forest Green Professional üåø"
        self.theme_var = tk.StringVar(value=current_theme)

        # All available themes from ThemeManager
        all_theme_names = self.theme_manager.names() if self.theme_manager else ["Forest Green Professional üåø"]
        
        # Fallback if no themes found
        if not all_theme_names:
            all_theme_names = ["Forest Green Professional üåø"]

        # Create clean 4x4 grid layout for 16 themes with 20px font
        # Configure grid weights for even distribution
        for col_idx in range(4):
            theme_controls.grid_columnconfigure(col_idx, weight=1)

        self.theme_radio_buttons = []
        for i, theme_name in enumerate(all_theme_names):
            row = i // 4  # 4 themes per row
            col = i % 4

            # Theme names from JSON config already include icons and formatting
            display_name = theme_name

            # Simple radiobutton with 20px font and equal spacing
            radio_btn = ttk.Radiobutton(
                theme_controls,
                text=display_name,
                variable=self.theme_var,
                value=theme_name,
                command=self._on_theme_changed,
            )
            radio_btn.grid(row=row, column=col, sticky="w", padx=5, pady=3)

            # Configure font size to 20px and store reference for styling
            try:
                fonts = self.theme_manager.get_fonts() if self.theme_manager else {}
                radio_font = fonts.get(
                    "button", fonts.get("body", ("Inter", 20, "normal"))
                )
                radio_btn.configure(font=radio_font)
            except:
                # Fallback if font configuration fails
                pass

            # Store radio button reference for theme styling
            self.theme_radio_buttons.append(radio_btn)

        # Artistic Theme Info Panel - shows evocative descriptions
        info_frame = ttk.Frame(theme_frame)
        info_frame.grid(row=1, column=0, sticky="ew", pady=(10, 0))
        info_frame.grid_columnconfigure(0, weight=1)

        # Luxury Museum Placard - Theme intro with elegant styling
        fonts = self.theme_manager.get_fonts() if self.theme_manager else {}
        intro_font = fonts.get("intro", fonts.get("body", ("Georgia", 16, "normal")))

        # Create luxury museum placard frame with theme-aware styling
        base_colors = self.theme_manager.get_base_colors() if self.theme_manager else {}
        placard_bg = base_colors.get("panel_bg", "#2A2A2A")
        placard_accent = base_colors.get("highlight", "#D4AF37")

        placard_frame = tk.Frame(
            info_frame,
            relief="raised",
            borderwidth=2,
            bg=placard_bg,
            highlightbackground=placard_accent,
            highlightcolor=placard_accent,
            highlightthickness=1,
        )
        dimensions = self.theme_manager.get_dimensions() if self.theme_manager else {"padding": {"medium": 5}}
        medium_pad = dimensions["padding"]["medium"]
        placard_frame.grid(
            row=0, column=0, sticky="ew", padx=medium_pad, pady=medium_pad
        )
        placard_frame.grid_columnconfigure(0, weight=1)

        # Store reference to placard frame for dynamic styling
        self.placard_frame = placard_frame

        # Get initial theme colors instead of hardcoding
        initial_bg = base_colors.get("panel_bg", "#1A1A1A")
        initial_fg = base_colors.get("text", "#F5F5DC")

        intro_height = dimensions.get("text_height", {}).get("medium", 3)
        self.theme_intro_label = tk.Text(
            placard_frame,
            height=intro_height,
            wrap=tk.WORD,
            relief="flat",
            borderwidth=0,
            font=intro_font,
            state="disabled",
            cursor="arrow",
            padx=dimensions["padding"].get("xlarge", 10),
            pady=dimensions["padding"]["medium"],
            bg=initial_bg,
            fg=initial_fg,
        )
        self.theme_intro_label.grid(row=0, column=0, sticky="ew")

        # Show current theme's introduction
        self._show_theme_intro(current_theme)

        # Library type selector
        type_frame = ttk.Frame(library_frame)
        type_frame.grid(row=2, column=0, sticky="ew", pady=(0, 10))
        type_frame.grid_columnconfigure(0, weight=1)

        self.library_type = tk.StringVar(value="legendary")
        ttk.Radiobutton(
            type_frame,
            text="üèÜ Legendary",
            variable=self.library_type,
            value="legendary",
            command=self._on_library_type_change,
        ).grid(row=0, column=0, sticky="w")
        ttk.Radiobutton(
            type_frame,
            text="ü§ñ Bot Sessions",
            variable=self.library_type,
            value="bot",
            command=self._on_library_type_change,
        ).grid(row=0, column=1, sticky="w")
        ttk.Radiobutton(
            type_frame,
            text="üì• Imported",
            variable=self.library_type,
            value="imported",
            command=self._on_library_type_change,
        ).grid(row=0, column=2, sticky="w")

        # Collection selector 
        collections_frame = ttk.Frame(library_frame)
        collections_frame.grid(row=3, column=0, sticky="ew", pady=(0, 10))
        collections_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(collections_frame, text="Collection:").grid(
            row=0, column=0, sticky="w", padx=(0, 5)
        )
        self.collection_var = tk.StringVar(value="ü§ñ GTO Hands")
        self.collection_combo = ttk.Combobox(
            collections_frame, textvariable=self.collection_var, state="readonly"
        )
        self.collection_combo.grid(row=0, column=1, sticky="ew")
        self.collection_combo.bind("<<ComboboxSelected>>", self._on_collection_change)

        # Hand selector dropdown
        hand_selector_frame = ttk.Frame(library_frame)
        hand_selector_frame.grid(row=4, column=0, sticky="ew", pady=(0, 10))
        hand_selector_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(hand_selector_frame, text="Hand:").grid(
            row=0, column=0, sticky="w", padx=(0, 5)
        )
        self.hand_selector = ttk.Combobox(
            hand_selector_frame, state="readonly"
        )
        self.hand_selector.grid(row=0, column=1, sticky="ew")
        self.hand_selector.bind("<<ComboboxSelected>>", self._on_hand_selected)

        # Hands listbox
        hands_frame = ttk.Frame(library_frame)
        hands_frame.grid(row=5, column=0, sticky="nsew", pady=(0, 10))
        hands_frame.grid_columnconfigure(0, weight=1)
        hands_frame.grid_rowconfigure(0, weight=1)

        # Get fonts from theme
        fonts = self.theme_manager.get_fonts() if self.theme_manager else {}
        body_font = fonts.get("body", ("Consolas", 20))

        self.hands_listbox = tk.Listbox(
            hands_frame, font=body_font, selectmode=tk.SINGLE
        )
        self.hands_listbox.grid(row=0, column=0, sticky="nsew")
        self.hands_listbox.bind("<<ListboxSelect>>", self._on_hand_select)

        # Apply theme colors to listbox with dynamic selection highlight
        try:
            # Get theme-specific selection highlight
            current_theme_name = self.theme_manager.current() if self.theme_manager else "Forest Green Professional üåø"
            # Get selection highlight from config-driven system
            base_colors = self.theme_manager.get_base_colors() if self.theme_manager else {}
            selection_highlight = {
                "color": base_colors.get(
                    "highlight", base_colors.get("accent", "#D4AF37")
                )
            }

            self.hands_listbox.configure(
                bg=theme.get("panel.bg", "#111827"),
                fg=theme.get("panel.fg", "#E5E7EB"),
                selectbackground=selection_highlight[
                    "color"
                ],  # Dynamic theme-specific highlight
                selectforeground=base_colors.get(
                    "highlight_text", base_colors.get("text", "#FFFFFF")
                ),  # Theme-aware text when highlighted
                highlightbackground=theme.get("panel.border", "#1F2937"),
                highlightcolor=theme.get("a11y.focusRing", "#22D3EE"),
            )
        except Exception:
            pass

        scrollbar = ttk.Scrollbar(
            hands_frame, orient="vertical", command=self.hands_listbox.yview
        )
        scrollbar.grid(row=0, column=1, sticky="ns")
        self.hands_listbox.configure(yscrollcommand=scrollbar.set)

        # Hand details text (smaller in the combined layout)
        details_frame = ttk.LabelFrame(library_frame, text="Hand Details", padding=5)
        details_frame.grid(row=6, column=0, sticky="ew")
        details_frame.grid_columnconfigure(0, weight=1)

        self.hand_details_text = tk.Text(
            details_frame, height=4, wrap=tk.WORD, state="disabled",
            font=("Consolas", 12)
        )
        self.hand_details_text.grid(row=0, column=0, sticky="ew")

    def _create_controls_section(self, parent):
        """Create the Filters & Controls section exactly like the original"""
        # Get theme colors
        theme = self.theme_manager.get_theme() if self.theme_manager else {}
        
        filters_frame = ttk.LabelFrame(
            parent, text="üîç Filters & Study Mode", padding=10
        )
        filters_frame.grid(row=1, column=0, sticky="nsew", pady=(2.5, 0))

        # Apply theme colors to the frame
        try:
            filters_frame.configure(
                background=theme.get("panel.bg", "#111827"),
                foreground=theme.get("panel.sectionTitle", "#C7D2FE"),
            )
        except Exception:
            pass
        filters_frame.grid_columnconfigure(0, weight=1)

        # Study Mode selector
        study_frame = ttk.LabelFrame(filters_frame, text="Study Mode", padding=5)
        study_frame.grid(row=0, column=0, sticky="ew", pady=(0, 10))

        self.study_mode = tk.StringVar(value="REPLAY")
        ttk.Radiobutton(
            study_frame,
            text="üîÑ Replay",
            variable=self.study_mode,
            value="REPLAY",
            command=self._on_study_mode_change,
        ).grid(row=0, column=0, sticky="w")
        ttk.Radiobutton(
            study_frame,
            text="üìä Solver Diff",
            variable=self.study_mode,
            value="SOLVER_DIFF",
            command=self._on_study_mode_change,
        ).grid(row=1, column=0, sticky="w")
        ttk.Radiobutton(
            study_frame,
            text="üß† Recall Quiz",
            variable=self.study_mode,
            value="RECALL_QUIZ",
            command=self._on_study_mode_change,
        ).grid(row=2, column=0, sticky="w")
        ttk.Radiobutton(
            study_frame,
            text="‚ùì Explain Mistake",
            variable=self.study_mode,
            value="EXPLAIN_MISTAKE",
            command=self._on_study_mode_change,
        ).grid(row=3, column=0, sticky="w")

        # Filters section
        filter_frame = ttk.LabelFrame(filters_frame, text="Filters", padding=5)
        filter_frame.grid(row=1, column=0, sticky="ew", pady=(0, 10))
        filter_frame.grid_columnconfigure(1, weight=1)

        # Position filter
        ttk.Label(filter_frame, text="Position:").grid(
            row=0, column=0, sticky="w", padx=(0, 5)
        )
        self.position_var = tk.StringVar(value="All")
        position_combo = ttk.Combobox(
            filter_frame,
            textvariable=self.position_var,
            values=["All", "UTG", "MP", "CO", "BTN", "SB", "BB"],
            state="readonly",
            width=8,
        )
        position_combo.grid(row=0, column=1, sticky="w", pady=2)

        # Stack depth filter
        ttk.Label(filter_frame, text="Stack Depth:").grid(
            row=1, column=0, sticky="w", padx=(0, 5)
        )
        stack_frame = ttk.Frame(filter_frame)
        stack_frame.grid(row=1, column=1, sticky="w", pady=2)
        self.min_stack = tk.StringVar(value="20")
        self.max_stack = tk.StringVar(value="200")
        ttk.Entry(stack_frame, textvariable=self.min_stack, width=5).grid(
            row=0, column=0
        )
        ttk.Label(stack_frame, text=" - ").grid(row=0, column=1)
        ttk.Entry(stack_frame, textvariable=self.max_stack, width=5).grid(
            row=0, column=2
        )
        ttk.Label(stack_frame, text=" BB").grid(row=0, column=3)

        # Pot type filter
        ttk.Label(filter_frame, text="Pot Type:").grid(
            row=2, column=0, sticky="w", padx=(0, 5)
        )
        self.pot_type_var = tk.StringVar(value="All")
        pot_combo = ttk.Combobox(
            filter_frame,
            textvariable=self.pot_type_var,
            values=["All", "SRP", "3BP", "4BP+"],
            state="readonly",
            width=8,
        )
        pot_combo.grid(row=2, column=1, sticky="w", pady=2)

        # Search text
        ttk.Label(filter_frame, text="Search:").grid(
            row=3, column=0, sticky="w", padx=(0, 5)
        )
        self.search_var = tk.StringVar()
        search_entry = ttk.Entry(filter_frame, textvariable=self.search_var)
        search_entry.grid(row=3, column=1, sticky="ew", pady=2)
        search_entry.bind("<KeyRelease>", lambda e: self._apply_filters())

        # Apply filters button
        ttk.Button(
            filter_frame, text="Apply Filters", command=self._apply_filters
        ).grid(row=4, column=0, columnspan=2, pady=5)

        # Action buttons
        actions_frame = ttk.LabelFrame(filters_frame, text="Actions", padding=5)
        actions_frame.grid(row=2, column=0, sticky="ew", pady=(0, 10))
        actions_frame.grid_columnconfigure(0, weight=1)

        # Load button (main action) - Enhanced primary button
        self.load_btn = ttk.Button(
            actions_frame,
            text="üî• LOAD HAND",
            command=self._load_selected_hand,
        )
        self.load_btn.grid(row=0, column=0, sticky="ew", pady=5)

        # Playback controls
        controls_frame = ttk.Frame(actions_frame)
        controls_frame.grid(row=1, column=0, sticky="ew", pady=5)
        controls_frame.grid_columnconfigure(1, weight=1)

        # Navigation buttons
        self.next_btn = ttk.Button(
            controls_frame,
            text="Next ‚Üí",
            command=self._on_next_action,
        )
        self.next_btn.grid(row=0, column=0, padx=(0, 5))

        self.auto_btn = ttk.Button(
            controls_frame,
            text="Auto ‚ñ∂",
            command=self._on_autoplay_toggle,
        )
        self.auto_btn.grid(row=0, column=1, padx=(0, 5))

        self.reset_btn = ttk.Button(
            controls_frame,
            text="‚èπ Reset",
            command=self._on_reset,
        )
        self.reset_btn.grid(row=0, column=2)

    def _initialize_mvu(self) -> None:
        """Initialize MVU components with real PPSM"""
        print("üé¨ MVUHandsReviewTabIntegrated: Initializing MVU components")
        
        # Create and configure the real PPSM
        config = GameConfig(
            num_players=6,  # Start with fewer players for review
            starting_stack=1000.0,
            small_blind=5.0,
            big_blind=10.0
        )
        self.ppsm = PurePokerStateMachine(config)
        
        # Create initial model for REVIEW mode
        initial_model = Model.initial(session_mode="REVIEW")
        
        # Create MVU store with real PPSM
        self.store = MVUStore(
            initial_model=initial_model,
            effect_bus=self.effect_bus,
            game_director=self.game_director,
            event_bus=self.event_bus,
            ppsm=self.ppsm  # Pass the real PPSM instance
        )
        
        # Create intent handler
        self.intent_handler = MVUIntentHandler(self.store)
        
        # Create table renderer
        self.table_renderer = MVUPokerTableRenderer(
            parent=self,
            intent_handler=self.intent_handler,
            theme_manager=self.theme_manager
        )
        self.table_renderer.grid(row=0, column=1, sticky="nsew", padx=(2.5, 5), pady=5)
        
        # Set initialization flags
        self._mvu_initialized = True
        self._first_render_complete = False
        
        print("üé¨ MVUHandsReviewTabIntegrated: MVU components initialized")

    def _load_hands_data(self) -> None:
        """Load hands data using direct JSON reading"""
        try:
            self.hands_data = []
            
            # Load GTO hands directly from JSON - try realistic file first
            gto_file = os.path.join(
                os.path.dirname(__file__), "..", "..", "data", "gto_hands_realistic.json"
            )
            if not os.path.exists(gto_file):
                # Fallback to comprehensive file
                gto_file = os.path.join(
                    os.path.dirname(__file__), "..", "..", "data", "gto_hands_comprehensive.json"
                )
                if not os.path.exists(gto_file):
                    # Final fallback to old file
                    gto_file = os.path.join(
                        os.path.dirname(__file__), "..", "..", "gto_hands.json"
                    )
            
            if os.path.exists(gto_file):
                with open(gto_file, 'r') as f:
                    raw_gto_data = json.load(f)
                
                # Check if this is the new comprehensive format (already normalized) or old format
                if raw_gto_data and isinstance(raw_gto_data, list) and len(raw_gto_data) > 0:
                    first_hand = raw_gto_data[0]
                    if "metadata" in first_hand:
                        # New comprehensive format - already normalized
                        gto_hands = raw_gto_data
                        print(f"üìä MVUHandsReviewTabIntegrated: Using comprehensive GTO hands format")
                    else:
                        # Old format - needs conversion
                        print(f"üìä MVUHandsReviewTabIntegrated: Converting old GTO hands format")
                        gto_hands = []
                        for i, gto_hand_data in enumerate(raw_gto_data[:10]):  # Limit old format for testing
                            try:
                                # Extract metadata
                                metadata = gto_hand_data.get("metadata", {})
                                seats_data = gto_hand_data.get("seats", [])
                                
                                # Convert to normalized format
                                normalized_hand = {
                                    "metadata": {
                                        "hand_id": metadata.get("hand_id", f"GTO_{i+1:03d}"),
                                        "variant": metadata.get("variant", "NLHE"),
                                        "small_blind": metadata.get("small_blind", 5),
                                        "big_blind": metadata.get("big_blind", 10),
                                        "max_players": metadata.get("max_players", len(seats_data)),
                                        "session_type": "gto"
                                    },
                                    "seats": seats_data,
                                    "streets": gto_hand_data.get("streets", {}),
                                    "hero_player_uid": gto_hand_data.get("hero_player_uid"),
                                    "pots": gto_hand_data.get("pots", []),
                                    "showdown": gto_hand_data.get("showdown", []),
                                    "final_stacks": gto_hand_data.get("final_stacks", {})
                                }
                                gto_hands.append(normalized_hand)
                            except Exception as e:
                                print(f"‚ö†Ô∏è Error processing GTO hand {i}: {e}")
                else:
                    gto_hands = []
                
                self.hands_data.extend(gto_hands)
                print(f"üìä MVUHandsReviewTabIntegrated: Loaded {len(gto_hands)} GTO hands")
            else:
                print("üìä MVUHandsReviewTabIntegrated: GTO hands file not found")
            
            # Load legendary hands directly
            legendary_file = os.path.join(
                os.path.dirname(__file__), "..", "..", "data", "legendary_hands_normalized.json"
            )
            
            if os.path.exists(legendary_file):
                with open(legendary_file, 'r') as f:
                    raw_legendary_data = json.load(f)
                
                try:
                    # Extract hands array from the normalized format
                    if "hands" in raw_legendary_data:
                        legendary_hands = raw_legendary_data["hands"]
                        self.hands_data.extend(legendary_hands)
                        print(f"üìä MVUHandsReviewTabIntegrated: Loaded {len(legendary_hands)} legendary hands")
                    else:
                        print("üìä MVUHandsReviewTabIntegrated: No hands array found in legendary data")
                except Exception as e:
                    print(f"‚ö†Ô∏è Error processing legendary hands: {e}")
            else:
                print("üìä MVUHandsReviewTabIntegrated: Legendary hands file not found")
            
            # If no hands loaded, use sample data
            if not self.hands_data:
                self.hands_data = self._create_sample_hands()
                print("üìä MVUHandsReviewTabIntegrated: Using sample hands data")
            
            print(f"üìä MVUHandsReviewTabIntegrated: Total loaded {len(self.hands_data)} hands")
            
            # UI will be populated after hands are loaded
            
            # Load first hand if MVU is ready
            if self.hands_data and hasattr(self, '_mvu_initialized') and self._mvu_initialized:
                # Subscribe to model changes AFTER hand data is ready
                if not hasattr(self, 'unsubscribe'):
                    self.unsubscribe = self.store.subscribe(self._on_model_changed)
                # Load first hand immediately (not deferred)
                self._load_hand(0)
                
        except Exception as e:
            print(f"‚ö†Ô∏è MVUHandsReviewTabIntegrated: Error loading hands: {e}")
            self.hands_data = self._create_sample_hands()
    
    def _populate_ui_with_hands(self) -> None:
        """Populate UI components with loaded hands data"""
        try:
            if not self.hands_data:
                print("‚ö†Ô∏è No hands data to populate")
                return
                
            # Update hand selector dropdown if it exists
            if hasattr(self, 'hand_selector') and self.hand_selector:
                self._update_hand_selector()
            else:
                print("‚ö†Ô∏è hand_selector not found during population")
                
            # Update hands listbox if it exists  
            if hasattr(self, 'hands_listbox') and self.hands_listbox:
                self._refresh_hands_list()
            else:
                print("‚ö†Ô∏è hands_listbox not found during population")
                
            print(f"‚úÖ UI populated with {len(self.hands_data)} hands")
            
        except Exception as e:
            print(f"‚ùå Error populating UI with hands: {e}")
            import traceback
            traceback.print_exc()

    def _parse_legendary_hands_data(self, raw_data: Any) -> List[Dict[str, Any]]:
        """Parse legendary hands data format"""
        hands = []
        
        if isinstance(raw_data, list):
            for i, hand_data in enumerate(raw_data[:10]):  # Limit for testing
                if isinstance(hand_data, dict):
                    parsed_hand = self._normalize_hand_data(hand_data, f"LEGENDARY_{i+1:03d}")
                    if parsed_hand:
                        hands.append(parsed_hand)
        
        return hands

    def _parse_gto_hands_data(self, raw_data: Any) -> List[Dict[str, Any]]:
        """Parse GTO hands data format"""
        hands = []
        
        if isinstance(raw_data, list):
            for i, hand_data in enumerate(raw_data[:10]):  # Limit for testing
                if isinstance(hand_data, dict):
                    parsed_hand = self._normalize_hand_data(hand_data, f"GTO_{i+1:03d}")
                    if parsed_hand:
                        hands.append(parsed_hand)
        
        return hands

    def _normalize_hand_data(self, hand_data: dict, hand_id: str) -> Optional[Dict[str, Any]]:
        """Normalize hand data to our expected format"""
        try:
            # Extract seats information
            seats = {}
            players_data = hand_data.get("players", hand_data.get("seats", {}))
            
            if isinstance(players_data, list):
                # Convert list to dict
                for i, player in enumerate(players_data):
                    if isinstance(player, dict):
                        seats[i] = {
                            "name": player.get("name", f"Player {i}"),
                            "stack": player.get("stack", 1000),
                            "cards": player.get("cards", []),
                            "chips_in_front": player.get("current_bet", 0),
                            "folded": player.get("has_folded", False),
                            "all_in": player.get("is_all_in", False)
                        }
            elif isinstance(players_data, dict):
                seats = players_data
            
            if not seats:
                return None
            
            return {
                "hand_id": hand_id,
                "seats": seats,
                "pot": hand_data.get("pot", hand_data.get("committed_pot", 0)),
                "board": hand_data.get("board", hand_data.get("community_cards", [])),
                "to_act_seat": hand_data.get("to_act_seat", hand_data.get("action_player_index")),
                "legal_actions": hand_data.get("legal_actions", ["CHECK", "BET", "FOLD"]),
                "review_len": len(hand_data.get("actions", [])) + 5  # Estimate
            }
            
        except Exception as e:
            print(f"‚ö†Ô∏è Error normalizing hand {hand_id}: {e}")
            return None

    def _create_sample_hands(self) -> List[Dict[str, Any]]:
        """Create sample hands for testing"""
        return [
            {
                "hand_id": "SAMPLE_001",
                "seats": {
                    0: {"name": "Hero", "stack": 1000, "cards": ["As", "Kh"], "chips_in_front": 0, "folded": False, "all_in": False},
                    1: {"name": "Villain", "stack": 1000, "cards": ["Qd", "Jc"], "chips_in_front": 0, "folded": False, "all_in": False}
                },
                "pot": 30,
                "board": [],
                "to_act_seat": 0,
                "legal_actions": ["CHECK", "BET", "FOLD"],
                "review_len": 8
            },
            {
                "hand_id": "SAMPLE_002", 
                "seats": {
                    0: {"name": "Hero", "stack": 800, "cards": ["Qs", "Qh"], "chips_in_front": 0, "folded": False, "all_in": False},
                    1: {"name": "Villain", "stack": 1200, "cards": ["Ac", "Kc"], "chips_in_front": 0, "folded": False, "all_in": False},
                    2: {"name": "Fish", "stack": 500, "cards": ["7d", "2s"], "chips_in_front": 0, "folded": False, "all_in": False}
                },
                "pot": 150,
                "board": ["Qc", "Jh", "Ts"],
                "to_act_seat": 1,
                "legal_actions": ["CHECK", "BET", "FOLD"],
                "review_len": 12
            }
        ]

    def _update_hand_selector(self) -> None:
        """Update the hand selector dropdown"""
        if self.hands_data:
            hand_descriptions = []
            for hand in self.hands_data:
                # Access HandModel format
                metadata = hand.get("metadata", {})
                hand_id = metadata.get("hand_id", "Unknown")
                seats = hand.get("seats", [])
                players_count = len(seats) if isinstance(seats, list) else len(seats)
                description = f"{hand_id} ({players_count}P)"
                hand_descriptions.append(description)
            
            self.hand_selector["values"] = hand_descriptions
            
            if hand_descriptions:
                self.hand_selector.current(0)
                print(f"üìö Loaded {len(self.hands_data)} hands")
                
            # Hands listbox will be populated separately

    def _on_hand_selected(self, event=None) -> None:
        """Handle hand selection from dropdown"""
        current_index = self.hand_selector.current()
        if 0 <= current_index < len(self.hands_data):
            hand_data = self.hands_data[current_index]
            self._update_hand_info(hand_data)
            self._load_hand(current_index)

    def _load_hand(self, index: int) -> None:
        """Load a specific hand by index"""
        if not (0 <= index < len(self.hands_data)):
            return
            
        hand_data = self.hands_data[index]
        metadata = hand_data.get("metadata", {})
        hand_id = metadata.get('hand_id', 'Unknown')
        print(f"üìã MVUHandsReviewTabIntegrated: Loading hand {hand_id}")
        
        # Create session driver for this hand
        driver = create_driver("REVIEW", hand_data=hand_data)
        self.store.set_session_driver(driver)
        
        # Dispatch LoadHand message to the store
        self.store.dispatch(LoadHand(hand_data=hand_data))
        
        # Update status
        print(f"üìã Loaded: {hand_id}")

    def _on_model_changed(self, model: Model) -> None:
        """Handle model changes from the store"""
        try:
            # Skip first empty model notification
            if not self._first_render_complete and len(model.seats) == 0:
                print(f"üîÑ MVUHandsReviewTabIntegrated: Skipping initial empty model render")
                self._first_render_complete = True
                return
            
            print(f"üîÑ MVUHandsReviewTabIntegrated: Model changed - {len(model.seats)} seats, pot={model.pot}")
            
            # Create props from model
            props = TableRendererProps.from_model(model)
            
            # Check if props actually changed (memoization)
            if hasattr(self, '_last_props') and props == self._last_props:
                print(f"üîÑ MVUHandsReviewTabIntegrated: Props unchanged, skipping render")
                return
            
            print(f"üîÑ MVUHandsReviewTabIntegrated: Props changed, updating renderer")
            self._last_props = props
            
            # Update the table renderer
            if self.table_renderer:
                self.table_renderer.render(props)
                
        except Exception as e:
            print(f"‚ö†Ô∏è MVUHandsReviewTabIntegrated: Error updating view: {e}")
            import traceback
            traceback.print_exc()

    # Event handlers for the left pane controls
    def _on_theme_changed(self, event=None):
        """Handle theme selection change"""
        if self.theme_manager and hasattr(self.theme_manager, 'set_active_theme'):
            selected_theme = self.theme_var.get()
            self.theme_manager.set_active_theme(selected_theme)
            print(f"üé® Theme changed to: {selected_theme}")
            self._show_theme_intro(selected_theme)

    def _show_theme_intro(self, theme_name):
        """Show theme introduction in the placard"""
        if hasattr(self, 'theme_intro_label'):
            self.theme_intro_label.config(state="normal")
            self.theme_intro_label.delete(1.0, tk.END)
            intro_text = f"Selected: {theme_name}\nExperience the elegant atmosphere of professional poker."
            self.theme_intro_label.insert(1.0, intro_text)
            self.theme_intro_label.config(state="disabled")

    def _on_library_type_change(self):
        """Handle library type change"""
        lib_type = self.library_type.get()
        print(f"üìö Library type changed to: {lib_type}")
        self._refresh_hands_list()

    def _on_collection_change(self, event=None):
        """Handle collection change"""
        collection = self.collection_var.get()
        print(f"üìÇ Collection changed to: {collection}")
        self._refresh_hands_list()

    def _on_hand_select(self, event=None):
        """Handle hand selection from listbox"""
        if self.hands_listbox.curselection():
            index = self.hands_listbox.curselection()[0]
            if 0 <= index < len(self.hands_data):
                hand_data = self.hands_data[index]
                self._update_hand_details(hand_data)
                metadata = hand_data.get("metadata", {})
                hand_id = metadata.get('hand_id', 'Unknown')
                print(f"üéØ Hand selected from listbox: {hand_id}")

    def _refresh_hands_list(self):
        """Refresh the hands list based on current filters"""
        if hasattr(self, 'hands_listbox'):
            self.hands_listbox.delete(0, tk.END)
            for i, hand_data in enumerate(self.hands_data):
                # Access HandModel format
                metadata = hand_data.get("metadata", {})
                hand_id = metadata.get('hand_id', f'Hand {i+1}')
                self.hands_listbox.insert(tk.END, hand_id)

    def _update_hand_details(self, hand_data):
        """Update the hand details display"""
        if hasattr(self, 'hand_details_text'):
            self.hand_details_text.config(state="normal")
            self.hand_details_text.delete(1.0, tk.END)
            
            # Access HandModel format
            metadata = hand_data.get("metadata", {})
            hand_id = metadata.get('hand_id', 'N/A')
            seats = hand_data.get('seats', [])
            players_count = len(seats) if isinstance(seats, list) else len(seats)
            
            # Calculate total actions across all streets
            streets = hand_data.get('streets', {})
            total_actions = 0
            for street_data in streets.values():
                if isinstance(street_data, dict):
                    total_actions += len(street_data.get('actions', []))
            
            details_text = f"Hand: {hand_id}\n"
            details_text += f"Players: {players_count}\n"
            details_text += f"Blinds: ${metadata.get('small_blind', 0)}/${metadata.get('big_blind', 0)}\n"
            details_text += f"Actions: {total_actions}"
            
            self.hand_details_text.insert(1.0, details_text)
            self.hand_details_text.config(state="disabled")

    def _apply_filters(self):
        """Apply the current filters"""
        print(f"üîç Applying filters: Position={self.position_var.get()}, "
              f"Stack={self.min_stack.get()}-{self.max_stack.get()}, "
              f"Pot={self.pot_type_var.get()}, Search={self.search_var.get()}")
        self._refresh_hands_list()

    def _load_selected_hand(self):
        """Load the selected hand"""
        if hasattr(self, 'hands_listbox') and self.hands_listbox.curselection():
            index = self.hands_listbox.curselection()[0]
            self._load_hand(index)
        else:
            print("‚ö†Ô∏è No hand selected")

    def _on_study_mode_change(self):
        """Handle study mode change"""
        mode = self.study_mode.get()
        print(f"üìö Study mode changed to: {mode}")
        # TODO: Update MVU store with study mode

    def _on_autoplay_toggle(self):
        """Handle autoplay toggle"""
        if self.intent_handler:
            autoplay_on = hasattr(self, 'autoplay_var') and self.autoplay_var.get()
            self.intent_handler.on_toggle_autoplay(autoplay_on)
        print("üîÑ Autoplay toggled")

    def _on_next_action(self):
        """Handle next action button"""
        if self.intent_handler:
            self.intent_handler.on_click_next()

    def _on_reset(self):
        """Handle reset button"""
        print("‚èπ Reset")
        # TODO: Implement reset in MVU

    def _update_hand_info(self, hand_data: Dict[str, Any]):
        """Update the hand info display"""
        if not hasattr(self, 'hand_info_text'):
            return
            
        self.hand_info_text.config(state="normal")
        self.hand_info_text.delete(1.0, tk.END)
        
        # Format hand information
        info_text = f"Hand ID: {hand_data.get('hand_id', 'N/A')}\n"
        info_text += f"Players: {len(hand_data.get('seats', {}))}\n"
        info_text += f"Pot: ${hand_data.get('pot', 0)}\n"
        info_text += f"Street: {hand_data.get('street', 'PREFLOP')}\n"
        
        # Add action summary
        actions = hand_data.get('actions', [])
        if actions:
            info_text += f"\nActions ({len(actions)}):\n"
            for i, action in enumerate(actions[:5]):  # Show first 5 actions
                action_text = f"  {i+1}. Seat {action.get('seat', '?')}: {action.get('action', 'UNKNOWN')}"
                if action.get('amount'):
                    action_text += f" ${action['amount']}"
                info_text += action_text + "\n"
            if len(actions) > 5:
                info_text += f"  ... and {len(actions) - 5} more actions\n"
        
        self.hand_info_text.insert(1.0, info_text)
        self.hand_info_text.config(state="disabled")

    def dispose(self) -> None:
        """Clean up resources"""
        if hasattr(self, 'unsubscribe'):
            self.unsubscribe()
        print("üßπ MVUHandsReviewTabIntegrated: Disposed")
```

---

### hands_review_mvu.py

**Path**: `backend/ui/mvu/hands_review_mvu.py`

**Size**: 15.1 KB

```python
"""
MVU-based Hands Review Tab
Replaces the existing HandsReviewTab with clean MVU architecture
"""

import tkinter as tk
from tkinter import ttk
from typing import Optional, Dict, Any, List
import json

from .types import Model, TableRendererProps, LoadHand, SeatState
from .store import MVUStore, MVUIntentHandler
from .view import MVUPokerTableRenderer
from .drivers import create_driver


class MVUHandsReviewTab(ttk.Frame):
    """
    MVU-based Hands Review Tab
    Clean, testable, and follows the architecture handbook
    """
    
    def __init__(
        self,
        parent: tk.Widget,
        services: Any = None,
        **kwargs
    ):
        super().__init__(parent, **kwargs)
        
        self.services = services
        
        # Get required services
        self.effect_bus = services.get_app("effect_bus") if services else None
        self.game_director = services.get_app("game_director") if services else None
        self.event_bus = services.get_app("event_bus") if services else None
        self.theme_manager = services.get_app("theme") if services else None
        
        # MVU components
        self.store: Optional[MVUStore] = None
        self.intent_handler: Optional[MVUIntentHandler] = None
        self.table_renderer: Optional[MVUPokerTableRenderer] = None
        
        # Hand data
        self.hands_data: List[Dict[str, Any]] = []
        self.current_hand_index = 0
        
        # UI components
        self.hand_selector: Optional[ttk.Combobox] = None
        self.hand_info_label: Optional[ttk.Label] = None
        
        # Props memoization
        self._last_props: Optional[TableRendererProps] = None
        
        self._setup_ui()
        self._initialize_mvu()
        self._load_hands_data()
        
        print("üé¨ MVUHandsReviewTab: Initialized with clean MVU architecture")
    
    def _setup_ui(self) -> None:
        """Setup the UI layout"""
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(1, weight=1)
        
        # Top controls frame
        controls_frame = ttk.Frame(self)
        controls_frame.grid(row=0, column=0, sticky="ew", padx=5, pady=5)
        controls_frame.grid_columnconfigure(1, weight=1)
        
        # Hand selector
        ttk.Label(controls_frame, text="Hand:").grid(row=0, column=0, padx=5)
        
        self.hand_selector = ttk.Combobox(
            controls_frame,
            state="readonly",
            width=30
        )
        self.hand_selector.grid(row=0, column=1, padx=5, sticky="w")
        self.hand_selector.bind("<<ComboboxSelected>>", self._on_hand_selected)
        
        # Hand info
        self.hand_info_label = ttk.Label(
            controls_frame,
            text="No hand loaded"
        )
        self.hand_info_label.grid(row=0, column=2, padx=10, sticky="w")
        
        # Refresh button
        refresh_btn = ttk.Button(
            controls_frame,
            text="Refresh Hands",
            command=self._load_hands_data
        )
        refresh_btn.grid(row=0, column=3, padx=5)
        
        # Table renderer will be added in _initialize_mvu()
    
    def _initialize_mvu(self) -> None:
        """Initialize MVU components - FIXED VERSION"""
        
        # Create initial model for REVIEW mode
        initial_model = Model.initial(session_mode="REVIEW")
        
        # Create store
        self.store = MVUStore(
            initial_model=initial_model,
            effect_bus=self.effect_bus,
            game_director=self.game_director,
            event_bus=self.event_bus,
            ppsm=None  # We'll set this up when we have PPSM integration
        )
        
        # Create intent handler
        self.intent_handler = MVUIntentHandler(self.store)
        
        # Create table renderer
        self.table_renderer = MVUPokerTableRenderer(
            parent=self,
            intent_handler=self.intent_handler,
            theme_manager=self.theme_manager
        )
        self.table_renderer.grid(row=1, column=0, sticky="nsew", padx=5, pady=5)
        
        # Flag to prevent double initialization and race conditions
        self._mvu_initialized = True
        self._first_render_complete = False
        
        print("üé¨ MVUHandsReviewTab: MVU components initialized")
    
    def _load_hands_data(self) -> None:
        """Load hands data for review"""
        try:
            # Try to load from GTO hands file (as in original implementation)
            import os
            gto_file = os.path.join(
                os.path.dirname(__file__), "..", "..", "..", "gto_hands.json"
            )
            
            if os.path.exists(gto_file):
                with open(gto_file, 'r') as f:
                    raw_data = json.load(f)
                    
                self.hands_data = self._parse_hands_data(raw_data)
                print(f"üìä MVUHandsReviewTab: Loaded {len(self.hands_data)} hands")
                
            else:
                # Fallback to sample data
                self.hands_data = self._create_sample_hands()
                print("üìä MVUHandsReviewTab: Using sample hands data")
            
            self._update_hand_selector()
            
            # CRITICAL FIX: Only load hand if MVU is initialized and we have data
            if self.hands_data and hasattr(self, '_mvu_initialized') and self._mvu_initialized:
                # Subscribe AFTER we have hand data ready
                if not hasattr(self, 'unsubscribe'):
                    self.unsubscribe = self.store.subscribe(self._on_model_changed)
                
                # Load first hand immediately (no defer)
                self._load_hand(0)
        
        except Exception as e:
            print(f"‚ö†Ô∏è MVUHandsReviewTab: Error loading hands: {e}")
            self.hands_data = self._create_sample_hands()
            self._update_hand_selector()
    
    def _parse_hands_data(self, raw_data: Any) -> List[Dict[str, Any]]:
        """Parse raw hands data into MVU format"""
        hands = []
        
        try:
            # Handle different data formats
            if isinstance(raw_data, dict):
                if "hands" in raw_data:
                    hands_list = raw_data["hands"]
                else:
                    hands_list = [raw_data]  # Single hand
            elif isinstance(raw_data, list):
                hands_list = raw_data
            else:
                return []
            
            for i, hand_data in enumerate(hands_list):
                parsed_hand = self._parse_single_hand(hand_data, i)
                if parsed_hand:
                    hands.append(parsed_hand)
        
        except Exception as e:
            print(f"‚ö†Ô∏è MVUHandsReviewTab: Error parsing hands data: {e}")
        
        return hands
    
    def _parse_single_hand(self, hand_data: Dict[str, Any], index: int) -> Optional[Dict[str, Any]]:
        """Parse a single hand into MVU format"""
        try:
            hand_id = hand_data.get("hand_id", f"Hand_{index + 1}")
            
            # Parse players/seats
            seats = {}
            stacks = {}
            
            players = hand_data.get("players", [])
            for i, player in enumerate(players[:6]):  # Max 6 players
                seat_state = {
                    "player_uid": player.get("name", f"Player_{i}"),
                    "name": player.get("name", f"Player {i}"),
                    "stack": player.get("stack", 1000),
                    "chips_in_front": 0,
                    "folded": False,
                    "all_in": False,
                    "cards": player.get("hole_cards", []),
                    "position": i
                }
                seats[i] = seat_state
                stacks[i] = seat_state["stack"]
            
            # Parse actions
            actions = []
            raw_actions = hand_data.get("actions", [])
            
            for action_data in raw_actions:
                if isinstance(action_data, dict):
                    actions.append({
                        "seat": action_data.get("player_index", 0),
                        "action": action_data.get("action", "CHECK"),
                        "amount": action_data.get("amount"),
                        "street": action_data.get("street", "PREFLOP")
                    })
            
            return {
                "hand_id": hand_id,
                "seats": seats,
                "stacks": stacks,
                "board": hand_data.get("board", []),
                "pot": hand_data.get("pot", 0),
                "actions": actions,
                "review_len": len(actions),
                "to_act_seat": 0,  # Start with first seat
                "legal_actions": ["CHECK", "CALL", "BET", "RAISE", "FOLD"]
            }
        
        except Exception as e:
            print(f"‚ö†Ô∏è MVUHandsReviewTab: Error parsing hand {index}: {e}")
            return None
    
    def _create_sample_hands(self) -> List[Dict[str, Any]]:
        """Create sample hands for testing"""
        return [
            {
                "hand_id": "SAMPLE_001",
                "seats": {
                    0: {
                        "player_uid": "hero",
                        "name": "Hero",
                        "stack": 1000,
                        "chips_in_front": 0,
                        "folded": False,
                        "all_in": False,
                        "cards": ["As", "Kh"],
                        "position": 0
                    },
                    1: {
                        "player_uid": "villain",
                        "name": "Villain",
                        "stack": 1000,
                        "chips_in_front": 0,
                        "folded": False,
                        "all_in": False,
                        "cards": ["Qd", "Jc"],
                        "position": 1
                    }
                },
                "stacks": {0: 1000, 1: 1000},
                "board": ["7h", "8s", "9d"],
                "pot": 60,
                "actions": [
                    {"seat": 0, "action": "RAISE", "amount": 30, "street": "PREFLOP"},
                    {"seat": 1, "action": "CALL", "amount": 30, "street": "PREFLOP"},
                    {"seat": 0, "action": "BET", "amount": 50, "street": "FLOP"},
                    {"seat": 1, "action": "FOLD", "amount": None, "street": "FLOP"}
                ],
                "review_len": 4,
                "to_act_seat": 0,
                "legal_actions": ["CHECK", "CALL", "BET", "RAISE", "FOLD"]
            },
            {
                "hand_id": "SAMPLE_002",
                "seats": {
                    0: {
                        "player_uid": "hero",
                        "name": "Hero",
                        "stack": 800,
                        "chips_in_front": 0,
                        "folded": False,
                        "all_in": False,
                        "cards": ["Kd", "Kc"],
                        "position": 0
                    },
                    1: {
                        "player_uid": "villain",
                        "name": "Villain",
                        "stack": 1200,
                        "chips_in_front": 0,
                        "folded": False,
                        "all_in": False,
                        "cards": ["Ad", "Qh"],
                        "position": 1
                    }
                },
                "stacks": {0: 800, 1: 1200},
                "board": ["2h", "7c", "Ks", "4d", "8h"],
                "pot": 400,
                "actions": [
                    {"seat": 1, "action": "RAISE", "amount": 40, "street": "PREFLOP"},
                    {"seat": 0, "action": "CALL", "amount": 40, "street": "PREFLOP"},
                    {"seat": 0, "action": "CHECK", "amount": None, "street": "FLOP"},
                    {"seat": 1, "action": "BET", "amount": 60, "street": "FLOP"},
                    {"seat": 0, "action": "RAISE", "amount": 180, "street": "FLOP"},
                    {"seat": 1, "action": "CALL", "amount": 120, "street": "FLOP"}
                ],
                "review_len": 6,
                "to_act_seat": 1,
                "legal_actions": ["CHECK", "BET"]
            }
        ]
    
    def _update_hand_selector(self) -> None:
        """Update the hand selector combobox"""
        hand_names = [hand["hand_id"] for hand in self.hands_data]
        self.hand_selector["values"] = hand_names
        
        if hand_names:
            self.hand_selector.current(0)
    
    def _on_hand_selected(self, event=None) -> None:
        """Handle hand selection"""
        try:
            index = self.hand_selector.current()
            if 0 <= index < len(self.hands_data):
                self._load_hand(index)
        except Exception as e:
            print(f"‚ö†Ô∏è MVUHandsReviewTab: Error selecting hand: {e}")
    
    def _load_hand(self, index: int) -> None:
        """Load a specific hand into the MVU store"""
        if not (0 <= index < len(self.hands_data)):
            return
        
        self.current_hand_index = index
        hand_data = self.hands_data[index]
        
        # Update hand info
        hand_id = hand_data["hand_id"]
        num_actions = hand_data.get("review_len", 0)
        self.hand_info_label.config(
            text=f"{hand_id} ({num_actions} actions)"
        )
        
        # Create and set session driver
        driver = create_driver("REVIEW", hand_data=hand_data)
        self.store.set_session_driver(driver)
        
        # Dispatch LoadHand message to store
        load_msg = LoadHand(hand_data=hand_data)
        self.store.dispatch(load_msg)
        
        print(f"üìã MVUHandsReviewTab: Loaded hand {hand_id}")
    
    def _on_model_changed(self, model: Model) -> None:
        """Handle model changes - FIXED VERSION"""
        try:
            # Skip first empty model notification
            if not self._first_render_complete and len(model.seats) == 0:
                print(f"üîÑ MVUHandsReviewTab: Skipping initial empty model render")
                self._first_render_complete = True
                return
            
            print(f"üîÑ MVUHandsReviewTab: Model changed - {len(model.seats)} seats, pot={model.pot}")
            
            # Convert model to props
            props = TableRendererProps.from_model(model)
            
            # Use props caching to prevent re-renders
            if hasattr(self, '_last_props') and props == self._last_props:
                print(f"üîÑ MVUHandsReviewTab: Props unchanged, skipping render")
                return
            
            print(f"üîÑ MVUHandsReviewTab: Props changed, updating renderer")
            self._last_props = props
            
            # Render table
            if self.table_renderer:
                self.table_renderer.render(props)
        
        except Exception as e:
            print(f"‚ö†Ô∏è MVUHandsReviewTab: Error updating view: {e}")
            import traceback
            traceback.print_exc()
    
    def dispose(self) -> None:
        """Clean up resources"""
        if hasattr(self, 'unsubscribe') and self.unsubscribe:
            self.unsubscribe()
        
        if self.store:
            self.store.cleanup()
        
        print("üßπ MVUHandsReviewTab: Disposed")
```

---

### store.py

**Path**: `backend/ui/mvu/store.py`

**Size**: 14.4 KB

```python
"""
MVU Store - Manages Model state and executes Commands
Based on PokerPro UI Implementation Handbook v2
"""

from typing import List, Callable, Optional, Any, Dict
import time
import threading

from .types import (
    Model, Msg, Cmd, SessionDriver, IntentHandler,
    PlaySound, Speak, Animate, AskDriverForDecision, ApplyPPSM,
    ScheduleTimer, PublishEvent, GetReviewEvent,
    DecisionReady, AppliedAction, StreetAdvanced, HandFinished, AnimationFinished
)
from .update import update


class MVUStore:
    """
    MVU Store - Single source of truth for Model state
    Handles message dispatch and command execution
    """
    
    def __init__(
        self,
        initial_model: Model,
        effect_bus: Any = None,
        game_director: Any = None,
        event_bus: Any = None,
        ppsm: Any = None
    ):
        self.model = initial_model
        self.effect_bus = effect_bus
        self.game_director = game_director
        self.event_bus = event_bus
        self.ppsm = ppsm
        
        # Subscribers to model changes
        self.subscribers: List[Callable[[Model], None]] = []
        
        # Session driver (pluggable)
        self.session_driver: Optional[SessionDriver] = None
        
        # Lock for thread safety
        self._lock = threading.RLock()
        
        # Scheduled timers
        self._timers: Dict[str, Any] = {}
        
        print("üè™ MVUStore: Initialized with model:", self.model.session_mode)
    
    def set_session_driver(self, driver: SessionDriver) -> None:
        """Set the session driver for this store"""
        with self._lock:
            self.session_driver = driver
            print(f"üè™ MVUStore: Session driver set: {type(driver).__name__}")
    
    def subscribe(self, callback: Callable[[Model], None]) -> Callable[[], None]:
        """
        Subscribe to model changes
        Returns unsubscribe function
        """
        with self._lock:
            self.subscribers.append(callback)
            
            # Immediately notify with current model
            callback(self.model)
            
            def unsubscribe():
                with self._lock:
                    if callback in self.subscribers:
                        self.subscribers.remove(callback)
            
            return unsubscribe
    
    def dispatch(self, msg: Msg) -> None:
        """
        Dispatch a message to update the model - FIXED VERSION
        """
        with self._lock:
            print(f"üé¨ MVUStore: Dispatching {type(msg).__name__}")
            
            # Debug logging for LoadHand
            if hasattr(msg, 'hand_data'):
                seats_count = len(msg.hand_data.get('seats', {})) if msg.hand_data else 0
                print(f"üé¨ MVUStore: LoadHand with {seats_count} seats")
            
            # Store old model for comparison
            old_model = self.model
            
            # Update model using pure reducer
            new_model, commands = update(self.model, msg)
            
            # CRITICAL FIX: Prevent empty model from overwriting populated model
            # This prevents the alternating state issue
            if (len(old_model.seats) > 0 and len(new_model.seats) == 0 and 
                type(msg).__name__ not in ['ResetHand', 'ClearTable']):
                print(f"‚ö†Ô∏è MVUStore: Blocking reset from {len(old_model.seats)} to 0 seats")
                print(f"‚ö†Ô∏è MVUStore: Message type was: {type(msg).__name__}")
                # Keep the old model, but still execute commands
                for cmd in commands:
                    self._execute_command(cmd)
                return
            
            # Debug model changes
            if len(new_model.seats) != len(old_model.seats):
                print(f"üé¨ MVUStore: Seats changed from {len(old_model.seats)} to {len(new_model.seats)}")
            
            if new_model.pot != old_model.pot:
                print(f"üé¨ MVUStore: Pot changed from {old_model.pot} to {new_model.pot}")
            
            if new_model.board != old_model.board:
                print(f"üé¨ MVUStore: Board changed from {old_model.board} to {new_model.board}")
            
            # Check if model actually changed using proper equality
            if new_model == old_model:
                print(f"üé¨ MVUStore: Model unchanged, skipping subscriber notification")
                # Still execute commands even if model didn't change
                for cmd in commands:
                    self._execute_command(cmd)
                return
            
            # Update stored model
            self.model = new_model
            print(f"üé¨ MVUStore: Model updated, notifying {len(self.subscribers)} subscribers")
            
            # Execute commands first
            for cmd in commands:
                self._execute_command(cmd)
            
            # Then notify subscribers (use slice to avoid mutation during iteration)
            for subscriber in self.subscribers[:]:
                try:
                    subscriber(new_model)
                except Exception as e:
                    print(f"‚ö†Ô∏è MVUStore: Subscriber error: {e}")
                    import traceback
                    traceback.print_exc()
    
    def get_model(self) -> Model:
        """Get current model (thread-safe)"""
        with self._lock:
            return self.model
    
    def _execute_command(self, cmd: Cmd) -> None:
        """
        Execute a command using available services
        All I/O happens here, never in reducers
        """
        try:
            if isinstance(cmd, PlaySound):
                self._execute_play_sound(cmd)
            
            elif isinstance(cmd, Speak):
                self._execute_speak(cmd)
            
            elif isinstance(cmd, Animate):
                self._execute_animate(cmd)
            
            elif isinstance(cmd, AskDriverForDecision):
                self._execute_ask_driver(cmd)
            
            elif isinstance(cmd, ApplyPPSM):
                self._execute_apply_ppsm(cmd)
            
            elif isinstance(cmd, ScheduleTimer):
                self._execute_schedule_timer(cmd)
            
            elif isinstance(cmd, PublishEvent):
                self._execute_publish_event(cmd)
            

            
            elif isinstance(cmd, GetReviewEvent):
                self._execute_get_review_event(cmd)
            
            else:
                print(f"‚ö†Ô∏è MVUStore: Unknown command: {type(cmd).__name__}")
        
        except Exception as e:
            print(f"‚ö†Ô∏è MVUStore: Command execution error: {e}")
    
    def _execute_play_sound(self, cmd: PlaySound) -> None:
        """Execute PlaySound command"""
        if self.effect_bus:
            try:
                self.effect_bus.play_sound(cmd.name)
                print(f"üîä MVUStore: Played sound: {cmd.name}")
            except Exception as e:
                print(f"‚ö†Ô∏è MVUStore: Sound error: {e}")
    
    def _execute_speak(self, cmd: Speak) -> None:
        """Execute Speak command"""
        if self.effect_bus and hasattr(self.effect_bus, 'voice_manager'):
            try:
                self.effect_bus.voice_manager.speak(cmd.text)
                print(f"üó£Ô∏è MVUStore: Spoke: {cmd.text}")
            except Exception as e:
                print(f"‚ö†Ô∏è MVUStore: Speech error: {e}")
    
    def _execute_animate(self, cmd: Animate) -> None:
        """Execute Animate command"""
        if self.effect_bus:
            try:
                # Start animation and set up completion callback
                def on_animation_complete():
                    self.dispatch(AnimationFinished(token=cmd.token))
                
                self.effect_bus.animate(
                    cmd.name,
                    cmd.payload,
                    callback=on_animation_complete
                )
                print(f"üé¨ MVUStore: Started animation: {cmd.name} (token: {cmd.token})")
                
            except Exception as e:
                print(f"‚ö†Ô∏è MVUStore: Animation error: {e}")
                # Immediately complete animation on error
                self.dispatch(AnimationFinished(token=cmd.token))
    
    def _execute_ask_driver(self, cmd: AskDriverForDecision) -> None:
        """Execute AskDriverForDecision command"""
        if self.session_driver:
            try:
                def on_decision_ready(decision: DecisionReady):
                    self.dispatch(decision)
                
                self.session_driver.decide(self.model, cmd.seat, on_decision_ready)
                print(f"ü§ñ MVUStore: Asked driver for decision: seat {cmd.seat}")
                
            except Exception as e:
                print(f"‚ö†Ô∏è MVUStore: Driver decision error: {e}")
    
    def _execute_apply_ppsm(self, cmd: ApplyPPSM) -> None:
        """Execute ApplyPPSM command"""
        if self.ppsm:
            try:
                # Apply action to PPSM
                if cmd.seat == -1 and cmd.action == "CONTINUE":
                    # Continue game flow
                    result = self.ppsm.continue_game()
                else:
                    # Apply player action
                    result = self.ppsm.apply_action(cmd.seat, cmd.action, cmd.amount)
                
                # Process PPSM result and dispatch appropriate messages
                self._process_ppsm_result(result, cmd)
                
                print(f"üÉè MVUStore: Applied PPSM action: {cmd.action} by seat {cmd.seat}")
                
            except Exception as e:
                print(f"‚ö†Ô∏è MVUStore: PPSM error: {e}")
    
    def _execute_schedule_timer(self, cmd: ScheduleTimer) -> None:
        """Execute ScheduleTimer command"""
        try:
            timer_id = f"timer_{time.time()}_{id(cmd.msg)}"
            
            def timer_callback():
                self.dispatch(cmd.msg)
                if timer_id in self._timers:
                    del self._timers[timer_id]
            
            if self.game_director and hasattr(self.game_director, 'schedule'):
                # Use GameDirector for scheduling (architecture compliant)
                self.game_director.schedule(cmd.delay_ms, {
                    "type": "MVU_TIMER",
                    "callback": timer_callback
                })
            else:
                # Fallback to threading.Timer
                timer = threading.Timer(cmd.delay_ms / 1000.0, timer_callback)
                self._timers[timer_id] = timer
                timer.start()
            
            print(f"‚è∞ MVUStore: Scheduled timer: {cmd.delay_ms}ms -> {type(cmd.msg).__name__}")
            
        except Exception as e:
            print(f"‚ö†Ô∏è MVUStore: Timer error: {e}")
    
    def _execute_publish_event(self, cmd: PublishEvent) -> None:
        """Execute PublishEvent command"""
        if self.event_bus:
            try:
                self.event_bus.publish(cmd.topic, cmd.payload)
                print(f"üì° MVUStore: Published event: {cmd.topic}")
            except Exception as e:
                print(f"‚ö†Ô∏è MVUStore: Event publish error: {e}")
    

    
    def _execute_get_review_event(self, cmd: GetReviewEvent) -> None:
        """Execute GetReviewEvent command - get event from session driver"""
        if self.session_driver:
            try:
                event = self.session_driver.review_event_at(cmd.index)
                if event:
                    print(f"üìñ MVUStore: Got review event at {cmd.index}: {type(event).__name__}")
                    # Dispatch the review event
                    self.dispatch(event)
                else:
                    print(f"üìñ MVUStore: No review event at index {cmd.index}")
            except Exception as e:
                print(f"‚ö†Ô∏è MVUStore: Error getting review event: {e}")
        else:
            print("‚ö†Ô∏è MVUStore: No session driver for review event")
    
    def _process_ppsm_result(self, result: Any, original_cmd: ApplyPPSM) -> None:
        """
        Process PPSM result and dispatch appropriate messages
        This would be customized based on your PPSM interface
        """
        try:
            # Dispatch AppliedAction to trigger state update
            self.dispatch(AppliedAction(
                seat=original_cmd.seat,
                action=original_cmd.action,
                amount=original_cmd.amount
            ))
            
            # Check for street advancement
            if hasattr(result, 'street_changed') and result.street_changed:
                self.dispatch(StreetAdvanced(street=result.new_street))
            
            # Check for hand completion
            if hasattr(result, 'hand_finished') and result.hand_finished:
                self.dispatch(HandFinished(
                    winners=getattr(result, 'winners', []),
                    payouts=getattr(result, 'payouts', {})
                ))
        
        except Exception as e:
            print(f"‚ö†Ô∏è MVUStore: PPSM result processing error: {e}")
    
    def cleanup(self) -> None:
        """Cleanup resources"""
        with self._lock:
            # Cancel all timers
            for timer in self._timers.values():
                if hasattr(timer, 'cancel'):
                    timer.cancel()
            self._timers.clear()
            
            # Clear subscribers
            self.subscribers.clear()
            
            print("üè™ MVUStore: Cleaned up")


class MVUIntentHandler(IntentHandler):
    """
    Intent handler that dispatches messages to MVU store
    Converts UI events to messages
    """
    
    def __init__(self, store: MVUStore):
        self.store = store
    
    def on_click_next(self) -> None:
        """Next button clicked"""
        from .types import NextPressed
        self.store.dispatch(NextPressed())
    
    def on_toggle_autoplay(self, on: bool) -> None:
        """Auto-play toggled"""
        from .types import AutoPlayToggled
        self.store.dispatch(AutoPlayToggled(on=on))
    
    def on_action_btn(self, action: str, amount: Optional[int] = None) -> None:
        """Action button clicked"""
        from .types import UserChose
        self.store.dispatch(UserChose(action=action, amount=amount))
    
    def on_seek(self, index: int) -> None:
        """Review seek"""
        from .types import ReviewSeek
        self.store.dispatch(ReviewSeek(index=index))
    
    def on_request_hint(self) -> None:
        """GTO hint requested"""
        # This would dispatch a GTO hint request message
        print("üéØ MVUIntentHandler: GTO hint requested")
        pass
```

---

### store_integrated.py

**Path**: `backend/ui/mvu/store_integrated.py`

**Size**: 13.6 KB

```python
"""
MVU Store - PPSM Integrated
Complete integration with PurePokerStateMachine
"""

from typing import List, Callable, Optional, Any, Dict
import time
import threading

from .types_integrated import (
    Model, Msg, Cmd, SessionDriver, IntentHandler,
    PlaySound, Speak, Animate, AskDriverForDecision, ApplyPPSM,
    ScheduleTimer, PublishEvent, GetReviewEvent,
    DecisionReady, AppliedAction, StreetAdvanced, HandFinished, AnimationFinished,
    NextPressed, AutoPlayToggled, UserChose, ReviewSeek
)
from .update_integrated import update

# Import the real PPSM and related types
import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..', '..'))

from backend.core.pure_poker_state_machine import PurePokerStateMachine
from backend.core.poker_types import Player, ActionType
from backend.core.hand_model import ActionType as HandActionType


class MVUStore:
    """
    MVU Store - Single source of truth for Model state
    Handles message dispatch and command execution
    INTEGRATED with real PurePokerStateMachine
    """
    
    def __init__(
        self,
        initial_model: Model,
        effect_bus: Any = None,
        game_director: Any = None,
        event_bus: Any = None,
        ppsm: Optional[PurePokerStateMachine] = None
    ):
        self.model = initial_model
        self.effect_bus = effect_bus
        self.game_director = game_director
        self.event_bus = event_bus
        self.ppsm = ppsm
        
        # Subscribers to model changes
        self.subscribers: List[Callable[[Model], None]] = []
        
        # Session driver (pluggable)
        self.session_driver: Optional[SessionDriver] = None
        
        # Lock for thread safety
        self._lock = threading.RLock()
        
        # Scheduled timers
        self._timers: Dict[str, Any] = {}
    
    def set_session_driver(self, driver: SessionDriver) -> None:
        """Set the session driver for handling bot decisions and review events"""
        with self._lock:
            self.session_driver = driver
    
    def subscribe(self, callback: Callable[[Model], None]) -> Callable[[], None]:
        """Subscribe to model changes"""
        with self._lock:
            self.subscribers.append(callback)
            # Immediately call with current model
            callback(self.model)
            
            def unsubscribe():
                with self._lock:
                    if callback in self.subscribers:
                        self.subscribers.remove(callback)
            return unsubscribe
    
    def dispatch(self, msg: Msg) -> None:
        """Dispatch a message to update the model"""
        with self._lock:
            print(f"üé¨ MVUStore: Dispatching {type(msg).__name__}")
            
            # Debug logging for specific message types
            if hasattr(msg, 'hand_data'):
                seats_count = len(msg.hand_data.get('seats', {})) if msg.hand_data else 0
                print(f"üé¨ MVUStore: LoadHand with {seats_count} seats")
            
            old_model = self.model
            new_model, commands = update(self.model, msg)
            
            # CRITICAL FIX: Prevent empty model from overwriting populated model
            if (len(old_model.seats) > 0 and len(new_model.seats) == 0 and 
                type(msg).__name__ not in ['ResetHand', 'ClearTable']):
                print(f"‚ö†Ô∏è MVUStore: Blocking reset from {len(old_model.seats)} to 0 seats")
                print(f"‚ö†Ô∏è MVUStore: Message type was: {type(msg).__name__}")
                # Execute commands but don't update model
                for cmd in commands:
                    self._execute_command(cmd)
                return
            
            # Debug logging for state changes
            if len(new_model.seats) != len(old_model.seats):
                print(f"üé¨ MVUStore: Seats changed from {len(old_model.seats)} to {len(new_model.seats)}")
            
            if new_model.pot != old_model.pot:
                print(f"üé¨ MVUStore: Pot changed from {old_model.pot} to {new_model.pot}")
            
            if new_model.board != old_model.board:
                print(f"üé¨ MVUStore: Board changed from {old_model.board} to {new_model.board}")
            
            # Only update if model actually changed
            if new_model == old_model:
                print(f"üé¨ MVUStore: Model unchanged, skipping subscriber notification")
                # Still execute commands
                for cmd in commands:
                    self._execute_command(cmd)
                return
            
            self.model = new_model
            print(f"üé¨ MVUStore: Model updated, notifying {len(self.subscribers)} subscribers")
            
            # Execute commands first
            for cmd in commands:
                self._execute_command(cmd)
            
            # Notify all subscribers of the change
            for subscriber in self.subscribers[:]:  # Copy list to prevent iteration issues
                try:
                    subscriber(new_model)
                except Exception as e:
                    print(f"‚ö†Ô∏è MVUStore: Subscriber error: {e}")
                    import traceback
                    traceback.print_exc()

    def _execute_command(self, cmd: Cmd) -> None:
        """Execute a command (side effect)"""
        if isinstance(cmd, ApplyPPSM):
            self._execute_apply_ppsm(cmd)
        elif isinstance(cmd, ScheduleTimer):
            self._execute_schedule_timer(cmd)
        elif isinstance(cmd, GetReviewEvent):
            self._execute_get_review_event(cmd)
        elif isinstance(cmd, PlaySound):
            self._execute_play_sound(cmd)
        elif isinstance(cmd, Speak):
            self._execute_speak(cmd)
        elif isinstance(cmd, Animate):
            self._execute_animate(cmd)
        elif isinstance(cmd, AskDriverForDecision):
            self._execute_ask_driver_for_decision(cmd)
        elif isinstance(cmd, PublishEvent):
            self._execute_publish_event(cmd)
        else:
            print(f"‚ö†Ô∏è MVUStore: Unknown command type: {type(cmd)}")

    def _execute_apply_ppsm(self, cmd: ApplyPPSM) -> None:
        """Execute ApplyPPSM command by calling the real PPSM"""
        if not self.ppsm:
            print(f"‚ö†Ô∏è MVUStore: No PPSM available for action: {cmd.action}")
            return
            
        try:
            print(f"üÉè MVUStore: Applying REAL PPSM action: {cmd.action} by seat {cmd.seat} amount {cmd.amount}")
            
            if cmd.action == "CONTINUE":
                # This would be for advancing the street when no player action is needed
                # In practice, this might not be needed if PPSM auto-advances
                ppsm_result_state = self.ppsm.get_game_info()
                print(f"üÉè MVUStore: CONTINUE action - current state retrieved")
            else:
                # Apply a specific player action to the PPSM
                # First, we need to find the player object for this seat
                game_info = self.ppsm.get_game_info()
                players = game_info.get("players", [])
                
                if cmd.seat < 0 or cmd.seat >= len(players):
                    print(f"‚ö†Ô∏è MVUStore: Invalid seat {cmd.seat} for {len(players)} players")
                    return
                
                # Get the player object
                player_data = players[cmd.seat]
                player_name = player_data.get("name", f"Player {cmd.seat}")
                
                # Create a Player object - we need to find the actual player in the PPSM
                target_player = None
                for player in self.ppsm.game_state.players:
                    if player.name == player_name:
                        target_player = player
                        break
                
                if not target_player:
                    print(f"‚ö†Ô∏è MVUStore: Could not find player {player_name} in PPSM")
                    return
                
                # Convert our action string to PPSM ActionType
                action_type = self._convert_action_to_ppsm(cmd.action)
                if not action_type:
                    print(f"‚ö†Ô∏è MVUStore: Unknown action type: {cmd.action}")
                    return
                
                # Execute the action
                success = self.ppsm.execute_action(target_player, action_type, cmd.amount)
                if not success:
                    print(f"‚ö†Ô∏è MVUStore: PPSM rejected action: {cmd.action} by {player_name}")
                    return
                
                # Get the updated state
                ppsm_result_state = self.ppsm.get_game_info()
                print(f"üÉè MVUStore: PPSM action successful, new state retrieved")
            
            # Process the result from the PPSM
            self._process_ppsm_result(ppsm_result_state, cmd)
            
        except Exception as e:
            print(f"‚ö†Ô∏è MVUStore: REAL PPSM error: {e}")
            import traceback
            traceback.print_exc()

    def _convert_action_to_ppsm(self, action: str) -> Optional[ActionType]:
        """Convert our action string to PPSM ActionType"""
        action_mapping = {
            "FOLD": ActionType.FOLD,
            "CHECK": ActionType.CHECK,
            "CALL": ActionType.CALL,
            "BET": ActionType.BET,
            "RAISE": ActionType.RAISE,
            "ALL_IN": ActionType.ALL_IN
        }
        return action_mapping.get(action.upper())

    def _process_ppsm_result(self, ppsm_state: dict, original_cmd: ApplyPPSM) -> None:
        """Process the result from PPSM and dispatch appropriate messages"""
        # Dispatch AppliedAction with the PPSM state
        self.dispatch(AppliedAction(
            seat=original_cmd.seat,
            action=original_cmd.action,
            amount=original_cmd.amount,
            ppsm_state=ppsm_state
        ))
        
        # TODO: Check ppsm_state for street changes or hand end
        # and dispatch StreetAdvanced or HandFinished messages
        # This would require examining the PPSM state to detect transitions

    def _execute_schedule_timer(self, cmd: ScheduleTimer) -> None:
        """Execute ScheduleTimer command"""
        def timer_callback():
            self.dispatch(cmd.msg)
        
        timer = threading.Timer(cmd.delay_ms / 1000.0, timer_callback)
        timer.start()
        self._timers[f"timer_{time.time()}"] = timer

    def _execute_get_review_event(self, cmd: GetReviewEvent) -> None:
        """Execute GetReviewEvent command"""
        if self.session_driver:
            event = self.session_driver.review_event_at(cmd.index)
            if event:
                self.dispatch(event)

    def _execute_play_sound(self, cmd: PlaySound) -> None:
        """Execute PlaySound command"""
        if self.effect_bus and hasattr(self.effect_bus, 'play_sound'):
            try:
                self.effect_bus.play_sound(cmd.name)
                print(f"üîä MVUStore: Played sound: {cmd.name}")
            except Exception as e:
                print(f"‚ö†Ô∏è MVUStore: Sound error: {e}")

    def _execute_speak(self, cmd: Speak) -> None:
        """Execute Speak command"""
        if self.effect_bus and hasattr(self.effect_bus, 'speak'):
            try:
                self.effect_bus.speak(cmd.text)
                print(f"üó£Ô∏è MVUStore: Spoke: {cmd.text}")
            except Exception as e:
                print(f"‚ö†Ô∏è MVUStore: Speech error: {e}")

    def _execute_animate(self, cmd: Animate) -> None:
        """Execute Animate command"""
        if self.effect_bus and hasattr(self.effect_bus, 'animate'):
            try:
                self.effect_bus.animate(cmd.name, cmd.payload, cmd.token)
                print(f"üé¨ MVUStore: Animated: {cmd.name}")
            except Exception as e:
                print(f"‚ö†Ô∏è MVUStore: Animation error: {e}")

    def _execute_ask_driver_for_decision(self, cmd: AskDriverForDecision) -> None:
        """Execute AskDriverForDecision command"""
        if self.session_driver:
            def decision_callback(decision: DecisionReady):
                self.dispatch(decision)
            
            try:
                self.session_driver.decide(self.model, cmd.seat, decision_callback)
                print(f"ü§ñ MVUStore: Asked driver for decision for seat {cmd.seat}")
            except Exception as e:
                print(f"‚ö†Ô∏è MVUStore: Driver decision error: {e}")

    def _execute_publish_event(self, cmd: PublishEvent) -> None:
        """Execute PublishEvent command"""
        if self.event_bus and hasattr(self.event_bus, 'publish'):
            try:
                self.event_bus.publish(cmd.topic, cmd.payload)
                print(f"üì° MVUStore: Published event: {cmd.topic}")
            except Exception as e:
                print(f"‚ö†Ô∏è MVUStore: Event publish error: {e}")


class MVUIntentHandler(IntentHandler):
    """Intent handler that converts UI events to MVU messages"""
    
    def __init__(self, store: MVUStore):
        self.store = store
    
    def on_click_next(self) -> None:
        """Next button clicked"""
        self.store.dispatch(NextPressed())
    
    def on_toggle_autoplay(self, on: bool) -> None:
        """Auto-play toggled"""
        self.store.dispatch(AutoPlayToggled(on=on))
    
    def on_action_btn(self, action: str, amount: Optional[int] = None) -> None:
        """Action button clicked"""
        self.store.dispatch(UserChose(action=action, amount=amount))
    
    def on_seek(self, index: int) -> None:
        """Review seek"""
        self.store.dispatch(ReviewSeek(index=index))
    
    def on_request_hint(self) -> None:
        """GTO hint requested"""
        # TODO: Implement GTO hint request
        pass
```

---

### types.py

**Path**: `backend/ui/mvu/types.py`

**Size**: 12.6 KB

```python
"""
MVU (Model-View-Update) Architecture Types
Based on PokerPro UI Implementation Handbook v2
"""

from dataclasses import dataclass
from typing import Literal, Optional, Dict, List, Set, Any, Protocol, Callable, FrozenSet, Mapping
from abc import ABC, abstractmethod
from functools import cached_property


# ============================================================================
# CORE MODEL - FIXED WITH PROPER IMMUTABILITY
# ============================================================================

# Helper types for immutable collections
ImmutableSeats = Mapping[int, "SeatState"]
ImmutableStacks = Mapping[int, int]

@dataclass(frozen=True, slots=True)
class SeatState:
    """State for a single seat at the poker table - FULLY IMMUTABLE"""
    player_uid: str
    name: str
    stack: int
    chips_in_front: int  # Current bet amount
    folded: bool
    all_in: bool
    cards: tuple[str, ...]  # Hole cards (visibility rules applied) - immutable tuple
    position: int
    acting: bool = False
    
    def __eq__(self, other):
        """Explicit equality for reliability"""
        if not isinstance(other, SeatState):
            return False
        return (
            self.player_uid == other.player_uid and
            self.name == other.name and
            self.stack == other.stack and
            self.chips_in_front == other.chips_in_front and
            self.folded == other.folded and
            self.all_in == other.all_in and
            self.cards == other.cards and
            self.position == other.position and
            self.acting == other.acting
        )
    
    def __hash__(self):
        """Consistent hash for frozen dataclass"""
        return hash((
            self.player_uid,
            self.name, 
            self.stack,
            self.chips_in_front,
            self.folded,
            self.all_in,
            self.cards,  # Already a tuple
            self.position,
            self.acting
        ))


@dataclass(frozen=True)
class Action:
    """Represents a poker action"""
    seat: int
    action: str  # "CHECK", "CALL", "BET", "RAISE", "FOLD"
    amount: Optional[int] = None
    street: str = "PREFLOP"


@dataclass(frozen=True)
class GtoHint:
    """GTO strategy hint"""
    action: str
    frequency: float
    reasoning: str


@dataclass(frozen=True)
class Banner:
    """UI banner/message"""
    text: str
    type: Literal["info", "warning", "error", "success"]
    duration_ms: int = 3000


@dataclass(frozen=True, slots=True)
class Model:
    """
    Canonical Model - FIXED with proper immutability
    Single source of truth that describes the complete state
    """
    # Game State - using immutable types
    hand_id: str
    street: Literal["PREFLOP", "FLOP", "TURN", "RIVER", "SHOWDOWN", "DONE"]
    to_act_seat: Optional[int]
    stacks: ImmutableStacks  # Changed from Dict to Mapping
    pot: int
    board: tuple[str, ...]  # ("As", "Kd", "7h", ...) - immutable tuple
    seats: ImmutableSeats  # Changed from Dict to Mapping
    legal_actions: FrozenSet[str]  # Changed from Set to frozenset
    last_action: Optional[Action]
    
    # Session Configuration
    session_mode: Literal["PRACTICE", "GTO", "REVIEW"]
    autoplay_on: bool
    step_delay_ms: int
    waiting_for: Literal["HUMAN_DECISION", "BOT_DECISION", "ANIMATION", "NONE"]
    
    # Review-specific
    review_cursor: int
    review_len: int
    review_paused: bool
    
    # UI State
    gto_hint: Optional[GtoHint]
    banners: tuple[Banner, ...]
    theme_id: str
    tx_id: int  # Animation token
    
    @classmethod
    def initial(cls, session_mode: Literal["PRACTICE", "GTO", "REVIEW"] = "REVIEW") -> "Model":
        """Create initial model state with immutable collections"""
        return cls(
            hand_id="",
            street="PREFLOP",
            to_act_seat=None,
            stacks={},  # Will be converted to immutable in update
            pot=0,
            board=(),
            seats={},  # Will be converted to immutable in update
            legal_actions=frozenset(),
            last_action=None,
            session_mode=session_mode,
            autoplay_on=False,
            step_delay_ms=1000,
            waiting_for="NONE",
            review_cursor=0,
            review_len=0,
            review_paused=False,
            gto_hint=None,
            banners=(),
            theme_id="forest-green-pro",
            tx_id=0
        )
    
    def __eq__(self, other):
        """Deep equality check for Model"""
        if not isinstance(other, Model):
            return False
        
        # Compare all fields explicitly
        return (
            self.hand_id == other.hand_id and
            self.street == other.street and
            self.to_act_seat == other.to_act_seat and
            dict(self.stacks) == dict(other.stacks) and
            self.pot == other.pot and
            self.board == other.board and
            dict(self.seats) == dict(other.seats) and
            self.legal_actions == other.legal_actions and
            self.last_action == other.last_action and
            self.session_mode == other.session_mode and
            self.autoplay_on == other.autoplay_on and
            self.step_delay_ms == other.step_delay_ms and
            self.waiting_for == other.waiting_for and
            self.review_cursor == other.review_cursor and
            self.review_len == other.review_len and
            self.review_paused == other.review_paused and
            self.gto_hint == other.gto_hint and
            self.banners == other.banners and
            self.theme_id == other.theme_id and
            self.tx_id == other.tx_id
        )


# ============================================================================
# MESSAGES (Facts)
# ============================================================================

class Msg(ABC):
    """Base message type"""
    pass


class NextPressed(Msg):
    """User pressed Next button"""
    pass


@dataclass
class AutoPlayToggled(Msg):
    """User toggled auto-play"""
    on: bool


@dataclass
class TimerTick(Msg):
    """Timer tick event"""
    now_ms: int


@dataclass
class UserChose(Msg):
    """Human user made a decision"""
    action: str
    amount: Optional[int] = None


@dataclass
class DecisionRequested(Msg):
    """System requests decision from a seat"""
    seat: int


@dataclass
class DecisionReady(Msg):
    """Decision is ready (from bot or async process)"""
    seat: int
    action: str
    amount: Optional[int]


@dataclass
class AppliedAction(Msg):
    """Action was applied to PPSM"""
    seat: int
    action: str
    amount: Optional[int]


@dataclass
class StreetAdvanced(Msg):
    """Street changed (PREFLOP -> FLOP, etc.)"""
    street: str


@dataclass
class HandFinished(Msg):
    """Hand completed"""
    winners: List[int]
    payouts: Dict[int, int]


@dataclass
class AnimationFinished(Msg):
    """Animation completed"""
    token: int


@dataclass
class ReviewSeek(Msg):
    """Seek to specific position in review"""
    index: int


class ReviewPlayStep(Msg):
    """Play next step in review"""
    pass


@dataclass
class LoadHand(Msg):
    """Load a new hand for review/practice"""
    hand_data: Dict[str, Any]


@dataclass
class ThemeChanged(Msg):
    """Theme was changed"""
    theme_id: str


# ============================================================================
# COMMANDS (Effects)
# ============================================================================

class Cmd(ABC):
    """Base command type"""
    pass


@dataclass
class PlaySound(Cmd):
    """Play a sound effect"""
    name: str


@dataclass
class Speak(Cmd):
    """Text-to-speech announcement"""
    text: str


@dataclass
class Animate(Cmd):
    """Trigger animation"""
    name: str
    payload: Dict[str, Any]
    token: int


@dataclass
class AskDriverForDecision(Cmd):
    """Ask session driver for decision"""
    seat: int


@dataclass
class ApplyPPSM(Cmd):
    """Apply action to Pure Poker State Machine"""
    seat: int
    action: str
    amount: Optional[int]


@dataclass
class ScheduleTimer(Cmd):
    """Schedule a delayed message"""
    delay_ms: int
    msg: Msg


@dataclass
class PublishEvent(Cmd):
    """Publish event to EventBus"""
    topic: str
    payload: Dict[str, Any]



@dataclass
class GetReviewEvent(Cmd):
    """Get and dispatch review event at index"""
    index: int


# ============================================================================
# SESSION DRIVER PROTOCOL
# ============================================================================

class SessionDriver(Protocol):
    """Protocol for session-specific behavior"""
    
    @abstractmethod
    def decide(self, model: Model, seat: int, callback: Callable[[DecisionReady], None]) -> None:
        """Make decision for given seat (async, calls callback when ready)"""
        pass
    
    @abstractmethod
    def review_event_at(self, index: int) -> Optional[Msg]:
        """Get review event at index (REVIEW mode only)"""
        pass
    
    @abstractmethod
    def review_length(self) -> int:
        """Get total review length (REVIEW mode only)"""
        pass


# ============================================================================
# TABLE RENDERER PROPS
# ============================================================================

@dataclass(frozen=True, slots=True)
class TableRendererProps:
    """Props derived from Model - FIXED with proper immutability"""
    # Table state - using immutable types
    seats: ImmutableSeats
    board: tuple[str, ...]
    pot: int
    to_act_seat: Optional[int]
    legal_actions: FrozenSet[str]
    
    # UI state
    banners: tuple[Banner, ...]
    theme_id: str
    autoplay_on: bool
    waiting_for: str
    
    # Review state
    review_cursor: int
    review_len: int
    review_paused: bool
    session_mode: str
    
    # Hints
    gto_hint: Optional[GtoHint]
    
    def __eq__(self, other):
        """Deep equality check that actually works"""
        if not isinstance(other, TableRendererProps):
            return False
        
        # Compare all fields including nested structures
        return (
            dict(self.seats) == dict(other.seats) and
            self.board == other.board and
            self.pot == other.pot and
            self.to_act_seat == other.to_act_seat and
            self.legal_actions == other.legal_actions and
            self.banners == other.banners and
            self.theme_id == other.theme_id and
            self.autoplay_on == other.autoplay_on and
            self.waiting_for == other.waiting_for and
            self.review_cursor == other.review_cursor and
            self.review_len == other.review_len and
            self.review_paused == other.review_paused and
            self.session_mode == other.session_mode and
            self.gto_hint == other.gto_hint
        )
    
    def __hash__(self):
        """Make props hashable for caching"""
        return hash((
            tuple(sorted(self.seats.items())),
            self.board,
            self.pot,
            self.to_act_seat,
            self.legal_actions,
            self.banners,
            self.theme_id,
            self.autoplay_on,
            self.waiting_for,
            self.review_cursor,
            self.review_len,
            self.review_paused,
            self.session_mode,
            self.gto_hint
        ))
    
    @classmethod
    def from_model(cls, model: Model) -> "TableRendererProps":
        """Derive props from model"""
        return cls(
            seats=model.seats,
            board=model.board,
            pot=model.pot,
            to_act_seat=model.to_act_seat,
            legal_actions=model.legal_actions,
            banners=model.banners,
            theme_id=model.theme_id,
            autoplay_on=model.autoplay_on,
            waiting_for=model.waiting_for,
            review_cursor=model.review_cursor,
            review_len=model.review_len,
            review_paused=model.review_paused,
            session_mode=model.session_mode,
            gto_hint=model.gto_hint
        )


# ============================================================================
# INTENT HANDLER PROTOCOL
# ============================================================================

class IntentHandler(Protocol):
    """Protocol for handling user intents from the UI"""
    
    def on_click_next(self) -> None:
        """Next button clicked"""
        pass
    
    def on_toggle_autoplay(self, on: bool) -> None:
        """Auto-play toggled"""
        pass
    
    def on_action_btn(self, action: str, amount: Optional[int] = None) -> None:
        """Action button clicked"""
        pass
    
    def on_seek(self, index: int) -> None:
        """Review seek"""
        pass
    
    def on_request_hint(self) -> None:
        """GTO hint requested"""
        pass
```

---

### types_integrated.py

**Path**: `backend/ui/mvu/types_integrated.py`

**Size**: 12.5 KB

```python
"""
MVU (Model-View-Update) Architecture Types - PPSM Integrated
Complete integration with PurePokerStateMachine
"""

from dataclasses import dataclass, replace
from typing import Literal, Optional, Dict, List, Set, Any, Protocol, Callable, FrozenSet, Mapping
from abc import ABC, abstractmethod
from functools import cached_property

# Helper types for immutable collections
ImmutableSeats = Mapping[int, "SeatState"]
ImmutableStacks = Mapping[int, int]

@dataclass(frozen=True, slots=True)
class SeatState:
    """State for a single seat at the poker table - FULLY IMMUTABLE"""
    player_uid: str
    name: str
    stack: int
    chips_in_front: int  # Current bet amount
    folded: bool
    all_in: bool
    cards: tuple[str, ...]  # Hole cards (visibility rules applied) - immutable tuple
    position: int
    acting: bool = False
    
    def __eq__(self, other):
        """Explicit equality for reliability"""
        if not isinstance(other, SeatState):
            return False
        return (
            self.player_uid == other.player_uid and
            self.name == other.name and
            self.stack == other.stack and
            self.chips_in_front == other.chips_in_front and
            self.folded == other.folded and
            self.all_in == other.all_in and
            self.cards == other.cards and
            self.position == other.position and
            self.acting == other.acting
        )
    
    def __hash__(self):
        """Consistent hash for frozen dataclass"""
        return hash((
            self.player_uid,
            self.name, 
            self.stack,
            self.chips_in_front,
            self.folded,
            self.all_in,
            self.cards,  # Already a tuple
            self.position,
            self.acting
        ))


@dataclass(frozen=True)
class Action:
    """Represents a poker action"""
    seat: int
    action: str  # "CHECK", "CALL", "BET", "RAISE", "FOLD"
    amount: Optional[int] = None
    street: str = "PREFLOP"


@dataclass(frozen=True)
class GtoHint:
    """GTO strategy hint"""
    action: str
    frequency: float
    reasoning: str


@dataclass(frozen=True)
class Banner:
    """UI banner/message"""
    text: str
    type: Literal["info", "warning", "error", "success"]
    duration_ms: int = 3000


@dataclass(frozen=True, slots=True)
class Model:
    """
    Canonical Model - FIXED with proper immutability
    Single source of truth that describes the complete state
    """
    # Game State - using immutable types
    hand_id: str
    street: Literal["PREFLOP", "FLOP", "TURN", "RIVER", "SHOWDOWN", "DONE"]
    to_act_seat: Optional[int]
    stacks: ImmutableStacks  # Changed from Dict to Mapping
    pot: int
    board: tuple[str, ...]  # ("As", "Kd", "7h", ...) - immutable tuple
    seats: ImmutableSeats  # Changed from Dict to Mapping
    legal_actions: FrozenSet[str]  # Changed from Set to frozenset
    last_action: Optional[Action]
    
    # Session Configuration
    session_mode: Literal["PRACTICE", "GTO", "REVIEW"]
    autoplay_on: bool
    step_delay_ms: int
    waiting_for: Literal["HUMAN_DECISION", "BOT_DECISION", "ANIMATION", "NONE"]
    
    # Review-specific
    review_cursor: int
    review_len: int
    review_paused: bool
    
    # UI State
    gto_hint: Optional[GtoHint]
    banners: tuple[Banner, ...]
    theme_id: str
    tx_id: int  # Animation token
    
    @classmethod
    def initial(cls, session_mode: Literal["PRACTICE", "GTO", "REVIEW"] = "REVIEW") -> "Model":
        """Create initial model state with immutable collections"""
        return cls(
            hand_id="",
            street="PREFLOP",
            to_act_seat=None,
            stacks={},  # Will be converted to immutable in update
            pot=0,
            board=(),
            seats={},  # Will be converted to immutable in update
            legal_actions=frozenset(),
            last_action=None,
            session_mode=session_mode,
            autoplay_on=False,
            step_delay_ms=1000,
            waiting_for="NONE",
            review_cursor=0,
            review_len=0,
            review_paused=False,
            gto_hint=None,
            banners=(),
            theme_id="forest-green-pro",
            tx_id=0
        )
    
    def __eq__(self, other):
        """Deep equality check for Model"""
        if not isinstance(other, Model):
            return False
        
        # Compare all fields explicitly
        return (
            self.hand_id == other.hand_id and
            self.street == other.street and
            self.to_act_seat == other.to_act_seat and
            dict(self.stacks) == dict(other.stacks) and
            self.pot == other.pot and
            self.board == other.board and
            dict(self.seats) == dict(other.seats) and
            self.legal_actions == other.legal_actions and
            self.last_action == other.last_action and
            self.session_mode == other.session_mode and
            self.autoplay_on == other.autoplay_on and
            self.step_delay_ms == other.step_delay_ms and
            self.waiting_for == other.waiting_for and
            self.review_cursor == other.review_cursor and
            self.review_len == other.review_len and
            self.review_paused == other.review_paused and
            self.gto_hint == other.gto_hint and
            self.banners == other.banners and
            self.theme_id == other.theme_id and
            self.tx_id == other.tx_id
        )


# ============================================================================
# MESSAGES (Facts)
# ============================================================================

class Msg(ABC):
    """Base message type"""
    pass


class NextPressed(Msg):
    """User pressed Next button"""
    pass


@dataclass
class AutoPlayToggled(Msg):
    """User toggled auto-play"""
    on: bool


@dataclass
class TimerTick(Msg):
    """Timer tick event"""
    now_ms: int


@dataclass
class UserChose(Msg):
    """Human user made a decision"""
    action: str
    amount: Optional[int] = None


@dataclass
class DecisionRequested(Msg):
    """System requests decision from a seat"""
    seat: int


@dataclass
class DecisionReady(Msg):
    """Decision is ready (from bot or async process)"""
    seat: int
    action: str
    amount: Optional[int]


@dataclass
class AppliedAction(Msg):
    """Action was applied to PPSM"""
    seat: int
    action: str
    amount: Optional[int]
    ppsm_state: dict  # Holds the new state from the PPSM


@dataclass
class StreetAdvanced(Msg):
    """Street changed (PREFLOP -> FLOP, etc.)"""
    street: str


@dataclass
class HandFinished(Msg):
    """Hand completed"""
    winners: List[int]
    payouts: Dict[int, int]


@dataclass
class AnimationFinished(Msg):
    """Animation completed"""
    token: int


@dataclass
class ReviewSeek(Msg):
    """Seek to specific position in review"""
    index: int


class ReviewPlayStep(Msg):
    """Play next step in review"""
    pass


@dataclass
class LoadHand(Msg):
    """Load a new hand for review/practice"""
    hand_data: Dict[str, Any]


@dataclass
class ThemeChanged(Msg):
    """Theme was changed"""
    theme_id: str


# ============================================================================
# COMMANDS (Effects)
# ============================================================================

class Cmd(ABC):
    """Base command type"""
    pass


@dataclass
class PlaySound(Cmd):
    """Play a sound effect"""
    name: str


@dataclass
class Speak(Cmd):
    """Text-to-speech announcement"""
    text: str


@dataclass
class Animate(Cmd):
    """Trigger animation"""
    name: str
    payload: Dict[str, Any]
    token: int


@dataclass
class AskDriverForDecision(Cmd):
    """Ask session driver for decision"""
    seat: int


@dataclass
class ApplyPPSM(Cmd):
    """Apply action to Pure Poker State Machine"""
    seat: int
    action: str
    amount: Optional[int]


@dataclass
class ScheduleTimer(Cmd):
    """Schedule a delayed message"""
    delay_ms: int
    msg: Msg


@dataclass
class PublishEvent(Cmd):
    """Publish event to EventBus"""
    topic: str
    payload: Dict[str, Any]


@dataclass
class GetReviewEvent(Cmd):
    """Get and dispatch review event at index"""
    index: int


# ============================================================================
# SESSION DRIVER PROTOCOL
# ============================================================================

class SessionDriver(Protocol):
    """Protocol for session-specific behavior"""
    
    @abstractmethod
    def decide(self, model: Model, seat: int, callback: Callable[[DecisionReady], None]) -> None:
        """Make decision for given seat (async, calls callback when ready)"""
        pass
    
    @abstractmethod
    def review_event_at(self, index: int) -> Optional[Msg]:
        """Get review event at index (REVIEW mode only)"""
        pass
    
    @abstractmethod
    def review_length(self) -> int:
        """Get total review length (REVIEW mode only)"""
        pass


# ============================================================================
# TABLE RENDERER PROPS
# ============================================================================

@dataclass(frozen=True, slots=True)
class TableRendererProps:
    """Props derived from Model - FIXED with proper immutability"""
    # Table state - using immutable types
    seats: ImmutableSeats
    board: tuple[str, ...]
    pot: int
    to_act_seat: Optional[int]
    legal_actions: FrozenSet[str]
    
    # UI state
    banners: tuple[Banner, ...]
    theme_id: str
    autoplay_on: bool
    waiting_for: str
    
    # Review state
    review_cursor: int
    review_len: int
    review_paused: bool
    session_mode: str
    
    # Hints
    gto_hint: Optional[GtoHint]
    
    def __eq__(self, other):
        """Deep equality check that actually works"""
        if not isinstance(other, TableRendererProps):
            return False
        
        # Compare all fields including nested structures
        return (
            dict(self.seats) == dict(other.seats) and
            self.board == other.board and
            self.pot == other.pot and
            self.to_act_seat == other.to_act_seat and
            self.legal_actions == other.legal_actions and
            self.banners == other.banners and
            self.theme_id == other.theme_id and
            self.autoplay_on == other.autoplay_on and
            self.waiting_for == other.waiting_for and
            self.review_cursor == other.review_cursor and
            self.review_len == other.review_len and
            self.review_paused == other.review_paused and
            self.session_mode == other.session_mode and
            self.gto_hint == other.gto_hint
        )
    
    def __hash__(self):
        """Make props hashable for caching"""
        return hash((
            tuple(sorted(self.seats.items())),
            self.board,
            self.pot,
            self.to_act_seat,
            self.legal_actions,
            self.banners,
            self.theme_id,
            self.autoplay_on,
            self.waiting_for,
            self.review_cursor,
            self.review_len,
            self.review_paused,
            self.session_mode,
            self.gto_hint
        ))
    
    @classmethod
    def from_model(cls, model: Model) -> "TableRendererProps":
        """Derive props from model"""
        return cls(
            seats=model.seats,
            board=model.board,
            pot=model.pot,
            to_act_seat=model.to_act_seat,
            legal_actions=model.legal_actions,
            banners=model.banners,
            theme_id=model.theme_id,
            autoplay_on=model.autoplay_on,
            waiting_for=model.waiting_for,
            review_cursor=model.review_cursor,
            review_len=model.review_len,
            review_paused=model.review_paused,
            session_mode=model.session_mode,
            gto_hint=model.gto_hint
        )


# ============================================================================
# INTENT HANDLER PROTOCOL
# ============================================================================

class IntentHandler(Protocol):
    """Protocol for handling user intents from the UI"""
    
    def on_click_next(self) -> None:
        """Next button clicked"""
        pass
    
    def on_toggle_autoplay(self, on: bool) -> None:
        """Auto-play toggled"""
        pass
    
    def on_action_btn(self, action: str, amount: Optional[int] = None) -> None:
        """Action button clicked"""
        pass
    
    def on_seek(self, index: int) -> None:
        """Review seek"""
        pass
    
    def on_request_hint(self) -> None:
        """GTO hint requested"""
        pass
```

---

### update.py

**Path**: `backend/ui/mvu/update.py`

**Size**: 16.0 KB

```python
"""
MVU Update Function - Pure reducers for poker table state
Based on PokerPro UI Implementation Handbook v2
"""

from typing import Tuple, List, Optional
from dataclasses import replace

from .types import (
    Model, Msg, Cmd, SeatState, Action,
    NextPressed, AutoPlayToggled, TimerTick, UserChose,
    DecisionReady, AppliedAction, StreetAdvanced, HandFinished, AnimationFinished,
    ReviewSeek, ReviewPlayStep, LoadHand, ThemeChanged,
    PlaySound, Speak, Animate, AskDriverForDecision, ApplyPPSM,
    ScheduleTimer, GetReviewEvent
)


def update(model: Model, msg: Msg) -> Tuple[Model, List[Cmd]]:
    """
    Pure update function - computes (Model', Cmds) from (Model, Msg)
    No I/O operations allowed inside reducers.
    """
    if isinstance(msg, NextPressed):
        return next_pressed_reducer(model)
    
    if isinstance(msg, AutoPlayToggled):
        return replace(model, autoplay_on=msg.on), []
    
    if isinstance(msg, TimerTick):
        return on_timer_tick(model, msg)
    
    if isinstance(msg, UserChose):
        return apply_decision(model, model.to_act_seat, msg.action, msg.amount)
    
    if isinstance(msg, DecisionReady):
        return apply_decision(model, msg.seat, msg.action, msg.amount)
    
    if isinstance(msg, AppliedAction):
        return on_applied_action(model, msg)
    
    if isinstance(msg, StreetAdvanced):
        return on_street_advanced(model, msg)
    
    if isinstance(msg, HandFinished):
        return on_hand_finished(model, msg)
    
    if isinstance(msg, AnimationFinished):
        return on_animation_finished(model, msg)
    
    if isinstance(msg, ReviewSeek):
        return rebuild_state_to(model, msg.index)
    
    if isinstance(msg, ReviewPlayStep):
        return play_review_step(model)
    
    if isinstance(msg, LoadHand):
        return load_hand(model, msg)
    
    if isinstance(msg, ThemeChanged):
        return replace(model, theme_id=msg.theme_id), []
    
    # Unknown message - no change
    return model, []


# ============================================================================
# KEY REDUCERS
# ============================================================================

def next_pressed_reducer(model: Model) -> Tuple[Model, List[Cmd]]:
    """Handle Next button press based on current state"""
    
    print(f"üîò Next pressed - State: waiting_for={model.waiting_for}, to_act_seat={model.to_act_seat}, mode={model.session_mode}, cursor={model.review_cursor}/{model.review_len}")
    
    # If waiting for human decision, Next does nothing
    if model.waiting_for == "HUMAN_DECISION":
        print("‚è∏Ô∏è Next pressed but waiting for human decision")
        return model, []
    
    # If waiting for bot decision, ask driver
    if model.waiting_for == "BOT_DECISION" and model.to_act_seat is not None:
        print(f"ü§ñ Next pressed - asking driver for decision for seat {model.to_act_seat}")
        new_model = replace(model, waiting_for="NONE")
        return new_model, [AskDriverForDecision(model.to_act_seat)]
    
    # If waiting for animation, Next does nothing
    if model.waiting_for == "ANIMATION":
        print("üé¨ Next pressed but waiting for animation")
        return model, []
    
    # If no one to act, continue game flow (or advance review)
    if model.to_act_seat is None:
        if model.session_mode == "REVIEW":
            print("üìñ Next pressed - no one to act in REVIEW, advancing review")
            return model, [ScheduleTimer(0, ReviewPlayStep())]
        else:
            print("‚è≠Ô∏è Next pressed - no one to act, continuing game flow")
            return model, [ApplyPPSM(seat=-1, action="CONTINUE", amount=None)]
    
    # Someone needs to act
    if model.session_mode == "REVIEW":
        # In review mode, all actions are pre-recorded, so advance review
        print(f"üìñ Next pressed in REVIEW mode with to_act_seat={model.to_act_seat} - advancing review")
        return model, [ScheduleTimer(0, ReviewPlayStep())]
    
    # If autoplay is on and current seat is bot, ask for decision
    if model.autoplay_on and seat_is_bot(model, model.to_act_seat):
        print(f"ü§ñ Next pressed - autoplay bot decision for seat {model.to_act_seat}")
        new_model = replace(model, waiting_for="BOT_DECISION")
        return new_model, [AskDriverForDecision(model.to_act_seat)]
    
    print("‚ùì Next pressed - no action taken")
    return model, []


def apply_decision(model: Model, seat: Optional[int], action: str, amount: Optional[int]) -> Tuple[Model, List[Cmd]]:
    """Apply a poker decision (from human or bot)"""
    
    # Validate decision
    if seat is None or seat != model.to_act_seat:
        return model, []
    
    if action not in model.legal_actions:
        return model, []
    
    # Generate new transaction ID for animation
    tx = model.tx_id + 1
    
    # Create commands for effects
    cmds = [
        PlaySound(action.lower()),
        Speak(action.capitalize()),
    ]
    
    # Add appropriate animation
    if action in {"BET", "RAISE", "CALL"}:
        cmds.append(Animate("chips_to_pot", {"seat": seat, "amount": amount or 0}, token=tx))
    else:
        cmds.append(Animate("minor_flash", {"seat": seat}, token=tx))
    
    # Apply to PPSM
    cmds.append(ApplyPPSM(seat, action, amount))
    
    # In REVIEW mode, skip animation waiting
    if model.session_mode == "REVIEW":
        new_model = replace(
            model,
            tx_id=tx,
            waiting_for="NONE",
            last_action=Action(seat=seat, action=action, amount=amount, street=model.street)
        )
        # Auto-complete animation immediately
        cmds.append(ScheduleTimer(0, AnimationFinished(token=tx)))
    else:
        # Update model to wait for animation
        new_model = replace(
            model,
            tx_id=tx,
            waiting_for="ANIMATION",
            last_action=Action(seat=seat, action=action, amount=amount, street=model.street)
        )
    
    return new_model, cmds


def on_applied_action(model: Model, msg: AppliedAction) -> Tuple[Model, List[Cmd]]:
    """Handle action applied to PPSM - update from PPSM snapshot"""
    
    # This would typically get updated state from PPSM
    # For now, we'll simulate the state update
    new_model = apply_ppsm_snapshot(model, msg)
    cmds = []
    
    # In REVIEW mode, all actions are pre-recorded, so never wait for decisions
    if model.session_mode == "REVIEW":
        # Always ready for next review step
        new_model = replace(new_model, waiting_for="NONE")
    else:
        # Determine next action for live play
        if new_model.to_act_seat is not None:
            if seat_is_human(new_model, new_model.to_act_seat):
                new_model = replace(new_model, waiting_for="HUMAN_DECISION")
            else:
                new_model = replace(new_model, waiting_for="BOT_DECISION")
                if new_model.autoplay_on:
                    cmds.append(AskDriverForDecision(new_model.to_act_seat))
        else:
            # No one to act - schedule continuation
            cmds.append(ScheduleTimer(new_model.step_delay_ms, NextPressed()))
    

    return new_model, cmds


def on_street_advanced(model: Model, msg: StreetAdvanced) -> Tuple[Model, List[Cmd]]:
    """Handle street advancement (PREFLOP -> FLOP, etc.)"""
    
    tx = model.tx_id + 1
    cmds = [
        Animate("reveal_board", {"street": msg.street}, token=tx),
        PlaySound("deal")
    ]
    
    # In REVIEW mode, skip animation waiting
    if model.session_mode == "REVIEW":
        new_model = replace(
            model,
            street=msg.street,
            tx_id=tx,
            waiting_for="NONE"
        )
        # Auto-complete animation immediately
        cmds.append(ScheduleTimer(0, AnimationFinished(token=tx)))
    else:
        new_model = replace(
            model,
            street=msg.street,
            tx_id=tx,
            waiting_for="ANIMATION"
        )
    
    return new_model, cmds


def on_hand_finished(model: Model, msg: HandFinished) -> Tuple[Model, List[Cmd]]:
    """Handle hand completion"""
    
    tx = model.tx_id + 1
    cmds = [
        Animate("pot_to_winners", {"payouts": msg.payouts}, token=tx),
        PlaySound("win")
    ]
    
    # In REVIEW mode, skip animation waiting
    if model.session_mode == "REVIEW":
        new_model = replace(
            model,
            waiting_for="NONE",
            tx_id=tx,
            street="DONE"
        )
        # Auto-complete animation and schedule next step
        cmds.append(ScheduleTimer(0, AnimationFinished(token=tx)))
        cmds.append(ScheduleTimer(model.step_delay_ms, ReviewPlayStep()))
    else:
        new_model = replace(
            model,
            waiting_for="ANIMATION",
            tx_id=tx,
            street="DONE"
        )
        # Schedule next action for live play
        cmds.append(ScheduleTimer(model.step_delay_ms, NextPressed()))
    
    return new_model, cmds


def on_animation_finished(model: Model, msg: AnimationFinished) -> Tuple[Model, List[Cmd]]:
    """Handle animation completion"""
    
    # Only process if this is the current animation
    if msg.token != model.tx_id:
        return model, []
    
    # Clear waiting state
    new_model = replace(model, waiting_for="NONE")
    
    # Trigger next action if needed
    cmds = []
    if model.autoplay_on and new_model.to_act_seat is not None:
        if seat_is_bot(new_model, new_model.to_act_seat):
            new_model = replace(new_model, waiting_for="BOT_DECISION")
            cmds.append(AskDriverForDecision(new_model.to_act_seat))
    
    return new_model, cmds


def on_timer_tick(model: Model, msg: TimerTick) -> Tuple[Model, List[Cmd]]:
    """Handle timer tick - can be used for timeouts, etc."""
    
    # Remove expired banners
    current_banners = [
        banner for banner in model.banners
        if msg.now_ms < banner.duration_ms  # Simplified - would need actual timestamps
    ]
    
    if len(current_banners) != len(model.banners):
        return replace(model, banners=current_banners), []
    
    return model, []


# ============================================================================
# REVIEW-SPECIFIC REDUCERS
# ============================================================================

def rebuild_state_to(model: Model, index: int) -> Tuple[Model, List[Cmd]]:
    """Rebuild state to specific review index"""
    
    if model.session_mode != "REVIEW":
        return model, []
    
    # Clamp index
    index = max(0, min(index, model.review_len - 1))
    
    # This would typically replay events up to index
    # For now, just update cursor
    new_model = replace(
        model,
        review_cursor=index,
        waiting_for="NONE"
    )
    
    return new_model, []


def play_review_step(model: Model) -> Tuple[Model, List[Cmd]]:
    """Play next step in review"""
    
    print(f"üìñ PlayReviewStep: cursor={model.review_cursor}, len={model.review_len}, mode={model.session_mode}")
    
    if model.session_mode != "REVIEW":
        print("‚ùå PlayReviewStep: Not in REVIEW mode")
        return model, []
    
    if model.review_cursor >= model.review_len - 1:
        print("üèÅ PlayReviewStep: End of review reached")
        return model, []
    
    # Advance cursor
    new_cursor = model.review_cursor + 1
    new_model = replace(model, review_cursor=new_cursor)
    
    print(f"‚û°Ô∏è PlayReviewStep: Advancing to cursor {new_cursor}")
    
    # We need to get the event from session driver and dispatch it
    return new_model, [GetReviewEvent(index=new_cursor)]


def load_hand(model: Model, msg: LoadHand) -> Tuple[Model, List[Cmd]]:
    """Load new hand data - FIXED VERSION"""
    
    hand_data = msg.hand_data
    
    # Extract hand information
    hand_id = hand_data.get("hand_id", "")
    seats_data = hand_data.get("seats", {})
    board = tuple(hand_data.get("board", []))
    pot = hand_data.get("pot", 0)
    
    # Convert seats data to SeatState objects (immutable)
    seats = {}
    stacks = {}
    for seat_num, seat_data in seats_data.items():
        seat_state = SeatState(
            player_uid=seat_data.get("player_uid", f"player_{seat_num}"),
            name=seat_data.get("name", f"Player {seat_num}"),
            stack=seat_data.get("stack", 1000),
            chips_in_front=seat_data.get("chips_in_front", 0),
            folded=seat_data.get("folded", False),
            all_in=seat_data.get("all_in", False),
            cards=tuple(seat_data.get("cards", [])),  # Ensure tuple
            position=int(seat_num)
        )
        seats[int(seat_num)] = seat_state
        stacks[int(seat_num)] = seat_state.stack
    
    # CRITICAL: Use frozenset for legal_actions
    legal_actions = frozenset(hand_data.get("legal_actions", []))
    
    new_model = replace(
        model,
        hand_id=hand_id,
        seats=seats,  # Will be treated as immutable Mapping
        stacks=stacks,  # Will be treated as immutable Mapping
        board=board,
        pot=pot,
        street="PREFLOP",
        to_act_seat=hand_data.get("to_act_seat"),
        legal_actions=legal_actions,  # Now frozenset
        waiting_for="NONE",
        review_cursor=0,
        review_len=hand_data.get("review_len", 0)
    )
    
    return new_model, []


# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

def seat_is_human(model: Model, seat: int) -> bool:
    """Check if seat is controlled by human player"""
    # For now, assume seat 0 is human in practice/review mode
    if model.session_mode in ["PRACTICE", "REVIEW"]:
        return seat == 0
    return False


def seat_is_bot(model: Model, seat: int) -> bool:
    """Check if seat is controlled by bot"""
    return not seat_is_human(model, seat)


def apply_ppsm_snapshot(model: Model, msg: AppliedAction) -> Model:
    """
    Apply PPSM state snapshot after action
    This would typically get real state from PPSM
    """
    
    # Simulate basic state changes
    new_seats = dict(model.seats)
    new_stacks = dict(model.stacks)
    new_pot = model.pot
    
    print(f"üéØ Applying action: {msg.action} by seat {msg.seat} (amount: {msg.amount})")
    
    # Clear all acting status first
    for seat_num in new_seats:
        new_seats[seat_num] = replace(new_seats[seat_num], acting=False)
    
    # Update acting seat
    if msg.seat in new_seats:
        seat_state = new_seats[msg.seat]
        
        # Simulate stack/bet changes
        if msg.action in ["BET", "RAISE", "CALL"] and msg.amount:
            new_stacks[msg.seat] = max(0, new_stacks[msg.seat] - msg.amount)
            new_pot += msg.amount
            new_seats[msg.seat] = replace(
                new_seats[msg.seat],
                stack=new_stacks[msg.seat],
                chips_in_front=seat_state.chips_in_front + msg.amount
            )
            print(f"üí∞ Seat {msg.seat} bet ${msg.amount}, stack now ${new_stacks[msg.seat]}, pot now ${new_pot}")
            
        elif msg.action == "FOLD":
            new_seats[msg.seat] = replace(new_seats[msg.seat], folded=True)
            print(f"üÉè Seat {msg.seat} folded")
            
        elif msg.action in ["CHECK", "CALL"]:
            print(f"‚úÖ Seat {msg.seat} {msg.action.lower()}ed")
    
    # Find next acting seat (simplified)
    next_seat = None
    active_seats = [s for s in sorted(new_seats.keys()) if not new_seats[s].folded]
    
    if len(active_seats) > 1:
        # Find next seat after current actor
        current_idx = active_seats.index(msg.seat) if msg.seat in active_seats else -1
        next_idx = (current_idx + 1) % len(active_seats)
        next_seat = active_seats[next_idx]
    
    # Update acting status
    if next_seat is not None:
        new_seats[next_seat] = replace(new_seats[next_seat], acting=True)
        print(f"üëâ Next to act: Seat {next_seat}")
    else:
        print("üèÅ No more players to act")
    
    return replace(
        model,
        seats=new_seats,
        stacks=new_stacks,
        to_act_seat=next_seat,
        pot=new_pot,
        legal_actions={"CHECK", "CALL", "BET", "RAISE", "FOLD"} if next_seat else set()
    )
```

---

### update_integrated.py

**Path**: `backend/ui/mvu/update_integrated.py`

**Size**: 13.6 KB

```python
"""
MVU Update Function - PPSM Integrated
Complete integration with PurePokerStateMachine
"""

from typing import Tuple, List, Optional
from dataclasses import replace

from .types_integrated import (
    Model, Msg, Cmd, SeatState, Action,
    NextPressed, AutoPlayToggled, TimerTick, UserChose,
    DecisionReady, AppliedAction, StreetAdvanced, HandFinished, AnimationFinished,
    ReviewSeek, ReviewPlayStep, LoadHand, ThemeChanged,
    PlaySound, Speak, Animate, AskDriverForDecision, ApplyPPSM,
    ScheduleTimer, GetReviewEvent
)

# ============================================================================
# PPSM STATE TRANSLATOR
# ============================================================================

def ppsm_state_to_model_update(model: Model, ppsm_state: dict) -> Model:
    """
    Translates a state snapshot from the PPSM into a new MVU Model.
    This is the adapter between the poker engine and the UI state.
    """
    if not ppsm_state:
        return model

    # Extract players from PPSM state
    ppsm_players = ppsm_state.get("players", [])
    
    # Convert PPSM players to immutable SeatState objects
    new_seats = {}
    new_stacks = {}
    
    for i, ppsm_player in enumerate(ppsm_players):
        seat_state = SeatState(
            player_uid=ppsm_player.get("name", f"player_{i}"),
            name=ppsm_player.get("name", f"Player {i}"),
            stack=int(ppsm_player.get("stack", 0)),
            chips_in_front=int(ppsm_player.get("current_bet", 0)),
            folded=ppsm_player.get("has_folded", False),
            all_in=ppsm_player.get("is_all_in", False),
            cards=tuple(ppsm_player.get("cards", [])),
            position=ppsm_player.get("position", i),
            acting=ppsm_player.get("is_acting", False)
        )
        new_seats[i] = seat_state
        new_stacks[i] = seat_state.stack

    # Extract other game state
    pot = ppsm_state.get("committed_pot", model.pot)
    board = tuple(ppsm_state.get("community_cards", model.board))
    to_act_seat = ppsm_state.get("action_player_index")
    if to_act_seat is not None and to_act_seat >= 0:
        to_act_seat = int(to_act_seat)
    else:
        to_act_seat = None
    
    # Convert PPSM legal actions to our format
    legal_actions_raw = ppsm_state.get("legal_actions", [])
    legal_actions = frozenset(str(action).upper() for action in legal_actions_raw)
    
    # Map PPSM poker state to our street
    poker_state = ppsm_state.get("poker_state", "PREFLOP")
    street_mapping = {
        "START_HAND": "PREFLOP",
        "PREFLOP_BETTING": "PREFLOP", 
        "DEAL_FLOP": "FLOP",
        "FLOP_BETTING": "FLOP",
        "DEAL_TURN": "TURN", 
        "TURN_BETTING": "TURN",
        "DEAL_RIVER": "RIVER",
        "RIVER_BETTING": "RIVER",
        "SHOWDOWN": "SHOWDOWN",
        "END_HAND": "DONE"
    }
    street = street_mapping.get(str(poker_state), "PREFLOP")

    # Create a new immutable model with the updated state from PPSM
    return replace(
        model,
        seats=new_seats,
        stacks=new_stacks,
        pot=pot,
        board=board,
        to_act_seat=to_act_seat,
        legal_actions=legal_actions,
        street=street
    )


# ============================================================================
# CORE UPDATE FUNCTION
# ============================================================================

def update(model: Model, msg: Msg) -> Tuple[Model, List[Cmd]]:
    """
    Pure update function - computes (Model, Cmds) from (Model, Msg)
    No I/O operations allowed inside reducers.
    """
    if isinstance(msg, NextPressed):
        return next_pressed_reducer(model)
    
    if isinstance(msg, AutoPlayToggled):
        return replace(model, autoplay_on=msg.on), []
    
    if isinstance(msg, TimerTick):
        return on_timer_tick(model, msg)
    
    if isinstance(msg, UserChose):
        return apply_decision(model, model.to_act_seat, msg.action, msg.amount)
    
    if isinstance(msg, DecisionReady):
        return apply_decision(model, msg.seat, msg.action, msg.amount)
    
    if isinstance(msg, AppliedAction):
        return on_applied_action(model, msg)
    
    if isinstance(msg, StreetAdvanced):
        return on_street_advanced(model, msg)
    
    if isinstance(msg, HandFinished):
        return on_hand_finished(model, msg)
    
    if isinstance(msg, AnimationFinished):
        return on_animation_finished(model, msg)
    
    if isinstance(msg, ReviewSeek):
        return rebuild_state_to(model, msg.index)
    
    if isinstance(msg, ReviewPlayStep):
        return play_review_step(model)
    
    if isinstance(msg, LoadHand):
        return load_hand(model, msg)
    
    if isinstance(msg, ThemeChanged):
        return replace(model, theme_id=msg.theme_id), []
    
    # Unknown message - no change
    return model, []


# ============================================================================
# KEY REDUCERS
# ============================================================================

def next_pressed_reducer(model: Model) -> Tuple[Model, List[Cmd]]:
    """Handle Next button press based on current state"""
    
    print(f"üîò Next pressed - State: waiting_for={model.waiting_for}, to_act_seat={model.to_act_seat}, mode={model.session_mode}, cursor={model.review_cursor}/{model.review_len}")
    
    if model.waiting_for == "HUMAN_DECISION":
        return model, []
    
    if model.waiting_for == "BOT_DECISION" and model.to_act_seat is not None:
        new_model = replace(model, waiting_for="NONE")
        return new_model, [AskDriverForDecision(model.to_act_seat)]
    
    if model.waiting_for == "ANIMATION":
        return model, []
    
    if model.to_act_seat is None:
        if model.session_mode == "REVIEW":
            return model, [ScheduleTimer(0, ReviewPlayStep())]
        else:
            # Continue game - advance to next street or finish hand
            return model, [ApplyPPSM(seat=-1, action="CONTINUE", amount=None)]
    
    if model.session_mode == "REVIEW":
        return model, [ScheduleTimer(0, ReviewPlayStep())]
    
    if model.autoplay_on and not seat_is_human(model, model.to_act_seat):
        new_model = replace(model, waiting_for="BOT_DECISION")
        return new_model, [AskDriverForDecision(model.to_act_seat)]
    
    return model, []


def apply_decision(model: Model, seat: Optional[int], action: str, amount: Optional[int]) -> Tuple[Model, List[Cmd]]:
    """Apply a poker decision (from human or bot)"""
    
    if seat is None or seat != model.to_act_seat:
        return model, []
    
    if action not in model.legal_actions:
        return model, []
    
    tx = model.tx_id + 1
    
    # Generate audio/visual effects
    cmds = [PlaySound(action.lower()), Speak(action.capitalize())]
    
    if action in {"BET", "RAISE", "CALL"}:
        cmds.append(Animate("chips_to_pot", {"seat": seat, "amount": amount or 0}, token=tx))
    else:
        cmds.append(Animate("minor_flash", {"seat": seat}, token=tx))
    
    # Apply action to PPSM
    cmds.append(ApplyPPSM(seat, action, amount))
    
    waiting_state = "ANIMATION" if model.session_mode != "REVIEW" else "NONE"
    new_model = replace(
        model,
        tx_id=tx,
        waiting_for=waiting_state,
        last_action=Action(seat=seat, action=action, amount=amount, street=model.street)
    )
    
    # In review mode, finish animations immediately
    if model.session_mode == "REVIEW":
        cmds.append(ScheduleTimer(0, AnimationFinished(token=tx)))
        
    return new_model, cmds


def on_applied_action(model: Model, msg: AppliedAction) -> Tuple[Model, List[Cmd]]:
    """Handle action applied to PPSM - update from the REAL PPSM snapshot"""
    
    # Translate the PPSM state into our new UI Model
    new_model = ppsm_state_to_model_update(model, msg.ppsm_state)
    cmds = []
    
    if new_model.session_mode == "REVIEW":
        new_model = replace(new_model, waiting_for="NONE")
    else:
        if new_model.to_act_seat is not None:
            if seat_is_human(new_model, new_model.to_act_seat):
                new_model = replace(new_model, waiting_for="HUMAN_DECISION")
            else:
                new_model = replace(new_model, waiting_for="BOT_DECISION")
                if new_model.autoplay_on:
                    cmds.append(AskDriverForDecision(new_model.to_act_seat))
        else:
            # No one to act - continue game automatically
            cmds.append(ScheduleTimer(new_model.step_delay_ms, NextPressed()))

    return new_model, cmds


def on_street_advanced(model: Model, msg: StreetAdvanced) -> Tuple[Model, List[Cmd]]:
    """Handle street advancement (PREFLOP -> FLOP, etc.)"""
    
    tx = model.tx_id + 1
    cmds = [Animate("reveal_board", {"street": msg.street}, token=tx), PlaySound("deal")]
    
    waiting_state = "ANIMATION" if model.session_mode != "REVIEW" else "NONE"
    new_model = replace(model, street=msg.street, tx_id=tx, waiting_for=waiting_state)
    
    if model.session_mode == "REVIEW":
        cmds.append(ScheduleTimer(0, AnimationFinished(token=tx)))
        
    return new_model, cmds


def on_hand_finished(model: Model, msg: HandFinished) -> Tuple[Model, List[Cmd]]:
    """Handle hand completion"""
    
    tx = model.tx_id + 1
    cmds = [Animate("pot_to_winners", {"payouts": msg.payouts}, token=tx), PlaySound("win")]

    waiting_state = "ANIMATION" if model.session_mode != "REVIEW" else "NONE"
    new_model = replace(model, waiting_for=waiting_state, tx_id=tx, street="DONE")
    
    if model.session_mode == "REVIEW":
        cmds.extend([
            ScheduleTimer(0, AnimationFinished(token=tx)),
            ScheduleTimer(model.step_delay_ms, ReviewPlayStep())
        ])
    else:
        cmds.append(ScheduleTimer(model.step_delay_ms, NextPressed()))
        
    return new_model, cmds


def on_animation_finished(model: Model, msg: AnimationFinished) -> Tuple[Model, List[Cmd]]:
    """Handle animation completion"""
    
    if msg.token != model.tx_id:
        return model, []
    
    new_model = replace(model, waiting_for="NONE")
    cmds = []
    
    if model.autoplay_on and new_model.to_act_seat is not None and not seat_is_human(new_model, new_model.to_act_seat):
        new_model = replace(new_model, waiting_for="BOT_DECISION")
        cmds.append(AskDriverForDecision(new_model.to_act_seat))
    
    return new_model, cmds


def on_timer_tick(model: Model, msg: TimerTick) -> Tuple[Model, List[Cmd]]:
    """Handle timer tick - can be used for timeouts, etc."""
    
    current_banners = tuple(b for b in model.banners if msg.now_ms < b.duration_ms)
    
    if len(current_banners) != len(model.banners):
        return replace(model, banners=current_banners), []
    
    return model, []


def rebuild_state_to(model: Model, index: int) -> Tuple[Model, List[Cmd]]:
    """Rebuild state to specific review index"""
    
    if model.session_mode != "REVIEW":
        return model, []
    
    index = max(0, min(index, model.review_len - 1))
    new_model = replace(model, review_cursor=index, waiting_for="NONE")
    
    return new_model, []


def play_review_step(model: Model) -> Tuple[Model, List[Cmd]]:
    """Play next step in review"""
    
    if model.session_mode != "REVIEW" or model.review_cursor >= model.review_len - 1:
        return model, []
    
    new_cursor = model.review_cursor + 1
    new_model = replace(model, review_cursor=new_cursor)
    
    return new_model, [GetReviewEvent(index=new_cursor)]


def load_hand(model: Model, msg: LoadHand) -> Tuple[Model, List[Cmd]]:
    """Load new hand data"""
    
    hand_data = msg.hand_data
    seats_data = hand_data.get("seats", {})
    
    # Convert seat data to immutable SeatState objects
    seats = {}
    stacks = {}
    
    # Handle both list and dict formats for seats
    if isinstance(seats_data, list):
        for i, seat in enumerate(seats_data):
            seat_num = seat.get("seat_no", i)
            seat_state = SeatState(
                player_uid=seat.get("player_uid", f"p_{i}"),
                name=seat.get("display_name", seat.get("name", f"Player {i}")),
                stack=seat.get("starting_stack", seat.get("stack", 1000)),
                chips_in_front=seat.get("chips_in_front", 0),
                folded=seat.get("folded", False),
                all_in=seat.get("all_in", False),
                cards=tuple(seat.get("cards", [])),
                position=seat_num
            )
            seats[seat_num] = seat_state
            stacks[seat_num] = seat_state.stack
    else:
        for k, v in seats_data.items():
            seat_num = int(k)
            seat_state = SeatState(
                player_uid=v.get("player_uid", f"p_{k}"),
                name=v.get("name", f"Player {k}"),
                stack=v.get("stack", 1000),
                chips_in_front=v.get("chips_in_front", 0),
                folded=v.get("folded", False),
                all_in=v.get("all_in", False),
                cards=tuple(v.get("cards", [])),
                position=seat_num
            )
            seats[seat_num] = seat_state
            stacks[seat_num] = seat_state.stack
    
    new_model = replace(
        model,
        hand_id=hand_data.get("hand_id", ""),
        seats=seats,
        stacks=stacks,
        board=tuple(hand_data.get("board", [])),
        pot=hand_data.get("pot", 0),
        street="PREFLOP",
        to_act_seat=hand_data.get("to_act_seat"),
        legal_actions=frozenset(hand_data.get("legal_actions", [])),
        waiting_for="NONE",
        review_cursor=0,
        review_len=hand_data.get("review_len", 0)
    )
    
    return new_model, []


def seat_is_human(model: Model, seat: int) -> bool:
    """Check if seat is controlled by human player"""
    # In this implementation, seat 0 is typically the human player
    return model.session_mode in ["PRACTICE", "REVIEW"] and seat == 0
```

---

### view.py

**Path**: `backend/ui/mvu/view.py`

**Size**: 9.7 KB

```python
"""
MVU View - Pure rendering components that read from Model
Based on PokerPro UI Implementation Handbook v2
"""

import tkinter as tk
from tkinter import ttk
from typing import Optional, Callable, Dict, Any

from .types_integrated import Model, TableRendererProps, IntentHandler


class MVUPokerTableRenderer(ttk.Frame):
    """
    Pure View component for poker table
    Reads only from Model, emits intents via IntentHandler
    """
    
    def __init__(
        self,
        parent: tk.Widget,
        intent_handler: Optional[IntentHandler] = None,
        theme_manager: Any = None
    ):
        super().__init__(parent)
        
        self.intent_handler = intent_handler or DummyIntentHandler()
        self.theme_manager = theme_manager
        self.current_props: Optional[TableRendererProps] = None
        self._updating_scale = False
        
        self._setup_ui()
    
    def _setup_ui(self) -> None:
        """Setup the UI components"""
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=1)
        
        # Main poker table canvas
        self.canvas = tk.Canvas(self, width=800, height=600, bg="#0D4F3C")
        self.canvas.grid(row=0, column=0, sticky="nsew")
        
        # Controls frame
        controls_frame = ttk.Frame(self)
        controls_frame.grid(row=1, column=0, sticky="ew")
        
        # Basic controls
        self.next_btn = ttk.Button(controls_frame, text="Next", command=self.intent_handler.on_click_next)
        self.next_btn.pack(side="left", padx=5)
        
        self.autoplay_btn = ttk.Button(controls_frame, text="Auto-Play", command=self._on_toggle_autoplay)
        self.autoplay_btn.pack(side="left", padx=5)
        
        self.status_label = ttk.Label(controls_frame, text="Ready")
        self.status_label.pack(side="left", padx=10)
        
        # Review controls frame (initially hidden)
        self.review_frame = ttk.Frame(self)
        self.review_frame.grid(row=2, column=0, sticky="ew")
        self.review_frame.grid_remove()  # Hide initially
        
        ttk.Label(self.review_frame, text="Review:").pack(side="left", padx=5)
        
        self.review_scale = ttk.Scale(self.review_frame, from_=0, to=100, 
                                     orient="horizontal", length=200,
                                     command=self._on_review_seek)
        self.review_scale.pack(side="left", padx=5)
        
        self.review_position_label = ttk.Label(self.review_frame, text="0/0")
        self.review_position_label.pack(side="left", padx=5)

    def render(self, props: TableRendererProps) -> None:
        """Render the table based on props"""
        if self.current_props == props:
            return
        
        if self.current_props is None:
            print(f"üé® MVUPokerTableRenderer: Initial render with {len(props.seats)} seats")
        
        self.current_props = props
        self._update_controls(props)
        self._render_table(props)
        self._update_review_controls(props)
    
    def _update_controls(self, props: TableRendererProps) -> None:
        """Update control buttons and status"""
        # Update status text
        status_text = f"Waiting for: {props.waiting_for}"
        if props.to_act_seat is not None:
            status_text += f" (Seat {props.to_act_seat})"
        if props.session_mode == "REVIEW":
            status_text += f" | Review: {props.review_cursor}/{props.review_len}"
        
        self.status_label.config(text=status_text)
        
        # Update autoplay button
        autoplay_text = "Pause" if props.autoplay_on else "Auto-Play"
        self.autoplay_btn.config(text=autoplay_text)
        
    def _update_review_controls(self, props: TableRendererProps) -> None:
        """Update review-specific controls"""
        is_review = props.session_mode == "REVIEW"
        if is_review:
            self.review_frame.grid()
            if not hasattr(self, '_updating_scale'):
                self._updating_scale = False
            
            if props.review_len > 0 and not self._updating_scale:
                self._updating_scale = True
                try:
                    self.review_scale.config(to=max(props.review_len - 1, 0))
                    current_val = self.review_scale.get()
                    if current_val != props.review_cursor:
                        self.review_scale.config(command="")
                        self.review_scale.set(props.review_cursor)
                        self.after(10, lambda: self.review_scale.config(command=self._on_review_seek))
                finally:
                    self._updating_scale = False
            self.review_position_label.config(text=f"{props.review_cursor}/{props.review_len}")
        else:
            self.review_frame.grid_remove()
        
    def _render_table(self, props: TableRendererProps) -> None:
        """Render the poker table visual"""
        self.canvas.delete("all")
        width, height = self.canvas.winfo_width(), self.canvas.winfo_height()
        if width <= 1: 
            width, height = 800, 600

        # Draw table felt
        self.canvas.create_oval(50, 50, width - 50, height - 50, 
                               fill="#0D4F3C", outline="#2D5016", width=3)
        
        # Draw components
        self._draw_seats(props, width, height)
        self._draw_community_cards(props, width, height)
        self._draw_pot(props, width, height)

    def _draw_seats(self, props: TableRendererProps, width: int, height: int) -> None:
        """Draw player seats around the table"""
        import math
        center_x, center_y = width / 2, height / 2
        radius_x, radius_y = (width - 120) / 2, (height - 120) / 2
        
        for seat_num, seat_state in props.seats.items():
            # Calculate position around table
            angle = (seat_num / max(len(props.seats), 1)) * 2 * math.pi - math.pi / 2
            x = center_x + radius_x * math.cos(angle)
            y = center_y + radius_y * math.sin(angle)
            
            # Determine seat color
            color = "#FFD700" if seat_state.acting else "#8B4513"
            if seat_state.folded:
                color = "#696969"
            
            # Draw seat background
            self.canvas.create_rectangle(x - 60, y - 30, x + 60, y + 30, 
                                       fill=color, outline="white", width=2)
            
            # Draw player name
            self.canvas.create_text(x, y - 15, text=seat_state.name, 
                                  fill="white", font=("Arial", 10, "bold"))
            
            # Draw stack
            self.canvas.create_text(x, y, text=f"${seat_state.stack}", 
                                  fill="white", font=("Arial", 9))
            
            # Draw current bet if any
            if seat_state.chips_in_front > 0:
                self.canvas.create_text(x, y + 15, text=f"Bet: ${seat_state.chips_in_front}", 
                                      fill="yellow", font=("Arial", 8))
            
            # Draw hole cards if visible
            if seat_state.cards:
                card_x = x - 15
                for i, card in enumerate(seat_state.cards[:2]):  # Show max 2 hole cards
                    self.canvas.create_rectangle(card_x + i*15, y - 45, card_x + i*15 + 12, y - 30,
                                               fill="white", outline="black")
                    self.canvas.create_text(card_x + i*15 + 6, y - 37.5, text=card,
                                          fill="black", font=("Arial", 6))

    def _draw_community_cards(self, props: TableRendererProps, width: int, height: int) -> None:
        """Draw community cards in center of table"""
        center_x, center_y = width / 2, height / 2 - 40
        
        if props.board:
            card_width, card_height = 25, 35
            total_width = len(props.board) * card_width + (len(props.board) - 1) * 5
            start_x = center_x - total_width / 2
            
            for i, card in enumerate(props.board):
                x = start_x + i * (card_width + 5)
                self.canvas.create_rectangle(x, center_y - card_height/2, 
                                           x + card_width, center_y + card_height/2,
                                           fill="white", outline="black", width=2)
                self.canvas.create_text(x + card_width/2, center_y, text=card,
                                      fill="black", font=("Arial", 8, "bold"))

    def _draw_pot(self, props: TableRendererProps, width: int, height: int) -> None:
        """Draw pot in center of table"""
        center_x, center_y = width / 2, height / 2 + 40
        self.canvas.create_text(center_x, center_y, text=f"Pot: ${props.pot}", 
                               font=("Arial", 16, "bold"), fill="white")

    def _on_toggle_autoplay(self) -> None:
        """Handle autoplay button click"""
        current_state = self.current_props.autoplay_on if self.current_props else False
        self.intent_handler.on_toggle_autoplay(not current_state)

    def _on_review_seek(self, value: str) -> None:
        """Handle review slider movement"""
        if hasattr(self, '_updating_scale') and self._updating_scale:
            return
        try:
            index = int(float(value))
            self.intent_handler.on_seek(index)
        except ValueError:
            pass


class DummyIntentHandler:
    """Dummy intent handler for testing"""
    def on_click_next(self) -> None:
        print("Dummy: Next")
    def on_toggle_autoplay(self, on: bool) -> None:
        print(f"Dummy: Auto-play {on}")
    def on_action_btn(self, action: str, amount: Optional[int] = None) -> None:
        print(f"Dummy: Action {action} {amount}")
    def on_seek(self, index: int) -> None:
        print(f"Dummy: Seek {index}")
    def on_request_hint(self) -> None:
        print("Dummy: Request hint")
```

---

### poker_table_renderer.py

**Path**: `backend/ui/renderers/poker_table_renderer.py`

**Size**: 6.7 KB

```python
"""
Pure state-driven poker table renderer.
This component ONLY renders ‚Äì no business logic, no state management.
"""

from __future__ import annotations

from typing import Any, Dict, List, Optional, Callable
from tkinter import ttk

from ..tableview.canvas_manager import CanvasManager
from ..tableview.layer_manager import LayerManager
from ..tableview.renderer_pipeline import RendererPipeline
from ..tableview.components.table_felt import TableFelt
from ..tableview.components.seats import Seats
from ..tableview.components.community import Community
from ..tableview.components.pot_display import PotDisplay
from ..tableview.components.bet_display import BetDisplay
from ..tableview.components.dealer_button import DealerButton
from ..tableview.components.player_highlighting import PlayerHighlighting


from ..table.state import PokerTableState


class PokerTableRenderer(ttk.Frame):
    """
    Pure rendering component for poker table.
    Renders state, emits intents, no business logic.
    """

    def __init__(
        self,
        parent,
        intent_handler: Optional[Callable[[Dict[str, Any]], None]] = None,
        theme_manager: Any = None,
    ) -> None:
        super().__init__(parent)
        self.intent_handler = intent_handler or (lambda _: None)
        self.theme_manager = theme_manager

        self._setup_rendering_pipeline()
        self.current_state: Optional[PokerTableState] = None
        self.renderer = None  # Will be initialized when canvas is ready
        self._ready_callbacks = []  # Callbacks to call when renderer is ready

    def _setup_rendering_pipeline(self) -> None:
        # Create CanvasManager first; it will initialize canvas lazily
        self.canvas_manager = CanvasManager(self)

        # Prepare components
        self.components = [
            TableFelt(),
            Seats(),
            Community(),
            BetDisplay(),
            PotDisplay(),
            DealerButton(),
            PlayerHighlighting(),
        ]

        # LayerManager depends on a real canvas; set up when ready
        def _finalize_pipeline():
            try:
                print(f"üîß PokerTableRenderer: Starting pipeline finalization...")
                print(f"üîß PokerTableRenderer: Canvas: {self.canvas_manager.canvas}")
                print(f"üîß PokerTableRenderer: Overlay: {self.canvas_manager.overlay}")
                
                self.layer_manager = LayerManager(
                    self.canvas_manager.canvas, self.canvas_manager.overlay
                )
                print(f"üîß PokerTableRenderer: LayerManager created: {self.layer_manager}")
                
                self.renderer = RendererPipeline(
                    self.canvas_manager, self.layer_manager, self.components
                )
                print(f"üîß PokerTableRenderer: Renderer created: {self.renderer is not None}")
                print(f"üîß PokerTableRenderer: Renderer object: {self.renderer}")
                
                # Grid now that canvas exists
                try:
                    self.canvas_manager.canvas.grid(row=0, column=0, sticky="nsew")
                    print(f"üîß PokerTableRenderer: Canvas gridded successfully")
                except Exception as grid_e:
                    print(f"‚ö†Ô∏è PokerTableRenderer: Canvas grid error: {grid_e}")
                    
                self.grid_columnconfigure(0, weight=1)
                self.grid_rowconfigure(0, weight=1)
                print("‚úÖ PokerTableRenderer: Pipeline finalized successfully")
                print(f"üîç PokerTableRenderer: Final renderer state: {hasattr(self, 'renderer')} / {self.renderer is not None}")
                
                # Notify any waiting callbacks that renderer is ready
                print(f"üîÑ PokerTableRenderer: Processing {len(self._ready_callbacks)} ready callbacks")
                for i, callback in enumerate(self._ready_callbacks):
                    try:
                        print(f"üîÑ PokerTableRenderer: Calling ready callback {i+1}")
                        callback()
                        print(f"‚úÖ PokerTableRenderer: Ready callback {i+1} completed")
                    except Exception as cb_e:
                        print(f"‚ö†Ô∏è PokerTableRenderer: Ready callback {i+1} error: {cb_e}")
                        import traceback
                        traceback.print_exc()
                self._ready_callbacks.clear()
                print(f"üîÑ PokerTableRenderer: All callbacks processed, renderer final check: {self.renderer is not None}")
                
            except Exception as e:
                print(f"‚ö†Ô∏è PokerTableRenderer finalize error: {e}")
                import traceback
                traceback.print_exc()
                # Initialize renderer to None to prevent AttributeError
                self.renderer = None

        if getattr(self.canvas_manager, 'is_ready', lambda: False)():
            _finalize_pipeline()
        else:
            # Defer until the canvas is created
            try:
                self.canvas_manager.defer_render(lambda: _finalize_pipeline())
            except Exception:
                pass

    def render(self, state: PokerTableState) -> None:
        if state != self.current_state:
            # Check if renderer is initialized
            has_attr = hasattr(self, 'renderer')
            is_not_none = has_attr and self.renderer is not None
            print(f"üîç PokerTableRenderer: Render check - hasattr: {has_attr}, not None: {is_not_none}")
            
            if not has_attr or self.renderer is None:
                print("‚ö†Ô∏è PokerTableRenderer: Renderer not ready, deferring render")
                # Defer render until renderer is ready
                self._ready_callbacks.append(lambda: self.render(state))
                print(f"üîÑ PokerTableRenderer: Render deferred via ready callback (callbacks: {len(self._ready_callbacks)})")
                return
            
            # Render table
            self.renderer.render_once(state.__dict__)
            # Process declarative effects
            self._process_effects(state.effects)
            self.current_state = state

    def _process_effects(self, effects: List[Dict[str, Any]]) -> None:
        """Emit intents for visual effects to be handled externally."""
        for effect in effects or []:
            et = effect.get("type")
            if et in {"CHIP_TO_POT", "POT_TO_WINNER", "HIGHLIGHT_PLAYER"}:
                # Pure visual effects handled here; acoustic handled by EffectBus
                self._emit_intent(
                    {"type": "REQUEST_ANIMATION", "payload": effect}
                )

    def _emit_intent(self, intent: Dict[str, Any]) -> None:
        try:
            self.intent_handler(intent)
        except Exception:
            pass


```

---

### __init__.py

**Path**: `backend/ui/services/__init__.py`

**Size**: 2 bytes

```python


```

---

### advanced_theme_manager.py

**Path**: `backend/ui/services/advanced_theme_manager.py`

**Size**: 20.4 KB

```python
"""
Advanced Theme Manager with real-time color editing, hue adjustment, and theme customization.
Provides a comprehensive interface for theme creation, modification, and management.
"""

import json
import colorsys
from pathlib import Path
from typing import Dict, Any, Optional, Tuple, List
from dataclasses import dataclass


@dataclass
class ColorAdjustment:
    """Represents a color adjustment with hue, saturation, and lightness deltas."""
    hue_shift: float = 0.0      # -180 to +180 degrees
    saturation_delta: float = 0.0  # -1.0 to +1.0
    lightness_delta: float = 0.0   # -1.0 to +1.0


class AdvancedThemeManager:
    """
    Advanced theme management system with real-time editing capabilities.
    
    Features:
    - Real-time color palette editing
    - Hue/saturation/lightness adjustments
    - Theme creation and saving
    - Import/export functionality
    - Robust fallback defaults
    - Live preview capabilities
    """
    
    def __init__(self, theme_file_path: Optional[str] = None):
        if theme_file_path is None:
            backend_dir = Path(__file__).parent.parent.parent
            theme_file_path = str(backend_dir / "data" / "poker_themes.json")
        
        self.theme_file_path = theme_file_path
        self._themes: Dict[str, Dict[str, Any]] = {}
        self._defaults: Dict[str, Any] = {}
        self._current_theme_id: Optional[str] = None
        self._custom_themes: Dict[str, Dict[str, Any]] = {}
        self._unsaved_changes: Dict[str, Dict[str, Any]] = {}
        
        self.load_themes()
    
    def load_themes(self) -> bool:
        """Load themes from JSON file with fallback defaults."""
        try:
            with open(self.theme_file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
                
            self._defaults = data.get('defaults', {})
            themes_list = data.get('themes', [])
            
            # Convert themes list to dict by ID
            self._themes = {theme['id']: theme for theme in themes_list}
            
            print(f"‚úÖ Loaded {len(self._themes)} themes from {self.theme_file_path}")
            return True
            
        except Exception as e:
            print(f"‚ö†Ô∏è Failed to load themes: {e}")
            self._load_fallback_defaults()
            return False
    
    def _load_fallback_defaults(self):
        """Load robust fallback defaults when theme file is unavailable."""
        self._defaults = {
            "dimensions": {
                "padding": {"small": 5, "medium": 8, "large": 16, "xlarge": 18},
                "text_height": {"small": 3, "medium": 4, "large": 6},
                "border_width": {"thin": 1, "medium": 2, "thick": 3},
                "widget_width": {"narrow": 5, "medium": 8, "wide": 12}
            }
        }
        
        # Create a basic fallback theme
        self._themes = {
            "forest-green-pro": {
                "id": "forest-green-pro",
                "name": "Forest Green Professional üåø",
                "intro": "Classic casino green with dark wood rails‚Äîcalm, familiar, and relentlessly focused.",
                "persona": "Doyle Brunson",
                "palette": {
                    "felt": "#2D5A3D",
                    "rail": "#4A3428",
                    "metal": "#C9A34E",
                    "accent": "#1DB954",
                    "raise": "#B63D3D",
                    "call": "#2AA37A",
                    "neutral": "#9AA0A6",
                    "text": "#EDECEC",
                    "highlight": "#D4AF37",
                    "highlight_text": "#0B0B0E",
                    "emphasis_text": "#F8E7C9",
                    "emphasis_bg_top": "#314F3A",
                    "emphasis_bg_bottom": "#1E3A28",
                    "emphasis_border": "#A88433",
                    "emphasis_accent_text": "#D4AF37"
                }
            }
        }
        print("‚úÖ Loaded fallback default theme")
    
    def get_theme_ids(self) -> List[str]:
        """Get list of all available theme IDs."""
        return list(self._themes.keys())
    
    def get_theme_names(self) -> List[str]:
        """Get list of all theme display names."""
        return [theme['name'] for theme in self._themes.values()]
    
    def get_theme_by_id(self, theme_id: str) -> Optional[Dict[str, Any]]:
        """Get theme configuration by ID."""
        return self._themes.get(theme_id)
    
    def get_theme_by_name(self, theme_name: str) -> Optional[Dict[str, Any]]:
        """Get theme configuration by display name."""
        for theme in self._themes.values():
            if theme.get('name') == theme_name:
                return theme
        return None
    
    def get_current_theme(self) -> Optional[Dict[str, Any]]:
        """Get currently selected theme."""
        if self._current_theme_id:
            return self.get_theme_by_id(self._current_theme_id)
        return None
    
    def set_current_theme(self, theme_id: str) -> bool:
        """Set the current theme by ID."""
        if theme_id in self._themes:
            self._current_theme_id = theme_id
            return True
        return False
    
    def get_palette(self, theme_id: Optional[str] = None) -> Dict[str, str]:
        """Get color palette for specified theme or current theme."""
        if theme_id is None:
            theme_id = self._current_theme_id
        
        if theme_id and theme_id in self._themes:
            return self._themes[theme_id].get('palette', {}).copy()
        
        # Return fallback palette
        return self._get_fallback_palette()
    
    def _get_fallback_palette(self) -> Dict[str, str]:
        """Get fallback color palette."""
        return {
            "felt": "#2D5A3D",
            "rail": "#4A3428", 
            "metal": "#C9A34E",
            "accent": "#1DB954",
            "raise": "#B63D3D",
            "call": "#2AA37A",
            "neutral": "#9AA0A6",
            "text": "#EDECEC",
            "highlight": "#D4AF37",
            "highlight_text": "#0B0B0E",
            "emphasis_text": "#F8E7C9",
            "emphasis_bg_top": "#314F3A",
            "emphasis_bg_bottom": "#1E3A28", 
            "emphasis_border": "#A88433",
            "emphasis_accent_text": "#D4AF37"
        }
    
    def update_color(self, theme_id: str, color_key: str, new_color: str) -> bool:
        """Update a specific color in a theme's palette."""
        if theme_id not in self._themes:
            return False
        
        # Store change in unsaved changes
        if theme_id not in self._unsaved_changes:
            self._unsaved_changes[theme_id] = {}
        
        self._unsaved_changes[theme_id][color_key] = new_color
        
        # Apply change immediately for live preview
        self._themes[theme_id]['palette'][color_key] = new_color
        return True
    
    def adjust_hue(self, theme_id: str, hue_shift_degrees: float) -> bool:
        """Adjust hue for all colors in a theme's palette."""
        if theme_id not in self._themes:
            return False
        
        palette = self._themes[theme_id]['palette']
        
        for color_key, hex_color in palette.items():
            if hex_color.startswith('#') and len(hex_color) == 7:
                new_color = self._adjust_color_hue(hex_color, hue_shift_degrees)
                self.update_color(theme_id, color_key, new_color)
        
        return True
    
    def adjust_saturation(self, theme_id: str, saturation_delta: float) -> bool:
        """Adjust saturation for all colors in a theme's palette."""
        if theme_id not in self._themes:
            return False
        
        palette = self._themes[theme_id]['palette']
        
        for color_key, hex_color in palette.items():
            if hex_color.startswith('#') and len(hex_color) == 7:
                new_color = self._adjust_color_saturation(hex_color, saturation_delta)
                self.update_color(theme_id, color_key, new_color)
        
        return True
    
    def adjust_lightness(self, theme_id: str, lightness_delta: float) -> bool:
        """Adjust lightness for all colors in a theme's palette."""
        if theme_id not in self._themes:
            return False
        
        palette = self._themes[theme_id]['palette']
        
        for color_key, hex_color in palette.items():
            if hex_color.startswith('#') and len(hex_color) == 7:
                new_color = self._adjust_color_lightness(hex_color, lightness_delta)
                self.update_color(theme_id, color_key, new_color)
        
        return True
    
    def _adjust_color_hue(self, hex_color: str, hue_shift_degrees: float) -> str:
        """Adjust the hue of a hex color."""
        try:
            # Convert hex to RGB
            hex_color = hex_color.lstrip('#')
            r, g, b = tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
            
            # Convert to HSL
            h, l, s = colorsys.rgb_to_hls(r/255.0, g/255.0, b/255.0)
            
            # Adjust hue (wrap around)
            h = (h + hue_shift_degrees/360.0) % 1.0
            
            # Convert back to RGB
            r, g, b = colorsys.hls_to_rgb(h, l, s)
            r, g, b = int(r*255), int(g*255), int(b*255)
            
            return f"#{r:02X}{g:02X}{b:02X}"
        except:
            return hex_color
    
    def _adjust_color_saturation(self, hex_color: str, saturation_delta: float) -> str:
        """Adjust the saturation of a hex color."""
        try:
            hex_color = hex_color.lstrip('#')
            r, g, b = tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
            
            h, l, s = colorsys.rgb_to_hls(r/255.0, g/255.0, b/255.0)
            s = max(0.0, min(1.0, s + saturation_delta))
            
            r, g, b = colorsys.hls_to_rgb(h, l, s)
            r, g, b = int(r*255), int(g*255), int(b*255)
            
            return f"#{r:02X}{g:02X}{b:02X}"
        except:
            return hex_color
    
    def _adjust_color_lightness(self, hex_color: str, lightness_delta: float) -> str:
        """Adjust the lightness of a hex color."""
        try:
            hex_color = hex_color.lstrip('#')
            r, g, b = tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
            
            h, l, s = colorsys.rgb_to_hls(r/255.0, g/255.0, b/255.0)
            l = max(0.0, min(1.0, l + lightness_delta))
            
            r, g, b = colorsys.hls_to_rgb(h, l, s)
            r, g, b = int(r*255), int(g*255), int(b*255)
            
            return f"#{r:02X}{g:02X}{b:02X}"
        except:
            return hex_color
    
    def create_theme(self, name: str, base_theme_id: Optional[str] = None) -> str:
        """Create a new custom theme, optionally based on an existing theme."""
        # Generate unique ID
        theme_id = name.lower().replace(' ', '-').replace('üåø', '').replace('üç∑', '').replace('üíé', '').replace('üåå', '').replace('‚ù§Ô∏è‚Äçüî•', '').replace('ü™∏', '').replace('üåá', '').replace('‚ú®', '').replace('üèõÔ∏è', '').replace('üåä', '').replace('üî∑', '').replace('üé®', '').replace('üïØÔ∏è', '').replace('üñ§', '').replace('üåÖ', '').replace('‚ö°', '').strip()
        
        # Ensure unique ID
        counter = 1
        original_id = theme_id
        while theme_id in self._themes:
            theme_id = f"{original_id}-{counter}"
            counter += 1
        
        # Create theme based on existing theme or defaults
        if base_theme_id and base_theme_id in self._themes:
            base_theme = self._themes[base_theme_id].copy()
            new_theme = {
                "id": theme_id,
                "name": name,
                "intro": f"Custom theme based on {base_theme.get('name', 'Unknown')}",
                "persona": "Custom",
                "palette": base_theme['palette'].copy()
            }
        else:
            new_theme = {
                "id": theme_id,
                "name": name,
                "intro": "Custom poker theme with distinctive character.",
                "persona": "Custom",
                "palette": self._get_fallback_palette()
            }
        
        self._themes[theme_id] = new_theme
        self._custom_themes[theme_id] = new_theme
        return theme_id
    
    def duplicate_theme(self, source_theme_id: str, new_name: str) -> Optional[str]:
        """Duplicate an existing theme with a new name."""
        if source_theme_id not in self._themes:
            return None
        
        return self.create_theme(new_name, source_theme_id)
    
    def delete_theme(self, theme_id: str) -> bool:
        """Delete a custom theme (cannot delete built-in themes)."""
        if theme_id in self._custom_themes:
            del self._custom_themes[theme_id]
            del self._themes[theme_id]
            if theme_id in self._unsaved_changes:
                del self._unsaved_changes[theme_id]
            return True
        return False
    
    def save_theme(self, theme_id: str) -> bool:
        """Save a theme's changes to the JSON file."""
        try:
            # Load current file data
            with open(self.theme_file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            # Update the theme in the data
            themes_list = data.get('themes', [])
            
            # Find and update existing theme or add new one
            theme_found = False
            for i, theme in enumerate(themes_list):
                if theme['id'] == theme_id:
                    themes_list[i] = self._themes[theme_id]
                    theme_found = True
                    break
            
            if not theme_found:
                # Add new theme
                themes_list.append(self._themes[theme_id])
            
            data['themes'] = themes_list
            
            # Save back to file
            with open(self.theme_file_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2)
            
            # Clear unsaved changes for this theme
            if theme_id in self._unsaved_changes:
                del self._unsaved_changes[theme_id]
            
            print(f"‚úÖ Saved theme '{theme_id}' to {self.theme_file_path}")
            return True
            
        except Exception as e:
            print(f"‚ùå Failed to save theme '{theme_id}': {e}")
            return False
    
    def has_unsaved_changes(self, theme_id: Optional[str] = None) -> bool:
        """Check if there are unsaved changes for a theme or any theme."""
        if theme_id:
            return theme_id in self._unsaved_changes
        return len(self._unsaved_changes) > 0
    
    def revert_changes(self, theme_id: str) -> bool:
        """Revert unsaved changes for a theme."""
        if theme_id in self._unsaved_changes:
            del self._unsaved_changes[theme_id]
            # Reload the theme from file
            self.load_themes()
            return True
        return False
    
    def export_theme(self, theme_id: str, export_path: str) -> bool:
        """Export a single theme to a JSON file."""
        if theme_id not in self._themes:
            return False
        
        try:
            export_data = {
                "version": "2.0",
                "themes": [self._themes[theme_id]]
            }
            
            with open(export_path, 'w', encoding='utf-8') as f:
                json.dump(export_data, f, indent=2)
            
            print(f"‚úÖ Exported theme '{theme_id}' to {export_path}")
            return True
            
        except Exception as e:
            print(f"‚ùå Failed to export theme '{theme_id}': {e}")
            return False
    
    def import_theme(self, import_path: str) -> List[str]:
        """Import themes from a JSON file. Returns list of imported theme IDs."""
        try:
            with open(import_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            imported_themes = []
            themes_list = data.get('themes', [])
            
            for theme in themes_list:
                theme_id = theme.get('id')
                if theme_id:
                    # Handle name conflicts
                    original_id = theme_id
                    counter = 1
                    while theme_id in self._themes:
                        theme_id = f"{original_id}-imported-{counter}"
                        counter += 1
                    
                    theme['id'] = theme_id
                    self._themes[theme_id] = theme
                    self._custom_themes[theme_id] = theme
                    imported_themes.append(theme_id)
            
            print(f"‚úÖ Imported {len(imported_themes)} themes from {import_path}")
            return imported_themes
            
        except Exception as e:
            print(f"‚ùå Failed to import themes from {import_path}: {e}")
            return []
    
    def get_color_info(self, hex_color: str) -> Dict[str, Any]:
        """Get detailed color information (HSL values, etc.)."""
        try:
            hex_color = hex_color.lstrip('#')
            r, g, b = tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
            h, l, s = colorsys.rgb_to_hls(r/255.0, g/255.0, b/255.0)
            
            return {
                "hex": f"#{hex_color.upper()}",
                "rgb": (r, g, b),
                "hue": h * 360,
                "saturation": s * 100,
                "lightness": l * 100
            }
        except:
            return {"hex": "#000000", "rgb": (0, 0, 0), "hue": 0, "saturation": 0, "lightness": 0}
    
    def calculate_contrast_ratio(self, color1: str, color2: str) -> float:
        """Calculate WCAG contrast ratio between two colors."""
        try:
            def luminance(hex_color):
                hex_color = hex_color.lstrip('#')
                r, g, b = tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
                
                def gamma_correct(c):
                    c = c / 255.0
                    return c / 12.92 if c <= 0.03928 else ((c + 0.055) / 1.055) ** 2.4
                
                r, g, b = map(gamma_correct, (r, g, b))
                return 0.2126 * r + 0.7152 * g + 0.0722 * b
            
            l1 = luminance(color1)
            l2 = luminance(color2)
            
            lighter = max(l1, l2)
            darker = min(l1, l2)
            
            return (lighter + 0.05) / (darker + 0.05)
        except:
            return 1.0
    
    def suggest_contrast_fix(self, bg_color: str, text_color: str, min_ratio: float = 4.5) -> Optional[str]:
        """Suggest a text color that meets contrast requirements against background."""
        current_ratio = self.calculate_contrast_ratio(bg_color, text_color)
        
        if current_ratio >= min_ratio:
            return None  # Already good
        
        # Try common high-contrast alternatives
        alternatives = ["#FFFFFF", "#F8F8F8", "#000000", "#0D0D0D"]
        
        for alt_color in alternatives:
            if self.calculate_contrast_ratio(bg_color, alt_color) >= min_ratio:
                return alt_color
        
        # If no standard alternative works, try adjusting lightness
        try:
            hex_color = text_color.lstrip('#')
            r, g, b = tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
            h, l, s = colorsys.rgb_to_hls(r/255.0, g/255.0, b/255.0)
            
            # Try making it much lighter or much darker
            for new_l in [0.95, 0.05, 0.85, 0.15]:
                r, g, b = colorsys.hls_to_rgb(h, new_l, s)
                r, g, b = int(r*255), int(g*255), int(b*255)
                suggested = f"#{r:02X}{g:02X}{b:02X}"
                
                if self.calculate_contrast_ratio(bg_color, suggested) >= min_ratio:
                    return suggested
        except:
            pass
        
        return "#FFFFFF"  # Ultimate fallback
    
    def reset_theme_to_default(self, theme_id: str) -> bool:
        """Reset a theme to its original default values."""
        if theme_id in self._unsaved_changes:
            del self._unsaved_changes[theme_id]
        
        # Reload from file to get original values
        self.load_themes()
        return theme_id in self._themes
    
    def get_theme_statistics(self) -> Dict[str, Any]:
        """Get statistics about the theme system."""
        return {
            "total_themes": len(self._themes),
            "custom_themes": len(self._custom_themes),
            "unsaved_changes": len(self._unsaved_changes),
            "current_theme": self._current_theme_id,
            "theme_file_path": self.theme_file_path
        }
```

---

### effect_bus.py

**Path**: `backend/ui/services/effect_bus.py`

**Size**: 21.8 KB

```python
#!/usr/bin/env python3
"""
EffectBus - Coordinates sounds & animations; integrates with GameDirector.
"""
from __future__ import annotations

import os
import json
from typing import Dict, Any, List, Optional
from pathlib import Path
from dataclasses import dataclass, field

# Import VoiceManager for human voice announcements
try:
    from ...utils.voice_manager import VoiceManager
except ImportError:
    try:
        from utils.voice_manager import VoiceManager
    except ImportError:
        try:
            from backend.utils.voice_manager import VoiceManager
        except ImportError:
            VoiceManager = None


# Minimal effect representation
@dataclass
class Effect:
    type: str
    id: Optional[str] = None
    name: Optional[str] = None
    ms: int = 200
    args: Dict[str, Any] = field(default_factory=dict)


class EffectBus:
    def __init__(self, game_director=None, sound_manager=None, event_bus=None, renderer=None):
        self.director = game_director
        self.sound = sound_manager
        self.event_bus = event_bus
        self.renderer = renderer
        self.enabled = True
        self.effects: List[Effect] = []
        self.next_id = 0
        
        # Initialize VoiceManager for human voice announcements
        self.voice_manager = None
        if VoiceManager:
            try:
                self.voice_manager = VoiceManager()
                print("üîä EffectBus: VoiceManager initialized for human voice announcements")
            except Exception as e:
                print(f"‚ö†Ô∏è EffectBus: VoiceManager not available: {e}")
        
        # Initialize pygame mixer for audio
        try:
            import pygame
            pygame.mixer.init(
                frequency=22050, size=-16, channels=2, buffer=512
            )
            self.pygame_available = True
            print("üîä EffectBus: Pygame mixer initialized for audio")
        except Exception as e:
            self.pygame_available = False
            print(f"‚ö†Ô∏è EffectBus: Pygame mixer not available: {e}")
        
        # Load sound configuration from file
        self.sound_mapping = {}
        self.config: Dict[str, Any] = {}
        self._load_sound_config()
        
        # Load sound files
        self.sounds = {}
        self._load_sounds()
    
    def _load_sound_config(self):
        """Load sound configuration from JSON file."""
        try:
            config_file = os.path.join(
                os.path.dirname(__file__), '..', '..', 'sounds',
                'poker_sound_config.json'
            )

            if os.path.exists(config_file):
                with open(config_file, 'r') as f:
                    config = json.load(f)

                # Save full config for voice lookups
                self.config = config

                # Load sound mappings
                self.sound_mapping = config.get("sounds", {})

                # Load global settings
                self.master_volume = config.get("master_volume", 1.0)
                self.sounds_enabled = config.get("sounds_enabled", True)
                self.voice_enabled = config.get("voice_enabled", True)
                self.voice_type = config.get("voice_type", "announcer_female")

                # Optional base directory for sounds
                self.sound_dir_hint = Path(config.get("sound_directory", "sounds"))

                print(f"üîä EffectBus: Loaded sound config with {len(self.sound_mapping)} mappings")
            else:
                print(f"‚ö†Ô∏è EffectBus: Sound config file not found: {config_file}")
                # Use empty mapping - let the UI handle defaults
                self.config = {}
                self.sound_mapping = {}
                self.master_volume = 1.0
                self.sounds_enabled = True
                self.voice_enabled = True
                self.voice_type = "announcer_female"
                self.sound_dir_hint = Path("sounds")

        except Exception as e:
            print(f"‚ö†Ô∏è EffectBus: Error loading sound config: {e}")
            # Fallback to empty mappings
            self.config = {}
            self.sound_mapping = {}
            self.master_volume = 1.0
            self.sounds_enabled = True
            self.voice_enabled = True
            self.voice_type = "announcer_female"
            self.sound_dir_hint = Path("sounds")
    
    def reload_sound_config(self):
        """Dynamically reload sound configuration from file."""
        print("üîÑ EffectBus: Reloading sound configuration...")
        self._load_sound_config()
        # Clear existing loaded sounds to force reload
        self.sounds.clear()
        # Reload sounds with new mapping
        self._load_sounds()
        print(f"‚úÖ EffectBus: Reloaded sound config with {len(self.sound_mapping)} mappings")

    def set_game_director(self, game_director):
        """Set the game director for coordinating effects timing."""
        self.director = game_director
        print(f"üîä EffectBus: Connected to GameDirector")

    def set_event_bus(self, event_bus):
        """Set the event bus for publishing effect events."""
        self.event_bus = event_bus
        print(f"üîä EffectBus: Connected to EventBus")
        # Bridge basic animate events to ChipAnimations if a renderer is present
        try:
            if self.event_bus is not None:
                self.event_bus.subscribe("effect_bus:animate", self._on_animation_request)
        except Exception:
            pass

    def _resolve_sound_path(self, rel_or_abs: str) -> Optional[Path]:
        """Resolve a sound path robustly across likely locations."""
        try:
            # Absolute path as-is
            p = Path(rel_or_abs)
            if p.is_file():
                return p

            # Relative to configured sounds dir if provided
            if hasattr(self, 'sound_dir_hint'):
                cand = self.sound_dir_hint / rel_or_abs
                if cand.is_file():
                    return cand

            # Relative to this module's ../../sounds
            here = Path(__file__).parent
            cand2 = (here / '..' / '..' / 'sounds').resolve() / rel_or_abs
            if cand2.is_file():
                return cand2

            # Relative to CWD/sounds
            cand3 = Path.cwd() / 'sounds' / rel_or_abs
            if cand3.is_file():
                return cand3
        except Exception:
            pass
        return None

    def _load_sounds(self):
        """Load all available sound files."""
        if not self.pygame_available:
            return
            
        try:
            import pygame
            for action, filename in self.sound_mapping.items():
                resolved = self._resolve_sound_path(filename)
                if resolved and resolved.exists() and resolved.stat().st_size > 100:
                    try:
                        sound = pygame.mixer.Sound(str(resolved))
                        self.sounds[action.upper()] = sound
                        print(f"üîä EffectBus: Loaded sound {action} -> {resolved}")
                    except Exception as e:
                        print(f"‚ö†Ô∏è EffectBus: Failed to load {filename}: {e}")
                else:
                    print(f"‚ö†Ô∏è EffectBus: Sound file not found or empty: {filename}")
                    
            print(f"üîä EffectBus: Loaded {len(self.sounds)} sound files")
        except Exception as e:
            print(f"‚ö†Ô∏è EffectBus: Error loading sounds: {e}")

    def add_effect(self, effect: Effect) -> str:
        """Add an effect to the queue."""
        if not self.enabled:
            return ""
            
        effect.id = f"{effect.type}_{self.next_id}"
        self.next_id += 1
        self.effects.append(effect)
        
        # Notify event bus
        if self.event_bus:
            self.event_bus.publish(f"effect_bus:{effect.type}", {
                "id": effect.id,
                "name": effect.name,
                "ms": effect.ms,
                "args": effect.args
            })
        
        return effect.id

    def add_sound_effect(self, sound_name: str, ms: int = 200):
        """Add sound effect with proper gating, even if pygame audio fails."""
        # try to play; don't crash if mixer is unavailable
        played = False
        try:
            if hasattr(self, 'pygame_available') and self.pygame_available:
                import pygame
                # First try to use pre-loaded sound from self.sounds
                if sound_name in self.sounds:
                    try:
                        sound = self.sounds[sound_name]
                        sound.set_volume(self.master_volume)
                        sound.play()
                        played = True
                        print(f"üîä EffectBus: Playing pre-loaded sound: {sound_name}")
                    except Exception as e:
                        print(f"‚ö†Ô∏è EffectBus: Failed to play pre-loaded sound {sound_name}: {e}")
                        played = False
                else:
                    # Fallback: try to load from file mapping
                    sound_file = self.sound_mapping.get(sound_name.upper(), "")
                    if sound_file:
                        resolved = self._resolve_sound_path(sound_file)
                        try:
                            if resolved and resolved.exists():
                                sound = pygame.mixer.Sound(str(resolved))
                                sound.set_volume(self.master_volume)
                                sound.play()
                                played = True
                                print(f"üîä EffectBus: Playing sound {sound_name} -> {resolved}")
                            else:
                                print(f"‚ö†Ô∏è EffectBus: Could not resolve sound path for {sound_file}")
                                played = False
                        except Exception as e:
                            print(f"‚ö†Ô∏è EffectBus: Failed to play {sound_file}: {e}")
                            played = False
                    else:
                        print(f"‚ö†Ô∏è EffectBus: No sound mapping found for {sound_name}")
        except Exception as e:
            print(f"‚ö†Ô∏è EffectBus: Error in add_sound_effect: {e}")
            played = False

        # Gate autoplay regardless of audio success. Use the director to schedule
        # a SOUND_COMPLETE event so the autoplay rhythm stays deterministic.
        if self.director:
            try:
                self.director.gate_begin()
                # Use ms even if sound didn't play to keep timing consistent
                self.director.schedule(ms, {"type": "SOUND_COMPLETE", "id": sound_name},
                                       callback=self.director.notify_sound_complete)
            except Exception:
                # Ensure gate_end still occurs in case schedule failed
                try:
                    self.director.gate_end()
                except Exception:
                    pass

        # optional: telemetry/log
        if self.event_bus:
            self.event_bus.publish("effect_bus:sound", {"id": sound_name, "ms": ms})

    def add_animation_effect(self, name: str, ms: int = 250, args: dict | None = None):
        """Add animation effect with proper gating."""
        args = args or {}
        if self.event_bus:
            self.event_bus.publish("effect_bus:animate", {"name": name, "ms": ms, "args": args})

        if self.director:
            self.director.gate_begin()
            self.director.schedule(ms, {"type": "ANIM_COMPLETE", "name": name},
                                   callback=self.director.notify_animation_complete)

    # --- Animation bridge ---
    def _on_animation_request(self, payload: dict):
        """Translate simple animate events to ChipAnimations drawing calls.
        Requires renderer with canvas and theme_manager context.
        """
        try:
            name = (payload or {}).get("name", "")
            args = (payload or {}).get("args", {}) or {}
            renderer = getattr(self, "renderer", None)
            if renderer is None:
                return
            canvas = getattr(renderer, "canvas_manager", None)
            canvas = getattr(canvas, "canvas", None)
            theme_manager = getattr(renderer, "theme_manager", None)
            if canvas is None or theme_manager is None:
                return
            from ..tableview.components.chip_animations import ChipAnimations
            anim = ChipAnimations(theme_manager)

            if name == "chips_to_pot":
                anim.fly_chips_to_pot(
                    canvas,
                    args.get("from_x", 0), args.get("from_y", 0),
                    args.get("to_x", 0), args.get("to_y", 0),
                    int(args.get("amount", 0)),
                )
            elif name == "pot_to_winner":
                anim.fly_pot_to_winner(
                    canvas,
                    args.get("pot_x", 0), args.get("pot_y", 0),
                    args.get("winner_x", 0), args.get("winner_y", 0),
                    int(args.get("amount", 0)),
                )
        except Exception:
            pass

    def add_banner_effect(self, message: str, banner_type: str = "info", ms: int = 2000) -> str:
        """Add a banner notification effect."""
        effect = Effect(
            type="banner",
            name=message,
            ms=ms,
            args={"type": banner_type}
        )
        return self.add_effect(effect)

    def add_poker_action_effects(self, action_type: str, player_name: str = ""):
        """Add poker action effects with proper sound mapping and gating."""
        action_type = (action_type or "").upper()
        
        # Debug: log what we're receiving
        print(f"üîä DEBUG: EffectBus received action_type: '{action_type}'")

        # Use config-driven sound mapping from poker_sound_config.json
        # The sound_map is loaded dynamically from the config file
        sound_map = self.sound_mapping
        
        maybe = sound_map.get(action_type)
        if maybe:
            print(f"üîä DEBUG: Found sound mapping for '{action_type}' -> '{maybe}'")
            self.add_sound_effect(action_type, ms=220)   # Pass action_type, not filename
        else:
            print(f"üîä DEBUG: No sound mapping found for '{action_type}'")
            print(f"üîä DEBUG: Available sound mappings: {list(sound_map.keys())}")

        # Add voice announcements for key actions via event bus and direct playback
        voice_action = self._map_action_to_voice(action_type)
        if self.voice_enabled and voice_action and hasattr(self, 'voice_manager') and self.voice_manager:
            try:
                print(f"üîä DEBUG: Playing voice for action '{action_type}' -> '{voice_action}'")
                self.voice_manager.play_action_voice(voice_action.lower(), 0)
            except Exception as e:
                print(f"üîä DEBUG: Voice playback failed: {e}")
        elif self.voice_enabled:
            # 1) Publish event for listeners
            if self.event_bus:
                self.event_bus.publish(
                    "effect_bus:voice",
                    {"type": "POKER_ACTION", "action": voice_action, "player": player_name},
                )
            print(f"üîä EffectBus: Emitted voice event: {voice_action}")

            # 2) Direct playback via VoiceManager if available
            try:
                if self.voice_manager:
                    voice_sounds = (self.config or {}).get("voice_sounds", {})
                    voice_table = voice_sounds.get(self.voice_type or "", {})
                    file_rel = voice_table.get(voice_action)
                    if file_rel:
                        self.voice_manager.play(file_rel)
            except Exception as e:
                print(f"‚ö†Ô∏è EffectBus: Voice playback failed: {e}")

        if action_type == "SHOWDOWN":
            self.add_sound_effect("ui_winner", ms=700)

        # Publish simple banner text (optional)
        if self.event_bus:
            txt = f"{player_name or 'Player'} {action_type}"
            self.event_bus.publish("effect_bus:banner_show", {"style": "action", "text": txt})

        # Publish animation events for chip movements
        if action_type in ("DEAL_BOARD", "DEAL_FLOP", "DEAL_TURN", "DEAL_RIVER"):
            self.add_animation_effect("chips_to_pot", ms=260)

        if action_type in ("SHOWDOWN", "END_HAND"):
            self.add_animation_effect("pot_to_winner", ms=520)
            if self.event_bus:
                self.event_bus.publish("effect_bus:banner_show",
                    {"style": "winner", "text": f"{player_name or 'Player'} wins!"})

    def update(self):
        """Update effect processing."""
        if not self.enabled:
            return
            
        # Process effects
        for effect in self.effects[:]:
            if effect.type == "sound":
                self._play_sound(effect)
            elif effect.type == "animation":
                self._start_animation(effect)
            elif effect.type == "banner":
                self._show_banner(effect)
            
            # Remove processed effects
            self.effects.remove(effect)

    def _play_sound(self, effect: Effect):
        """Play a sound effect."""
        if not self.pygame_available or not self.sounds:
            return
            
        try:
            sound_name = effect.name
            if sound_name in self.sounds:
                # Gate effects while sound plays
                if self.director:
                    self.director.gate_begin()
                
                # Play the sound
                try:
                    self.sounds[sound_name].play()
                except Exception:
                    pass
                print(f"üîä EffectBus: Playing sound: {sound_name}")
                
                # Schedule gate end through GameDirector only (no Tk timers)
                if self.director:
                    try:
                        self.director.schedule(
                            effect.ms,
                            {"type": "SOUND_COMPLETE", "id": effect.id},
                            callback=self.director.notify_sound_complete,
                        )
                    except Exception:
                        try:
                            self.director.gate_end()
                        except Exception:
                            pass
            else:
                print(f"‚ö†Ô∏è EffectBus: Sound not found: {sound_name}")
        except Exception as e:
            print(f"‚ö†Ô∏è EffectBus: Error playing sound: {e}")
            if self.director:
                self.director.gate_end()

    def _start_animation(self, effect: Effect):
        """Start an animation effect."""
        try:
            # Gate effects while animation runs
            if self.director:
                self.director.gate_begin()
            
            print(f"üé¨ EffectBus: Started animation: {effect.name}")
            
            # Publish animation event
            if self.event_bus:
                self.event_bus.publish("effect_bus:animate", {
                    "id": effect.id,
                    "name": effect.name,
                    "ms": effect.ms,
                    "args": effect.args
                })
            
            # Schedule gate end through GameDirector only (no Tk timers)
            if self.director:
                try:
                    self.director.schedule(
                        effect.ms,
                        {"type": "ANIM_COMPLETE", "name": effect.name},
                        callback=self.director.notify_animation_complete,
                    )
                except Exception:
                    try:
                        self.director.gate_end()
                    except Exception:
                        pass
        except Exception as e:
            print(f"‚ö†Ô∏è EffectBus: Error starting animation: {e}")
            if self.director:
                self.director.gate_end()

    def _show_banner(self, effect: Effect):
        """Show a banner notification."""
        try:
            # Publish banner event
            if self.event_bus:
                self.event_bus.publish("effect_bus:banner_show", {
                    "id": effect.id,
                    "message": effect.name,
                    "type": effect.args.get("type", "info"),
                    "ms": effect.ms
                })
                print(f"üé≠ EffectBus: Added banner effect: {effect.name}")
        except Exception as e:
            print(f"‚ö†Ô∏è EffectBus: Error showing banner: {e}")

    def clear_queue(self):
        """Clear all pending effects."""
        self.effects.clear()

    def stop_all_effects(self):
        """Stop all running effects."""
        if self.pygame_available:
            try:
                import pygame
                pygame.mixer.stop()
            except:
                pass
        self.clear_queue()

    def get_status(self) -> Dict[str, Any]:
        """Get current status."""
        return {
            "enabled": self.enabled,
            "effects_count": len(self.effects),
            "sounds_loaded": len(self.sounds),
            "pygame_available": self.pygame_available
        }

    def set_effect_enabled(self, enabled: bool):
        """Enable/disable effects."""
        self.enabled = enabled

    def _map_action_to_voice(self, action_type: str) -> str:
        """Map poker action types to voice announcement actions."""
        voice_map = {
            "BET": "bet",
            "RAISE": "raise", 
            "CALL": "call",
            "CHECK": "check",
            "FOLD": "fold",
            "ALL_IN": "all_in",
            "DEAL_HOLE": "dealing",
            "DEAL_BOARD": "dealing",
            "POST_BLIND": "dealing",
            "SHOWDOWN": "winner",
            "END_HAND": "winner"
        }
        return voice_map.get(action_type, "")


class NoopEffectBus:
    """No-op EffectBus for testing."""
    def __init__(self, *args, **kwargs):
        pass
    
    def __getattr__(self, name):
        return lambda *args, **kwargs: None
```

---

### event_bus.py

**Path**: `backend/ui/services/event_bus.py`

**Size**: 1.0 KB

```python
from collections import defaultdict
from typing import Any, Callable, Dict, List


class EventBus:
    """
    Simple in-memory pub/sub event bus with string topics.

    Topics should be namespaced using a session identifier to prevent
    cross-talk between tabs/sessions.
    Example: f"{session_id}:ui:action".
    """

    def __init__(self) -> None:
        self._subs: Dict[str, List[Callable[[Any], None]]] = defaultdict(list)

    def topic(self, session_id: str, name: str) -> str:
        return f"{session_id}:{name}"

    def subscribe(
        self, topic: str, handler: Callable[[Any], None]
    ) -> Callable[[], None]:
        self._subs[topic].append(handler)

        def unsubscribe() -> None:
            try:
                self._subs[topic].remove(handler)
            except ValueError:
                pass

        return unsubscribe

    def publish(self, topic: str, payload: Any) -> None:
        # Copy list to avoid mutation during iteration
        for handler in list(self._subs.get(topic, [])):
            handler(payload)


```

---

### game_director.py

**Path**: `backend/ui/services/game_director.py`

**Size**: 8.2 KB

```python
#!/usr/bin/env python3
"""
GameDirector - Centralized timing, autoplay, and effect sequencing
(minimal, single-threaded)
"""
from __future__ import annotations

import time
import heapq
import itertools
from typing import Dict, Any, List, Optional, Callable
from enum import Enum
from dataclasses import dataclass


class PlaybackState(Enum):
    STOPPED = "stopped"
    PLAYING = "playing"
    PAUSED = "paused"


@dataclass
class _Scheduled:
    due_ms: int
    seq: int
    event: Dict[str, Any]
    callback: Optional[Callable]


class GameDirector:
    def __init__(self, event_bus=None):
        self.event_bus = event_bus
        self.playback_state = PlaybackState.STOPPED
        self.speed = 1.0
        self.autoplay_interval_ms = 600
        self.current_step = 0
        self.total_steps = 0
        self.on_advance_callback: Optional[Callable[[int], None]] = None
        self.on_step_change_callback: Optional[Callable[[int], None]] = None

        self._q: List[tuple] = []  # (due_ms, seq, event, callback)
        self._seq = itertools.count()
        self._gate_count = 0
        self._cancelled = set()
        self._last_now = self._now_ms()
        print("üé¨ GameDirector: Initialized")

    # Wiring
    def set_event_bus(self, event_bus): 
        self.event_bus = event_bus

    def set_advance_callback(self, callback: Callable[[int], None]): 
        self.on_advance_callback = callback

    def set_step_change_callback(self, callback: Callable[[int], None]): 
        self.on_step_change_callback = callback

    def set_total_steps(self, total: int):
        self.total_steps = max(0, int(total))
        print(f"üé¨ GameDirector: Total steps set to {self.total_steps}")

    # Playback controls
    def play(self) -> None:
        if self.playback_state == PlaybackState.STOPPED:
            self.current_step = max(0, self.current_step)
        self.playback_state = PlaybackState.PLAYING
        print("üé¨ GameDirector: PLAY")
        # Ensure scheduling is attempted when play is pressed. _schedule_next_auto
        # will internally respect gate_count and playback_state.
        try:
            self._schedule_next_auto()
        except Exception:
            # Scheduling is best-effort; swallow errors for robustness
            pass

    def pause(self) -> None:
        self.playback_state = PlaybackState.PAUSED
        print("üé¨ GameDirector: PAUSE")
        # Don't schedule more autoplay when paused

    def stop(self) -> None:
        self.playback_state = PlaybackState.STOPPED
        self._q.clear()
        self._gate_count = 0
        print("üé¨ GameDirector: STOP")

    def step_forward(self, n: int = 1) -> None:
        for _ in range(max(1, n)):
            self._advance_once()

    def step_back(self, n: int = 1) -> None:
        self.current_step = max(0, self.current_step - max(1, n))
        if self.on_step_change_callback:
            self.on_step_change_callback(self.current_step)

    def seek(self, step_index: int) -> None:
        # Cancel pending tokens and reset gate count
        self._q.clear()
        self._gate_count = 0
        self.current_step = max(0, min(int(step_index),
                                       self.total_steps - 1))
        if self.on_step_change_callback:
            self.on_step_change_callback(self.current_step)

    def set_speed(self, multiplier: float) -> None:
        self.speed = max(0.1, float(multiplier))
        print(f"üé¨ GameDirector: Speed={self.speed}x")

    def set_autoplay_interval(self, ms: int) -> None:
        self.autoplay_interval_ms = max(60, int(ms))

    # Gate controls (effects)
    def gate_begin(self) -> None:
        self._gate_count += 1
        print(f"üé¨ GameDirector: GATE ++ ({self._gate_count})")

    def gate_end(self) -> None:
        self._gate_count = max(0, self._gate_count - 1)
        print(f"üé¨ GameDirector: GATE -- ({self._gate_count})")
        # Only schedule next autoplay when gate is closed and we're playing
        if (self._gate_count == 0 and
                self.playback_state == PlaybackState.PLAYING):
            self._schedule_next_auto()

    def notify_sound_complete(self, event_data=None):
        """Called when sound effect completes."""
        if event_data is None:
            event_data = {}
        print(f"üé¨ GameDirector: Sound complete: {event_data.get('id', 'unknown')}")
        self.gate_end()

    def notify_animation_complete(self, event_data=None):
        """Called when animation effect completes."""
        if event_data is None:
            event_data = {}
        print(f"üé¨ GameDirector: Animation complete: {event_data.get('name', 'unknown')}")
        self.gate_end()

    # Scheduling
    def schedule(self, delay_ms: int, event: Dict[str, Any],
                 callback: Optional[Callable] = None) -> str:
        """Schedule an event with delay."""
        # Use defensive speed scaling: divide delay by speed multiplier (faster -> shorter delay)
        scaled_delay = int(delay_ms / max(0.1, float(self.speed)))
        due_ms = self._now_ms() + scaled_delay
        seq = next(self._seq)
        heapq.heappush(self._q, (due_ms, seq, event, callback))
        # Telemetry: publish scheduled event for diagnostics
        try:
            if self.event_bus:
                self.event_bus.publish("game_director:scheduled", {"delay_ms": delay_ms, "event": event})
        except Exception:
            pass

        return f"{seq}"

    def cancel(self, token: str) -> None:
        try:
            seq = int(token[1:])
            self._cancelled.add(seq)
        except Exception:
            pass

    def update(self, dt_ms: int = 16) -> None:
        """Update the director - process scheduled events."""
        now = self._now_ms()
        while self._q and self._q[0][0] <= now:
            due_ms, seq, event, callback = heapq.heappop(self._q)
            # Publish dispatch telemetry so callers can trace scheduling behavior
            try:
                if self.event_bus:
                    self.event_bus.publish("game_director:dispatch", event)
            except Exception:
                pass

            if event.get("type") == "AUTO_ADVANCE":
                self._advance_once()
                # Only schedule next if gate is closed and we're playing
                if (self._gate_count == 0 and
                        self.playback_state == PlaybackState.PLAYING):
                    self._schedule_next_auto()
            else:
                if callback:
                    callback()

    # Internals
    def _schedule_next_auto(self) -> None:
        """Schedule the next autoplay step."""
        if (self.playback_state == PlaybackState.PLAYING and
                self.current_step < self.total_steps):
            self.schedule(self.autoplay_interval_ms,
                         {"type": "AUTO_ADVANCE"})

    def _advance_once(self) -> None:
        """Advance one step forward."""
        if self.current_step < self.total_steps:
            self.current_step += 1
            if self.on_advance_callback:
                self.on_advance_callback(self.current_step)
            if self.on_step_change_callback:
                self.on_step_change_callback(self.current_step)

    def _now_ms(self) -> int:
        """Get current time in milliseconds."""
        return int(time.time() * 1000)


class NoopDirector:
    """No-op director for testing or when GameDirector is not needed."""
    
    def __init__(self):
        pass
    
    def play(self) -> None: pass
    def pause(self) -> None: pass
    def stop(self) -> None: pass
    def step_forward(self, n: int = 1) -> None: pass
    def step_back(self, n: int = 1) -> None: pass
    def seek(self, step_index: int) -> None: pass
    def set_speed(self, multiplier: float) -> None: pass
    def set_autoplay_interval(self, ms: int) -> None: pass
    def schedule(self, delay_ms: int, event: Dict[str, Any], callback: Optional[Callable] = None) -> str: return "noop"
    def cancel(self, token: str) -> None: pass
    def gate_begin(self) -> None: pass
    def gate_end(self) -> None: pass
    def notify_animation_complete(self) -> None: pass
    def notify_sound_complete(self) -> None: pass
    def get_status(self) -> Dict[str, Any]: return {"type": "noop"}
    def update(self, delta_time_ms: float = 16.67) -> None: pass
```

---

### hands_repository.py

**Path**: `backend/ui/services/hands_repository.py`

**Size**: 7.1 KB

```python
import json
import os
from typing import List, Dict, Any, Optional
from enum import Enum

class StudyMode(Enum):
    """Study modes for hands review."""
    REPLAY = "replay"
    SOLVER_DIFF = "solver_diff"
    RECALL_QUIZ = "recall_quiz"
    EXPLAIN_MISTAKE = "explain_mistake"

class HandsFilter:
    """Filter criteria for hands."""
    def __init__(self):
        self.positions: List[str] = []
        self.pot_type: Optional[str] = None  # "SRP", "3BP", "4BP+"
        self.min_stack_depth: Optional[int] = None
        self.max_stack_depth: Optional[int] = None
        self.line_type: Optional[str] = None
        self.themes: List[str] = []
        self.min_spr: Optional[float] = None
        self.max_spr: Optional[float] = None
        self.search_text: str = ""

    def matches(self, hand: Dict[str, Any]) -> bool:
        """Check if a hand matches the filter criteria."""
        # Position filter
        if self.positions:
            hand_positions = []
            for player in hand.get('players', []):
                if player.get('position'):
                    hand_positions.append(player['position'])
            if not any(pos in hand_positions for pos in self.positions):
                return False
        
        # Stack depth filter
        if self.min_stack_depth is not None or self.max_stack_depth is not None:
            stacks = [p.get('stack', 0) for p in hand.get('players', [])]
            avg_stack = sum(stacks) / len(stacks) if stacks else 0
            bb = hand.get('big_blind', 10)
            stack_depth_bb = avg_stack / bb if bb > 0 else 0
            
            if self.min_stack_depth is not None and stack_depth_bb < self.min_stack_depth:
                return False
            if self.max_stack_depth is not None and stack_depth_bb > self.max_stack_depth:
                return False
        
        # Search text filter
        if self.search_text:
            search_lower = self.search_text.lower()
            hand_text = f"{hand.get('hand_id', '')} {hand.get('description', '')}".lower()
            if search_lower not in hand_text:
                return False
        
        # TODO: Add more filter logic for pot_type, line_type, themes, SPR
        
        return True

class HandsRepository:
    """Repository for managing poker hands data."""
    
    def __init__(self):
        self.legendary_hands: List[Dict[str, Any]] = []
        self.bot_hands: List[Dict[str, Any]] = []
        self.imported_hands: List[Dict[str, Any]] = []
        self.collections: Dict[str, List[str]] = {}  # collection_name -> [hand_ids]
        self.current_filter = HandsFilter()
        self._load_hands()
    
    def _load_hands(self):
        """Load hands from various sources."""
        self._load_legendary_hands()
        # TODO: Load bot hands and imported hands
        self._create_default_collections()
    
    def _load_legendary_hands(self):
        """Load legendary hands from data directory."""
        try:
            data_paths = [
                "backend/data/legendary_hands.json",
                "data/legendary_hands.json", 
                os.path.join(os.path.dirname(__file__), "../../../data/legendary_hands.json"),
                os.path.join(os.path.dirname(__file__), "../../data/legendary_hands.json")
            ]
            
            for path in data_paths:
                if os.path.exists(path):
                    with open(path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    
                    if isinstance(data, list):
                        self.legendary_hands = data
                    elif isinstance(data, dict) and 'hands' in data:
                        self.legendary_hands = data['hands']
                    
                    # Ensure each hand has required metadata
                    for i, hand in enumerate(self.legendary_hands):
                        if 'source' not in hand:
                            hand['source'] = 'legendary'
                        if 'hand_id' not in hand:
                            hand['hand_id'] = f'legendary_{i+1}'
                    
                    print(f"‚úÖ HandsRepository loaded {len(self.legendary_hands)} legendary hands")
                    break
        except Exception as e:
            print(f"‚ùå Error loading legendary hands: {e}")
    
    def _create_default_collections(self):
        """Create default collections."""
        if self.legendary_hands:
            # Create collections by pot size ranges
            self.collections["High Stakes"] = [
                hand['hand_id'] for hand in self.legendary_hands 
                if hand.get('pot_size', 0) > 1000
            ]
            self.collections["Tournament Classics"] = [
                hand['hand_id'] for hand in self.legendary_hands 
                if any(keyword in hand.get('description', '').lower() 
                      for keyword in ['wsop', 'tournament', 'final table'])
            ]
    
    def get_all_hands(self) -> List[Dict[str, Any]]:
        """Get all hands from all sources."""
        return self.legendary_hands + self.bot_hands + self.imported_hands
    
    def get_filtered_hands(self) -> List[Dict[str, Any]]:
        """Get hands that match current filter."""
        all_hands = self.get_all_hands()
        return [hand for hand in all_hands if self.current_filter.matches(hand)]
    
    def get_hand_by_id(self, hand_id: str) -> Optional[Dict[str, Any]]:
        """Get a specific hand by ID."""
        for hand in self.get_all_hands():
            if hand.get('hand_id') == hand_id:
                return hand
        return None
    
    def set_filter(self, filter_criteria: HandsFilter):
        """Set new filter criteria."""
        self.current_filter = filter_criteria
    
    def get_collections(self) -> Dict[str, List[str]]:
        """Get all collections."""
        return self.collections.copy()
    
    def get_collection_hands(self, collection_name: str) -> List[Dict[str, Any]]:
        """Get hands in a specific collection."""
        hand_ids = self.collections.get(collection_name, [])
        hands = []
        for hand_id in hand_ids:
            hand = self.get_hand_by_id(hand_id)
            if hand:
                hands.append(hand)
        return hands
    
    def add_to_collection(self, collection_name: str, hand_id: str):
        """Add hand to a collection."""
        if collection_name not in self.collections:
            self.collections[collection_name] = []
        if hand_id not in self.collections[collection_name]:
            self.collections[collection_name].append(hand_id)
    
    def create_collection(self, collection_name: str, hand_ids: List[str] = None):
        """Create a new collection."""
        self.collections[collection_name] = hand_ids or []
    
    def get_stats(self) -> Dict[str, int]:
        """Get repository statistics."""
        return {
            "total_hands": len(self.get_all_hands()),
            "legendary_hands": len(self.legendary_hands),
            "bot_hands": len(self.bot_hands),
            "imported_hands": len(self.imported_hands),
            "collections": len(self.collections),
            "filtered_hands": len(self.get_filtered_hands())
        }
```

---

### hands_review_controller.py

**Path**: `backend/ui/services/hands_review_controller.py`

**Size**: 10.6 KB

```python
"""
Hands Review Session Controller - Handles business logic for hands review
Follows the service layer pattern from the handbook.
"""

import time
from core.pure_poker_state_machine import PurePokerStateMachine, GameConfig


class HandsReviewController:
    """
    Controller for Hands Review Session - handles PPSM interactions and state updates.
    Follows the handbook pattern: UI dispatches actions ‚Üí Controller ‚Üí PPSM ‚Üí Store updates.
    """
    
    def __init__(self, event_bus, store, session_id: str):
        self.event_bus = event_bus
        self.store = store
        self.session_id = session_id
        self.ppsm = None
        self.hand_model = None
        self.flattened_actions = []
        self.current_step = 0
        
        self._setup_event_handlers()
    
    def _setup_event_handlers(self):
        """Subscribe to relevant events."""
        self.event_bus.subscribe(
            f"session:{self.session_id}:enhanced_rpgw:action_executed",
            self._handle_action_execution
        )
        self.event_bus.subscribe(
            f"session:{self.session_id}:load_review_hand",
            self._handle_load_review_hand
        )
        self.event_bus.subscribe(
            f"session:{self.session_id}:next_review_action",
            self._handle_next_action
        )
        self.event_bus.subscribe(
            f"session:{self.session_id}:prev_review_action",
            self._handle_prev_action
        )
        self.event_bus.subscribe(
            f"session:{self.session_id}:reset_review_hand",
            self._handle_reset_hand
        )
    
    def _handle_load_review_hand(self, event_data):
        """Handle loading a new hand for review."""
        hand_data = event_data.get('hand_data', {})
        
        # Initialize PPSM with hand data
        self._initialize_ppsm(hand_data)
        
        # Flatten hand actions for step-by-step replay
        self.flattened_actions = self._flatten_hand_actions(hand_data)
        
        # Update store with loaded hand
        self.store.dispatch({
            'type': 'LOAD_REVIEW_HAND',
            'hand_data': hand_data,
            'flattened_actions': self.flattened_actions
        })
        
        # Trigger feedback event
        self.event_bus.publish(
            f"session:{self.session_id}:enhanced_rpgw:feedback",
            {
                'type': 'hand_loaded',
                'hand_id': hand_data.get('hand_id', 'Unknown'),
                'total_actions': len(self.flattened_actions)
            }
        )
    
    def _handle_action_execution(self, event_data):
        """Handle action execution from Enhanced RPGW."""
        action = event_data.get('action')
        
        if not action or not self.ppsm:
            return
        
        try:
            # Execute action in PPSM
            ppsm_result = self._execute_ppsm_action(action)
            
            # Update store with PPSM results
            self.store.dispatch({
                'type': 'UPDATE_ENHANCED_RPGW_STATE',
                'updates': {
                    'ppsm_result': ppsm_result,
                    'last_executed_action': action,
                    'execution_timestamp': time.time(),
                    'current_street': self.ppsm.game_state.current_street,
                    'pot_amount': self.ppsm.game_state.displayed_pot(),
                    'seats': self._get_seats_state(),
                    'board': self._get_board_state(),
                    'dealer': self._get_dealer_state(),
                    'current_actor': self._get_current_actor(),
                    'legal_actions': self._get_legal_actions()
                }
            })
            
            # Trigger appropriate feedback
            self._trigger_action_feedback(action, ppsm_result)
            
        except Exception as e:
            # Log error and update store
            print(f"‚ö†Ô∏è Error executing action: {e}")
            self.store.dispatch({
                'type': 'UPDATE_ENHANCED_RPGW_STATE',
                'updates': {
                    'execution_status': 'error',
                    'error_message': str(e)
                }
            })
    
    def _handle_next_action(self, event_data):
        """Handle moving to next action."""
        if self.current_step < len(self.flattened_actions) - 1:
            self.current_step += 1
            action = self.flattened_actions[self.current_step]
            
            # Execute the action
            self.store.dispatch({
                'type': 'ENHANCED_RPGW_EXECUTE_ACTION',
                'action': action,
                'action_index': self.current_step
            })
    
    def _handle_prev_action(self, event_data):
        """Handle moving to previous action."""
        if self.current_step > 0:
            self.current_step -= 1
            
            # Reset PPSM and replay up to current step
            self._reset_and_replay_to_step(self.current_step)
    
    def _handle_reset_hand(self, event_data):
        """Handle resetting the hand."""
        self.current_step = 0
        self._reset_and_replay_to_step(0)
    
    def _initialize_ppsm(self, hand_data):
        """Initialize PPSM with hand data."""
        # Extract game configuration
        players = hand_data.get('players', [])
        small_blind = hand_data.get('small_blind', 5)
        big_blind = hand_data.get('big_blind', 10)
        
        # Create game config
        config = GameConfig(
            num_players=len(players),
            small_blind=small_blind,
            big_blind=big_blind,
            starting_stack=1000  # Default starting stack
        )
        
        # Initialize PPSM
        self.ppsm = PurePokerStateMachine(config)
        
        # Set up players (placeholder for PPSM integration)
        # This would need to be implemented in PPSM
        for i, player in enumerate(players):
            # Extract player info for PPSM setup
            player.get('player_uid', f'player_{i}')
            player.get('name', f'Player {i+1}')
            player.get('starting_stack', 1000)
    
    def _flatten_hand_actions(self, hand_data):
        """Flatten hand actions into chronological list."""
        flattened = []
        
        # Extract actions from each street
        streets = ['PREFLOP', 'FLOP', 'TURN', 'RIVER']
        
        for street in streets:
            if street in hand_data:
                street_data = hand_data[street]
                actions = street_data.get('actions', [])
                
                for action in actions:
                    # Ensure action has required fields
                    if 'type' in action and 'actor' in action:
                        flattened.append({
                            'type': action['type'],
                            'actor': action['actor'],
                            'street': street,
                            'amount': action.get('amount'),
                            'to_amount': action.get('to_amount'),
                            'note': action.get('note')
                        })
        
        return flattened
    
    def _execute_ppsm_action(self, action):
        """Execute action in PPSM."""
        if not self.ppsm:
            raise ValueError("PPSM not initialized")
        
        # Convert action to PPSM format
        ppsm_action = {
            'type': action['type'],
            'actor_uid': action['actor'],
            'street': action['street'],
            'to_amount': action.get('to_amount'),
            'note': action.get('note')
        }
        
        # Execute in PPSM (this would need to be implemented in PPSM)
        # For now, we'll return a placeholder result
        return {
            'success': True,
            'action': ppsm_action,
            'new_state': 'executed'
        }
    
    def _get_seats_state(self):
        """Get current seats state from PPSM."""
        if not self.ppsm:
            return []
        
        # This would extract seat state from PPSM
        # For now, return placeholder
        return []
    
    def _get_board_state(self):
        """Get current board state from PPSM."""
        if not self.ppsm:
            return []
        
        # This would extract board state from PPSM
        # For now, return placeholder
        return []
    
    def _get_dealer_state(self):
        """Get current dealer state from PPSM."""
        if not self.ppsm:
            return {'position': 0}
        
        # This would extract dealer state from PPSM
        # For now, return placeholder
        return {'position': 0}
    
    def _get_current_actor(self):
        """Get current actor from PPSM."""
        if not self.ppsm:
            return None
        
        # This would extract current actor from PPSM
        # For now, return placeholder
        return None
    
    def _get_legal_actions(self):
        """Get legal actions from PPSM."""
        if not self.ppsm:
            return []
        
        # This would extract legal actions from PPSM
        # For now, return placeholder
        return []
    
    def _reset_and_replay_to_step(self, target_step):
        """Reset PPSM and replay actions up to target step."""
        # Reset PPSM
        self._initialize_ppsm(self.hand_model or {})
        
        # Replay actions up to target step
        for i in range(target_step + 1):
            if i < len(self.flattened_actions):
                action = self.flattened_actions[i]
                self._execute_ppsm_action(action)
        
        # Update store
        self.store.dispatch({
            'type': 'SET_REVIEW_PROGRESS',
            'current_step': target_step,
            'total_steps': len(self.flattened_actions)
        })
    
    def _trigger_action_feedback(self, action, ppsm_result):
        """Trigger appropriate feedback events."""
        # Map action types to feedback types
        feedback_mapping = {
            'DEAL_HOLE': 'card_deal',
            'DEAL_BOARD': 'card_deal',
            'POST_BLIND': 'chip_bet',
            'BET': 'player_bet',
            'RAISE': 'player_bet',
            'CALL': 'player_call',
            'CHECK': 'player_check',
            'FOLD': 'player_fold',
            'END_HAND': 'hand_end'
        }
        
        feedback_type = feedback_mapping.get(action['type'], 'default')
        
        self.event_bus.publish(
            f"session:{self.session_id}:enhanced_rpgw:feedback",
            {
                'type': feedback_type,
                'action': action,
                'ppsm_result': ppsm_result
            }
        )
    
    def dispose(self):
        """Clean up resources."""
        self.ppsm = None
        self.hand_model = None
        self.flattened_actions = []
        self.current_step = 0
```

---

### hands_review_event_controller.py

**Path**: `backend/ui/services/hands_review_event_controller.py`

**Size**: 4.8 KB

```python
#!/usr/bin/env python3
"""
HandsReviewEventController - Architecture compliant event handler for hands review.
Handles business logic triggered by UI actions via Store/Reducer pattern.
"""

from typing import Dict, Any
import time


class HandsReviewEventController:
    """
    Architecture compliant controller for hands review events.
    
    This controller handles business logic triggered by Store actions,
    maintaining clean separation between UI and business logic.
    """
    
    def __init__(self, event_bus, store, services):
        self.event_bus = event_bus
        self.store = store
        self.services = services
        self.session_managers = {}  # session_id -> HandsReviewSessionManager
        
        # Subscribe to hands review events
        self._setup_event_handlers()
        print("üéØ HandsReviewEventController: Architecture compliant controller initialized")
    
    def _setup_event_handlers(self):
        """Setup event handlers for hands review actions."""
        self.event_bus.subscribe(
            "hands_review:next_action_requested",
            self._handle_next_action_request
        )
        
        self.event_bus.subscribe(
            "hands_review:session_created",
            self._handle_session_created
        )
        
        self.event_bus.subscribe(
            "hands_review:session_disposed",
            self._handle_session_disposed
        )
    
    def _handle_next_action_request(self, event_data: Dict[str, Any]):
        """Handle next action request - pure business logic."""
        try:
            session_id = event_data.get('session_id')
            timestamp = event_data.get('timestamp', time.time())
            
            print(f"üéØ HandsReviewEventController: Processing next action for session {session_id}")
            
            # Get session manager
            session_manager = self.session_managers.get(session_id)
            if not session_manager:
                print(f"‚ö†Ô∏è HandsReviewEventController: No session manager for {session_id}")
                self._update_review_status("error", f"Session {session_id} not found")
                return
            
            # Execute business logic via session manager
            try:
                session_state = session_manager.execute_action()
                
                # Update store with results
                if session_state:
                    self.store.dispatch({
                        "type": "UPDATE_HANDS_REVIEW_STATE",
                        "session_id": session_id,
                        "state": session_state,
                        "timestamp": timestamp
                    })
                    
                    # Trigger UI update via event
                    self.event_bus.publish(
                        "hands_review:state_updated",
                        {
                            "session_id": session_id,
                            "state": session_state,
                            "timestamp": timestamp
                        }
                    )
                    
                    print(f"üéØ HandsReviewEventController: Action executed successfully")
                else:
                    self._update_review_status("completed", "Hand complete")
                    
            except Exception as e:
                print(f"‚ùå HandsReviewEventController: Action execution error: {e}")
                self._update_review_status("error", str(e))
                
        except Exception as e:
            print(f"‚ùå HandsReviewEventController: Event handling error: {e}")
            self._update_review_status("error", str(e))
    
    def _handle_session_created(self, event_data: Dict[str, Any]):
        """Register a new hands review session."""
        session_id = event_data.get('session_id')
        session_manager = event_data.get('session_manager')
        
        if session_id and session_manager:
            self.session_managers[session_id] = session_manager
            print(f"üéØ HandsReviewEventController: Registered session {session_id}")
    
    def _handle_session_disposed(self, event_data: Dict[str, Any]):
        """Clean up disposed session."""
        session_id = event_data.get('session_id')
        
        if session_id in self.session_managers:
            del self.session_managers[session_id]
            print(f"üéØ HandsReviewEventController: Disposed session {session_id}")
    
    def _update_review_status(self, status: str, message: str = ""):
        """Update review status in store."""
        self.store.dispatch({
            "type": "SET_REVIEW_STATUS",
            "status": status,
            "message": message,
            "timestamp": time.time()
        })
    
    def dispose(self):
        """Clean up controller resources."""
        self.session_managers.clear()
        print("üéØ HandsReviewEventController: Disposed")
```

---

### hands_review_session_manager.py

**Path**: `backend/ui/services/hands_review_session_manager.py`

**Size**: 19.2 KB

```python
#!/usr/bin/env python3
"""
HandsReviewSessionManager - Manages hands review session logic per architecture guidelines.
"""

from typing import Dict, Any, List, Optional
from dataclasses import dataclass


try:
    from core.pure_poker_state_machine import PurePokerStateMachine, GameConfig
    from core.hand_model import Hand, Street
    from core.hand_model_decision_engine import HandModelDecisionEngine
    from core.session_logger import get_session_logger
    from core.poker_types import Player
except ImportError:
    # Fallback for when running from different directory
    from ...core.pure_poker_state_machine import PurePokerStateMachine, GameConfig
    from ...core.hand_model import Hand, Street
    from ...core.hand_model_decision_engine import HandModelDecisionEngine
    from ...core.session_logger import get_session_logger
    from ...core.poker_types import Player


@dataclass
class HandsReviewState:
    """Immutable state for hands review session."""
    current_hand: Optional[Hand] = None
    current_action_index: int = 0
    total_actions: int = 0
    is_playing: bool = False
    playback_speed: float = 1.0
    street: str = "PREFLOP"
    board: List[str] = None
    seats: List[Dict[str, Any]] = None
    pot: Dict[str, Any] = None
    dealer: Dict[str, Any] = None
    action: Dict[str, Any] = None
    effects: List[Dict[str, Any]] = None
    table: Dict[str, Any] = None
    animation: Dict[str, Any] = None


class HandsReviewSessionManager:
    """Manages hands review session logic per architecture guidelines."""
    
    def __init__(self, store, ppsm: PurePokerStateMachine, game_director, effect_bus, event_bus):
        self.store = store
        self.ppsm = ppsm
        self.game_director = game_director
        self.effect_bus = effect_bus
        self.event_bus = event_bus
        self.session_logger = get_session_logger()
        
        # Session state
        self.current_hand: Optional[Hand] = None
        self.current_action_index: int = 0
        self.total_actions: int = 0
        self.is_playing: bool = False
        self.playback_speed: float = 1.0
        
        # Decision engine for hand replay
        self.decision_engine: Optional[HandModelDecisionEngine] = None
        
        print("üéØ HandsReviewSessionManager: Initialized per architecture guidelines")
    
    def load_hand(self, hand_data: Dict[str, Any]) -> HandsReviewState:
        """Load a hand for review - business logic only."""
        try:
            # Create Hand object from data
            self.current_hand = Hand.from_dict(hand_data)
            
            # Initialize PPSM with hand data
            self._initialize_ppsm_for_hand()
            
            # Create decision engine for replay
            self.decision_engine = HandModelDecisionEngine(self.current_hand)
            
            # Count total actions across all streets
            self.total_actions = sum(len(street_state.actions) for street_state in self.current_hand.streets.values())
            
            # Reset to beginning
            self.current_action_index = 0
            self.is_playing = False
            
            # Create initial state
            initial_state = self._create_table_state()
            
            # Update store (not UI directly)
            self.store.dispatch({
                "type": "HANDS_REVIEW_LOADED",
                "hand_id": self.current_hand.metadata.hand_id,
                "total_actions": self.total_actions,
                "state": initial_state
            })
            
            print(f"üéØ HandsReviewSessionManager: Loaded hand {self.current_hand.metadata.hand_id} with {self.total_actions} actions")
            
            return HandsReviewState(
                current_hand=self.current_hand,
                current_action_index=self.current_action_index,
                total_actions=self.total_actions,
                is_playing=self.is_playing,
                playback_speed=self.playback_speed,
                **initial_state
            )
            
        except Exception as e:
            print(f"‚ùå HandsReviewSessionManager: Error loading hand: {e}")
            raise
    
    def execute_action(self) -> HandsReviewState:
        """Execute next action through PPSM - business logic only."""
        try:
            if not self.current_hand:
                raise ValueError("No hand loaded")
            
            # Get action from hand data (need to find which street it's in)
            if self.current_action_index >= self.total_actions:
                print("üéØ HandsReviewSessionManager: All actions completed")
                return self._get_current_state()
            
            # Find the action across all streets
            action = self._get_action_by_index(self.current_action_index)
            
            # Convert action to PPSM format
            player = self._get_player_by_uid(action.actor_uid)
            action_type = action.action
            to_amount = action.to_amount if action.to_amount is not None else action.amount
            
            # Execute in PPSM
            result = self.ppsm.execute_action(player, action_type, to_amount)
            
            # Update action index
            self.current_action_index += 1
            
            # Create new table state
            new_state = self._create_table_state()
            
            # Add action effects
            self._add_action_effects(action, result)
            
            # Update store (not UI directly)
            self.store.dispatch({
                "type": "HANDS_REVIEW_ACTION_EXECUTED",
                "action_index": self.current_action_index - 1,
                "action": action,
                "state": new_state
            })
            
            print(f"üéØ HandsReviewSessionManager: Executed action {self.current_action_index}/{self.total_actions}")
            
            return HandsReviewState(
                current_hand=self.current_hand,
                current_action_index=self.current_action_index,
                total_actions=self.total_actions,
                is_playing=self.is_playing,
                playback_speed=self.playback_speed,
                street=new_state.get('street', 'PREFLOP'),
                board=new_state.get('board', []),
                seats=new_state.get('seats', []),
                pot=new_state.get('pot', {}),
                dealer=new_state.get('dealer', {}),
                action=new_state.get('action', {}),
                effects=new_state.get('effects', []),
                table=new_state.get('table', {}),
                animation=new_state.get('animation', {})
            )
            
        except Exception as e:
            print(f"‚ùå HandsReviewSessionManager: Error executing action: {e}")
            raise
    
    def _get_action_by_index(self, action_index: int) -> Dict[str, Any]:
        """Get action by global index across all streets."""
        if not self.current_hand:
            raise ValueError("No hand loaded")
        
        current_index = 0
        for street in [Street.PREFLOP, Street.FLOP, Street.TURN, Street.RIVER]:
            street_actions = self.current_hand.streets[street].actions
            if current_index + len(street_actions) > action_index:
                return street_actions[action_index - current_index]
            current_index += len(street_actions)
        
        raise IndexError(f"Action index {action_index} out of range")
    
    def _get_player_by_uid(self, player_uid: str) -> Player:
        """Get Player object by UID from PPSM."""
        if not self.ppsm:
            raise ValueError("PPSM not initialized")
        
        # Get current game state
        game_state = self.ppsm.get_game_state()
        
        # Find player by name/UID
        for player_data in game_state.get('players', []):
            if player_data.get('name') == player_uid:
                # Create Player object from data
                from core.poker_types import Player
                return Player(
                    name=player_data.get('name', 'Unknown'),
                    stack=player_data.get('current_stack', 1000),
                    position=player_data.get('position', ''),
                    is_human=False,
                    is_active=player_data.get('acting', False),
                    cards=player_data.get('hole_cards', [])
                )
        
        # If not found, create a default player
        from core.poker_types import Player
        return Player(
            name=player_uid,
            stack=1000,
            position='',
            is_human=False,
            is_active=False,
            cards=[]
        )
    
    def play(self) -> None:
        """Start autoplay - business logic only."""
        if not self.is_playing and self.current_action_index < self.total_actions:
            self.is_playing = True
            
            # Schedule next action via GameDirector
            if self.game_director:
                self.game_director.schedule(
                    int(1000 / self.playback_speed),  # Convert to milliseconds
                    {"type": "AUTO_ADVANCE_HANDS_REVIEW"}
                )
            
            # Update store
            self.store.dispatch({
                "type": "HANDS_REVIEW_PLAY_STARTED",
                "is_playing": True
            })
            
            print("üéØ HandsReviewSessionManager: Autoplay started")
    
    def pause(self) -> None:
        """Pause autoplay - business logic only."""
        if self.is_playing:
            self.is_playing = False
            
            # Cancel scheduled events via GameDirector
            if self.game_director:
                self.game_director.cancel_all()
            
            # Update store
            self.store.dispatch({
                "type": "HANDS_REVIEW_PLAY_PAUSED",
                "is_playing": False
            })
            
            print("üéØ HandsReviewSessionManager: Autoplay paused")
    
    def seek(self, action_index: int) -> HandsReviewState:
        """Seek to specific action - business logic only."""
        if not self.current_hand:
            raise ValueError("No hand loaded")
        
        # Validate action index
        action_index = max(0, min(action_index, self.total_actions))
        
        # Reset PPSM to beginning
        self._initialize_ppsm_for_hand()
        
        # Execute actions up to target index
        self.current_action_index = 0
        for i in range(action_index):
            action = self._get_action_by_index(i)
            # Convert action to PPSM format
            player = self._get_player_by_uid(action.actor_uid)
            action_type = action.action
            to_amount = action.to_amount if action.to_amount is not None else action.amount
            
            self.ppsm.execute_action(player, action_type, to_amount)
            self.current_action_index += 1
        
        # Create table state
        new_state = self._create_table_state()
        
        # Update store
        self.store.dispatch({
            "type": "HANDS_REVIEW_SEEK_COMPLETED",
            "action_index": self.current_action_index,
            "state": new_state
        })
        
        print(f"üéØ HandsReviewSessionManager: Seeked to action {self.current_action_index}")
        
        return HandsReviewState(
            current_hand=self.current_hand,
            current_action_index=self.current_action_index,
            total_actions=self.total_actions,
            is_playing=self.is_playing,
            playback_speed=self.playback_speed,
            **new_state
        )
    
    def set_playback_speed(self, speed: float) -> None:
        """Set playback speed - business logic only."""
        self.playback_speed = max(0.1, min(5.0, speed))
        
        # Update GameDirector if playing
        if self.is_playing and self.game_director:
            self.game_director.set_speed(self.playback_speed)
        
        # Update store
        self.store.dispatch({
            "type": "HANDS_REVIEW_SPEED_CHANGED",
            "speed": self.playback_speed
        })
        
        print(f"üéØ HandsReviewSessionManager: Playback speed set to {self.playback_speed}x")
    
    def _initialize_ppsm_for_hand(self) -> None:
        """Initialize PPSM with hand data - business logic only."""
        if not self.current_hand:
            return
        
        # Create game config from hand data
        config = GameConfig(
            num_players=len(self.current_hand.seats),
            small_blind=self.current_hand.metadata.small_blind,
            big_blind=self.current_hand.metadata.big_blind,
            starting_stack=1000  # Default, could be configurable
        )
        
        # Initialize PPSM
        self.ppsm.initialize_game(config)
        
        # Add players from seats
        for seat in self.current_hand.seats:
            self.ppsm.add_player(seat.player_uid, seat.starting_stack)
        
        # Set dealer position (default to seat 0 for now)
        self.ppsm.set_dealer_position(0)
    
    def _create_table_state(self) -> Dict[str, Any]:
        """Create table state from PPSM - business logic only."""
        try:
            # Get current game state from PPSM
            game_state = self.ppsm.get_game_state()
            
            # Extract relevant information
            seats = []
            for player in game_state.get('players', []):
                seats.append({
                    'player_uid': player.get('name', 'Unknown'),
                    'name': player.get('name', 'Unknown'),
                    'starting_stack': player.get('starting_stack', 1000),
                    'current_stack': player.get('current_stack', 1000),
                    'current_bet': player.get('current_bet', 0),
                    'stack': player.get('current_stack', 1000),
                    'bet': player.get('current_bet', 0),
                    'cards': player.get('hole_cards', []),
                    'folded': player.get('folded', False),
                    'all_in': player.get('all_in', False),
                    'acting': player.get('acting', False),
                    'position': player.get('position', ''),
                    'last_action': player.get('last_action', '')
                })
            
            # Determine current street
            street = "PREFLOP"
            board = game_state.get('board', [])
            if len(board) >= 3:
                street = "FLOP"
            if len(board) >= 4:
                street = "TURN"
            if len(board) >= 5:
                street = "RIVER"
            
            return {
                'table': {
                    'width': 1200,
                    'height': 800
                },
                'seats': seats,
                'board': board,
                'street': street,
                'pot': {
                    'amount': game_state.get('pot', 0),
                    'side_pots': game_state.get('side_pots', [])
                },
                'dealer': {
                    'position': game_state.get('dealer_position', 0)
                },
                'action': {
                    'current_player': game_state.get('current_player', -1),
                    'action_type': game_state.get('last_action_type', ''),
                    'amount': game_state.get('last_action_amount', 0)
                },
                'animation': {},
                'effects': []
            }
            
        except Exception as e:
            print(f"‚ö†Ô∏è HandsReviewSessionManager: Error creating table state: {e}")
            # Return default state
            return {
                'table': {'width': 1200, 'height': 800},
                'seats': [],
                'board': [],
                'street': 'PREFLOP',
                'pot': {'amount': 0, 'side_pots': []},
                'dealer': {'position': 0},
                'action': {'current_player': -1, 'action_type': '', 'amount': 0},
                'animation': {},
                'effects': []
            }
    
    def _add_action_effects(self, action, result) -> None:
        """Add action effects - business logic only."""
        try:
            # Get action type from Action object
            action_type = action.action.value if hasattr(action.action, 'value') else str(action.action)
            actor_uid = action.actor_uid if hasattr(action, 'actor_uid') else 'Unknown'
            
            # Debug: log what action type we're getting
            print(f"üéØ DEBUG: Action type: '{action_type}' (type: {type(action.action)})")
            
            # Add sound effects via EffectBus
            if self.effect_bus:
                self.effect_bus.add_poker_action_effects(action_type, actor_uid)
            
            # Add animation effects for ALL betting actions (not just end-of-street)
            if action_type in ["BET", "RAISE", "CALL", "CHECK", "FOLD"]:
                # Betting action animation - chips to pot
                if self.event_bus:
                    print(f"üé¨ Triggering betting animation for action: {action_type}")
                    self.event_bus.publish("effect_bus:animate", {
                        "name": "betting_action",
                        "ms": 300,
                        "action_type": action_type,
                        "actor_uid": actor_uid
                    })
            
            # Add animation effects for specific actions
            if action_type in ["DEAL_BOARD", "DEAL_FLOP", "DEAL_TURN", "DEAL_RIVER"]:
                # End-of-street animation
                if self.event_bus:
                    print(f"üé¨ Triggering end-of-street animation for: {action_type}")
                    self.event_bus.publish("effect_bus:animate", {
                        "name": "chips_to_pot",
                        "ms": 260
                    })
            
            # Add showdown effects
            if action_type == "SHOWDOWN":
                if self.event_bus:
                    print(f"üé¨ Triggering showdown animation")
                    self.event_bus.publish("effect_bus:animate", {
                        "name": "pot_to_winner",
                        "ms": 520
                    })
            
        except Exception as e:
            print(f"‚ö†Ô∏è HandsReviewSessionManager: Error adding action effects: {e}")
    
    def _get_current_state(self) -> HandsReviewState:
        """Get current session state."""
        table_state = self._create_table_state()
        return HandsReviewState(
            current_hand=self.current_hand,
            current_action_index=self.current_action_index,
            total_actions=self.total_actions,
            is_playing=self.is_playing,
            playback_speed=self.playback_speed,
            **table_state
        )
    
    def cleanup(self) -> None:
        """Clean up session resources."""
        try:
            # Cancel any scheduled events
            if self.game_director:
                self.game_director.cancel_all()
            
            # Reset state
            self.current_hand = None
            self.current_action_index = 0
            self.total_actions = 0
            self.is_playing = False
            
            print("üéØ HandsReviewSessionManager: Cleanup completed")
            
        except Exception as e:
            print(f"‚ö†Ô∏è HandsReviewSessionManager: Cleanup error: {e}")
```

---

### service_container.py

**Path**: `backend/ui/services/service_container.py`

**Size**: 1.1 KB

```python
from typing import Any, Dict


class ServiceContainer:
    """
    Lightweight service registry with app-wide and session-scoped services.
    """

    def __init__(self) -> None:
        self.app_scope: Dict[str, Any] = {}
        self.session_scopes: Dict[str, Dict[str, Any]] = {}

    def provide_app(self, name: str, service: Any) -> None:
        self.app_scope[name] = service

    def get_app(self, name: str) -> Any:
        return self.app_scope[name]

    def provide_session(
        self, session_id: str, name: str, service: Any
    ) -> None:
        self.session_scopes.setdefault(session_id, {})[name] = service

    def get_session(self, session_id: str, name: str) -> Any:
        return self.session_scopes[session_id][name]

    def dispose_session(self, session_id: str) -> None:
        scope = self.session_scopes.pop(session_id, {})
        for service in scope.values():
            if hasattr(service, "dispose"):
                try:
                    service.dispose()
                except Exception:
                    # Best-effort cleanup
                    pass
```

---

### session_controller.py

**Path**: `backend/ui/services/session_controller.py`

**Size**: 6.3 KB

```python
from __future__ import annotations

from typing import Any, Callable, Dict
import time


class SessionController:
    """
    Bridges an FPSM-like engine to the UI store by translating snapshots
    to store actions. The controller does not schedule time; GameDirector
    (out of scope here) would drive progression.
    """

    def __init__(self, session_id: str, services, store, fsm: Any):
        self.session_id = session_id
        self.services = services
        self.store = store
        self.fsm = fsm
        self._unsubs: list[Callable[[], None]] = []

    def start(self) -> None:
        # Subscribe to FSM updates if available
        if hasattr(self.fsm, "subscribe"):
            self._unsubs.append(
                self.fsm.subscribe("snapshot", self._on_snapshot)
            )

    def _on_snapshot(self, snapshot: Dict[str, Any]) -> None:
        # Expected snapshot fields: pot, seats, board, dealer
        if "pot" in snapshot:
            amt = int(snapshot.get("pot") or 0)
            self.store.dispatch({"type": "SET_POT", "amount": amt})
        if "seats" in snapshot:
            self.store.dispatch(
                {"type": "SET_SEATS", "seats": snapshot["seats"]}
            )
        if "board" in snapshot:
            self.store.dispatch(
                {"type": "SET_BOARD", "board": snapshot["board"]}
            )
        if "dealer" in snapshot:
            self.store.dispatch(
                {"type": "SET_DEALER", "dealer": snapshot["dealer"]}
            )

    def dispose(self) -> None:
        for u in self._unsubs:
            try:
                u()
            except Exception:
                pass
        self._unsubs.clear()


class EnhancedRPGWController:
    """Controller for Enhanced RPGW actions - maintains architectural compliance."""
    
    def __init__(self, event_bus, store, ppsm):
        self.event_bus = event_bus
        self.store = store
        self.ppsm = ppsm
        self._setup_event_handlers()
    
    def _setup_event_handlers(self):
        """Setup event handlers for Enhanced RPGW actions."""
        self.event_bus.subscribe(
            "enhanced_rpgw:action_executed",
            self._handle_action_execution
        )
        
        self.event_bus.subscribe(
            "enhanced_rpgw:trigger_animation",
            self._handle_animation_trigger
        )
    
    def _handle_action_execution(self, event_data):
        """Handle Enhanced RPGW action execution via PPSM."""
        try:
            action = event_data['action']
            action_index = event_data['action_index']
            
            # Execute action in PPSM (business logic)
            ppsm_result = self._execute_ppsm_action(action)
            
            # Update store with PPSM results
            self.store.dispatch({
                "type": "UPDATE_ENHANCED_RPGW_STATE",
                "updates": {
                    "ppsm_result": ppsm_result,
                    "last_executed_action": action,
                    "execution_timestamp": time.time()
                }
            })
            
            # Trigger appropriate animations/sounds
            self._trigger_action_feedback(action, ppsm_result)
            
            print(f"üéØ Enhanced RPGW: Action {action_index} executed via PPSM")
            
        except Exception as e:
            print(f"‚ö†Ô∏è Enhanced RPGW: Action execution error: {e}")
            # Dispatch error state
            self.store.dispatch({
                "type": "UPDATE_ENHANCED_RPGW_STATE",
                "updates": {
                    "error": str(e),
                    "execution_status": "error"
                }
            })
    
    def _execute_ppsm_action(self, action):
        """Execute action in PPSM - pure business logic."""
        action_type = action['type']
        
        if action_type == 'DEAL_HOLE':
            return {"type": "hole_cards_dealt", "status": "success"}
        
        elif action_type == 'DEAL_BOARD':
            street = action['payload']['street']
            board = action['payload'].get('board', [])
            return {
                "type": "board_dealt",
                "street": street,
                "cards": board,
                "status": "success"
            }
        
        elif action_type in ['POST_BLIND', 'BET', 'RAISE', 'CALL', 'CHECK', 'FOLD']:
            actor_uid = action['payload'].get('actor_uid')
            amount = action['payload'].get('amount', 0)
            return {
                "type": "player_action",
                "action": action_type,
                "actor": actor_uid,
                "amount": amount,
                "status": "success"
            }
        
        elif action_type == 'END_HAND':
            return {"type": "hand_ended", "status": "success"}
        
        return {"type": "unknown", "status": "unknown"}
    
    def _trigger_action_feedback(self, action, ppsm_result):
        """Trigger appropriate feedback (sounds, animations) based on action."""
        action_type = action['type']
        
        # Map action types to feedback events
        feedback_mapping = {
            'DEAL_HOLE': 'card_deal',
            'DEAL_BOARD': 'card_deal',
            'POST_BLIND': 'chip_bet',
            'BET': 'player_bet',
            'RAISE': 'player_bet',
            'CALL': 'player_call',
            'CHECK': 'player_check',
            'FOLD': 'player_fold',
            'END_HAND': 'hand_end'
        }
        
        feedback_type = feedback_mapping.get(action_type, 'default')
        
        # Publish feedback event
        self.event_bus.publish(
            "enhanced_rpgw:feedback",
            {
                "type": feedback_type,
                "action": action,
                "ppsm_result": ppsm_result
            }
        )
    
    def _handle_animation_trigger(self, event_data):
        """Handle animation trigger events."""
        animation_type = event_data.get('type')
        
        if animation_type == 'player_highlight':
            # Schedule highlight clear animation
            self.event_bus.publish(
                "enhanced_rpgw:animation_event",
                {
                    "type": "SCHEDULE_HIGHLIGHT_CLEAR",
                    "delay_ms": 200,
                    "action": "clear_highlight"
                }
            )
        
        print(f"üé¨ Enhanced RPGW: Animation triggered: {animation_type}")

```

---

### state_styler.py

**Path**: `backend/ui/services/state_styler.py`

**Size**: 20.6 KB

```python
"""
State-driven styling system for poker UI elements.
Handles luxury highlighting and animations for player states.
"""

import time
import math
from typing import Dict, Any, Optional
try:
    # Prefer consolidated loader available in this project
    from .theme_loader_consolidated import load_themes as _load_themes
except Exception:
    _load_themes = None

def get_theme_loader():
    """Compatibility shim that exposes get_defaults/get_theme_by_id API."""
    class _Accessor:
        def __init__(self):
            try:
                self._config = _load_themes() if _load_themes else {"defaults": {}, "themes": []}
            except Exception:
                self._config = {"defaults": {}, "themes": []}

        def get_defaults(self) -> Dict[str, Any]:
            return self._config.get("defaults", {})

        def get_theme_by_id(self, theme_id: str) -> Dict[str, Any]:
            for t in self._config.get("themes", []):
                if t.get("id") == theme_id:
                    return t
            themes = self._config.get("themes", [])
            return themes[0] if themes else {"palette": {}}

    return _Accessor()
from .theme_derive import get_player_state_style


class StateStyler:
    """Manages state-driven styling and animations for poker UI elements."""

    def __init__(self):
        self._active_animations = {}  # Track active animations
        self._last_update = time.time()

    def get_state_style(self, player_state: str, theme_id: str) -> Dict[str, Any]:
        """
        Get styling configuration for a player state.

        Args:
            player_state: State name (active, folded, winner, showdown, allin)
            theme_id: Current theme ID

        Returns:
            Style configuration with resolved colors and animation parameters
        """
        loader = get_theme_loader()
        defaults = loader.get_defaults()
        theme_config = loader.get_theme_by_id(theme_id)
        palette = theme_config.get("palette", {})

        state_styles = get_player_state_style(defaults, palette)
        return state_styles.get(player_state, {})

    def apply_player_state_styling(
        self,
        canvas,
        seat_idx: int,
        state: str,
        theme_id: str,
        x: int,
        y: int,
        pod_width: int,
        pod_height: int,
    ) -> None:
        """
        Apply state-specific styling to a player seat.

        Args:
            canvas: Tkinter canvas to draw on
            seat_idx: Seat index for element tagging
            state: Player state (active, folded, winner, showdown, allin)
            theme_id: Current theme ID
            x, y: Seat center coordinates
            pod_width, pod_height: Seat pod dimensions
        """
        style_config = self.get_state_style(state, theme_id)
        if not style_config:
            return

        current_time = time.time()

        if state == "active":
            self._apply_active_glow(
                canvas,
                seat_idx,
                style_config,
                x,
                y,
                pod_width,
                pod_height,
                current_time,
            )
        elif state == "folded":
            self._apply_folded_styling(
                canvas, seat_idx, style_config, x, y, pod_width, pod_height
            )
        elif state == "winner":
            self._apply_winner_effects(
                canvas,
                seat_idx,
                style_config,
                x,
                y,
                pod_width,
                pod_height,
                current_time,
            )
        elif state == "showdown":
            self._apply_showdown_spotlight(
                canvas,
                seat_idx,
                style_config,
                x,
                y,
                pod_width,
                pod_height,
                current_time,
            )
        elif state == "allin":
            self._apply_allin_flash(
                canvas,
                seat_idx,
                style_config,
                x,
                y,
                pod_width,
                pod_height,
                current_time,
            )

    def _apply_active_glow(
        self,
        canvas,
        seat_idx: int,
        config: Dict[str, Any],
        x: int,
        y: int,
        pod_width: int,
        pod_height: int,
        current_time: float,
    ) -> None:
        """Apply pulsing glow effect for active player."""
        glow_color = config.get("glow", "#1DB954")
        shimmer_color = config.get("shimmer", "#C9A34E")
        strength = config.get("strength", 1.0)
        period_ms = config.get("period_ms", 2000)

        # Calculate pulsing intensity
        period_s = period_ms / 1000.0
        pulse_phase = (current_time % period_s) / period_s
        pulse_intensity = (math.sin(pulse_phase * 2 * math.pi) + 1) / 2  # 0.0 to 1.0

        # Outer glow ring
        glow_radius = int(
            (pod_width + pod_height) / 4 + 10 * strength * pulse_intensity
        )
        canvas.create_oval(
            x - glow_radius,
            y - glow_radius,
            x + glow_radius,
            y + glow_radius,
            fill="",
            outline=glow_color,
            width=int(2 + strength * pulse_intensity),
            tags=("layer:effects", f"active_glow:{seat_idx}"),
        )

        # Inner shimmer highlight  
        shimmer_size = int(pod_width * 0.8)
        canvas.create_oval(
            x - shimmer_size // 2,
            y - shimmer_size // 2,
            x + shimmer_size // 2,
            y + shimmer_size // 2,
            fill="",
            outline=shimmer_color,
            width=1,
            tags=("layer:effects", f"active_shimmer:{seat_idx}"),
        )

    def _apply_folded_styling(
        self,
        canvas,
        seat_idx: int,
        config: Dict[str, Any],
        x: int,
        y: int,
        pod_width: int,
        pod_height: int,
    ) -> None:
        """Apply desaturated/faded styling for folded player."""
        opacity = config.get("opacity", 0.4)
        # Note: desaturate value available in config but not used in this implementation

        # Semi-transparent overlay to simulate reduced opacity
        overlay_color = "#000000"  # Dark overlay

        canvas.create_rectangle(
            x - pod_width // 2,
            y - pod_height // 2,
            x + pod_width // 2,
            y + pod_height // 2,
            fill=overlay_color,
            stipple="gray50",  # Stipple simulates transparency
            tags=("layer:effects", f"folded_overlay:{seat_idx}"),
        )

    def _apply_winner_effects(
        self,
        canvas,
        seat_idx: int,
        config: Dict[str, Any],
        x: int,
        y: int,
        pod_width: int,
        pod_height: int,
        current_time: float,
    ) -> None:
        """Apply celebration effects for winning player."""
        glow_color = config.get("glow", "#C9A34E")
        shimmer_color = config.get("shimmer", "#1DB954")
        strength = config.get("strength", 1.4)
        period_ms = config.get("period_ms", 1500)
        show_particles = config.get("particles", True)

        # Intense winner glow
        period_s = period_ms / 1000.0
        pulse_phase = (current_time % period_s) / period_s
        pulse_intensity = (math.sin(pulse_phase * 2 * math.pi) + 1) / 2

        # Multiple glow rings for intensity
        for ring in range(3):
            glow_radius = int(
                (pod_width + pod_height) / 4
                + (15 + ring * 8) * strength * pulse_intensity
            )
            canvas.create_oval(
                x - glow_radius,
                y - glow_radius,
                x + glow_radius,
                y + glow_radius,
                fill="",
                outline=glow_color,
                width=int(3 - ring),
                tags=("layer:effects", f"winner_glow_{ring}:{seat_idx}"),
            )

        # Shimmer burst effect
        if show_particles:
            for i in range(8):  # 8 shimmer rays
                angle = i * math.pi / 4
                ray_length = int(pod_width * 0.6 * pulse_intensity)
                end_x = x + int(ray_length * math.cos(angle))
                end_y = y + int(ray_length * math.sin(angle))

                canvas.create_line(
                    x,
                    y,
                    end_x,
                    end_y,
                    fill=shimmer_color,
                    width=2,
                    tags=("layer:effects", f"winner_ray_{i}:{seat_idx}"),
                )

    def _apply_showdown_spotlight(
        self,
        canvas,
        seat_idx: int,
        config: Dict[str, Any],
        x: int,
        y: int,
        pod_width: int,
        pod_height: int,
        current_time: float,
    ) -> None:
        """Apply spotlight effect during showdown."""
        spotlight_color = config.get("spotlight", "#FFFFFF")
        opacity = config.get("spotlight_opacity", 0.18)
        duration_ms = config.get("duration_ms", 1500)

        # Fade in/out spotlight effect
        duration_s = duration_ms / 1000.0
        phase = (current_time % duration_s) / duration_s

        # Fade in first half, fade out second half
        if phase < 0.5:
            alpha = phase * 2  # 0 to 1
        else:
            alpha = (1 - phase) * 2  # 1 to 0

        alpha *= opacity

        # Large spotlight circle
        spotlight_radius = int((pod_width + pod_height) / 2 + 20)
        canvas.create_oval(
            x - spotlight_radius,
            y - spotlight_radius,
            x + spotlight_radius,
            y + spotlight_radius,
            fill="",
            outline=spotlight_color,
            width=int(3 * alpha),
            tags=("layer:effects", f"showdown_spotlight:{seat_idx}"),
        )

    def _apply_allin_flash(
        self,
        canvas,
        seat_idx: int,
        config: Dict[str, Any],
        x: int,
        y: int,
        pod_width: int,
        pod_height: int,
        current_time: float,
    ) -> None:
        """Apply dramatic flash effect for all-in players."""
        glow_color = config.get("glow", "#B63D3D")
        shimmer_color = config.get("shimmer", "#C9A34E")
        strength = config.get("strength", 1.2)
        flash_ms = config.get("flash_ms", 400)

        # Fast flash cycle
        flash_s = flash_ms / 1000.0
        flash_phase = (current_time % flash_s) / flash_s

        # Sharp flash: bright at 0, dim at 0.5, bright at 1
        flash_intensity = abs(math.sin(flash_phase * math.pi)) * strength

        # Dramatic border flash
        flash_width = int(4 * flash_intensity)
        canvas.create_rectangle(
            x - pod_width // 2 - flash_width,
            y - pod_height // 2 - flash_width,
            x + pod_width // 2 + flash_width,
            y + pod_height // 2 + flash_width,
            fill="",
            outline=glow_color,
            width=flash_width,
            tags=("layer:effects", f"allin_flash:{seat_idx}"),
        )

        # Inner shimmer
        if flash_intensity > 0.5:
            canvas.create_rectangle(
                x - pod_width // 2 + 2,
                y - pod_height // 2 + 2,
                x + pod_width // 2 - 2,
                y + pod_height // 2 - 2,
                fill="",
                outline=shimmer_color,
                width=2,
                tags=("layer:effects", f"allin_shimmer:{seat_idx}"),
            )

    def clear_state_effects(self, canvas, seat_idx: int) -> None:
        """Clear all state effects for a seat."""
        effect_tags = [
            f"active_glow:{seat_idx}",
            f"active_shimmer:{seat_idx}",
            f"folded_overlay:{seat_idx}",
            f"winner_glow_0:{seat_idx}",
            f"winner_glow_1:{seat_idx}",
            f"winner_glow_2:{seat_idx}",
            f"winner_ray_0:{seat_idx}",
            f"winner_ray_1:{seat_idx}",
            f"winner_ray_2:{seat_idx}",
            f"winner_ray_3:{seat_idx}",
            f"winner_ray_4:{seat_idx}",
            f"winner_ray_5:{seat_idx}",
            f"winner_ray_6:{seat_idx}",
            f"winner_ray_7:{seat_idx}",
            f"showdown_spotlight:{seat_idx}",
            f"allin_flash:{seat_idx}",
            f"allin_shimmer:{seat_idx}",
        ]

        for tag in effect_tags:
            try:
                canvas.delete(tag)
            except Exception:
                pass

    def update_animations(self, canvas, seats_data: list, theme_id: str) -> None:
        """
        Update all animated state effects.
        Should be called regularly (e.g., every 50ms) for smooth animations.
        """

        for idx, seat in enumerate(seats_data):
            # Clear old effects first
            self.clear_state_effects(canvas, idx)

            # Determine player state
            player_state = self._determine_player_state(seat)
            if player_state and player_state != "idle":
                # Get seat position (simplified - should use actual layout)
                w = canvas.winfo_width()
                h = canvas.winfo_height()
                if w > 1 and h > 1:
                    # Calculate position (this should match seats.py logic)
                    cx, cy = w // 2, int(h * 0.52)
                    radius = int(min(w, h) * 0.36)
                    count = len(seats_data)

                    if count > 0:
                        theta = -math.pi / 2 + (2 * math.pi * idx) / count
                        x = cx + int(radius * math.cos(theta))
                        y = cy + int(radius * math.sin(theta))

                        pod_width = 110
                        pod_height = 80

                        self.apply_player_state_styling(
                            canvas,
                            idx,
                            player_state,
                            theme_id,
                            x,
                            y,
                            pod_width,
                            pod_height,
                        )

    def _determine_player_state(self, seat: Dict[str, Any]) -> Optional[str]:
        """Determine the primary state for styling purposes."""
        if seat.get("winner", False):
            return "winner"
        elif seat.get("showdown", False):
            return "showdown"
        elif seat.get("all_in", False):
            return "allin"
        elif seat.get("acting", False):
            return "active"
        elif seat.get("folded", False):
            return "folded"
        else:
            return "idle"


class SelectionStyler:
    """Handles selection highlighting for lists and trees."""

    def apply_selection_styles(self, ttk_style, theme_id: str) -> None:
        """Apply theme-driven selection styles to ttk widgets."""
        loader = get_theme_loader()
        theme_config = loader.get_theme_by_id(theme_id)
        palette = theme_config.get("palette", {})

        # Get derived tokens for background
        from .theme_derive import derive_tokens, darken

        tokens = derive_tokens(palette)

        # Configure Treeview with theme colors
        ttk_style.configure(
            "Treeview",
            background=darken(palette["felt"], 0.75),
            fieldbackground=darken(palette["felt"], 0.75),
            foreground=tokens["text.primary"],
        )

        # Selection highlighting
        selection_bg = palette.get("highlight", "#D4AF37")
        selection_fg = palette.get("highlight_text", "#FFFFFF")

        ttk_style.map(
            "Treeview",
            background=[("selected", selection_bg)],
            foreground=[("selected", selection_fg)],
        )


class EmphasisBarStyler:
    """Handles emphasis bar styling with theme-aware colors and textures."""

    def get_emphasis_bar_colors(self, theme_id: str) -> Dict[str, str]:
        """Get emphasis bar color configuration."""
        loader = get_theme_loader()
        defaults = loader.get_defaults()
        theme_config = loader.get_theme_by_id(theme_id)
        palette = theme_config.get("palette", {})

        emphasis_config = defaults.get("emphasis_bar", {})

        # Resolve token references
        from .theme_derive import resolve_token_references

        resolved_config = resolve_token_references(emphasis_config, palette)

        return {
            "bg_top": resolved_config.get("bg_top", palette["felt"]),
            "bg_bottom": resolved_config.get("bg_bottom", palette["rail"]),
            "text": resolved_config.get(
                "text", palette.get("emphasis_text", "#F8E7C9")
            ),
            "accent_text": resolved_config.get("accent_text", palette["raise"]),
            "divider": resolved_config.get("divider", palette["metal"]),
            "texture": resolved_config.get("texture", "velvet_8pct"),
        }

    def render_emphasis_bar(
        self,
        canvas,
        x: int,
        y: int,
        width: int,
        height: int,
        text: str,
        theme_id: str,
        accent_words: list = None,
    ) -> None:
        """
        Render a luxury emphasis bar with theme-aware styling.

        Args:
            canvas: Tkinter canvas
            x, y: Top-left position
            width, height: Bar dimensions
            text: Text to display
            theme_id: Current theme ID
            accent_words: List of words to highlight with accent color
        """
        colors = self.get_emphasis_bar_colors(theme_id)

        # Background gradient simulation (top to bottom)
        bg_top = colors["bg_top"]
        bg_bottom = colors["bg_bottom"]

        # Draw gradient using multiple rectangles
        gradient_steps = 10
        for i in range(gradient_steps):
            y_pos = y + (height * i) // gradient_steps
            step_height = height // gradient_steps

            # Interpolate between top and bottom colors
            from .theme_derive import mix

            t = i / (gradient_steps - 1)
            step_color = mix(bg_top, bg_bottom, t)

            canvas.create_rectangle(
                x,
                y_pos,
                x + width,
                y_pos + step_height,
                fill=step_color,
                outline="",
                tags=("layer:emphasis", "emphasis_bg"),
            )

        # Divider lines
        divider_color = colors["divider"]
        canvas.create_line(
            x,
            y,
            x + width,
            y,
            fill=divider_color,
            width=1,
            tags=("layer:emphasis", "emphasis_top_line"),
        )
        canvas.create_line(
            x,
            y + height,
            x + width,
            y + height,
            fill=divider_color,
            width=1,
            tags=("layer:emphasis", "emphasis_bottom_line"),
        )

        # Text rendering with accent highlighting
        text_color = colors["text"]
        accent_color = colors["accent_text"]

        if accent_words:
            # Split text and highlight accent words
            words = text.split()
            current_x = x + 10  # Left padding
            text_y = y + height // 2

            for word in words:
                color = (
                    accent_color
                    if word.lower() in [w.lower() for w in accent_words]
                    else text_color
                )
                canvas.create_text(
                    current_x,
                    text_y,
                    text=word,
                    anchor="w",
                    font=fonts.get("label", ("Arial", 12, "bold")),
                    fill=color,
                    tags=("layer:emphasis", "emphasis_text"),
                )
                # Approximate word width for spacing
                current_x += len(word) * 8 + 6  # Rough character width + space
        else:
            # Simple centered text
            canvas.create_text(
                x + width // 2,
                y + height // 2,
                text=text,
                font=("Arial", 12, "bold"),
                fill=text_color,
                tags=("layer:emphasis", "emphasis_text"),
            )


# Global instances
_state_styler = None
_selection_styler = None
_emphasis_bar_styler = None


def get_state_styler() -> StateStyler:
    """Get global state styler instance."""
    global _state_styler
    if _state_styler is None:
        _state_styler = StateStyler()
    return _state_styler


def get_selection_styler() -> SelectionStyler:
    """Get global selection styler instance."""
    global _selection_styler
    if _selection_styler is None:
        _selection_styler = SelectionStyler()
    return _selection_styler


def get_emphasis_bar_styler() -> EmphasisBarStyler:
    """Get global emphasis bar styler instance."""
    global _emphasis_bar_styler
    if _emphasis_bar_styler is None:
        _emphasis_bar_styler = EmphasisBarStyler()
    return _emphasis_bar_styler
```

---

### theme_derive.py

**Path**: `backend/ui/services/theme_derive.py`

**Size**: 7.9 KB

```python
"""
Theme token derivation system for poker themes.
Converts base palette colors into comprehensive token sets for all UI elements.
"""

from typing import Dict, Any


def clamp(x: float) -> int:
    """Clamp value to valid RGB range [0, 255]."""
    return max(0, min(255, int(x)))


def hex_to_rgb(hex_color: str) -> tuple[int, int, int]:
    """Convert hex color to RGB tuple."""
    h = hex_color.strip("#")
    r = int(h[0:2], 16)
    g = int(h[2:4], 16)
    b = int(h[4:6], 16)
    return (r, g, b)


def rgb_to_hex(rgb_tuple: tuple[float, float, float]) -> str:
    """Convert RGB tuple to hex color."""
    return "#{:02X}{:02X}{:02X}".format(*map(clamp, rgb_tuple))


def mix(color_a: str, color_b: str, t: float) -> str:
    """Mix two hex colors with interpolation factor t (0.0 = color_a, 1.0 = color_b)."""
    ra, ga, ba = hex_to_rgb(color_a)
    rb, gb, bb = hex_to_rgb(color_b)
    return rgb_to_hex((ra + (rb - ra) * t, ga + (gb - ga) * t, ba + (bb - ba) * t))


def lighten(hex_color: str, t: float) -> str:
    """Lighten a hex color by factor t (0.0 = no change, 1.0 = white)."""
    return mix(hex_color, "#FFFFFF", t)


def darken(hex_color: str, t: float) -> str:
    """Darken a hex color by factor t (0.0 = no change, 1.0 = black)."""
    return mix(hex_color, "#000000", t)


def alpha_over(src: str, dst: str, alpha: float) -> str:
    """
    Simulate alpha blending of src color over dst color.
    alpha: 0.0 = fully transparent src (shows dst), 1.0 = fully opaque src
    """
    rs, gs, bs = hex_to_rgb(src)
    rd, gd, bd = hex_to_rgb(dst)
    return rgb_to_hex(
        (rd + (rs - rd) * alpha, gd + (gs - gd) * alpha, bd + (bs - bd) * alpha)
    )


def derive_tokens(palette: Dict[str, str]) -> Dict[str, str]:
    """
    Derive comprehensive token set from base palette.

    Args:
        palette: Base color palette with keys like felt, rail, metal, accent, etc.

    Returns:
        Dictionary of derived tokens for all UI elements
    """
    felt = palette["felt"]
    rail = palette["rail"]
    metal = palette["metal"]
    accent = palette["accent"]
    raise_color = palette["raise"]
    call_color = palette["call"]  # Used for future call-specific styling
    neutral = palette["neutral"]
    text = palette["text"]

    # Derive chip colors using sophisticated blending
    chip_face = alpha_over(lighten(felt, 0.18), neutral, 0.25)
    chip_edge = alpha_over(metal, felt, 0.25)
    chip_rim = alpha_over(metal, "#000000", 0.45)

    tokens = {
        # Table surface
        "table.felt": felt,
        "table.rail": rail,
        "table.edgeGlow": darken(felt, 0.6),
        "table.centerPattern": lighten(felt, 0.06),
        # Text hierarchy
        "text.primary": lighten(text, 0.10),
        "text.secondary": lighten(text, 0.35),
        "text.muted": lighten(text, 0.55),
        # Card faces and backs
        "card.face.bg": lighten(neutral, 0.85),
        "card.face.border": darken(neutral, 0.50),
        "card.pip.red": mix(raise_color, "#FF2A2A", 0.35),
        "card.pip.black": darken(neutral, 0.85),
        "card.back.bg": alpha_over(accent, felt, 0.35),
        "card.back.pattern": alpha_over(metal, accent, 0.25),
        "card.back.border": metal,
        # Board elements
        "board.slotBg": alpha_over(darken(felt, 0.45), felt, 0.80),
        "board.border": alpha_over(metal, felt, 0.85),
        "board.cardFaceFg": lighten(neutral, 0.85),
        "board.cardBack": alpha_over(accent, felt, 0.35),
        # Chip system (stack/bet/pot with theme awareness)
        "chip_face": chip_face,
        "chip_edge": chip_edge,
        "chip_rim": chip_rim,
        "chip_text": "#F8F7F4",
        # Bet chips (accent-themed)
        "bet_face": alpha_over(accent, chip_face, 0.60),
        "bet_edge": alpha_over(accent, chip_edge, 0.75),
        "bet_rim": alpha_over(metal, accent, 0.55),
        "bet_glow": alpha_over(metal, accent, 0.35),
        # Pot chips (metal-themed)
        "pot_face": alpha_over(lighten(metal, 0.20), chip_face, 0.70),
        "pot_edge": alpha_over(metal, "#000000", 0.15),
        "pot_rim": alpha_over(lighten(metal, 0.35), "#000000", 0.30),
        "pot_text": "#0B0B0E",
        "pot_glow": alpha_over(lighten(metal, 0.25), "#000000", 0.20),
        # Selection and highlighting
        "highlight": palette["highlight"],
        "highlight_text": palette["highlight_text"],
        "emphasis.text": palette["emphasis_text"],
        "emphasis.divider": metal,
        # Player seats and states
        "seat.bg.idle": alpha_over(darken(felt, 0.3), neutral, 0.15),
        "seat.bg.active": alpha_over(lighten(felt, 0.1), neutral, 0.20),
        "seat.ring": alpha_over(metal, felt, 0.40),
        "seat.accent": accent,
        "seat.highlight": alpha_over(lighten(metal, 0.15), felt, 0.30),
        "seat.shadow": darken(felt, 0.4),
        "seat.cornerAccent": metal,
        # Player nameplate
        "player.nameplate.bg": alpha_over(darken(felt, 0.2), neutral, 0.10),
        "player.nameplate.border": alpha_over(metal, felt, 0.50),
        "player.name": lighten(text, 0.05),
        # Action states and focus
        "a11y.focus": "#DAA520",  # Gold focus ring
        # Pot display
        "pot.badgeRing": lighten(metal, 0.15),
        "pot.bg": alpha_over(lighten(metal, 0.25), felt, 0.70),
        "pot.border": metal,
        # Button states
        "btn.secondary.border": alpha_over(metal, felt, 0.60),
        # Legacy compatibility tokens (for existing components)
        "bet.bg": alpha_over(accent, felt, 0.40),
        "bet.border": alpha_over(metal, accent, 0.60),
        "bet.text": lighten(metal, 0.20),
        "bet.active": raise_color,
    }

    return tokens


def resolve_token_references(
    config: Dict[str, Any], palette: Dict[str, str]
) -> Dict[str, Any]:
    """
    Resolve $token references in configuration using palette.

    Args:
        config: Configuration dict that may contain $token references
        palette: Base palette to resolve references from

    Returns:
        Configuration with all $token references resolved
    """

    def resolve_value(value):
        if isinstance(value, str) and value.startswith("$"):
            token_key = value[1:]  # Remove $ prefix
            if token_key in palette:
                return palette[token_key]
            else:
                print(f"‚ö†Ô∏è Unknown token reference: {value}")
                return value  # Return as-is if token not found
        elif isinstance(value, dict):
            return {k: resolve_value(v) for k, v in value.items()}
        elif isinstance(value, list):
            return [resolve_value(item) for item in value]
        else:
            return value

    return resolve_value(config)


def get_player_state_style(
    defaults: Dict[str, Any], palette: Dict[str, str]
) -> Dict[str, Dict[str, Any]]:
    """
    Get player state styling configuration with resolved token references.

    Args:
        defaults: Default configuration from theme pack
        palette: Base color palette

    Returns:
        Resolved state styling configuration
    """
    state_config = defaults.get("state", {})
    return resolve_token_references(state_config, palette)


def get_selection_style(
    defaults: Dict[str, Any], palette: Dict[str, str]
) -> Dict[str, str]:
    """Get selection highlighting style with resolved tokens."""
    selection_config = defaults.get("selection", {})
    return resolve_token_references(selection_config, palette)


def get_emphasis_bar_style(
    defaults: Dict[str, Any], palette: Dict[str, str]
) -> Dict[str, str]:
    """Get emphasis bar styling with resolved tokens."""
    emphasis_config = defaults.get("emphasis_bar", {})
    return resolve_token_references(emphasis_config, palette)


def get_chip_styles(
    defaults: Dict[str, Any], palette: Dict[str, str]
) -> Dict[str, Dict[str, str]]:
    """Get chip styling configurations with resolved tokens."""
    chip_config = defaults.get("chips", {})
    return resolve_token_references(chip_config, palette)
```

---

### theme_factory.py

**Path**: `backend/ui/services/theme_factory.py`

**Size**: 27.1 KB

```python
"""
Theme Factory - Deterministic Token Generation
Builds complete theme token sets from minimal base color palettes
Now integrated with config-driven theme system
"""

from .theme_utils import lighten, darken, mix, alpha_over
from .theme_loader import get_theme_loader
from .theme_derive import (
    derive_tokens,
    get_player_state_style,
    get_selection_style,
    get_emphasis_bar_style,
    get_chip_styles,
)


def _get_emphasis_background(base):
    """Get emphasis background with painter-specific styling."""
    painter = base.get("painter", "classic")
    felt = base["felt"]
    accent = base["accent"]

    if painter == "impressionist":  # Monet Noir
        # Misty gradient: #253C4A ‚Üí #0D1B1E
        return f"linear-gradient(180deg, {accent} 0%, {felt} 100%)"
    elif painter == "ornamental":  # Klimt Royale
        # Deep mahogany with gold tessellation
        return "linear-gradient(180deg, #6E0D0D 0%, #3D0606 100%)"
    elif painter == "gemstone":  # Imperial Jade
        # Jade gradient with mandala emboss
        return f"linear-gradient(180deg, {lighten(felt, 0.1)} 0%, {darken(felt, 0.2)} 100%)"
    elif painter == "geometric":  # Deco Luxe
        # Smoky indigo with art deco pattern
        return f"linear-gradient(180deg, {lighten(felt, 0.15)} 0%, {darken(felt, 0.1)} 100%)"
    else:
        # Classic gradient for other themes
        return f"linear-gradient(180deg, {lighten(felt, 0.2)} 0%, {darken(felt, 0.1)} 100%)"


def _get_emphasis_text_color(base):
    """Get emphasis text color optimized for readability."""
    painter = base.get("painter", "classic")

    if painter == "impressionist":  # Monet Noir
        return "#F5F7FA"  # Soft white for pastel glow
    elif painter == "ornamental":  # Klimt Royale
        return "#F4E2C9"  # Golden-ivory for luxury
    elif painter == "gemstone":  # Imperial Jade
        return "#E8E6E3"  # Pearl white for elegance
    elif painter == "geometric":  # Deco Luxe
        return "#F5F0E1"  # Cream white for sophistication
    else:
        return lighten(base["text"], 0.20)  # Enhanced contrast for others


def _get_emphasis_highlight(base):
    """Get emphasis highlight color for important words."""
    painter = base.get("painter", "classic")

    if painter == "impressionist":  # Monet Noir
        return "#E8A7C3"  # Pastel pink
    elif painter == "ornamental":  # Klimt Royale
        return "#C1121F"  # Blood crimson glow
    elif painter == "gemstone":  # Imperial Jade
        return "#C9A441"  # Antique gold
    elif painter == "geometric":  # Deco Luxe
        return "#B08D57"  # Polished brass
    else:
        return base["raise_"]  # Use theme's danger color


def _get_emphasis_glow(base):
    """Get emphasis inner glow color."""
    painter = base.get("painter", "classic")

    if painter == "impressionist":  # Monet Noir
        return alpha_over("#A7C8E8", "#000000", 0.12)  # Pale sky blue glow
    elif painter == "ornamental":  # Klimt Royale
        return alpha_over("#FFD700", "#000000", 0.12)  # Gold inner glow
    elif painter == "gemstone":  # Imperial Jade
        return alpha_over("#DAA520", "#000000", 0.10)  # Jade-gold glow
    elif painter == "geometric":  # Deco Luxe
        return alpha_over("#D4AF37", "#000000", 0.12)  # Art deco gold glow
    else:
        return alpha_over(base["metal"], "#000000", 0.15)


def _get_emphasis_border(base):
    """Get emphasis border color (gold trim lines)."""
    painter = base.get("painter", "classic")

    if painter in ["ornamental", "gemstone", "geometric"]:
        return "#B8860B"  # Gold leaf trim
    elif painter == "impressionist":
        return alpha_over("#C8D5DE", "#000000", 0.40)  # Soft metallic
    else:
        return base["metal"]


def build_theme(base):
    """
    Build complete theme tokens from base palette

    Args:
        base: dict with keys:
            - felt: Primary table surface color
            - metal: Trim/accent metallic color
            - accent: Secondary accent color
            - raise_: Danger/raise action color
            - call: Success/call action color
            - neutral: Neutral gray base
            - text: Primary text color
            - background: (optional) Background color for artistic themes
            - pattern_overlay: (optional) Pattern overlay identifier
            - identifier_effect: (optional) Unique visual effect
            - painter: (optional) Painter style identifier

    Returns:
        Complete token dictionary for all UI elements
    """
    felt = base["felt"]
    metal = base["metal"]
    accent = base["accent"]
    raise_c = base["raise_"]
    call_c = base["call"]
    neutral = base["neutral"]
    txt = base["text"]

    # Artistic theme enhancements
    background = base.get("background", darken(felt, 0.8))
    pattern_overlay = base.get("pattern_overlay", None)
    identifier_effect = base.get("identifier_effect", None)
    painter = base.get("painter", None)

    # Build comprehensive token set
    tokens = {
        # === SURFACES ===
        "table.felt": felt,
        "table.rail": darken(felt, 0.75),
        "table.inlay": metal,
        "table.edgeGlow": darken(felt, 0.6),
        "table.centerPattern": lighten(felt, 0.06),  # Subtle ellipse at center
        # === TEXT ===
        "text.primary": lighten(txt, 0.10),
        "text.secondary": lighten(txt, 0.35),
        "text.muted": lighten(txt, 0.55),
        # === EMPHASIZED TEXT (High-contrast bars) ===
        "text.emphasis.bg": _get_emphasis_background(base),
        "text.emphasis.color": _get_emphasis_text_color(base),
        "text.emphasis.highlight": _get_emphasis_highlight(base),
        "text.emphasis.shadow": alpha_over("#000000", felt, 0.60),
        "text.emphasis.glow": _get_emphasis_glow(base),
        "text.emphasis.border": _get_emphasis_border(base),
        # === CARDS ===
        # Neutral ivory face, theme-tinted back
        "card.face.bg": lighten(neutral, 0.85),
        "card.face.border": darken(neutral, 0.50),
        "card.pip.red": mix(raise_c, "#FF2A2A", 0.35),
        "card.pip.black": darken(neutral, 0.85),
        "card.back.bg": alpha_over(accent, felt, 0.35),
        "card.back.pattern": alpha_over(metal, accent, 0.25),
        "card.back.border": metal,
        # === COMMUNITY BOARD ===
        "board.slotBg": alpha_over(darken(felt, 0.45), felt, 0.80),
        "board.border": alpha_over(metal, felt, 0.85),
        "board.shadow": darken(felt, 0.85),
        # === CHIPS ===
        # Standard casino colors with theme-tinted rims
        "chip.$1": "#2E86AB",  # Blue
        "chip.$5": "#B63D3D",  # Red
        "chip.$25": "#2AA37A",  # Green
        "chip.$100": "#3C3A3A",  # Black
        "chip.$500": "#6C4AB6",  # Purple
        "chip.$1k": "#D1B46A",  # Gold
        "chip.rim": alpha_over(metal, "#000000", 0.35),
        "chip.text": "#F8F7F4",
        # === POT ===
        "pot.badgeBg": alpha_over(darken(felt, 0.5), felt, 0.85),
        "pot.badgeRing": metal,
        "pot.valueText": lighten(neutral, 0.9),
        # === BETS & ANIMATIONS ===
        "bet.path": alpha_over(accent, "#000000", 0.50),
        "bet.glow": alpha_over(metal, "#000000", 0.35),
        # === PLAYER LABELS ===
        "label.active.bg": alpha_over(call_c, "#000000", 0.60),
        "label.active.fg": lighten(neutral, 0.95),
        "label.folded.bg": alpha_over(neutral, "#000000", 0.75),
        "label.folded.fg": lighten(neutral, 0.65),
        "label.winner.bg": alpha_over(metal, "#000000", 0.70),
        "label.winner.fg": "#0B0B0E",
        # === BUTTONS (Enhanced from existing system) ===
        "btn.primary.bg": alpha_over(accent, "#000000", 0.70),
        "btn.primary.fg": lighten(neutral, 0.95),
        "btn.primary.border": metal,
        "btn.primary.hoverBg": alpha_over(accent, "#000000", 0.55),
        "btn.primary.hoverFg": "#FFFFFF",
        "btn.primary.hoverBorder": lighten(metal, 0.20),
        "btn.primary.activeBg": alpha_over(accent, "#000000", 0.85),
        "btn.primary.activeFg": "#FFFFFF",
        "btn.primary.activeBorder": lighten(metal, 0.35),
        "btn.secondary.bg": alpha_over(neutral, "#000000", 0.60),
        "btn.secondary.fg": lighten(txt, 0.20),
        "btn.secondary.border": alpha_over(metal, "#000000", 0.60),
        "btn.secondary.hoverBg": alpha_over(neutral, "#000000", 0.45),
        "btn.secondary.hoverFg": lighten(txt, 0.35),
        "btn.secondary.hoverBorder": alpha_over(metal, "#000000", 0.45),
        "btn.danger.bg": alpha_over(raise_c, "#000000", 0.70),
        "btn.danger.fg": lighten(neutral, 0.95),
        "btn.danger.border": lighten(raise_c, 0.20),
        "btn.danger.hoverBg": alpha_over(raise_c, "#000000", 0.55),
        "btn.danger.hoverFg": "#FFFFFF",
        "btn.danger.hoverBorder": lighten(raise_c, 0.35),
        # === PLAYER SEATS ===
        "seat.bg.idle": alpha_over(neutral, felt, 0.25),
        "seat.bg.active": alpha_over(call_c, felt, 0.15),
        "seat.bg.acting": alpha_over(call_c, "#000000", 0.40),
        "seat.bg.folded": alpha_over(neutral, "#000000", 0.70),
        "seat.ring": alpha_over(metal, felt, 0.60),
        "seat.highlight": lighten(felt, 0.15),
        "seat.shadow": darken(felt, 0.80),
        # === DEALER BUTTON ===
        "dealer.buttonBg": lighten(neutral, 0.90),
        "dealer.buttonFg": darken(neutral, 0.85),
        "dealer.buttonBorder": metal,
        # === ACTION COLORS ===
        "action.fold": alpha_over(neutral, "#000000", 0.60),
        "action.check": alpha_over(call_c, "#000000", 0.50),
        "action.call": call_c,
        "action.bet": alpha_over(metal, call_c, 0.70),
        "action.raise": raise_c,
        "action.allin": alpha_over(raise_c, metal, 0.60),
        # === ACCESSIBILITY & CHROME ===
        "a11y.focus": lighten(metal, 0.30),
        "divider": darken(felt, 0.70),
        "grid.lines": darken(felt, 0.60),
        # === MICRO-INTERACTIONS ===
        "glow.soft": alpha_over(metal, "#000000", 0.20),
        "glow.medium": alpha_over(metal, "#000000", 0.40),
        "glow.strong": alpha_over(metal, "#000000", 0.70),
        "pulse.slow": alpha_over(call_c, "#000000", 0.30),
        "pulse.fast": alpha_over(raise_c, "#000000", 0.50),
        # === TYPOGRAPHY ===
        "font.display": ("Inter", 24, "bold"),
        "font.h1": ("Inter", 20, "bold"),
        "font.h2": ("Inter", 16, "semibold"),
        "font.body": ("Inter", 14, "normal"),
        "font.small": ("Inter", 12, "normal"),
        "font.mono": ("JetBrains Mono", 12, "normal"),
        # === ARTISTIC ENHANCEMENTS ===
        "artistic.background": background,
        "artistic.pattern_overlay": pattern_overlay,
        "artistic.identifier_effect": identifier_effect,
        "artistic.painter": painter,
        # === PAINTER-SPECIFIC EFFECTS ===
        "effect.soft_glow": alpha_over(accent, "#FFFFFF", 0.15),
        "effect.gold_dust": "#FFD700",
        "effect.jade_gloss": alpha_over("#014421", "#FFFFFF", 0.25),
        "effect.arc_motion": metal,
        # === PATTERN OVERLAYS ===
        "pattern.mist_ripple": alpha_over(accent, "#FFFFFF", 0.12),
        "pattern.gold_tessellation": alpha_over("#D4AF37", felt, 0.15),
        "pattern.jade_mandala": alpha_over("#DAA520", felt, 0.10),
        "pattern.art_deco_sunburst": alpha_over("#D4AF37", felt, 0.12),
    }

    # Add premium chip tokens
    derive_chip_tokens(tokens, felt, metal, accent, raise_c, call_c, neutral)

    return tokens


def derive_chip_tokens(tokens, felt, metal, accent, raise_c, call_c, neutral):
    """Derive premium chip tokens from base theme swatches."""
    # Base "casino composite clay" hue: a mix of felt and neutral
    base_face = alpha_over(lighten(felt, 0.18), neutral, 0.25)
    base_edge = alpha_over(metal, felt, 0.25)
    base_rim = alpha_over(metal, "#000000", 0.45)
    base_text = "#F8F7F4"

    tokens.update(
        {
            # Generic chip tokens
            "chip.face": base_face,
            "chip.edge": base_edge,
            "chip.rim": base_rim,
            "chip.text": base_text,
            # Stack chips: calm, readable, less saturated to avoid UI noise
            "chip.stack.face": alpha_over(base_face, "#000000", 0.15),
            "chip.stack.edge": alpha_over(base_edge, "#000000", 0.10),
            "chip.stack.rim": base_rim,
            "chip.stack.text": base_text,
            "chip.stack.shadow": darken(felt, 0.85),
            # Bet/Call chips: pop with the theme accent for motion visibility
            "chip.bet.face": alpha_over(accent, base_face, 0.60),
            "chip.bet.edge": alpha_over(accent, base_edge, 0.75),
            "chip.bet.rim": alpha_over(metal, accent, 0.55),
            "chip.bet.text": base_text,
            "chip.bet.glow": alpha_over(metal, accent, 0.35),
            # Pot chips: prestigious‚Äîlean into metal, slightly brighter
            "chip.pot.face": alpha_over(lighten(metal, 0.20), base_face, 0.70),
            "chip.pot.edge": alpha_over(metal, "#000000", 0.15),
            "chip.pot.rim": alpha_over(lighten(metal, 0.35), "#000000", 0.30),
            "chip.pot.text": "#0B0B0E",
            "chip.pot.glow": alpha_over(lighten(metal, 0.25), "#000000", 0.20),
        }
    )


# Base color palettes for all 16 themes
THEME_BASES = {
    # Row 1 ‚Äî Classic
    "Forest Green Professional": {
        "felt": "#1E4D2B",
        "metal": "#C9A86A",
        "accent": "#2E7D32",
        "raise_": "#B63D3D",
        "call": "#2AA37A",
        "neutral": "#9AA0A6",
        "text": "#EDECEC",
    },
    "Velvet Burgundy": {
        "felt": "#4A1212",
        "metal": "#C0A066",
        "accent": "#702525",
        "raise_": "#B53A44",
        "call": "#2AA37A",
        "neutral": "#A29A90",
        "text": "#F2E9DF",
        "painter": "velvet",
        "identifier_effect": "crimson_glow",
    },
    "Obsidian Gold": {
        "felt": "#0A0A0A",
        "metal": "#D4AF37",
        "accent": "#2C2C2C",
        "raise_": "#A41E34",
        "call": "#2AA37A",
        "neutral": "#A7A7A7",
        "text": "#E6E6E6",
    },
    "Imperial Jade": {
        "felt": "#014421",
        "metal": "#DAA520",
        "accent": "#C9A441",
        "raise_": "#B23B43",
        "call": "#32B37A",
        "neutral": "#9CB1A8",
        "text": "#E8E6E3",
        "background": "#0C0C0C",
        "pattern_overlay": "jade_mandala",
        "identifier_effect": "jade_gloss",
        "painter": "gemstone",
    },
    # Row 2 ‚Äî Artistic 4 (Painter-Inspired Luxury)
    "Monet Noir": {
        "felt": "#0D1B1E",
        "metal": "#C8D5DE",
        "accent": "#253C4A",
        "raise_": "#E8A7C3",
        "call": "#A7C8E8",
        "neutral": "#8EA6B5",
        "text": "#F5F7FA",
        "background": "#3B2F4A",
        "pattern_overlay": "mist_ripple",
        "identifier_effect": "soft_glow",
        "painter": "impressionist",
    },
    "Caravaggio Noir": {
        "felt": "#0A0A0C",
        "metal": "#E1C16E",
        "accent": "#9E0F28",
        "raise_": "#B3122E",
        "call": "#2AA37A",
        "neutral": "#9C8F7A",
        "text": "#FFF7E6",
    },
    "Klimt Royale": {
        "felt": "#0A0A0A",
        "metal": "#FFD700",
        "accent": "#D4AF37",
        "raise_": "#A4161A",
        "call": "#32B37A",
        "neutral": "#A38E6A",
        "text": "#FFF2D9",
        "background": "#3C2B1F",
        "pattern_overlay": "gold_tessellation",
        "identifier_effect": "gold_dust",
        "painter": "ornamental",
    },
    "Deco Luxe": {
        "felt": "#1B1E2B",
        "metal": "#B08D57",
        "accent": "#D4AF37",
        "raise_": "#5B1922",
        "call": "#2AA37A",
        "neutral": "#9B9486",
        "text": "#F5F0E1",
        "background": "#2E3B55",
        "pattern_overlay": "art_deco_sunburst",
        "identifier_effect": "arc_motion",
        "painter": "geometric",
    },
    # Row 3 ‚Äî Nature & Light
    "Sunset Mirage": {
        "felt": "#2B1C1A",
        "metal": "#E6B87A",
        "accent": "#C16E3A",
        "raise_": "#C85C5C",
        "call": "#2AA37A",
        "neutral": "#A68C7A",
        "text": "#F7E7D6",
    },
    "Oceanic Blue": {
        "felt": "#0F1620",
        "metal": "#B7C1C8",
        "accent": "#3B6E8C",
        "raise_": "#6C94D2",
        "call": "#57C2B6",
        "neutral": "#9DB3C4",
        "text": "#F5F7FA",
    },
    "Velour Crimson": {
        "felt": "#6E0B14",
        "metal": "#C18F65",
        "accent": "#3B0A0F",
        "raise_": "#A41E34",
        "call": "#2AA37A",
        "neutral": "#A3928A",
        "text": "#F5E2C8",
    },
    "Golden Dusk": {
        "felt": "#5C3A21",
        "metal": "#C18F65",
        "accent": "#A3622B",
        "raise_": "#B35A3B",
        "call": "#2AA37A",
        "neutral": "#AF9A8A",
        "text": "#F3E3D3",
    },
    # Row 4 ‚Äî Modern / Bold
    "Cyber Neon": {
        "felt": "#0D0F13",
        "metal": "#9BE3FF",
        "accent": "#17C3E6",
        "raise_": "#D65DB1",
        "call": "#00D9A7",
        "neutral": "#A3A8B3",
        "text": "#EAF8FF",
    },
    "Stealth Graphite": {
        "felt": "#111214",
        "metal": "#8D8D8D",
        "accent": "#232629",
        "raise_": "#9E3B49",
        "call": "#57C2B6",
        "neutral": "#8E9196",
        "text": "#E6E7EA",
    },
    "Royal Sapphire": {
        "felt": "#0B1F36",
        "metal": "#C7D3E0",
        "accent": "#224D8F",
        "raise_": "#6C4AB6",
        "call": "#57C2B6",
        "neutral": "#9AB1CF",
        "text": "#F2F6FC",
    },
    "Midnight Aurora": {
        "felt": "#0E1A28",
        "metal": "#D0D9DF",
        "accent": "#1C3E4A",
        "raise_": "#6FB5E7",
        "call": "#7BD0BC",
        "neutral": "#98A8B8",
        "text": "#F5F7FA",
    },
}


def _get_theme_selection_highlight(theme_name: str) -> dict:
    """Get theme-specific selection highlight colors for immersive experience."""

    # Theme-specific highlight palette for hand selections (matching THEME_ORDER)
    highlights = {
        # Row 1 ‚Äî Classic Casino
        "Forest Green Professional": {
            "color": "#1DB954",
            "glow": "#22FF5A",
            "style": "emerald",
        },
        "Velvet Burgundy": {
            "color": "#A31D2B",
            "glow": "#C12839",
            "style": "deep_wine",
        },
        "Obsidian Gold": {"color": "#4169E1", "glow": "#6495ED", "style": "sapphire"},
        "Imperial Jade": {"color": "#00A86B", "glow": "#20C997", "style": "jade_teal"},
        # Row 2 ‚Äî Luxury Noir (Art-inspired)
        "Monet Noir": {"color": "#E8A7C3", "glow": "#FFB6C1", "style": "rose"},
        "Caravaggio Noir": {
            "color": "#EAD6B7",
            "glow": "#F5E6C8",
            "style": "candlelight_ivory",
        },
        "Klimt Royale": {
            "color": "#B87333",
            "glow": "#CD853F",
            "style": "burnished_copper",
        },
        "Deco Luxe": {"color": "#B08D57", "glow": "#D4AF37", "style": "art_deco_brass"},
        # Row 3 ‚Äî Nature & Light
        "Sunset Mirage": {
            "color": "#FF6B35",
            "glow": "#FF8C42",
            "style": "sunset_orange",
        },
        "Oceanic Blue": {"color": "#20B2AA", "glow": "#48D1CC", "style": "turquoise"},
        "Velour Crimson": {"color": "#FFD700", "glow": "#FFF700", "style": "gold"},
        "Golden Dusk": {"color": "#B87333", "glow": "#CD853F", "style": "copper"},
        # Row 4 ‚Äî Modern / Bold
        "Cyber Neon": {"color": "#00FFFF", "glow": "#00FFFF", "style": "electric_cyan"},
        "Stealth Graphite": {
            "color": "#708090",
            "glow": "#B0C4DE",
            "style": "steel_blue",
        },
        "Royal Sapphire": {
            "color": "#4169E1",
            "glow": "#6495ED",
            "style": "royal_blue",
        },
        "Midnight Aurora": {
            "color": "#7BD0BC",
            "glow": "#98FB98",
            "style": "aurora_green",
        },
    }

    return highlights.get(
        theme_name,
        {
            "color": "#1DB954",
            "glow": "#22FF5A",
            "style": "emerald",  # Default fallback
        },
    )


def _get_theme_emphasis_colors(theme_name: str) -> dict:
    """Get theme-specific emphasis text colors for better contrast."""

    emphasis_colors = {
        # Row 1 ‚Äî Classic Casino
        "Forest Green Professional": {
            "bg_gradient": ["#0B2818", "#051A0C"],
            "text": "#F0F8E8",
            "accent": "#1DB954",
        },
        "Velvet Burgundy": {
            "bg_gradient": ["#5C0A0A", "#2B0000"],
            "text": "#F9E7C9",
            "accent": "#A31D2B",
        },
        "Obsidian Gold": {
            "bg_gradient": ["#1A1A1A", "#0A0A0A"],
            "text": "#F9E7C9",
            "accent": "#D4AF37",
        },
        "Imperial Jade": {
            "bg_gradient": ["#1A2F1A", "#0F1F0F"],
            "text": "#F0F8E8",
            "accent": "#C9A441",
        },
        # Row 2 ‚Äî Luxury Noir (Art-inspired)
        "Monet Noir": {
            "bg_gradient": ["#2C2C2C", "#1A1A1A"],
            "text": "#F5F0E1",
            "accent": "#E8A7C3",
        },
        "Caravaggio Noir": {
            "bg_gradient": ["#2A1A1A", "#1A0F0F"],
            "text": "#EAD6B7",
            "accent": "#EAD6B7",
        },
        "Klimt Royale": {
            "bg_gradient": ["#3D2914", "#2A1C0E"],
            "text": "#F5F0E1",
            "accent": "#C1121F",
        },
        "Deco Luxe": {
            "bg_gradient": ["#2A2A2A", "#1A1A1A"],
            "text": "#F5F0E1",
            "accent": "#B08D57",
        },
        # Row 3 ‚Äî Nature & Light
        "Sunset Mirage": {
            "bg_gradient": ["#3D1A0F", "#2B1208"],
            "text": "#F5E6D3",
            "accent": "#FF6B35",
        },
        "Oceanic Blue": {
            "bg_gradient": ["#0F2B3D", "#081A2B"],
            "text": "#E8F4F8",
            "accent": "#20B2AA",
        },
        "Velour Crimson": {
            "bg_gradient": ["#5C0A0A", "#2B0000"],
            "text": "#F9E7C9",
            "accent": "#C1121F",
        },
        "Golden Dusk": {
            "bg_gradient": ["#4A2F1A", "#2B1C10"],
            "text": "#EBD9B0",
            "accent": "#C18F65",
        },
        # Row 4 ‚Äî Modern Bold
        "Cyber Neon": {
            "bg_gradient": ["#1A1F2E", "#0F1419"],
            "text": "#E8F8FF",
            "accent": "#00FFFF",
        },
        "Stealth Graphite": {
            "bg_gradient": ["#2A2A2A", "#1A1A1A"],
            "text": "#E6E7EA",
            "accent": "#708090",
        },
        "Royal Sapphire": {
            "bg_gradient": ["#1A2A4A", "#0F1A3D"],
            "text": "#F2F6FC",
            "accent": "#4169E1",
        },
        "Midnight Aurora": {
            "bg_gradient": ["#1A2F2A", "#0F1F1A"],
            "text": "#F0F8F5",
            "accent": "#7BD0BC",
        },
    }

    return emphasis_colors.get(
        theme_name,
        {
            "bg_gradient": ["#2A2A2A", "#1A1A1A"],
            "text": "#F5F5F5",
            "accent": "#1DB954",  # Default
        },
    )


def build_theme_from_config(theme_id: str) -> dict:
    """
    Build theme using new config-driven system.

    Args:
        theme_id: ID of theme to build from poker_themes.json

    Returns:
        Complete theme token set
    """
    loader = get_theme_loader()
    defaults = loader.get_defaults()
    theme_config = loader.get_theme_by_id(theme_id)

    palette = theme_config.get("palette", {})

    # Derive comprehensive token set
    tokens = derive_tokens(palette)

    # Add config-driven state styles
    state_styles = get_player_state_style(defaults, palette)
    for k, v in state_styles.items():
        tokens[f"state.{k}"] = v  # type: ignore

    # Add selection styles
    selection_style = get_selection_style(defaults, palette)
    for k, v in selection_style.items():
        tokens[f"selection.{k}"] = v  # type: ignore

    # Add emphasis bar styles
    emphasis_style = get_emphasis_bar_style(defaults, palette)
    for k, v in emphasis_style.items():
        tokens[f"emphasis.{k}"] = v  # type: ignore

    # Add chip styles
    chip_styles = get_chip_styles(defaults, palette)
    for chip_type, styles in chip_styles.items():
        for k, v in styles.items():
            tokens[f"chips.{chip_type}.{k}"] = v  # type: ignore

    # Add theme metadata
    tokens.update(
        {
            "theme.id": theme_config.get("id", theme_id),
            "theme.name": theme_config.get("name", theme_id),
            "theme.palette": palette,
        }
    )

    # Legacy compatibility: add UI highlight tokens
    tokens["ui.highlight"] = palette.get("highlight", "#D4AF37")
    tokens["ui.highlight.text"] = palette.get("highlight_text", "#FFFFFF")
    tokens["ui.highlight.glow"] = tokens.get("bet_glow", "#22C55E")

    return tokens


def build_all_themes():
    """Build complete token sets for all 16 themes using config-driven system"""
    themes = {}

    try:
        # Try to use new config-driven system
        loader = get_theme_loader()
        theme_list = loader.get_theme_list()
        print(f"üé® ThemeFactory: Found {len(theme_list)} themes in config")

        for theme_info in theme_list:
            theme_id = theme_info["id"]
            # Use display name as key for theme manager compatibility
            display_name = theme_info["name"]
            print(f"üé® Building theme: {display_name} (id: {theme_id})")
            themes[display_name] = build_theme_from_config(theme_id)

        print(f"‚úÖ Built {len(themes)} themes using config-driven system")

    except Exception as e:
        print(f"‚ö†Ô∏è Config-driven theme loading failed: {e}")
        print("üîÑ Falling back to legacy theme system...")

        # Fallback to legacy system
        for name, base in THEME_BASES.items():
            theme = build_theme(base)
            # Use actual JSON theme highlight colors instead of hardcoded values
            # The theme already has the correct highlight values from build_theme()
            # Don't override them with hardcoded selection_highlight values
            theme["ui.highlight"] = theme.get("ui.highlight", base.get("highlight", "#D4AF37"))
            theme["ui.highlight.text"] = theme.get("ui.highlight.text", base.get("highlight_text", "#FFFFFF"))
            theme["ui.highlight.glow"] = theme.get("ui.highlight.glow", base.get("metal", base.get("accent", "#FFD700")))
            themes[name] = theme

    return themes


def get_available_theme_names() -> list[str]:
    """Get list of available theme names for UI selection."""
    try:
        loader = get_theme_loader()
        theme_list = loader.get_theme_list()
        return [theme_info["name"] for theme_info in theme_list]
    except Exception:
        # Fallback to legacy theme names
        return list(THEME_BASES.keys())


def get_theme_by_name(theme_name: str) -> dict:
    """Get theme by display name (for UI compatibility)."""
    try:
        loader = get_theme_loader()
        theme_list = loader.get_theme_list()

        # Find theme by name
        for theme_info in theme_list:
            if theme_info["name"] == theme_name:
                return build_theme_from_config(theme_info["id"])

        # Fallback: try by ID (kebab-case)
        theme_id = theme_name.lower().replace(" ", "-")
        return build_theme_from_config(theme_id)

    except Exception as e:
        print(f"‚ö†Ô∏è Could not load theme '{theme_name}': {e}")

        # Legacy fallback
        if theme_name in THEME_BASES:
            return build_theme(THEME_BASES[theme_name])

        # Ultimate fallback
        return build_theme(THEME_BASES["Forest Green Professional"])
```

---

### theme_loader.py

**Path**: `backend/ui/services/theme_loader.py`

**Size**: 6.9 KB

```python
"""
Theme loader for config-driven poker theme system.
Loads theme packs from JSON and provides access to defaults and themes.
"""

import json
from typing import Dict, Any, Tuple, Optional
from pathlib import Path


class ThemeLoader:
    """Loads and manages poker theme configurations from JSON."""

    def __init__(self, theme_pack_path: Optional[str] = None):
        """Initialize theme loader with optional custom path."""
        if theme_pack_path is None:
            # Default to poker_themes.json in backend/data directory
            backend_dir = Path(__file__).parent.parent.parent
            theme_pack_path = str(backend_dir / "data" / "poker_themes.json")

        self.theme_pack_path = theme_pack_path
        self._defaults: Optional[Dict[str, Any]] = None
        self._themes: Optional[Dict[str, Dict[str, Any]]] = None
        self._loaded = False

    def load_theme_pack(self) -> Tuple[Dict[str, Any], Dict[str, Dict[str, Any]]]:
        """
        Load theme pack from JSON file.

        Returns:
            Tuple of (defaults, themes_dict) where:
            - defaults: Configuration defaults for states, selection, etc.
            - themes_dict: Dictionary mapping theme_id -> theme_config
        """
        if self._loaded and self._defaults is not None and self._themes is not None:
            return self._defaults, self._themes

        try:
            with open(self.theme_pack_path, "r", encoding="utf-8") as f:
                pack = json.load(f)

            self._defaults = pack.get("defaults", {})
            themes_list = pack.get("themes", [])
            self._themes = {theme["id"]: theme for theme in themes_list}
            self._loaded = True

            print(f"‚úÖ Loaded {len(self._themes)} themes from {self.theme_pack_path}")
            return self._defaults, self._themes

        except FileNotFoundError:
            print(f"‚ö†Ô∏è Theme pack not found: {self.theme_pack_path}")
            return self._get_fallback_config()
        except json.JSONDecodeError as e:
            print(f"‚ö†Ô∏è Invalid JSON in theme pack: {e}")
            return self._get_fallback_config()
        except Exception as e:
            print(f"‚ö†Ô∏è Error loading theme pack: {e}")
            return self._get_fallback_config()

    def get_theme_by_id(self, theme_id: str) -> Dict[str, Any]:
        """Get a specific theme by ID with auto-generated emphasis tokens."""
        defaults, themes = self.load_theme_pack()
        
        theme_config = None
        if theme_id in themes:
            theme_config = themes[theme_id].copy()  # Make a copy to avoid modifying original
        else:
            # Fallback to first available theme
            if themes:
                fallback_id = list(themes.keys())[0]
                print(f"‚ö†Ô∏è Theme '{theme_id}' not found, using '{fallback_id}'")
                theme_config = themes[fallback_id].copy()
            else:
                # Ultimate fallback
                theme_config = self._get_fallback_theme()

        return theme_config

    def get_theme_list(self) -> list[Dict[str, str]]:
        """Get list of available themes with id and name."""
        defaults, themes = self.load_theme_pack()
        return [
            {"id": theme_id, "name": theme_config.get("name", theme_id)}
            for theme_id, theme_config in themes.items()
        ]

    def get_defaults(self) -> Dict[str, Any]:
        """Get configuration defaults."""
        defaults, _ = self.load_theme_pack()
        return defaults
    


    def _get_fallback_config(self) -> Tuple[Dict[str, Any], Dict[str, Dict[str, Any]]]:
        """Provide fallback configuration if JSON loading fails."""
        defaults = {
            "state": {
                "active": {
                    "glow": "#1DB954",
                    "shimmer": "#C9A34E",
                    "strength": 1.0,
                    "period_ms": 2000,
                },
                "folded": {"desaturate": 0.8, "opacity": 0.4},
                "winner": {
                    "glow": "#C9A34E",
                    "shimmer": "#1DB954",
                    "strength": 1.4,
                    "period_ms": 1500,
                    "particles": True,
                },
                "showdown": {
                    "spotlight": "#FFFFFF",
                    "spotlight_opacity": 0.18,
                    "duration_ms": 1500,
                },
                "allin": {
                    "glow": "#B63D3D",
                    "shimmer": "#C9A34E",
                    "strength": 1.2,
                    "flash_ms": 400,
                },
            },
            "selection": {"row_bg": "$highlight", "row_fg": "$highlight_text"},
            "emphasis_bar": {
                "bg_top": "#2D5A3D",
                "bg_bottom": "#4A3428",
                "text": "#F8E7C9",
                "accent_text": "#B63D3D",
                "divider": "#C9A34E",
                "texture": "velvet_8pct",
            },
            "chips": {
                "stack": {
                    "face": "#334155",
                    "edge": "#6B7280",
                    "rim": "#9CA3AF",
                    "text": "#F8F7F4",
                },
                "bet": {
                    "face": "#1DB954",
                    "edge": "#16A34A",
                    "rim": "#C9A34E",
                    "text": "#F8F7F4",
                    "glow": "#22C55E",
                },
                "pot": {
                    "face": "#D4AF37",
                    "edge": "#B8860B",
                    "rim": "#F59E0B",
                    "text": "#0B0B0E",
                    "glow": "#FCD34D",
                },
            },
        }

        themes = {"forest-green-pro": self._get_fallback_theme()}

        return defaults, themes

    def _get_fallback_theme(self) -> Dict[str, Any]:
        """Provide fallback theme if loading fails."""
        return {
            "id": "forest-green-pro",
            "name": "Forest Green Professional",
            "palette": {
                "felt": "#2D5A3D",
                "rail": "#4A3428",
                "metal": "#C9A34E",
                "accent": "#1DB954",
                "raise": "#B63D3D",
                "call": "#2AA37A",
                "neutral": "#9AA0A6",
                "text": "#EDECEC",
                "highlight": "#D4AF37",
                "highlight_text": "#0B0B0E",
                "emphasis_text": "#F8E7C9",
            },
        }
    
    def reload(self):
        """Force reload themes from file."""
        print("üîÑ ThemeLoader: Forcing reload from file...")
        self._loaded = False
        self._defaults = None
        self._themes = None
        return self.load_theme_pack()


# Global instance for easy access
_theme_loader = None


def get_theme_loader() -> ThemeLoader:
    """Get the global theme loader instance."""
    global _theme_loader
    if _theme_loader is None:
        _theme_loader = ThemeLoader()
    return _theme_loader
```

---

### theme_loader_consolidated.py

**Path**: `backend/ui/services/theme_loader_consolidated.py`

**Size**: 8.7 KB

```python
"""
Consolidated theme loader with robust fallbacks and persistence.
Loads from single poker_themes_final_16.json with embedded defaults.
"""

import json
import pathlib
from typing import Dict, Any, Tuple, Optional

# Default theme file location (existing poker_themes.json)
DEFAULT_THEME_FILE = pathlib.Path(__file__).parent.parent.parent / "data" / "poker_themes.json"

# Embedded minimal fallback theme (single theme to ensure app boots)
EMBEDDED_FALLBACK = {
    "defaults": {
        "state_styling": {
            "active": {"glow_color": "$accent", "glow_intensity": 0.8},
            "folded": {"desaturation": 0.7, "opacity": 0.6},
            "winner": {"celebration_rings": 3, "shimmer_color": "$metal"},
            "showdown": {"spotlight_fade": 0.3},
            "all_in": {"flash_intensity": 0.9, "flash_color": "$raise"}
        },
        "selection_highlighting": {
            "treeview": {"selected_bg": "$highlight", "selected_fg": "$highlight_text"},
            "listbox": {"selected_bg": "$highlight", "selected_fg": "$highlight_text"}
        },
        "emphasis_bars": {
            "gradient": {"top": "$emphasis_bg_top", "bottom": "$emphasis_bg_bottom"},
            "border": "$emphasis_border",
            "text": "$emphasis_text",
            "accent_text": "$emphasis_accent_text"
        }
    },
    "themes": [
        {
            "id": "forest-green-pro",
            "name": "Forest Green Professional üåø",
            "intro": "Classic casino elegance with deep forest tones and golden accents.",
            "persona": "Sophisticated. Timeless. The choice of discerning players.",
            "palette": {
                "felt": "#1B4D3A",
                "rail": "#2E4F76", 
                "metal": "#D4AF37",
                "accent": "#FFD700",
                "raise": "#DC2626",
                "call": "#2563EB",
                "neutral": "#6B7280",
                "text": "#F8FAFC",
                "highlight": "#D4AF37",
                "highlight_text": "#000000",
                "emphasis_bg_top": "#1B4D3A",
                "emphasis_bg_bottom": "#0F2A1F",
                "emphasis_border": "#D4AF37",
                "emphasis_text": "#F8FAFC",
                "emphasis_accent_text": "#FFD700",
                "chip_face": "#2E7D5A",
                "chip_edge": "#1B4D3A",
                "chip_rim": "#D4AF37",
                "chip_text": "#F8FAFC",
                "bet_face": "#DC2626",
                "bet_edge": "#991B1B",
                "bet_rim": "#FCA5A5",
                "bet_text": "#F8FAFC",
                "bet_glow": "#FEE2E2",
                "pot_face": "#D4AF37",
                "pot_edge": "#92400E",
                "pot_rim": "#FDE68A",
                "pot_text": "#000000",
                "pot_glow": "#FEF3C7"
            }
        }
    ]
}


class ConsolidatedThemeLoader:
    """Robust theme loader with fallbacks and user load/save capability."""
    
    def __init__(self):
        """Initialize with default theme file."""
        self._config: Optional[Dict[str, Any]] = None
        self._loaded = False
        self._current_file: Optional[pathlib.Path] = None
    
    def load_themes(self, file_path: Optional[str] = None) -> Dict[str, Any]:
        """
        Load theme configuration with robust fallbacks.
        
        Args:
            file_path: Optional specific file to load, otherwise uses default
        
        Load order:
        1. Specified file_path (if provided)
        2. Project's backend/data/poker_themes.json (default)
        3. Embedded fallback (single theme)
        
        Returns:
            Complete theme configuration dict
        """
        if not file_path and self._loaded and self._config:
            return self._config
            
        theme_file = None
        
        # Try specified file first
        if file_path:
            try:
                theme_file = pathlib.Path(file_path)
                if theme_file.exists():
                    config_text = theme_file.read_text(encoding="utf-8")
                    self._config = json.loads(config_text)
                    self._current_file = theme_file
                    print(f"‚úÖ Loaded themes from specified file: {theme_file}")
                    self._loaded = True
                    return self._config
            except Exception as e:
                print(f"‚ö†Ô∏è  Failed to load specified theme file: {e}")
        
        # Try default project theme file
        try:
            if DEFAULT_THEME_FILE.exists():
                config_text = DEFAULT_THEME_FILE.read_text(encoding="utf-8")
                self._config = json.loads(config_text)
                self._current_file = DEFAULT_THEME_FILE
                print(f"‚úÖ Loaded themes from default file: {DEFAULT_THEME_FILE}")
                self._loaded = True
                return self._config
        except Exception as e:
            print(f"‚ö†Ô∏è  Failed to load default theme file: {e}")
        
        # Ultimate fallback - embedded theme
        print("üîÑ Using embedded fallback theme")
        self._config = EMBEDDED_FALLBACK
        self._current_file = None
        self._loaded = True
        return self._config
    
    def save_themes(self, config: Dict[str, Any], file_path: Optional[str] = None) -> bool:
        """
        Save theme configuration to specified file or current file.
        
        Args:
            config: Complete theme configuration to save
            file_path: Optional file path to save to, otherwise uses current or default
            
        Returns:
            True if saved successfully
        """
        try:
            # Determine save location
            if file_path:
                save_file = pathlib.Path(file_path)
            elif self._current_file:
                save_file = self._current_file
            else:
                save_file = DEFAULT_THEME_FILE
            
            # Ensure directory exists
            save_file.parent.mkdir(parents=True, exist_ok=True)
            
            # Save with nice formatting
            config_text = json.dumps(config, ensure_ascii=False, indent=2)
            save_file.write_text(config_text, encoding="utf-8")
            
            # Update cached config
            self._config = config
            self._current_file = save_file
            
            print(f"‚úÖ Saved themes to: {save_file}")
            return True
            
        except Exception as e:
            print(f"‚ùå Failed to save themes: {e}")
            return False
    
    def get_theme_by_id(self, theme_id: str) -> Optional[Dict[str, Any]]:
        """Get theme by ID."""
        config = self.load_themes()
        themes = config.get("themes", [])
        
        for theme in themes:
            if theme.get("id") == theme_id:
                return theme
                
        return None
    
    def get_theme_list(self) -> list[Dict[str, str]]:
        """Get list of available themes with metadata."""
        config = self.load_themes()
        themes = config.get("themes", [])
        
        return [
            {
                "id": theme.get("id", "unknown"),
                "name": theme.get("name", "Unknown Theme"),
                "intro": theme.get("intro", "")
            }
            for theme in themes
        ]
    
    def get_defaults(self) -> Dict[str, Any]:
        """Get default configuration."""
        config = self.load_themes()
        return config.get("defaults", {})
    
    def reload(self, file_path: Optional[str] = None):
        """Force reload from disk."""
        self._loaded = False
        self._config = None
        return self.load_themes(file_path)
    
    def get_current_file(self) -> Optional[pathlib.Path]:
        """Get currently loaded theme file path."""
        return self._current_file
    
    def load_from_file(self, file_path: str) -> Dict[str, Any]:
        """Load themes from specific file."""
        return self.load_themes(file_path)
    
    def save_to_file(self, config: Dict[str, Any], file_path: str) -> bool:
        """Save themes to specific file."""
        return self.save_themes(config, file_path)


# Singleton instance
_theme_loader: Optional[ConsolidatedThemeLoader] = None


def get_consolidated_theme_loader() -> ConsolidatedThemeLoader:
    """Get singleton theme loader instance."""
    global _theme_loader
    if _theme_loader is None:
        _theme_loader = ConsolidatedThemeLoader()
    return _theme_loader


def load_themes() -> Dict[str, Any]:
    """Convenience function to load themes."""
    return get_consolidated_theme_loader().load_themes()


def save_themes(config: Dict[str, Any], file_path: Optional[str] = None) -> bool:
    """Convenience function to save themes."""
    return get_consolidated_theme_loader().save_themes(config, file_path)
```

---

### theme_manager.py

**Path**: `backend/ui/services/theme_manager.py`

**Size**: 13.9 KB

```python
from __future__ import annotations

from typing import Dict, Any, Callable, List
import importlib
import json
import os

# Import the new token-driven theme system
try:
    from .theme_factory import build_all_themes
    from .theme_loader import get_theme_loader
    from .state_styler import (
        get_state_styler,
        get_selection_styler,
        get_emphasis_bar_styler
    )
    TOKEN_DRIVEN_THEMES_AVAILABLE = True
except ImportError:
    TOKEN_DRIVEN_THEMES_AVAILABLE = False


# Default theme name for fallbacks
DEFAULT_THEME_NAME = "Forest Green Professional üåø"  # Updated to match JSON


class ThemeManager:
    """
    App-scoped theme service that owns THEME/FONTS tokens and persistence.
    - Token access via dot paths (e.g., "table.felt", "pot.valueText").
    - Registers multiple theme packs and persists selected pack + fonts.
    - Now fully config-driven using poker_themes.json
    """

    CONFIG_PATH = os.path.join("backend", "ui", "theme_config.json")

    def __init__(self) -> None:
        self._theme: Dict[str, Any]
        self._fonts: Dict[str, Any]
        self._themes: Dict[str, Dict[str, Any]] = {}
        self._current: str | None = None
        self._subs: List[Callable[["ThemeManager"], None]] = []
        # Load defaults from codebase
        try:
            gm = importlib.import_module("backend.core.gui_models")
            self._theme = dict(getattr(gm, "THEME", {}))
            self._fonts = dict(getattr(gm, "FONTS", {}))
        except Exception:
            self._theme = {"table_felt": "#2B2F36", "text": "#E6E9EF"}
            self._fonts = {
                "main": ("Arial", 20),  # Base font at 20px for readability
                "pot_display": ("Arial", 28, "bold"),  # +8 for pot display
                "bet_amount": ("Arial", 24, "bold"),  # +4 for bet amounts
                "body": ("Consolas", 20),  # Same as main for body text
                "small": ("Consolas", 16),  # -4 for smaller text
                "header": ("Arial", 22, "bold")  # +2 for headers
            }
        # Apply persisted config if present
        # Register built-in packs
        packs = self._builtin_packs()
        for name, tokens in packs.items():
            self.register(name, tokens)
        self._load_config()
        if not self._current:
            # Use Forest Green Professional as safe default
            if DEFAULT_THEME_NAME in self._themes:
                self._current = DEFAULT_THEME_NAME
                self._theme = dict(self._themes[DEFAULT_THEME_NAME])
            else:
                # Fallback: choose first pack or defaults
                self._current = next(iter(self._themes.keys()), None)

    def _builtin_packs(self) -> Dict[str, Dict[str, Any]]:
        """Get built-in theme packs - now using token-driven system"""
        if TOKEN_DRIVEN_THEMES_AVAILABLE:
            try:
                # Use the new deterministic token system
                themes = build_all_themes()
                print(f"üé® ThemeManager: Loaded {len(themes)} themes: {list(themes.keys())}")
                return themes
            except Exception as e:
                print(f"‚ö†Ô∏è ThemeManager: Config-driven themes failed: {e}")
                return self._legacy_builtin_packs()
        else:
            print("‚ö†Ô∏è ThemeManager: Token-driven themes not available, using legacy")
            # Fallback to legacy themes if token system not available
            return self._legacy_builtin_packs()
    
    def _legacy_builtin_packs(self) -> Dict[str, Dict[str, Any]]:
        """Minimal legacy fallback if config system completely fails."""
        return {
            "Forest Green Professional üåø": {
                "table.felt": "#2D5A3D",
                "table.rail": "#4A3428", 
                "text.primary": "#EDECEC",
                "panel.bg": "#1F2937",
                "panel.fg": "#E5E7EB"
            }
        }

    def get_theme(self) -> Dict[str, Any]:
        return self._theme

    def get_fonts(self) -> Dict[str, Any]:
        return self._fonts
    
    def reload(self):
        """Reload themes from file - critical for Theme Manager integration."""
        print("üîÑ ThemeManager: Reloading themes from file...")
        
        # Clear cached themes
        self._themes = {}
        
        # Reload using the same logic as __init__
        if TOKEN_DRIVEN_THEMES_AVAILABLE:
            try:
                # Force reload from file
                loader = get_theme_loader()
                if hasattr(loader, 'reload'):
                    loader.reload()
                
                # Rebuild all themes
                themes = build_all_themes()
                
                # Register all themes
                for name, tokens in themes.items():
                    self.register(name, tokens)
                
                print(f"üîÑ ThemeManager: Reloaded {len(themes)} themes from file")
                
                # Reload current theme if it still exists
                current_name = self.current_profile_name()
                if current_name in self._themes:
                    self._theme = self._themes[current_name]
                    print(f"üéØ ThemeManager: Restored current theme: {current_name}")
                else:
                    # Fallback to first available theme
                    if self._themes:
                        first_theme_name = list(self._themes.keys())[0]
                        self._theme = self._themes[first_theme_name]
                        self._current_profile = first_theme_name
                        print(f"üîÑ ThemeManager: Switched to: {first_theme_name}")
                
            except Exception as e:
                print(f"‚ö†Ô∏è ThemeManager: Reload failed: {e}")
        else:
            print("‚ö†Ô∏è ThemeManager: Token-driven themes not available for reload")

    def set_fonts(self, fonts: Dict[str, Any]) -> None:
        self._fonts = fonts
        self._save_config()
    
    def get_dimensions(self) -> Dict[str, Any]:
        """Get theme dimensions for consistent spacing and sizing."""
        try:
            # Try to get dimensions from theme config
            theme_data = self.get_theme()
            if theme_data and "dimensions" in theme_data:
                return theme_data["dimensions"]
            
            # Fallback to default dimensions
            return {
                "padding": {"small": 5, "medium": 8, "large": 16, "xlarge": 18},
                "text_height": {"small": 3, "medium": 4, "large": 6},
                "border_width": {"thin": 1, "medium": 2, "thick": 3},
                "widget_width": {"narrow": 5, "medium": 8, "wide": 12}
            }
        except Exception:
            # Ultimate fallback
            return {
                "padding": {"small": 5, "medium": 8, "large": 16, "xlarge": 18},
                "text_height": {"small": 3, "medium": 4, "large": 6},
                "border_width": {"thin": 1, "medium": 2, "thick": 3},
                "widget_width": {"narrow": 5, "medium": 8, "wide": 12}
            }

    def register(self, name: str, tokens: Dict[str, Any]) -> None:
        self._themes[name] = tokens

    def names(self) -> list[str]:
        """Return all registered theme names from config-driven system."""
        if TOKEN_DRIVEN_THEMES_AVAILABLE:
            # Try to get theme names from config-driven system
            try:
                loader = get_theme_loader()
                theme_list = loader.get_theme_list()
                return [theme_info["name"] for theme_info in theme_list]
            except Exception:
                pass
        
        # Fallback: return all registered theme names
        return list(self._themes.keys())

    def register_all(self, packs: Dict[str, Dict[str, Any]]) -> None:
        """Register all themes from packs dictionary."""
        for name, tokens in packs.items():
            self.register(name, tokens)

    def current(self) -> str | None:
        """Return current theme name."""
        return self._current

    def set_profile(self, name: str) -> None:
        if name in self._themes:
            self._current = name
            self._theme = dict(self._themes[name])
            self._save_config()
            for fn in list(self._subs):
                fn(self)

    def _load_config(self) -> None:
        try:
            if os.path.exists(self.CONFIG_PATH):
                with open(self.CONFIG_PATH, "r", encoding="utf-8") as f:
                    data = json.load(f)
                prof = data.get("profile")
                if prof and prof in self._themes:
                    self._current = prof
                    self._theme = dict(self._themes[prof])
                fonts = data.get("fonts")
                if isinstance(fonts, dict):
                    self._fonts.update(fonts)
        except Exception:
            pass

    def _save_config(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.CONFIG_PATH), exist_ok=True)
            payload = {"profile": self.current_profile_name(), "fonts": self._fonts}
            with open(self.CONFIG_PATH, "w", encoding="utf-8") as f:
                json.dump(payload, f, indent=2)
        except Exception:
            pass

    def current_profile_name(self) -> str:
        for name, theme in self._themes.items():
            if all(self._theme.get(k) == theme.get(k) for k in ("table.felt",)):
                return name
        return "Custom"

    def get(self, token: str, default=None):
        # Dot-path lookup in current theme; fallback to fonts when font.* requested
        if token.startswith("font."):
            return self._theme.get(token) or self._fonts.get(token[5:], default)
        cur = self._theme
        for part in token.split("."):
            if isinstance(cur, dict) and part in cur:
                cur = cur[part]
            else:
                return self._theme.get(token, default)
        return cur
    
    def get_all_tokens(self) -> Dict[str, Any]:
        """Get complete token dictionary for current theme"""
        return dict(self._theme)
    
    def get_base_colors(self) -> Dict[str, str]:
        """Get the base color palette for current theme (if available)"""
        if TOKEN_DRIVEN_THEMES_AVAILABLE:
            # Try new config-driven system first
            try:
                loader = get_theme_loader()
                # Convert display name to theme ID using proper mapping
                name_to_id_map = {
                    "Forest Green Professional üåø": "forest-green-pro",
                    "Velvet Burgundy üç∑": "velvet-burgundy", 
                    "Emerald Aurora üåå": "emerald-aurora",
                    "Imperial Jade üíé": "imperial-jade",
                    "Ruby Royale ‚ù§Ô∏è‚Äçüî•": "ruby-royale",
                    "Coral Royale ü™∏": "coral-royale",
                    "Golden Dusk üåá": "golden-dusk",
                    "Klimt Royale ‚ú®": "klimt-royale",
                    "Deco Luxe üèõÔ∏è": "deco-luxe",
                    "Oceanic Aqua üåä": "oceanic-aqua",
                    "Royal Sapphire üî∑": "royal-sapphire",
                    "Monet Twilight üé®": "monet-twilight",
                    "Caravaggio Sepia Noir üïØÔ∏è": "caravaggio-sepia-noir",
                    "Stealth Graphite Steel üñ§": "stealth-graphite-steel",
                    "Sunset Mirage üåÖ": "sunset-mirage",
                    "Cyber Neon ‚ö°": "cyber-neon"
                }
                theme_id = name_to_id_map.get(self._current, "forest-green-pro") if self._current else "forest-green-pro"
                theme_config = loader.get_theme_by_id(theme_id)
                return theme_config.get("palette", {})
            except Exception:
                pass
        return {}
    
    def get_current_theme_id(self) -> str:
        """Get current theme ID for config-driven styling."""
        if self._current:
            # Convert display name to kebab-case ID (remove emojis)
            theme_id = self._current.lower()
            # Remove emojis and extra spaces
            for emoji in ["üåø", "üç∑", "üíé", "üåå", "‚ù§Ô∏è‚Äçüî•", "ü™∏", "üåá", "‚ú®", "üèõÔ∏è", "üåä", "üî∑", "üé®", "üïØÔ∏è", "üñ§", "üåÖ", "‚ö°"]:
                theme_id = theme_id.replace(emoji, "")
            theme_id = theme_id.strip().replace(" ", "-")
            return theme_id
        return "forest-green-pro"
    
    def get_state_styler(self):
        """Get state styler for player state effects."""
        if TOKEN_DRIVEN_THEMES_AVAILABLE:
            return get_state_styler()
        return None
    
    def get_selection_styler(self):
        """Get selection styler for list/tree highlighting."""
        if TOKEN_DRIVEN_THEMES_AVAILABLE:
            return get_selection_styler()
        return None
    
    def get_emphasis_bar_styler(self):
        """Get emphasis bar styler for luxury text bars."""
        if TOKEN_DRIVEN_THEMES_AVAILABLE:
            return get_emphasis_bar_styler()
        return None
    
    def get_theme_metadata(self, theme_name: str) -> Dict[str, str]:
        """Get theme metadata like intro and persona from config."""
        if TOKEN_DRIVEN_THEMES_AVAILABLE:
            try:
                loader = get_theme_loader()
                theme_list = loader.get_theme_list()
                for theme_info in theme_list:
                    if theme_info["name"] == theme_name:
                        theme_config = loader.get_theme_by_id(theme_info["id"])
                        return {
                            "intro": theme_config.get("intro", ""),
                            "persona": theme_config.get("persona", ""),
                            "id": theme_config.get("id", "")
                        }
            except Exception:
                pass
        return {"intro": "", "persona": "", "id": ""}

    def subscribe(self, fn: Callable[["ThemeManager"], None]) -> Callable[[], None]:
        self._subs.append(fn)
        def _unsub():
            try:
                self._subs.remove(fn)
            except ValueError:
                pass
        return _unsub
```

---

### theme_manager_clean.py

**Path**: `backend/ui/services/theme_manager_clean.py`

**Size**: 10.4 KB

```python
from __future__ import annotations

from typing import Dict, Any, Callable, List
import importlib
import json
import os

# Import the new token-driven theme system
try:
    from .theme_factory import build_all_themes, build_theme_from_config, get_available_theme_names, get_theme_by_name
    from .theme_loader import get_theme_loader
    from .state_styler import get_state_styler, get_selection_styler, get_emphasis_bar_styler
    TOKEN_DRIVEN_THEMES_AVAILABLE = True
except ImportError:
    TOKEN_DRIVEN_THEMES_AVAILABLE = False


# Default theme name for fallbacks
DEFAULT_THEME_NAME = "Forest Green Professional üåø"  # Updated to match JSON config name


class ThemeManager:
    """
    App-scoped theme service that owns THEME/FONTS tokens and persistence.
    - Token access via dot paths (e.g., "table.felt", "pot.valueText").
    - Registers multiple theme packs and persists selected pack + fonts.
    - Now fully config-driven using poker_themes.json
    """

    CONFIG_PATH = os.path.join("backend", "ui", "theme_config.json")

    def __init__(self) -> None:
        self._theme: Dict[str, Any]
        self._fonts: Dict[str, Any]
        self._themes: Dict[str, Dict[str, Any]] = {}
        self._current: str | None = None
        self._subs: List[Callable[["ThemeManager"], None]] = []
        # Load defaults from codebase
        try:
            gm = importlib.import_module("backend.core.gui_models")
            self._theme = dict(getattr(gm, "THEME", {}))
            self._fonts = dict(getattr(gm, "FONTS", {}))
        except Exception:
            self._theme = {"table_felt": "#2B2F36", "text": "#E6E9EF"}
            self._fonts = {
                "main": ("Arial", 20),  # Base font at 20px for readability
                "pot_display": ("Arial", 28, "bold"),  # +8 for pot display
                "bet_amount": ("Arial", 24, "bold"),  # +4 for bet amounts
                "body": ("Consolas", 20),  # Same as main for body text
                "small": ("Consolas", 16),  # -4 for smaller text
                "header": ("Arial", 22, "bold")  # +2 for headers
            }
        # Apply persisted config if present
        # Register built-in packs
        packs = self._builtin_packs()
        for name, tokens in packs.items():
            self.register(name, tokens)
        self._load_config()
        if not self._current:
            # Use Forest Green Professional as safe default
            if DEFAULT_THEME_NAME in self._themes:
                self._current = DEFAULT_THEME_NAME
                self._theme = dict(self._themes[DEFAULT_THEME_NAME])
            else:
                # Fallback: choose first pack or defaults
                self._current = next(iter(self._themes.keys()), None)

    def _builtin_packs(self) -> Dict[str, Dict[str, Any]]:
        """Get built-in theme packs - now using token-driven system"""
        if TOKEN_DRIVEN_THEMES_AVAILABLE:
            try:
                # Use the new deterministic token system
                themes = build_all_themes()
                print(f"üé® ThemeManager: Loaded {len(themes)} themes: {list(themes.keys())}")
                return themes
            except Exception as e:
                print(f"‚ö†Ô∏è ThemeManager: Config-driven themes failed: {e}")
                return self._legacy_builtin_packs()
        else:
            print("‚ö†Ô∏è ThemeManager: Token-driven themes not available, using legacy")
            # Fallback to legacy themes if token system not available
            return self._legacy_builtin_packs()
    
    def _legacy_builtin_packs(self) -> Dict[str, Dict[str, Any]]:
        """Minimal legacy fallback if config system completely fails."""
        return {
            "Forest Green Professional üåø": {
                "table.felt": "#2D5A3D",
                "table.rail": "#4A3428", 
                "text.primary": "#EDECEC",
                "panel.bg": "#1F2937",
                "panel.fg": "#E5E7EB"
            }
        }

    def get_theme(self) -> Dict[str, Any]:
        return self._theme

    def get_fonts(self) -> Dict[str, Any]:
        return self._fonts

    def set_fonts(self, fonts: Dict[str, Any]) -> None:
        self._fonts = fonts
        self._save_config()

    def register(self, name: str, tokens: Dict[str, Any]) -> None:
        self._themes[name] = tokens

    def names(self) -> list[str]:
        """Return all registered theme names from config-driven system."""
        if TOKEN_DRIVEN_THEMES_AVAILABLE:
            # Try to get theme names from config-driven system
            try:
                loader = get_theme_loader()
                theme_list = loader.get_theme_list()
                return [theme_info["name"] for theme_info in theme_list]
            except Exception:
                pass
        
        # Fallback: return all registered theme names
        return list(self._themes.keys())

    def register_all(self, packs: Dict[str, Dict[str, Any]]) -> None:
        """Register all themes from packs dictionary."""
        for name, tokens in packs.items():
            self.register(name, tokens)

    def current(self) -> str | None:
        """Return current theme name."""
        return self._current

    def set_profile(self, name: str) -> None:
        if name in self._themes:
            self._current = name
            self._theme = dict(self._themes[name])
            self._save_config()
            for fn in list(self._subs):
                fn(self)

    def _load_config(self) -> None:
        try:
            if os.path.exists(self.CONFIG_PATH):
                with open(self.CONFIG_PATH, "r", encoding="utf-8") as f:
                    data = json.load(f)
                prof = data.get("profile")
                if prof and prof in self._themes:
                    self._current = prof
                    self._theme = dict(self._themes[prof])
                fonts = data.get("fonts")
                if isinstance(fonts, dict):
                    self._fonts.update(fonts)
        except Exception:
            pass

    def _save_config(self) -> None:
        try:
            os.makedirs(os.path.dirname(self.CONFIG_PATH), exist_ok=True)
            payload = {"profile": self.current_profile_name(), "fonts": self._fonts}
            with open(self.CONFIG_PATH, "w", encoding="utf-8") as f:
                json.dump(payload, f, indent=2)
        except Exception:
            pass

    def current_profile_name(self) -> str:
        for name, theme in self._themes.items():
            if all(self._theme.get(k) == theme.get(k) for k in ("table.felt",)):
                return name
        return "Custom"

    def get(self, token: str, default=None):
        # Dot-path lookup in current theme; fallback to fonts when font.* requested
        if token.startswith("font."):
            return self._theme.get(token) or self._fonts.get(token[5:], default)
        cur = self._theme
        for part in token.split("."):
            if isinstance(cur, dict) and part in cur:
                cur = cur[part]
            else:
                return self._theme.get(token, default)
        return cur
    
    def get_all_tokens(self) -> Dict[str, Any]:
        """Get complete token dictionary for current theme"""
        return dict(self._theme)
    
    def get_base_colors(self) -> Dict[str, str]:
        """Get the base color palette for current theme (if available)"""
        if TOKEN_DRIVEN_THEMES_AVAILABLE:
            # Try new config-driven system first
            try:
                loader = get_theme_loader()
                # Convert display name to theme ID
                theme_id = self._current.lower().replace(" ", "-").replace("üåø", "").replace("üç∑", "").replace("üíé", "").replace("üåå", "").replace("‚ù§Ô∏è‚Äçüî•", "").replace("ü™∏", "").replace("üåá", "").replace("‚ú®", "").replace("üèõÔ∏è", "").replace("üåä", "").replace("üî∑", "").replace("üé®", "").replace("üïØÔ∏è", "").replace("üñ§", "").replace("üåÖ", "").replace("‚ö°", "").strip() if self._current else "forest-green-pro"
                theme_config = loader.get_theme_by_id(theme_id)
                return theme_config.get("palette", {})
            except Exception:
                pass
        return {}
    
    def get_current_theme_id(self) -> str:
        """Get current theme ID for config-driven styling."""
        if self._current:
            # Convert display name to kebab-case ID (remove emojis)
            theme_id = self._current.lower()
            # Remove emojis and extra spaces
            for emoji in ["üåø", "üç∑", "üíé", "üåå", "‚ù§Ô∏è‚Äçüî•", "ü™∏", "üåá", "‚ú®", "üèõÔ∏è", "üåä", "üî∑", "üé®", "üïØÔ∏è", "üñ§", "üåÖ", "‚ö°"]:
                theme_id = theme_id.replace(emoji, "")
            theme_id = theme_id.strip().replace(" ", "-")
            return theme_id
        return "forest-green-pro"
    
    def get_state_styler(self):
        """Get state styler for player state effects."""
        if TOKEN_DRIVEN_THEMES_AVAILABLE:
            return get_state_styler()
        return None
    
    def get_selection_styler(self):
        """Get selection styler for list/tree highlighting."""
        if TOKEN_DRIVEN_THEMES_AVAILABLE:
            return get_selection_styler()
        return None
    
    def get_emphasis_bar_styler(self):
        """Get emphasis bar styler for luxury text bars."""
        if TOKEN_DRIVEN_THEMES_AVAILABLE:
            return get_emphasis_bar_styler()
        return None
    
    def get_theme_metadata(self, theme_name: str) -> Dict[str, str]:
        """Get theme metadata like intro and persona from config."""
        if TOKEN_DRIVEN_THEMES_AVAILABLE:
            try:
                loader = get_theme_loader()
                theme_list = loader.get_theme_list()
                for theme_info in theme_list:
                    if theme_info["name"] == theme_name:
                        theme_config = loader.get_theme_by_id(theme_info["id"])
                        return {
                            "intro": theme_config.get("intro", ""),
                            "persona": theme_config.get("persona", ""),
                            "id": theme_config.get("id", "")
                        }
            except Exception:
                pass
        return {"intro": "", "persona": "", "id": ""}

    def subscribe(self, fn: Callable[["ThemeManager"], None]) -> Callable[[], None]:
        self._subs.append(fn)
        def _unsub():
            try:
                self._subs.remove(fn)
            except ValueError:
                pass
        return _unsub
```

---

### theme_utils.py

**Path**: `backend/ui/services/theme_utils.py`

**Size**: 2.2 KB

```python
"""
Theme Utilities - Color Derivation Helpers
Provides deterministic color manipulation functions for consistent theming
"""

def clamp(x):
    """Clamp value to 0-255 range"""
    return max(0, min(255, int(x)))

def hex_to_rgb(h):
    """Convert hex color to RGB tuple"""
    h = h.strip("#")
    return tuple(int(h[i:i+2], 16) for i in (0, 2, 4))

def rgb_to_hex(t):
    """Convert RGB tuple to hex color"""
    return "#{:02X}{:02X}{:02X}".format(*map(clamp, t))

def mix(a, b, t):
    """Mix two hex colors with ratio t (0=a, 1=b)"""
    ra, ga, ba = hex_to_rgb(a)
    rb, gb, bb = hex_to_rgb(b)
    return rgb_to_hex((
        ra + (rb - ra) * t,
        ga + (gb - ga) * t,
        ba + (bb - ba) * t
    ))

def lighten(h, t):
    """Lighten hex color by ratio t (0=no change, 1=white)"""
    return mix(h, "#FFFFFF", t)

def darken(h, t):
    """Darken hex color by ratio t (0=no change, 1=black)"""
    return mix(h, "#000000", t)

def alpha_over(src, dst, a):
    """Simple alpha compositing: src over dst with alpha a (0..1)"""
    rs, gs, bs = hex_to_rgb(src)
    rd, gd, bd = hex_to_rgb(dst)
    return rgb_to_hex((
        rd + (rs - rd) * a,
        gd + (gs - gd) * a,
        bd + (bs - bd) * a
    ))

def adjust_saturation(h, factor):
    """Adjust saturation of hex color (factor: 0=grayscale, 1=normal, >1=more saturated)"""
    r, g, b = hex_to_rgb(h)
    # Convert to HSL-like adjustment
    gray = (r + g + b) / 3
    r = gray + (r - gray) * factor
    g = gray + (g - gray) * factor
    b = gray + (b - gray) * factor
    return rgb_to_hex((r, g, b))

def get_contrast_color(bg_hex, light_text="#FFFFFF", dark_text="#000000"):
    """Get appropriate text color for background (simple luminance check)"""
    r, g, b = hex_to_rgb(bg_hex)
    # Simple luminance calculation
    luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255
    return dark_text if luminance > 0.5 else light_text

def ease_in_out_cubic(t):
    """Cubic ease-in-out function for smooth animations"""
    if t < 0.5:
        return 4 * t * t * t
    else:
        return 1 - pow(-2 * t + 2, 3) / 2

def ease_color_transition(color_a, color_b, progress):
    """Smooth color transition with easing"""
    eased_progress = ease_in_out_cubic(progress)
    return mix(color_a, color_b, eased_progress)
```

---

### timer_manager.py

**Path**: `backend/ui/services/timer_manager.py`

**Size**: 1.4 KB

```python
class TimerManager:
    """
    Centralized wrapper for Tkinter after() scheduling so timers can be
    cancelled on tab hide/unmount.
    """

    def __init__(self, tk_root) -> None:
        self.root = tk_root
        self._after_ids: set[str] = set()

    def after(self, ms: int, fn):
        after_id = self.root.after(ms, self._wrap(fn, after_id_ref=None))
        # Cannot capture after_id before it's created; store and best-effort
        # cleanup
        self._after_ids.add(after_id)
        return after_id

    def _wrap(self, fn, after_id_ref):
        def _inner():
            try:
                fn()
            finally:
                # Best-effort: we don't get the after_id here; callers may
                # remove manually; otherwise cancel_all will clear leftovers.
                pass
        return _inner

    def cancel(self, after_id) -> None:
        try:
            self.root.after_cancel(after_id)
        except Exception:
            pass
        finally:
            try:
                self._after_ids.remove(after_id)
            except KeyError:
                pass

    def cancel_all(self) -> None:
        for after_id in list(self._after_ids):
            try:
                self.root.after_cancel(after_id)
            except Exception:
                pass
        self._after_ids.clear()

    def dispose(self) -> None:
        self.cancel_all()
```

---

### timing_migration_helper.py

**Path**: `backend/ui/services/timing_migration_helper.py`

**Size**: 6.7 KB

```python
#!/usr/bin/env python3
"""
Timing Migration Helper - Architecture Compliance Utility

This utility helps migrate self.after() calls to event-driven scheduling
via GameDirector, ensuring compliance with the single-threaded architecture.

CRITICAL: All timing must go through GameDirector, not direct UI component calls.
"""

from typing import Optional, Callable, Dict, Any
from enum import Enum


class TimingType(Enum):
    """Types of timing operations that need migration."""
    ANIMATION = "animation"
    HIGHLIGHT = "highlight"
    UPDATE_LOOP = "update_loop"
    DELAYED_ACTION = "delayed_action"
    SOUND_COMPLETION = "sound_completion"
    CHIP_MOVEMENT = "chip_movement"
    POT_ANIMATION = "pot_animation"
    WINNER_CELEBRATION = "winner_celebration"


class TimingMigrationHelper:
    """
    Helper class to migrate self.after() calls to event-driven scheduling.
    
    This ensures all timing goes through GameDirector as required by the architecture.
    """
    
    def __init__(self, game_director=None, event_bus=None):
        self.game_director = game_director
        self.event_bus = event_bus
        self._pending_events = {}
        self._next_event_id = 0
    
    def schedule_event(self, 
                      delay_ms: int, 
                      timing_type: TimingType,
                      callback: Optional[Callable] = None,
                      data: Optional[Dict[str, Any]] = None,
                      component_name: str = "unknown") -> str:
        """
        Schedule an event via GameDirector instead of self.after().
        
        Args:
            delay_ms: Delay in milliseconds
            timing_type: Type of timing operation
            callback: Optional callback function
            data: Additional data for the event
            component_name: Name of the component scheduling the event
            
        Returns:
            Event ID for cancellation if needed
        """
        event_id = f"{timing_type.value}_{self._next_event_id}"
        self._next_event_id += 1
        
        event_data = {
            "type": "TIMED_EVENT",
            "timing_type": timing_type.value,
            "event_id": event_id,
            "component": component_name,
            "callback": callback,
            "data": data or {}
        }
        
        # Store pending event for callback execution
        if callback:
            self._pending_events[event_id] = {
                "callback": callback,
                "data": data or {},
                "component": component_name
            }
        
        # Schedule via GameDirector if available
        if self.game_director and hasattr(self.game_director, 'schedule'):
            self.game_director.schedule(delay_ms, event_data)
        else:
            # Fallback: publish event for manual handling
            if self.event_bus:
                self.event_bus.publish("timing:schedule_event", {
                    "delay_ms": delay_ms,
                    "event_data": event_data
                })
        
        return event_id
    
    def cancel_event(self, event_id: str) -> bool:
        """Cancel a pending event."""
        if event_id in self._pending_events:
            del self._pending_events[event_id]
            return True
        return False
    
    def execute_pending_event(self, event_id: str) -> bool:
        """Execute a pending event callback."""
        if event_id in self._pending_events:
            event_info = self._pending_events[event_id]
            try:
                if event_info["callback"]:
                    event_info["callback"]()
                del self._pending_events[event_id]
                return True
            except Exception as e:
                print(f"‚ö†Ô∏è Error executing timing event {event_id}: {e}")
                del self._pending_events[event_id]
        return False
    
    def clear_all_events(self):
        """Clear all pending events."""
        self._pending_events.clear()
    
    def get_pending_events(self) -> Dict[str, Dict]:
        """Get all pending events for debugging."""
        return self._pending_events.copy()


# Migration patterns for common self.after() usage:

def migrate_animation_timing(helper: TimingMigrationHelper, 
                           delay_ms: int, 
                           animation_callback: Callable,
                           component_name: str = "unknown") -> str:
    """Migrate animation timing from self.after() to event-driven."""
    return helper.schedule_event(
        delay_ms=delay_ms,
        timing_type=TimingType.ANIMATION,
        callback=animation_callback,
        component_name=component_name
    )


def migrate_highlight_timing(helper: TimingMigrationHelper,
                           delay_ms: int,
                           highlight_callback: Callable,
                           component_name: str = "unknown") -> str:
    """Migrate highlight timing from self.after() to event-driven."""
    return helper.schedule_event(
        delay_ms=delay_ms,
        timing_type=TimingType.HIGHLIGHT,
        callback=highlight_callback,
        component_name=component_name
    )


def migrate_update_loop(helper: TimingMigrationHelper,
                       interval_ms: int,
                       update_callback: Callable,
                       component_name: str = "unknown") -> str:
    """Migrate update loop timing from self.after() to event-driven."""
    return helper.schedule_event(
        delay_ms=interval_ms,
        timing_type=TimingType.UPDATE_LOOP,
        callback=lambda: _schedule_next_update(helper, interval_ms, update_callback, component_name),
        component_name=component_name
    )


def _schedule_next_update(helper: TimingMigrationHelper,
                         interval_ms: int,
                         update_callback: Callable,
                         component_name: str):
    """Helper to schedule the next update in a loop."""
    # Execute current update
    update_callback()
    
    # Schedule next update
    helper.schedule_event(
        delay_ms=interval_ms,
        timing_type=TimingType.UPDATE_LOOP,
        callback=lambda: _schedule_next_update(helper, interval_ms, update_callback, component_name),
        component_name=component_name
    )


# Example migration usage:
"""
# BEFORE (VIOLATION):
self.after(1000, self._complete_action)

# AFTER (COMPLIANT):
event_id = self.timing_helper.schedule_event(
    delay_ms=1000,
    timing_type=TimingType.DELAYED_ACTION,
    callback=self._complete_action,
    component_name="poker_widget"
)

# BEFORE (VIOLATION):
self.after(50, self._update_loop)

# AFTER (COMPLIANT):
event_id = migrate_update_loop(
    self.timing_helper,
    interval_ms=50,
    update_callback=self._update_loop,
    component_name="poker_widget"
)
"""
```

---

### managers.py

**Path**: `backend/ui/session/managers.py`

**Size**: 3.4 KB

```python
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, Optional

from ..table.state import PokerTableState
from ..table.geometry import pot_center, actor_seat_xy


@dataclass
class BaseSessionManager:
    store: Any
    ppsm: Any
    game_director: Any
    effect_bus: Any
    theme_manager: Any | None = None

    def build_state(self, game_info: Dict[str, Any]) -> PokerTableState:
        table = {"width": 0, "height": 0}
        seats = game_info.get("players", []) or game_info.get("seats", [])
        board = game_info.get("board", [])
        pot = {"amount": int(game_info.get("pot", 0))}
        dealer = {"position": game_info.get("dealer_position", 0)}
        action = {
            "current_player": game_info.get("action_player", -1),
            "action_type": None,
            "amount": 0,
        }
        return PokerTableState(
            table=table,
            seats=seats,
            board=board,
            pot=pot,
            dealer=dealer,
            action=action,
            animation={},
            effects=[],
        )

    def emit_chip_to_pot(
        self,
        display_state: Dict[str, Any],
        actor_uid: str,
        amount: int,
        canvas_size: tuple[int, int],
    ) -> Dict[str, Any]:
        w, h = canvas_size
        from_x, from_y = actor_seat_xy(display_state, actor_uid, w, h)
        to_x, to_y = pot_center(w, h)
        return {
            "type": "CHIP_TO_POT",
            "from_x": from_x,
            "from_y": from_y,
            "to_x": to_x,
            "to_y": to_y,
            "amount": int(amount or 0),
        }


class PracticeSessionManager(BaseSessionManager):
    def start(self) -> None:
        self.ppsm.start_hand()
        state = self.build_state(self.ppsm.get_game_info())
        self.store.dispatch({"type": "INIT_PRACTICE_TABLE", "table": state.__dict__})

    def handle_player_action(self, player_index: int, action: str, amount: int,
                             canvas_size: tuple[int, int]) -> None:
        # Execute through PPSM
        self.ppsm.execute_action(player_index, action, amount)
        game_info = self.ppsm.get_game_info()
        state = self.build_state(game_info)
        seats = state.seats
        actor_uid = (
            seats[player_index].get("player_uid", f"P{player_index}")
            if player_index < len(seats)
            else f"P{player_index}"
        )
        effect = self.emit_chip_to_pot(
            {"seats": seats}, actor_uid, amount, canvas_size
        )
        self.store.dispatch({
            "type": "UPDATE_PRACTICE_TABLE",
            "table": state.__dict__,
            "effects": [effect],
        })


class GTOSessionManager(BaseSessionManager):
    def __init__(self, store, ppsm, game_director, effect_bus, theme_manager=None, gto_engine: Optional[Any] = None):
        super().__init__(store, ppsm, game_director, effect_bus, theme_manager)
        self.gto_engine = gto_engine

    def start(self) -> None:
        self.ppsm.start_hand()
        state = self.build_state(self.ppsm.get_game_info())
        self.store.dispatch({"type": "INIT_GTO_TABLE", "table": state.__dict__})

    def request_advice(self) -> None:
        if not self.gto_engine:
            return
        advice = self.gto_engine.calculate_best_action(self.ppsm.get_game_info())
        self.store.dispatch({"type": "SHOW_GTO_ADVICE", "advice": advice})


```

---

### __init__.py

**Path**: `backend/ui/state/__init__.py`

**Size**: 2 bytes

```python


```

---

### actions.py

**Path**: `backend/ui/state/actions.py`

**Size**: 1001 bytes

```python
SET_TABLE_DIM = "SET_TABLE_DIM"
SET_POT = "SET_POT"
SET_SEATS = "SET_SEATS"
SET_BOARD = "SET_BOARD"
SET_ACTIVE_TAB = "SET_ACTIVE_TAB"
SET_DEALER = "SET_DEALER"

# Review actions
SET_REVIEW_HANDS = "SET_REVIEW_HANDS"
SET_REVIEW_FILTER = "SET_REVIEW_FILTER"
SET_LOADED_HAND = "SET_LOADED_HAND"
SET_STUDY_MODE = "SET_STUDY_MODE"
SET_REVIEW_COLLECTION = "SET_REVIEW_COLLECTION"

# Enhanced RPGW actions for Hands Review Session
ENHANCED_RPGW_EXECUTE_ACTION = "ENHANCED_RPGW_EXECUTE_ACTION"
UPDATE_ENHANCED_RPGW_STATE = "UPDATE_ENHANCED_RPGW_STATE"
ENHANCED_RPGW_ANIMATION_EVENT = "ENHANCED_RPGW_ANIMATION_EVENT"

# Hands Review Session specific actions
LOAD_REVIEW_HAND = "LOAD_REVIEW_HAND"
NEXT_REVIEW_ACTION = "NEXT_REVIEW_ACTION"
PREV_REVIEW_ACTION = "PREV_REVIEW_ACTION"
RESET_REVIEW_HAND = "RESET_REVIEW_HAND"
SET_REVIEW_PROGRESS = "SET_REVIEW_PROGRESS"
SET_REVIEW_STATUS = "SET_REVIEW_STATUS"

# Architecture compliant action for hands review
HANDS_REVIEW_NEXT_ACTION = "HANDS_REVIEW_NEXT_ACTION"


```

---

### reducers.py

**Path**: `backend/ui/state/reducers.py`

**Size**: 8.4 KB

```python
from typing import Any, Dict
from .actions import (
    SET_TABLE_DIM, SET_POT, SET_SEATS, SET_BOARD, SET_ACTIVE_TAB, 
    SET_DEALER, SET_REVIEW_HANDS, SET_REVIEW_FILTER, SET_LOADED_HAND, 
    SET_STUDY_MODE, SET_REVIEW_COLLECTION, ENHANCED_RPGW_EXECUTE_ACTION, 
    UPDATE_ENHANCED_RPGW_STATE, ENHANCED_RPGW_ANIMATION_EVENT,
    LOAD_REVIEW_HAND, NEXT_REVIEW_ACTION, PREV_REVIEW_ACTION, 
    RESET_REVIEW_HAND, SET_REVIEW_PROGRESS, SET_REVIEW_STATUS,
    HANDS_REVIEW_NEXT_ACTION
)


def root_reducer(
    state: Dict[str, Any], action: Dict[str, Any]
) -> Dict[str, Any]:
    action_type = action.get("type")
    
    # Table/game state actions
    if action_type == SET_TABLE_DIM:
        table = state.get("table", {})
        return {**state, "table": {**table, "dim": action["dim"]}}
    if action_type == SET_POT:
        return {**state, "pot": {"amount": action["amount"]}}
    if action_type == SET_SEATS:
        return {**state, "seats": action["seats"]}
    if action_type == SET_BOARD:
        return {**state, "board": action["board"]}
    if action_type == SET_DEALER:
        return {**state, "dealer": action["dealer"]}
    if action_type == SET_ACTIVE_TAB:
        return {**state, "active_tab": action["name"]}
    
    # Review state actions
    if action_type == SET_REVIEW_HANDS:
        review = state.get("review", {})
        return {**state, "review": {**review, "hands": action["hands"]}}
    if action_type == SET_REVIEW_FILTER:
        review = state.get("review", {})
        return {**state, "review": {**review, "filter": action["filter"]}}
    if action_type == SET_LOADED_HAND:
        review = state.get("review", {})
        return {**state, "review": {**review, "loaded_hand": action["hand"]}}
    if action_type == SET_STUDY_MODE:
        review = state.get("review", {})
        return {**state, "review": {**review, "study_mode": action["mode"]}}
    if action_type == SET_REVIEW_COLLECTION:
        review = state.get("review", {})
        return {**state, "review": {**review, "collection": action["collection"]}}
    
    # Enhanced RPGW actions
    if action_type in [
        ENHANCED_RPGW_EXECUTE_ACTION, 
        UPDATE_ENHANCED_RPGW_STATE, 
        ENHANCED_RPGW_ANIMATION_EVENT
    ]:
        return enhanced_rpgw_reducer(state, action)
    
    # Hands Review Session specific actions
    if action_type == LOAD_REVIEW_HAND:
        return hands_review_reducer(state, action)
    if action_type == NEXT_REVIEW_ACTION:
        return hands_review_reducer(state, action)
    if action_type == PREV_REVIEW_ACTION:
        return hands_review_reducer(state, action)
    if action_type == RESET_REVIEW_HAND:
        return hands_review_reducer(state, action)
    if action_type == SET_REVIEW_PROGRESS:
        return hands_review_reducer(state, action)
    if action_type == SET_REVIEW_STATUS:
        return hands_review_reducer(state, action)
    if action_type == HANDS_REVIEW_NEXT_ACTION:
        return hands_review_reducer(state, action)
    
    return state


def enhanced_rpgw_reducer(state, action):
    """Reducer for Enhanced RPGW actions - maintains architectural compliance."""
    if action['type'] == ENHANCED_RPGW_EXECUTE_ACTION:
        # Extract action data
        game_action = action['action']
        action_index = action['action_index']
        
        # Create new state with action execution
        new_state = {
            **state,
            'enhanced_rpgw': {
                **state.get('enhanced_rpgw', {}),
                'current_action': game_action,
                'action_index': action_index,
                'execution_status': 'pending'
            }
        }
        
        # Trigger event for service layer
        if 'event_bus' in state:
            state['event_bus'].publish(
                "enhanced_rpgw:action_executed",
                {
                    "action": game_action,
                    "action_index": action_index,
                    "state": new_state
                }
            )
        
        return new_state
    
    elif action['type'] == UPDATE_ENHANCED_RPGW_STATE:
        # Update state from PPSM execution results
        return {
            **state,
            'enhanced_rpgw': {
                **state.get('enhanced_rpgw', {}),
                **action['updates'],
                'execution_status': 'completed'
            }
        }
    
    elif action['type'] == ENHANCED_RPGW_ANIMATION_EVENT:
        # Handle animation events
        return {
            **state,
            'enhanced_rpgw': {
                **state.get('enhanced_rpgw', {}),
                'animation_event': action['animation_data']
            }
        }
    
    return state


def hands_review_reducer(state, action):
    """Reducer for Hands Review Session actions."""
    action_type = action.get('type')
    review = state.get('review', {})
    
    if action_type == LOAD_REVIEW_HAND:
        # Load a new hand for review
        hand_data = action.get('hand_data', {})
        flattened_actions = action.get('flattened_actions', [])
        
        return {
            **state,
            'review': {
                **review,
                'loaded_hand': hand_data,
                'flattened_actions': flattened_actions,
                'current_step': 0,
                'total_steps': len(flattened_actions),
                'status': 'loaded'
            },
            'enhanced_rpgw': {
                **state.get('enhanced_rpgw', {}),
                'current_action': None,
                'action_index': 0,
                'execution_status': 'idle'
            }
        }
    
    elif action_type == NEXT_REVIEW_ACTION:
        # Move to next action
        current_step = review.get('current_step', 0)
        total_steps = review.get('total_steps', 0)
        
        if current_step < total_steps - 1:
            new_step = current_step + 1
            return {
                **state,
                'review': {
                    **review,
                    'current_step': new_step,
                    'status': 'playing'
                }
            }
        return state
    
    elif action_type == PREV_REVIEW_ACTION:
        # Move to previous action
        current_step = review.get('current_step', 0)
        
        if current_step > 0:
            new_step = current_step - 1
            return {
                **state,
                'review': {
                    **review,
                    'current_step': new_step,
                    'status': 'playing'
                }
            }
        return state
    
    elif action_type == RESET_REVIEW_HAND:
        # Reset to beginning of hand
        return {
            **state,
            'review': {
                **review,
                'current_step': 0,
                'status': 'loaded'
            },
            'enhanced_rpgw': {
                **state.get('enhanced_rpgw', {}),
                'current_action': None,
                'action_index': 0,
                'execution_status': 'idle'
            }
        }
    
    elif action_type == SET_REVIEW_PROGRESS:
        # Set progress information
        return {
            **state,
            'review': {
                **review,
                'current_step': action.get('current_step', 0),
                'total_steps': action.get('total_steps', 0)
            }
        }
    
    elif action_type == SET_REVIEW_STATUS:
        # Set review status
        return {
            **state,
            'review': {
                **review,
                'status': action.get('status', 'idle')
            }
        }
    
    elif action_type == HANDS_REVIEW_NEXT_ACTION:
        # Architecture compliant: trigger service layer via event
        session_id = action.get('session_id')
        
        # Update state to show action is pending
        new_state = {
            **state,
            'review': {
                **review,
                'status': 'processing_action',
                'last_action_timestamp': action.get('timestamp', 0)
            }
        }
        
        # Trigger event for service layer to handle business logic
        event_bus = state.get('event_bus')
        if event_bus:
            event_bus.publish(
                "hands_review:next_action_requested",
                {
                    "session_id": session_id,
                    "timestamp": action.get('timestamp', 0),
                    "state": new_state
                }
            )
        
        return new_state
    
    return state
```

---

### selectors.py

**Path**: `backend/ui/state/selectors.py`

**Size**: 5.6 KB

```python
"""
Selectors for Hands Review Session - Pure functions for deriving UI state
All selectors must be pure and memoized where appropriate.
"""

from typing import Dict, Any, List, Optional
import math


def current_street(state: Dict[str, Any]) -> str:
    """Get current street from state."""
    enhanced_rpgw = state.get('enhanced_rpgw', {})
    return enhanced_rpgw.get('current_street', 'PREFLOP')


def current_actor(state: Dict[str, Any]) -> Optional[str]:
    """Get current actor (player_uid) from state."""
    enhanced_rpgw = state.get('enhanced_rpgw', {})
    return enhanced_rpgw.get('current_actor')


def legal_actions(state: Dict[str, Any]) -> List[str]:
    """Get legal actions for current state."""
    enhanced_rpgw = state.get('enhanced_rpgw', {})
    return enhanced_rpgw.get('legal_actions', [])


def pot_amount(state: Dict[str, Any]) -> int:
    """Get current pot amount."""
    enhanced_rpgw = state.get('enhanced_rpgw', {})
    return enhanced_rpgw.get('pot_amount', 0)


def seat_view(state: Dict[str, Any], uid: str) -> Dict[str, Any]:
    """Get seat view data for a specific player."""
    enhanced_rpgw = state.get('enhanced_rpgw', {})
    seats = enhanced_rpgw.get('seats', [])
    
    for seat in seats:
        if seat.get('player_uid') == uid:
            return {
                'name': seat.get('name', 'Unknown'),
                'stack': seat.get('current_stack', 0),
                'bet': seat.get('current_bet', 0),
                'folded': seat.get('folded', False),
                'acting': seat.get('acting', False),
                'cards': seat.get('cards', [])
            }
    
    return {
        'name': 'Unknown',
        'stack': 0,
        'bet': 0,
        'folded': False,
        'acting': False,
        'cards': []
    }


def board_cards(state: Dict[str, Any]) -> List[str]:
    """Get current board cards."""
    enhanced_rpgw = state.get('enhanced_rpgw', {})
    return enhanced_rpgw.get('board', [])


def review_progress(state: Dict[str, Any]) -> Dict[str, Any]:
    """Get hands review progress information."""
    review = state.get('review', {})
    return {
        'current_step': review.get('current_step', 0),
        'total_steps': review.get('total_steps', 0),
        'current_hand': review.get('loaded_hand'),
        'status': review.get('status', 'idle')
    }


def enhanced_rpgw_state(state: Dict[str, Any]) -> Dict[str, Any]:
    """Get complete Enhanced RPGW state for rendering."""
    enhanced_rpgw = state.get('enhanced_rpgw', {})
    return {
        'table': enhanced_rpgw.get('table', {}),
        'pot': enhanced_rpgw.get('pot', {}),
        'seats': enhanced_rpgw.get('seats', []),
        'board': enhanced_rpgw.get('board', []),
        'dealer': enhanced_rpgw.get('dealer', {}),
        'action': enhanced_rpgw.get('action', {}),
        'replay': enhanced_rpgw.get('replay', {})
    }


def can_execute_action(state: Dict[str, Any]) -> bool:
    """Check if an action can be executed."""
    enhanced_rpgw = state.get('enhanced_rpgw', {})
    return (
        enhanced_rpgw.get('execution_status') != 'pending' and
        enhanced_rpgw.get('current_action') is not None
    )


def can_go_next(state: Dict[str, Any]) -> bool:
    """Check if can go to next action."""
    review = state.get('review', {})
    current_step = review.get('current_step', 0)
    total_steps = review.get('total_steps', 0)
    return current_step < total_steps - 1


def can_go_prev(state: Dict[str, Any]) -> bool:
    """Check if can go to previous action."""
    review = state.get('review', {})
    current_step = review.get('current_step', 0)
    return current_step > 0


def is_hand_loaded(state: Dict[str, Any]) -> bool:
    """Check if a hand is currently loaded."""
    review = state.get('review', {})
    return review.get('loaded_hand') is not None


def get_num_seats(state: Dict[str, Any]) -> int:
    """Get number of seats from state."""
    enhanced_rpgw = state.get('enhanced_rpgw', {})
    seats = enhanced_rpgw.get('seats', [])
    return len(seats) if seats else 6  # Default to 6 seats


def get_seat_positions(
    state: Dict[str, Any], 
    seat_count: Optional[int] = None,
    canvas_width: Optional[int] = None,
    canvas_height: Optional[int] = None
) -> List[tuple]:
    """Get seat positions for rendering. Returns list of (x, y) coordinates."""
    if seat_count is None:
        seat_count = get_num_seats(state)
    
    # Use actual canvas dimensions if provided, otherwise use reasonable defaults
    if canvas_width and canvas_height:
        w, h = canvas_width, canvas_height
        cx, cy = w // 2, int(h * 0.52)  # Center of table
        radius = int(min(w, h) * 0.25)   # Seat radius - same as seats component
    else:
        # Fallback to reasonable defaults
        radius = 200
        cx, cy = 400, 300
    
    # Calculate positions for seats in a circle
    # Start from top (-90 degrees) and distribute evenly
    positions = []
    for i in range(seat_count):
        # Calculate angle: start from top (-90¬∞) and distribute evenly
        theta = -math.pi / 2 + (2 * math.pi * i) / seat_count
        
        # Calculate position on the circle
        x = cx + int(radius * math.cos(theta))
        y = cy + int(radius * math.sin(theta))
        
        positions.append((x, y))
        
        # Debug: Log the positioning calculation
        print(f"üéØ Seat {i} positioning: angle={theta:.2f}¬∞ -> ({x}, {y})")
    
    return positions


def get_dealer_position(state: Dict[str, Any]) -> int:
    """Get dealer position from state."""
    enhanced_rpgw = state.get('enhanced_rpgw', {})
    dealer_info = enhanced_rpgw.get('dealer', {})
    return dealer_info.get('position', 0)  # Default to seat 0


```

---

### store.py

**Path**: `backend/ui/state/store.py`

**Size**: 1.0 KB

```python
from typing import Any, Callable, Dict, List

Reducer = Callable[[Dict[str, Any], Dict[str, Any]], Dict[str, Any]]


class Store:
    """
    Minimal Redux-like store for UI state.
    """

    def __init__(
        self, initial_state: Dict[str, Any], reducer: Reducer
    ) -> None:
        self._state = initial_state
        self._reducer = reducer
        self._subs: List[Callable[[Dict[str, Any]], None]] = []

    def get_state(self) -> Dict[str, Any]:
        return self._state

    def dispatch(self, action: Dict[str, Any]) -> None:
        next_state = self._reducer(self._state, action)
        if next_state is not self._state:
            self._state = next_state
            for cb in list(self._subs):
                cb(self._state)

    def subscribe(
        self, cb: Callable[[Dict[str, Any]], None]
    ) -> Callable[[], None]:
        self._subs.append(cb)

        def unsub() -> None:
            try:
                self._subs.remove(cb)
            except ValueError:
                pass

        return unsub
```

---

### geometry.py

**Path**: `backend/ui/table/geometry.py`

**Size**: 970 bytes

```python
from __future__ import annotations

from typing import Any, Dict, List, Tuple

from ..state.selectors import get_seat_positions


def pot_center(canvas_width: int, canvas_height: int) -> Tuple[int, int]:
    """Standard pot center used across sessions (slightly below center)."""
    return canvas_width // 2, int(canvas_height * 0.58)


def actor_seat_xy(display_state: Dict[str, Any], actor_uid: str,
                  canvas_width: int, canvas_height: int) -> Tuple[int, int]:
    seats: List[Dict[str, Any]] = display_state.get('seats', [])
    positions = get_seat_positions(
        display_state,
        seat_count=len(seats),
        canvas_width=canvas_width,
        canvas_height=canvas_height,
    )
    idx = next(
        (i for i, s in enumerate(seats) if s.get('player_uid') == actor_uid),
        -1,
    )
    if 0 <= idx < len(positions):
        x, y = positions[idx]
        return int(x), int(y)
    return canvas_width // 2, canvas_height // 2


```

---

### state.py

**Path**: `backend/ui/table/state.py`

**Size**: 451 bytes

```python
from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Dict, List


@dataclass(frozen=True)
class PokerTableState:
    table: Dict[str, Any]
    seats: List[Dict[str, Any]]
    board: List[str]
    pot: Dict[str, Any]
    dealer: Dict[str, Any]
    action: Dict[str, Any]
    animation: Dict[str, Any]
    effects: List[Dict[str, Any]]
    street: str = "PREFLOP"  # Current street for community card rendering

```

---

### __init__.py

**Path**: `backend/ui/tableview/__init__.py`

**Size**: 2 bytes

```python


```

---

### canvas_manager.py

**Path**: `backend/ui/tableview/canvas_manager.py`

**Size**: 5.6 KB

```python
import tkinter as tk
import importlib


class CanvasManager:
    def __init__(self, parent):
        # Store parent; defer canvas creation until sized to avoid small initial render
        self.parent = parent
        self.canvas = None
        self.overlay = None
        self._configure_after_id = None
        self._initialized = False
        self._pending_render = None

        # Resolve theme bg color once for initialization
        try:
            from ui.services.theme_manager import ThemeManager
            tm = ThemeManager()
            theme_colors = tm.get()
            self._canvas_bg = theme_colors.get("table.bg", theme_colors.get("panel.bg", "#000000"))
        except Exception:
            self._canvas_bg = "#000000"

        # Schedule lazy initialization after idle; we may need to retry until sized
        try:
            self.parent.after_idle(self._initialize_canvas)
        except Exception:
            # Fallback: attempt immediate init
            self._initialize_canvas()

    def _on_configure(self, event):
        if event.width <= 1 or event.height <= 1:
            return
        try:
            if self.overlay is not None and self.canvas is not None:
                self.overlay.lift(self.canvas)
        except Exception:
            pass

    def size(self):
        if not self.canvas:
            return 0, 0
        w = self.canvas.winfo_width()
        h = self.canvas.winfo_height()
        if w <= 1 or h <= 1:
            try:
                w = self.canvas.winfo_reqwidth()
                h = self.canvas.winfo_reqheight()
            except Exception:
                pass
        return w, h

    # New APIs for deferred render gating
    def is_ready(self):
        return self._initialized and self.canvas is not None

    def defer_render(self, render_func):
        if self.is_ready():
            try:
                render_func()
            except Exception:
                pass
        else:
            self._pending_render = render_func

    def _initialize_canvas(self):
        # Force geometry update and get real size; retry until reasonable
        try:
            self.parent.update_idletasks()
        except Exception:
            pass

        try:
            pw = getattr(self.parent, 'winfo_width')()
            ph = getattr(self.parent, 'winfo_height')()
        except Exception:
            pw, ph = 0, 0

        if pw <= 100 or ph <= 100:
            # ARCHITECTURE COMPLIANT: Schedule via parent's GameDirector if available
            try:
                # Try to find GameDirector through parent hierarchy
                game_director = None
                widget = self.parent
                while widget and not game_director:
                    if hasattr(widget, 'game_director'):
                        game_director = widget.game_director
                        break
                    if hasattr(widget, 'services'):
                        try:
                            game_director = widget.services.get_app("game_director")
                            break
                        except Exception:
                            pass
                    widget = getattr(widget, 'master', None)
                
                if game_director:
                    game_director.schedule(50, {
                        "type": "CANVAS_INIT_RETRY",
                        "callback": self._initialize_canvas
                    })
                else:
                    # Fallback: direct retry (violation but necessary)
                    self.parent.after(50, self._initialize_canvas)
            except Exception:
                pass
            return

        # Create canvas now with proper size and grid into parent
        try:
            self.canvas = tk.Canvas(self.parent, width=pw, height=ph, bg=self._canvas_bg, highlightthickness=0)
            self.canvas.grid(row=0, column=0, sticky="nsew")
            try:
                self.canvas.bind("<Configure>", self._on_configure, add="+")
            except Exception:
                pass
            self._initialized = True

            # Execute any pending render deferral
            if self._pending_render is not None:
                pending = self._pending_render
                self._pending_render = None
                try:
                    pending()
                except Exception:
                    pass
        except Exception:
            # ARCHITECTURE COMPLIANT: Last resort retry via GameDirector
            try:
                # Try to find GameDirector through parent hierarchy
                game_director = None
                widget = self.parent
                while widget and not game_director:
                    if hasattr(widget, 'game_director'):
                        game_director = widget.game_director
                        break
                    if hasattr(widget, 'services'):
                        try:
                            game_director = widget.services.get_app("game_director")
                            break
                        except Exception:
                            pass
                    widget = getattr(widget, 'master', None)
                
                if game_director:
                    game_director.schedule(50, {
                        "type": "CANVAS_INIT_LAST_RESORT",
                        "callback": self._initialize_canvas
                    })
                else:
                    # Final fallback: direct retry (violation but necessary for bootstrap)
                    self.parent.after(50, self._initialize_canvas)
            except Exception:
                pass


```

---

### __init__.py

**Path**: `backend/ui/tableview/components/__init__.py`

**Size**: 2 bytes

```python


```

---

### action_indicator.py

**Path**: `backend/ui/tableview/components/action_indicator.py`

**Size**: 9.0 KB

```python
from ...state.selectors import get_seat_positions, get_num_seats
from ...services.theme_manager import ThemeManager


def _tokens(canvas):
    # Prefer ThemeManager from widget tree
    w = canvas
    while w is not None:
        try:
            if hasattr(w, "services"):
                tm = w.services.get_app("theme")  # type: ignore[attr-defined]
                if isinstance(tm, ThemeManager):
                    return tm.get_theme(), tm.get_fonts()
        except Exception:
            pass
        w = getattr(w, "master", None)
    # Fallbacks
    return (
        {
            "action.ring": "#10B981", 
            "action.pulse": "#34D399",
            "action.text": "#FFFFFF"
        }, 
        {"font.body": ("Arial", 10, "bold")}
    )


class ActionIndicator:
    def __init__(self):
        self._indicator_elements = {}  # Store indicator elements per seat
        self._pulse_state = 0  # For animation
    
    def render(self, state, canvas_manager, layer_manager) -> None:
        THEME, FONTS = _tokens(canvas_manager.canvas)
        c = canvas_manager.canvas
        w, h = canvas_manager.size()
        if w <= 1 or h <= 1:
            return
        
        # Get seats data from state
        seats_data = state.get("seats", [])
        if not seats_data:
            return
        
        count = len(seats_data)
        positions = get_seat_positions(state, seat_count=count, 
                                     canvas_width=w, canvas_height=h)
        
        # Clear old indicators
        for seat_idx in list(self._indicator_elements.keys()):
            for element_id in self._indicator_elements[seat_idx].values():
                try:
                    c.delete(element_id)
                except Exception:
                    pass
            del self._indicator_elements[seat_idx]
        
        # Find acting player
        acting_player_idx = None
        for idx, seat in enumerate(seats_data):
            if seat.get('acting', False) or seat.get('active', False):
                acting_player_idx = idx
                break
        
        if acting_player_idx is not None and acting_player_idx < len(positions):
            x, y = positions[acting_player_idx]
            
            # Create much more visible pulsing ring around acting player
            ring_radius = int(min(w, h) * 0.12)  # Larger radius for better visibility
            
            # Enhanced pulse effect with stronger colors and animation
            self._pulse_state = (self._pulse_state + 1) % 30
            pulse_factor = 1.0 + 0.2 * (1 + 0.8 * (self._pulse_state < 15))  # Stronger pulse
            current_radius = int(ring_radius * pulse_factor)
            
            self._indicator_elements[acting_player_idx] = {}
            
            # Outer ring (bright pulsing)
            self._indicator_elements[acting_player_idx]['outer_ring'] = c.create_oval(
                x - current_radius,
                y - current_radius,
                x + current_radius,
                y + current_radius,
                fill="",
                outline="#FFD700",  # Bright gold for maximum visibility
                width=4,  # Thicker line
                tags=("layer:action", f"action_ring_outer:{acting_player_idx}"),
            )
            
            # Inner ring (steady bright)
            inner_radius = ring_radius - 8
            self._indicator_elements[acting_player_idx]['inner_ring'] = c.create_oval(
                x - inner_radius,
                y - inner_radius,
                x + inner_radius,
                y + inner_radius,
                fill="",
                outline="#00FF00",  # Bright green for maximum visibility
                width=3,  # Thicker line
                tags=("layer:action", f"action_ring_inner:{acting_player_idx}"),
            )
            
            # Add a bright center dot for maximum visibility
            center_radius = 8
            self._indicator_elements[acting_player_idx]['center_dot'] = c.create_oval(
                x - center_radius,
                y - center_radius,
                x + center_radius,
                y + center_radius,
                fill="#FF0000",  # Bright red center
                outline="#FFFFFF",  # White outline
                width=2,
                tags=("layer:action", f"action_center:{acting_player_idx}"),
            )
            
            # Enhanced action text indicator with background
            action_text = "YOUR TURN"
            seat_data = seats_data[acting_player_idx]
            player_name = seat_data.get('name', f'Player {acting_player_idx + 1}')
            
            # Position text above the seat with background for better readability
            text_y = y - ring_radius - 30
            
            # Create background rectangle for text
            text_bg = c.create_rectangle(
                x - 80, text_y - 15,
                x + 80, text_y + 15,
                fill="#000000",  # Black background
                outline="#FFD700",  # Gold outline
                width=2,
                tags=("layer:action", f"action_bg:{acting_player_idx}"),
            )
            
            # Create the text
            self._indicator_elements[acting_player_idx]['text'] = c.create_text(
                x,
                text_y,
                text=f"{player_name}'s Turn",
                font=("Arial", 12, "bold"),  # Larger, bolder font
                fill="#FFFFFF",  # White text for maximum contrast
                tags=("layer:action", f"action_text:{acting_player_idx}"),
            )
            
            # Add player status labels for all seats
            self._add_player_status_labels(c, seats_data, positions)
            
            # Tag all elements
            for element_id in self._indicator_elements[acting_player_idx].values():
                c.addtag_withtag("layer:action", element_id)
        
        # Schedule next animation frame for pulsing effect
        if acting_player_idx is not None:
            canvas_manager.canvas.after(80, lambda: self._animate_pulse(canvas_manager))  # Faster animation
    
    def _animate_pulse(self, canvas_manager):
        """Continue the pulse animation."""
        try:
            # Trigger a re-render to update the pulse
            if hasattr(canvas_manager, 'parent') and hasattr(canvas_manager.parent, 'renderer_pipeline'):
                # Get current state and re-render
                if hasattr(canvas_manager.parent, 'store'):
                    state = canvas_manager.parent.store.get_state()
                    canvas_manager.parent.renderer_pipeline.render_once(state)
        except Exception:
            pass  # Silently continue if animation fails

    def _add_player_status_labels(self, canvas, seats_data, positions):
        """Add status labels for all players (folded, winner, etc.)"""
        for idx, (seat, (x, y)) in enumerate(zip(seats_data, positions)):
            if idx in self._indicator_elements:
                continue  # Skip acting player (already handled)
                
            # Create status label
            status = self._get_player_status(seat)
            if status:
                # Position label below the seat
                label_y = y + 40
                
                # Create background for status
                bg_id = canvas.create_rectangle(
                    x - 50, label_y - 10,
                    x + 50, label_y + 10,
                    fill="#1F2937",  # Dark background
                    outline="#6B7280",  # Gray outline
                    width=1,
                    tags=("layer:status", f"status_bg:{idx}"),
                )
                
                # Create status text
                text_id = canvas.create_text(
                    x,
                    label_y,
                    text=status,
                    font=("Arial", 9, "bold"),
                    fill=self._get_status_color(status),
                    tags=("layer:status", f"status_text:{idx}"),
                )
                
                # Store for cleanup
                if idx not in self._indicator_elements:
                    self._indicator_elements[idx] = {}
                self._indicator_elements[idx][f'status_bg'] = bg_id
                self._indicator_elements[idx][f'status_text'] = text_id
    
    def _get_player_status(self, seat):
        """Get the status text for a player seat"""
        if seat.get('folded', False):
            return "FOLDED"
        elif seat.get('all_in', False):
            return "ALL IN"
        elif seat.get('winner', False):
            return "WINNER"
        elif seat.get('acting', False):
            return "ACTING"
        else:
            return None
    
    def _get_status_color(self, status):
        """Get the appropriate color for a status"""
        if status == "FOLDED":
            return "#EF4444"  # Red
        elif status == "ALL IN":
            return "#F59E0B"  # Orange
        elif status == "WINNER":
            return "#10B981"  # Green
        elif status == "ACTING":
            return "#3B82F6"  # Blue
        else:
            return "#6B7280"  # Gray
```

---

### bet_display.py

**Path**: `backend/ui/tableview/components/bet_display.py`

**Size**: 15.1 KB

```python
from ...state.selectors import get_seat_positions, get_num_seats
from ...services.theme_manager import ThemeManager

try:
    from .chip_graphics import ChipGraphics, BetDisplay as ChipBetDisplay
except Exception:
    # Fallback: define minimal ChipGraphics inline if chip_graphics module is missing
    class ChipGraphics:
        @staticmethod
        def draw_chip_stack(canvas, x, y, amount, theme, fonts, tags=()):
            # Simple circle + text fallback
            r = 16
            canvas.create_oval(x-r, y-r, x+r, y+r, fill=theme.get("chip.gold","#D97706"), outline="black", width=1, tags=tags)
            canvas.create_text(x, y, text=str(amount), fill="white", font=fonts.get("font.body", ("Arial", 10, "bold")), tags=tags)
    class ChipBetDisplay:
        def render(self, canvas, pos, amount, theme, fonts):
            ChipGraphics.draw_chip_stack(canvas, pos[0], pos[1], amount, theme, fonts, tags=("layer:chips",))


def _tokens(canvas):
    # Prefer ThemeManager from widget tree
    w = canvas
    while w is not None:
        try:
            if hasattr(w, "services"):
                tm = w.services.get_app("theme")  # type: ignore[attr-defined]
                if isinstance(tm, ThemeManager):
                    return tm.get_theme(), tm.get_fonts()
        except Exception:
            pass
        w = getattr(w, "master", None)
    # Fallbacks
    return (
        {
            "bet.bg": "#374151", 
            "bet.border": "#6B7280",
            "bet.text": "#FFD700",
            "bet.active": "#DC2626"
        }, 
        {"font.body": ("Arial", 12, "bold")}
    )


class BetDisplay:
    def __init__(self):
        self._bet_elements = {}  # Store bet display elements per seat
        self._chip_graphics = None  # Will be initialized when canvas is available
        self._chip_bet_display = None
    
    def render(self, state, canvas_manager, layer_manager) -> None:
        THEME, FONTS = _tokens(canvas_manager.canvas)
        c = canvas_manager.canvas
        w, h = canvas_manager.size()
        if w <= 1 or h <= 1:
            return
        
        # Initialize chip graphics if needed
        if self._chip_graphics is None:
            self._chip_graphics = ChipGraphics(c)
            self._chip_bet_display = ChipBetDisplay(c)
        
        # Get seats data from state
        seats_data = state.get("seats", [])
        if not seats_data:
            return
        
        count = len(seats_data)
        # Pass canvas dimensions to get correct seat positions
        positions = get_seat_positions(state, seat_count=count, 
                                     canvas_width=w, canvas_height=h)
        
        # Clear old bet displays that are no longer needed
        current_seats = set(range(len(seats_data)))
        old_seats = set(self._bet_elements.keys()) - current_seats
        for old_seat in old_seats:
            if old_seat in self._bet_elements:
                for element_id in self._bet_elements[old_seat].values():
                    try:
                        c.delete(element_id)
                    except Exception:
                        pass
                del self._bet_elements[old_seat]
        
        for idx, (x, y) in enumerate(positions):
            if idx >= len(seats_data):
                break
                
            seat = seats_data[idx]
            current_bet = seat.get('current_bet', 0) or seat.get('bet', 0)
            
            # Debug: Log what data we have for each seat
            print(f"üéØ Seat {idx} data: {seat}")
            print(f"üéØ Seat {idx} position: ({x}, {y}), current_bet: {current_bet}")
            
            # Initialize bet elements for this seat if needed
            if idx not in self._bet_elements:
                self._bet_elements[idx] = {}
            
            # Always show stack size, even when no bet
            self._add_stack_display(c, x, y, seat, idx)
            
            # Show current bet if any
            if current_bet > 0:
                self._add_bet_display(c, x, y, current_bet, idx)
            
            if current_bet > 0:
                # Position bet display prominently in front of the player
                # Use proper offset based on seat position to ensure visibility
                # Calculate offset based on seat angle to position bet in front of player
                import math
                num_seats = len(seats_data)
                seat_angle = -math.pi / 2 + (2 * math.pi * idx) / num_seats
                
                # Offset in direction player is facing (toward table center)
                # Use larger offset for better visibility
                offset_distance = 60  # Increased from 40 for better visibility
                offset_x = int(offset_distance * math.cos(seat_angle))
                offset_y = int(offset_distance * math.sin(seat_angle))
                
                bet_x = int(x + offset_x)
                bet_y = int(y + offset_y)
                
                print(f"üéØ Bet positioning for seat {idx}: seat({x},{y}) -> bet({bet_x},{bet_y})")
                print(f"   Angle: {math.degrees(seat_angle):.1f}¬∞, offset: ({offset_x}, {offset_y})")
                
                # Clear old bet elements for this seat
                if idx in self._bet_elements:
                    for element_id in self._bet_elements[idx].values():
                        try:
                            c.delete(element_id)
                        except Exception:
                            pass
                    self._bet_elements[idx] = {}
                
                # Determine bet type for styling
                is_acting = seat.get('acting', False)
                last_action = seat.get('last_action', '')
                
                bet_type = "bet"
                if last_action == "call":
                    bet_type = "call"
                elif last_action in ["raise", "bet"]:
                    bet_type = "raise"
                elif is_acting:
                    bet_type = "active"
                
                # Create chip-based bet display using ChipAnimations
                try:
                    from .chip_animations import ChipAnimations
                    chip_anim = ChipAnimations(self._get_theme_manager(c))
                    
                    # Place bet chips in front of player (NOT flying to pot)
                    chip_elements = chip_anim.place_bet_chips(
                        c, bet_x, bet_y, current_bet, 
                        self._get_theme_tokens(c),
                        tags=("layer:bets", f"bet:{idx}")
                    )
                    
                    # Store all elements for cleanup
                    self._bet_elements[idx] = {
                        f"chip_{i}": elem_id for i, elem_id in enumerate(chip_elements)
                    }
                    
                    print(f"üéØ Bet chips placed for seat {idx}: ${current_bet} ({last_action}) at ({bet_x}, {bet_y})")
                    
                except Exception as e:
                    print(f"‚ö†Ô∏è Could not create chip-based bet display: {e}")
                    # Fallback to simple text display
                    self._create_fallback_bet_display(c, bet_x, bet_y, current_bet, last_action, idx)
            else:
                # No bet - hide bet display
                if idx in self._bet_elements:
                    for element_id in self._bet_elements[idx].values():
                        try:
                            c.delete(element_id)
                        except Exception:
                            pass
                    self._bet_elements[idx] = {}
    
    def _add_stack_display(self, canvas, x, y, seat, idx):
        """Add stack size display for the player"""
        stack_amount = seat.get('current_stack', seat.get('stack', 0))
        if stack_amount > 0:
            # Get sizing system from canvas widget tree
            sizing_system = self._get_sizing_system(canvas)
            
            # Get chip size and text size from sizing system
            chip_size = 12  # Default fallback
            text_size = 10  # Default fallback
            
            if sizing_system:
                chip_size = sizing_system.get_chip_size('stack')
                text_size = sizing_system.get_text_size('stack_amount')
            
            # Position stack display below the seat
            stack_x = x
            stack_y = y + 40
            
            # Create stack background
            stack_bg = canvas.create_rectangle(
                stack_x - chip_size * 2, stack_y - chip_size // 2,
                stack_x + chip_size * 2, stack_y + chip_size // 2,
                fill="#1F2937",  # Dark background
                outline="#6B7280",  # Gray outline
                width=1,
                tags=("layer:stacks", f"stack_bg:{idx}")
            )
            
            # Create stack amount text
            stack_text = canvas.create_text(
                stack_x, stack_y,
                text=f"${stack_amount}",
                font=("Arial", text_size, "bold"),
                fill="#10B981",  # Green for stack
                tags=("layer:stacks", f"stack_text:{idx}")
            )
            
            # Store for cleanup
            if idx not in self._bet_elements:
                self._bet_elements[idx] = {}
            self._bet_elements[idx][f'stack_bg'] = stack_bg
            self._bet_elements[idx][f'stack_text'] = stack_text
    
    def _add_bet_display(self, canvas, x, y, amount, idx):
        """Add bet display for current bet amount"""
        # Get sizing system from canvas widget tree
        sizing_system = self._get_sizing_system(canvas)
        
        # Get chip size and text sizes from sizing system
        chip_size = 25  # Default fallback
        amount_text_size = 10  # Default fallback
        
        if sizing_system:
            chip_size = sizing_system.get_chip_size('bet')
            amount_text_size = sizing_system.get_text_size('bet_amount')
        
        bet_tag = f"bet:{idx}"
        
        # Position bet display prominently in front of the player
        # Use angular offset to place it in front of the seat
        bet_x = x + int(chip_size * 0.8)  # Slightly to the right
        bet_y = y - int(chip_size * 0.6)  # Slightly above
        
        # Create background circle for bet amount
        bet_bg = canvas.create_oval(
            bet_x - chip_size, bet_y - chip_size // 2,
            bet_x + chip_size, bet_y + chip_size // 2,
            fill="#1F2937",  # Dark background
            outline="#FFD700",  # Gold outline
            width=2,
            tags=("layer:bets", bet_tag, "bet_bg")
        )
        
        # Create bet amount text
        bet_text = canvas.create_text(
            bet_x, bet_y,
            text=f"${amount}",
            font=("Arial", amount_text_size, "bold"),
            fill="#FFFFFF",  # White text
            tags=("layer:bets", bet_tag, "bet_text")
        )
        
        # Store elements for cleanup
        if idx not in self._bet_elements:
            self._bet_elements[idx] = {}
        self._bet_elements[idx]['bet_bg'] = bet_bg
        self._bet_elements[idx]['bet_text'] = bet_text
    
    def _create_fallback_bet_display(self, canvas, x, y, amount, action, idx):
        """Create a fallback bet display if chip system fails"""
        # Get sizing system from canvas widget tree
        sizing_system = self._get_sizing_system(canvas)
        
        # Get chip size and text sizes from sizing system
        chip_size = 25  # Default fallback
        amount_text_size = 10  # Default fallback
        action_text_size = 8   # Default fallback
        
        if sizing_system:
            chip_size = sizing_system.get_chip_size('bet')
            amount_text_size = sizing_system.get_text_size('bet_amount')
            action_text_size = sizing_system.get_text_size('action_label')
        
        bet_tag = f"bet:{idx}"
        
        # Create background circle for bet amount
        bet_bg = canvas.create_oval(
            x - chip_size, y - chip_size // 2,
            x + chip_size, y + chip_size // 2,
            fill="#1F2937",  # Dark background
            outline="#FFD700",  # Gold outline
            width=2,
            tags=("layer:bets", bet_tag, "bet_bg")
        )
        
        # Create bet amount text
        bet_text = canvas.create_text(
            x, y,
            text=f"${amount}",
            font=("Arial", amount_text_size, "bold"),
            fill="#FFFFFF",  # White text
            tags=("layer:bets", bet_tag, "bet_text")
        )
        
        # Add action type indicator below bet amount
        if action:
            action_y = y + chip_size // 2 + 5
            action_text = canvas.create_text(
                x, action_y,
                text=action.upper(),
                font=("Arial", action_text_size, "bold"),
                fill=self._get_action_color(action),
                tags=("layer:bets", bet_tag, "bet_action")
            )
            
            # Store all elements for cleanup
            self._bet_elements[idx] = {
                'bet_bg': bet_bg,
                'bet_text': bet_text,
                'bet_action': action_text
            }
        else:
            # Store elements for cleanup
            self._bet_elements[idx] = {
                'bet_bg': bet_bg,
                'bet_text': bet_text
            }
    
    def _get_theme_manager(self, canvas):
        """Get theme manager from canvas widget tree"""
        w = canvas
        while w is not None:
            try:
                if hasattr(w, "services"):
                    tm = w.services.get_app("theme")
                    if tm:
                        return tm
            except Exception:
                pass
            w = getattr(w, "master", None)
        return None
    
    def _get_theme_tokens(self, canvas):
        """Get theme tokens from canvas widget tree"""
        w = canvas
        while w is not None:
            try:
                if hasattr(w, "services"):
                    tm = w.services.get_app("theme")
                    if tm:
                        return tm.get_all_tokens()
            except Exception:
                pass
            w = getattr(w, "master", None)
        return {}
    
    def _get_action_color(self, action):
        """Get the appropriate color for an action type"""
        if action == "call":
            return "#10B981"  # Green
        elif action == "raise":
            return "#F59E0B"  # Orange
        elif action == "bet":
            return "#3B82F6"  # Blue
        elif action == "check":
            return "#6B7280"  # Gray
        elif action == "fold":
            return "#EF4444"  # Red
        else:
            return "#FFFFFF"  # White

    def _get_sizing_system(self, canvas):
        """Get sizing system from canvas widget tree"""
        w = canvas
        while w is not None:
            try:
                if hasattr(w, "services"):
                    tm = w.services.get_app("theme")
                    if tm and hasattr(tm, 'sizing_system'):
                        return tm.sizing_system
            except Exception:
                pass
            w = getattr(w, "master", None)
        return None
```

---

### card_utils.py

**Path**: `backend/ui/tableview/components/card_utils.py`

**Size**: 1.6 KB

```python
"""
Utilities for poker card rendering and display.
"""


def parse_card(card_str):
    """
    Parse a card string like 'Ah', 'Kc', '2d', 'Ts' into rank and suit.
    Returns (rank, suit, color, symbol) tuple.
    """
    if not card_str or len(card_str) < 2:
        return None, None, "#000000", ""
    
    rank = card_str[0].upper()
    suit_char = card_str[1].lower()
    
    # Suit mapping to symbols and colors
    suit_map = {
        'h': ('‚ô•', '#DC2626'),  # Hearts - red
        'd': ('‚ô¶', '#DC2626'),  # Diamonds - red  
        'c': ('‚ô£', '#000000'),  # Clubs - black
        's': ('‚ô†', '#000000')   # Spades - black
    }
    
    if suit_char in suit_map:
        symbol, color = suit_map[suit_char]
        return rank, suit_char, color, symbol
    
    return rank, suit_char, "#000000", suit_char


def format_card_display(card_str, show_suits=True):
    """
    Format a card string for display.
    Returns (display_text, text_color) tuple.
    """
    rank, suit, color, symbol = parse_card(card_str)
    
    if not rank:
        return "", "#000000"
    
    if show_suits and symbol:
        display_text = f"{rank}{symbol}"
    else:
        display_text = rank
    
    return display_text, color


def is_red_card(card_str):
    """Check if a card is red (hearts or diamonds)."""
    if not card_str or len(card_str) < 2:
        return False
    suit_char = card_str[1].lower()
    return suit_char in ['h', 'd']


def is_black_card(card_str):
    """Check if a card is black (clubs or spades)."""
    if not card_str or len(card_str) < 2:
        return False
    suit_char = card_str[1].lower()
    return suit_char in ['c', 's']
```

---

### chip_animations.py

**Path**: `backend/ui/tableview/components/chip_animations.py`

**Size**: 16.9 KB

```python
"""
Chip Animation System - Flying Chips for Bet‚ÜíPot and Pot‚ÜíWinner
Token-driven animations with smooth easing and particle effects
"""

import math
from ...services.theme_utils import ease_in_out_cubic

class ChipAnimations:
    def __init__(self, theme_manager):
        self.theme = theme_manager
        self.active_animations = {}
        
    def draw_chip(self, canvas, x, y, denom_key, text="", r=14, tags=None):
        """Draw a single chip with token-driven colors"""
        tokens = self.theme.get_all_tokens()
        
        # Get chip colors from tokens
        chip_color = tokens.get(denom_key, "#2E86AB")  # Default to $1 blue
        rim_color = tokens.get("chip.rim", "#000000")
        text_color = tokens.get("chip.text", "#F8F7F4")
        
        chip_tags = ["chip"]
        if tags:
            chip_tags.extend(tags)
        
        # Main chip circle
        chip_id = canvas.create_oval(
            x - r, y - r, x + r, y + r,
            fill=chip_color, outline=rim_color, width=2,
            tags=tuple(chip_tags)
        )
        
        # Inner ring for depth
        inner_r = r - 3
        canvas.create_oval(
            x - inner_r, y - inner_r, x + inner_r, y + inner_r,
            fill="", outline=rim_color, width=1,
            tags=tuple(chip_tags)
        )
        
        # Value text (if provided)
        if text:
            canvas.create_text(
                x, y, text=text, fill=text_color,
                font=("Inter", 8, "bold"), anchor="center",
                tags=tuple(chip_tags)
            )
        
        return chip_id
    
    def stack_height(self, amount):
        """Calculate stack height based on amount"""
        return min(8, max(1, int(amount / 50)))  # 50 units per chip
    
    def draw_chip_stack(self, canvas, x, y, amount, tags=None):
        """Draw a stack of chips representing the total value"""
        if amount <= 0:
            return []
        
        # Determine chip denominations to show
        denom_keys = ["chip.$1", "chip.$5", "chip.$25", "chip.$100", "chip.$500", "chip.$1k"]
        levels = self.stack_height(amount)
        
        chip_ids = []
        for i in range(levels):
            # Cycle through denominations for visual variety
            denom = denom_keys[i % len(denom_keys)]
            chip_y = y - (i * 4)  # Stack with 4px offset
            
            chip_id = self.draw_chip(canvas, x, chip_y, denom, tags=tags)
            chip_ids.append(chip_id)
        
        return chip_ids
    
    def fly_chips_to_pot(self, canvas, from_x, from_y, to_x, to_y, amount, callback=None):
        """Animate chips flying from player bet area to pot - ONLY at end of street"""
        animation_id = f"bet_to_pot_{from_x}_{from_y}"
        tokens = self.theme.get_all_tokens()
        
        # Create temporary chips for animation with proper denominations
        chip_plan = self._break_down_amount(amount)
        chip_ids = []
        
        for i, denom in enumerate(chip_plan):
            # Slight spread for natural look
            start_x = from_x + (i - len(chip_plan)//2) * 8
            start_y = from_y + (i - len(chip_plan)//2) * 4
            
            # Create chip with proper denomination and label
            chip_size = 12  # Standard chip size for animations
            chip_id = self._create_chip_with_label(canvas, start_x, start_y, denom, 
                                                 tokens, chip_size, tags=["flying_chip", "temp_animation"])
            chip_ids.append((chip_id, start_x, start_y, denom))
        
        # Animation parameters - slower for visibility
        frames = 30  # Increased from 20 for better visibility
        
        def animate_step(frame):
            if frame >= frames:
                # Animation complete
                self._cleanup_flying_chips(canvas, chip_ids)
                if animation_id in self.active_animations:
                    del self.active_animations[animation_id]
                if callback:
                    callback()
                return
            
            # Calculate progress with easing
            progress = frame / frames
            eased_progress = ease_in_out_cubic(progress)
            
            # Update each chip position
            for i, (chip_id, start_x, start_y, denom) in enumerate(chip_ids):
                # Calculate current position with slight arc
                current_x = start_x + (to_x - start_x) * eased_progress
                current_y = start_y + (to_y - start_y) * eased_progress
                
                # Add arc effect (parabolic path)
                arc_height = 30 * math.sin(progress * math.pi)
                current_y -= arc_height
                
                # Add slight randomness for natural movement
                wobble_x = math.sin(frame * 0.3 + i) * 3
                wobble_y = math.cos(frame * 0.2 + i) * 2
                
                # Update chip position
                try:
                    canvas.coords(chip_id, 
                                current_x + wobble_x - 14, current_y + wobble_y - 14,
                                current_x + wobble_x + 14, current_y + wobble_y + 14)
                except:
                    pass  # Chip may have been deleted
            
            # Add motion blur/glow effect
            if frame % 2 == 0:  # Every 2nd frame for more glow
                glow_color = tokens.get("bet.glow", "#FFD700")
                for _, (chip_id, _, _, _) in enumerate(chip_ids):
                    try:
                        bbox = canvas.bbox(chip_id)
                        if bbox:
                            x1, y1, x2, y2 = bbox
                            canvas.create_oval(
                                x1 - 4, y1 - 4, x2 + 4, y2 + 4,
                                outline=glow_color, width=2,
                                tags=("motion_glow", "temp_animation")
                            )
                    except:
                        pass
            
            # Schedule next frame - slower for visibility
            canvas.after(80, lambda: animate_step(frame + 1))  # Increased from 40ms
        
        self.active_animations[animation_id] = animate_step
        animate_step(0)
    
    def fly_pot_to_winner(self, canvas, pot_x, pot_y, winner_x, winner_y, amount, callback=None):
        """Animate pot chips flying to winner with celebration effect"""
        animation_id = f"pot_to_winner_{winner_x}_{winner_y}"
        tokens = self.theme.get_all_tokens()
        
        # Create explosion of chips from pot
        explosion_positions = []
        num_stacks = 6
        
        for i in range(num_stacks):
            angle = (i / num_stacks) * 2 * math.pi
            radius = 30
            exp_x = pot_x + radius * math.cos(angle)
            exp_y = pot_y + radius * math.sin(angle)
            explosion_positions.append((exp_x, exp_y))
        
        # Create chip stacks for animation
        all_chip_ids = []
        for exp_x, exp_y in explosion_positions:
            stack_chips = self.draw_chip_stack(canvas, exp_x, exp_y, amount // num_stacks,
                                             tags=["flying_chip", "temp_animation"])
            all_chip_ids.extend([(chip_id, exp_x, exp_y) for chip_id in stack_chips])
        
        frames = 30
        
        def animate_step(frame):
            if frame >= frames:
                # Show winner celebration
                self._show_winner_celebration(canvas, winner_x, winner_y, tokens)
                self._cleanup_flying_chips(canvas, all_chip_ids)
                if animation_id in self.active_animations:
                    del self.active_animations[animation_id]
                if callback:
                    callback()
                return
            
            progress = frame / frames
            eased_progress = ease_in_out_cubic(progress)
            
            # Move all chips toward winner
            for chip_id, start_x, start_y in all_chip_ids:
                # Calculate trajectory with arc
                current_x = start_x + (winner_x - start_x) * eased_progress
                current_y = start_y + (winner_y - start_y) * eased_progress
                
                # Higher arc for dramatic effect
                arc_height = 40 * math.sin(progress * math.pi)
                current_y -= arc_height
                
                try:
                    canvas.coords(chip_id,
                                current_x - 14, current_y - 14,
                                current_x + 14, current_y + 14)
                except:
                    pass
            
            canvas.after(35, lambda: animate_step(frame + 1))
        
        self.active_animations[animation_id] = animate_step
        animate_step(0)
    
    def place_bet_chips(self, canvas, x, y, amount, tokens, tags=()):
        """Place bet chips in front of player (NOT flying to pot) - for betting rounds"""
        # Get chip size from sizing system if available
        chip_size = 14  # Default fallback
        if hasattr(self, 'theme') and hasattr(self.theme, 'get_all_tokens'):
            try:
                # Try to get sizing system from theme
                sizing_system = getattr(self.theme, 'sizing_system', None)
                if sizing_system:
                    chip_size = sizing_system.get_chip_size('bet')
            except Exception:
                pass
        
        chip_plan = self._break_down_amount(amount)
        chip_ids = []
        
        # Position chips in a neat stack in front of player
        for i, denom in enumerate(chip_plan):
            chip_x = x + (i - len(chip_plan)//2) * 6  # Horizontal spread
            chip_y = y - (i * 3)  # Vertical stack
            
            # Create chip with denomination label
            chip_id = self._create_chip_with_label(canvas, chip_x, chip_y, denom, 
                                                 tokens, chip_size, tags=tags + (f"bet_chip_{i}",))
            chip_ids.append(chip_id)
        
        # Add total amount label above the chips
        label_y = y - (len(chip_plan) * 3) - 20
        
        # Get text size from sizing system if available
        text_size = 12  # Default fallback
        if hasattr(self, 'theme') and hasattr(self.theme, 'get_all_tokens'):
            try:
                sizing_system = getattr(self.theme, 'sizing_system', None)
                if sizing_system:
                    text_size = sizing_system.get_text_size('bet_amount')
            except Exception:
                pass
        
        label_id = canvas.create_text(
            x, label_y,
            text=f"${amount}",
            font=("Arial", text_size, "bold"),
            fill="#FFFFFF",
            tags=tags + ("bet_label",)
        )
        
        return chip_ids + [label_id]
    
    def _create_chip_with_label(self, canvas, x, y, denom, tokens, chip_size, tags=()):
        """Create a chip with denomination label"""
        # Get chip colors based on denomination
        bg_color, ring_color, text_color = self._get_chip_colors(denom, tokens)
        
        # Create chip body
        chip_id = canvas.create_oval(
            x - chip_size, y - chip_size, x + chip_size, y + chip_size,
            fill=bg_color, outline=ring_color, width=2,
            tags=tags
        )
        
        # Get text size from sizing system if available
        text_size = max(8, int(chip_size * 0.4))  # Default proportional sizing
        if hasattr(self, 'theme') and hasattr(self.theme, 'get_all_tokens'):
            try:
                sizing_system = getattr(self.theme, 'sizing_system', None)
                if sizing_system:
                    text_size = sizing_system.get_text_size('action_label')
            except Exception:
                pass
        
        # Create denomination label
        label_id = canvas.create_text(
            x, y,
            text=f"${denom}",
            font=("Arial", text_size, "bold"),
            fill=text_color,
            tags=tags
        )
        
        return chip_id
    
    def _get_chip_colors(self, denom, tokens):
        """Get appropriate colors for chip denomination"""
        if denom >= 1000:
            return "#2D1B69", "#FFD700", "#FFFFFF"  # Purple with gold ring
        elif denom >= 500:
            return "#8B0000", "#FFD700", "#FFFFFF"  # Red with gold ring
        elif denom >= 100:
            return "#006400", "#FFFFFF", "#FFFFFF"  # Green with white ring
        elif denom >= 25:
            return "#4169E1", "#FFFFFF", "#FFFFFF"  # Blue with white ring
        else:
            return "#FFFFFF", "#000000", "#000000"  # White with black ring
    
    def _break_down_amount(self, amount):
        """Break down amount into chip denominations"""
        denominations = [1000, 500, 100, 25, 5, 1]
        chip_plan = []
        remaining = amount
        
        for denom in denominations:
            if remaining >= denom:
                count = min(remaining // denom, 5)  # Max 5 chips per denomination
                chip_plan.extend([denom] * count)
                remaining -= denom * count
                
            if len(chip_plan) >= 8:  # Max 8 chips total
                break
        
        # If we still have remaining, add smaller denominations
        if remaining > 0 and len(chip_plan) < 8:
            remaining_space = 8 - len(chip_plan)
            chip_plan.extend([1] * min(remaining_space, remaining))
        
        return chip_plan
    
    def _show_winner_celebration(self, canvas, x, y, tokens):
        """Show celebration effect at winner position"""
        celebration_color = tokens.get("label.winner.bg", "#FFD700")
        
        # Create particle burst
        for i in range(12):
            angle = (i / 12) * 2 * math.pi
            
            # Particle trajectory
            end_x = x + 60 * math.cos(angle)
            end_y = y + 60 * math.sin(angle)
            
            # Create particle
            particle_id = canvas.create_oval(
                x - 3, y - 3, x + 3, y + 3,
                fill=celebration_color, outline="",
                tags=("celebration_particle", "temp_animation")
            )
            
            # Animate particle outward
            self._animate_particle(canvas, particle_id, x, y, end_x, end_y)
        
        # Winner text flash
        canvas.create_text(
            x, y - 40, text="WINNER!", 
            font=("Inter", 18, "bold"), fill=celebration_color,
            tags=("winner_flash", "temp_animation")
        )
        
        # Auto-cleanup after 2 seconds
        canvas.after(2000, lambda: canvas.delete("celebration_particle", "winner_flash"))
    
    def _animate_particle(self, canvas, particle_id, start_x, start_y, end_x, end_y):
        """Animate a single celebration particle"""
        frames = 15
        
        def particle_step(frame):
            if frame >= frames:
                try:
                    canvas.delete(particle_id)
                except:
                    pass
                return
            
            progress = frame / frames
            current_x = start_x + (end_x - start_x) * progress
            current_y = start_y + (end_y - start_y) * progress
            
            try:
                canvas.coords(particle_id,
                            current_x - 3, current_y - 3,
                            current_x + 3, current_y + 3)
            except:
                pass
            
            canvas.after(30, lambda: particle_step(frame + 1))
        
        particle_step(0)
    
    def _cleanup_flying_chips(self, canvas, chip_ids):
        """Clean up temporary animation chips"""
        for chip_data in chip_ids:
            if isinstance(chip_data, tuple):
                chip_id = chip_data[0]
            else:
                chip_id = chip_data
            try:
                canvas.delete(chip_id)
            except:
                pass
        
        # Clean up motion effects
        canvas.delete("motion_glow")
    
    def pulse_pot(self, canvas, pot_x, pot_y, tokens):
        """Subtle pot pulse when amount increases"""
        glow_color = tokens.get("glow.medium", "#FFD700")
        
        def pulse_step(radius, intensity):
            if intensity <= 0:
                canvas.delete("pot_pulse")
                return
            
            # Create expanding ring
            canvas.create_oval(
                pot_x - radius, pot_y - radius,
                pot_x + radius, pot_y + radius,
                outline=glow_color, width=2,
                tags=("pot_pulse", "temp_animation")
            )
            
            canvas.after(60, lambda: pulse_step(radius + 8, intensity - 1))
        
        pulse_step(20, 5)
    
    def stop_all_animations(self):
        """Stop all active chip animations"""
        self.active_animations.clear()
    
    def cleanup_temp_elements(self, canvas):
        """Clean up all temporary animation elements"""
        canvas.delete("temp_animation")
        canvas.delete("flying_chip")
        canvas.delete("motion_glow")
        canvas.delete("pot_pulse")
```

---

### chip_graphics.py

**Path**: `backend/ui/tableview/components/chip_graphics.py`

**Size**: 21.3 KB

```python
"""
Luxury Themed Chip Graphics System
Renders poker chips with theme-aware styling for bets, calls, and pot displays.
"""
import math
import tkinter as tk
from typing import Dict, List, Tuple, Optional
from ...services.theme_manager import ThemeManager


def _tokens(canvas):
    """Get theme tokens and fonts from widget tree."""
    w = canvas
    while w is not None:
        try:
            if hasattr(w, "services"):
                tm = w.services.get_app("theme")
                if isinstance(tm, ThemeManager):
                    return tm.get_theme(), tm.get_fonts()
        except Exception:
            pass
        w = getattr(w, "master", None)
    # Fallbacks
    return ({"chip.primary": "#DAA520", "chip.secondary": "#8B4513"}, {"body": ("Arial", 10, "bold")})


class ChipGraphics:
    """Renders luxury themed poker chips with animations."""
    
    def __init__(self, canvas):
        self.canvas = canvas
        self.chip_stacks = {}  # Track chip positions for animations
        self.animation_queue = []  # Queue for chip animations
        
    def get_chip_colors_for_value(self, value: int, theme: Dict) -> Tuple[str, str, str]:
        """Get themed chip colors based on value."""
        # Standard poker chip color scheme with theme variations
        if value >= 1000:
            # High value - use theme's luxury colors
            return (
                theme.get("chip.luxury.bg", "#2D1B69"),      # Deep purple/navy
                theme.get("chip.luxury.ring", "#FFD700"),    # Gold ring
                theme.get("chip.luxury.accent", "#E6E6FA")   # Light accent
            )
        elif value >= 500:
            # Medium-high value - theme primary colors
            return (
                theme.get("chip.high.bg", "#8B0000"),        # Deep red
                theme.get("chip.high.ring", "#FFD700"),      # Gold ring
                theme.get("chip.high.accent", "#FFFFFF")     # White accent
            )
        elif value >= 100:
            # Medium value - theme secondary colors
            return (
                theme.get("chip.medium.bg", "#006400"),      # Forest green
                theme.get("chip.medium.ring", "#FFFFFF"),    # White ring
                theme.get("chip.medium.accent", "#90EE90")   # Light green accent
            )
        elif value >= 25:
            # Low-medium value
            return (
                theme.get("chip.low.bg", "#4169E1"),         # Royal blue
                theme.get("chip.low.ring", "#FFFFFF"),       # White ring
                theme.get("chip.low.accent", "#ADD8E6")      # Light blue accent
            )
        else:
            # Lowest value - theme accent colors
            return (
                theme.get("chip.minimal.bg", "#FFFFFF"),     # White
                theme.get("chip.minimal.ring", "#000000"),   # Black ring
                theme.get("chip.minimal.accent", "#D3D3D3")  # Light gray accent
            )
    
    def render_chip(self, x: int, y: int, value: int, chip_type: str = "bet", 
                   size: int = 20, tags: Tuple = ()) -> List[int]:
        """Render a single luxury themed chip."""
        theme, fonts = _tokens(self.canvas)
        
        # Get themed colors for this chip value
        bg_color, ring_color, accent_color = self.get_chip_colors_for_value(value, theme)
        
        # Adjust colors based on chip type
        if chip_type == "pot":
            # Pot chips get special treatment with theme's pot colors
            bg_color = theme.get("pot.chipBg", bg_color)
            ring_color = theme.get("pot.badgeRing", ring_color)
        elif chip_type == "call":
            # Call chips get muted colors
            bg_color = theme.get("chip.call.bg", "#6B7280")
            ring_color = theme.get("chip.call.ring", "#9CA3AF")
        
        elements = []
        
        # Main chip body with luxury gradient effect
        chip_id = self.canvas.create_oval(
            x - size, y - size,
            x + size, y + size,
            fill=bg_color,
            outline=ring_color,
            width=3,
            tags=tags + ("chip", f"chip_{chip_type}")
        )
        elements.append(chip_id)
        
        # Inner highlight for 3D effect
        highlight_size = size - 4
        highlight_id = self.canvas.create_oval(
            x - highlight_size, y - highlight_size + 2,
            x + highlight_size, y - highlight_size + 8,
            fill=accent_color,
            outline="",
            tags=tags + ("chip_highlight",)
        )
        elements.append(highlight_id)
        
        # Luxury center pattern based on theme
        pattern_color = theme.get("chip.pattern", ring_color)
        
        # Theme-specific chip patterns
        theme_name = theme.get("_theme_name", "default")
        if "monet" in theme_name.lower():
            # Impressionist water lily pattern
            for angle in [0, 60, 120, 180, 240, 300]:
                rad = math.radians(angle)
                px = x + (size // 3) * math.cos(rad)
                py = y + (size // 3) * math.sin(rad)
                dot_id = self.canvas.create_oval(
                    px - 2, py - 2, px + 2, py + 2,
                    fill=pattern_color, outline="",
                    tags=tags + ("chip_pattern",)
                )
                elements.append(dot_id)
                
        elif "caravaggio" in theme_name.lower():
            # Baroque cross pattern
            cross_size = size // 2
            # Vertical line
            line1_id = self.canvas.create_line(
                x, y - cross_size, x, y + cross_size,
                fill=pattern_color, width=2,
                tags=tags + ("chip_pattern",)
            )
            elements.append(line1_id)
            # Horizontal line
            line2_id = self.canvas.create_line(
                x - cross_size, y, x + cross_size, y,
                fill=pattern_color, width=2,
                tags=tags + ("chip_pattern",)
            )
            elements.append(line2_id)
            
        elif "klimt" in theme_name.lower():
            # Art Nouveau geometric pattern
            square_size = size // 3
            square_id = self.canvas.create_rectangle(
                x - square_size, y - square_size,
                x + square_size, y + square_size,
                fill="", outline=pattern_color, width=2,
                tags=tags + ("chip_pattern",)
            )
            elements.append(square_id)
            
        else:
            # Default diamond pattern
            diamond_size = size // 2
            diamond_points = [
                x, y - diamond_size,  # Top
                x + diamond_size, y,  # Right
                x, y + diamond_size,  # Bottom
                x - diamond_size, y   # Left
            ]
            diamond_id = self.canvas.create_polygon(
                diamond_points,
                fill="", outline=pattern_color, width=2,
                tags=tags + ("chip_pattern",)
            )
            elements.append(diamond_id)
        
        # Value text (for larger chips)
        if size >= 15 and value >= 5:
            font_size = max(8, size // 3)
            text_font = (fonts.get("body", ("Arial", 10))[0], font_size, "bold")
            
            # Format value display
            if value >= 1000:
                display_value = f"{value//1000}K"
            else:
                display_value = str(value)
            
            text_id = self.canvas.create_text(
                x, y + size // 4,
                text=display_value,
                font=text_font,
                fill=theme.get("chip.text", "#FFFFFF"),
                tags=tags + ("chip_text",)
            )
            elements.append(text_id)
        
        return elements
    
    def render_chip_stack(self, x: int, y: int, total_value: int, 
                         chip_type: str = "bet", max_chips: int = 5,
                         tags: Tuple = ()) -> List[int]:
        """Render a stack of chips representing a total value."""
        theme, _ = _tokens(self.canvas)
        
        # Calculate chip denominations for the stack
        chip_values = self._calculate_chip_breakdown(total_value, max_chips)
        
        elements = []
        stack_height = 0
        
        for i, (value, count) in enumerate(chip_values):
            for j in range(count):
                # Stack chips with slight offset for 3D effect
                chip_x = x + j
                chip_y = y - stack_height - (j * 2)
                
                # Render individual chip
                chip_elements = self.render_chip(
                    chip_x, chip_y, value, chip_type,
                    size=18, tags=tags + (f"stack_{i}_{j}",)
                )
                elements.extend(chip_elements)
                
            stack_height += count * 3  # Increase stack height
        
        return elements
    
    def _calculate_chip_breakdown(self, total_value: int, max_chips: int) -> List[Tuple[int, int]]:
        """Calculate optimal chip breakdown for a given value."""
        denominations = [1000, 500, 100, 25, 5, 1]
        breakdown = []
        remaining = total_value
        chips_used = 0
        
        for denom in denominations:
            if chips_used >= max_chips:
                break
                
            if remaining >= denom:
                count = min(remaining // denom, max_chips - chips_used)
                if count > 0:
                    breakdown.append((denom, count))
                    remaining -= denom * count
                    chips_used += count
        
        # If we still have remaining value and room for chips, add smaller denominations
        if remaining > 0 and chips_used < max_chips:
            breakdown.append((remaining, 1))
        
        return breakdown
    
    def animate_chips_to_pot(self, start_x: int, start_y: int, 
                           end_x: int, end_y: int, chip_value: int,
                           duration: int = 500, callback=None):
        """Animate chips moving from player position to pot."""
        theme, _ = _tokens(self.canvas)
        
        # Create temporary chips for animation
        temp_chips = self.render_chip_stack(
            start_x, start_y, chip_value, "bet",
            tags=("animation", "temp_chip")
        )
        
        # Animation parameters
        steps = 20
        step_duration = duration // steps
        dx = (end_x - start_x) / steps
        dy = (end_y - start_y) / steps
        
        def animate_step(step: int):
            if step >= steps:
                # Animation complete - remove temp chips and call callback
                for chip_id in temp_chips:
                    try:
                        self.canvas.delete(chip_id)
                    except tk.TclError:
                        pass
                if callback:
                    callback()
                return
            
            # Move chips
            for chip_id in temp_chips:
                try:
                    self.canvas.move(chip_id, dx, dy)
                except tk.TclError:
                    pass
            
            # Schedule next step
            self.canvas.after(step_duration, lambda: animate_step(step + 1))
        
        # Start animation
        animate_step(0)
    
    def animate_pot_to_winner(self, pot_x: int, pot_y: int,
                            winner_x: int, winner_y: int, pot_value: int,
                            duration: int = 800, callback=None):
        """Animate pot chips moving to winner."""
        theme, _ = _tokens(self.canvas)
        
        # Create celebration effect
        self._create_winner_celebration(winner_x, winner_y, pot_value)
        
        # Create pot chips for animation
        temp_chips = self.render_chip_stack(
            pot_x, pot_y, pot_value, "pot",
            max_chips=8, tags=("animation", "pot_to_winner")
        )
        
        # Animation with arc trajectory
        steps = 25
        step_duration = duration // steps
        
        def animate_step(step: int):
            if step >= steps:
                # Animation complete
                for chip_id in temp_chips:
                    try:
                        self.canvas.delete(chip_id)
                    except tk.TclError:
                        pass
                if callback:
                    callback()
                return
            
            # Calculate arc position
            progress = step / steps
            # Parabolic arc
            arc_height = -50 * math.sin(math.pi * progress)
            
            current_x = pot_x + (winner_x - pot_x) * progress
            current_y = pot_y + (winner_y - pot_y) * progress + arc_height
            
            # Move chips to calculated position
            for i, chip_id in enumerate(temp_chips):
                try:
                    # Get current position
                    coords = self.canvas.coords(chip_id)
                    if len(coords) >= 4:
                        old_x = (coords[0] + coords[2]) / 2
                        old_y = (coords[1] + coords[3]) / 2
                        
                        # Calculate new position with slight spread
                        spread = i * 3
                        new_x = current_x + spread
                        new_y = current_y
                        
                        # Move chip
                        self.canvas.move(chip_id, new_x - old_x, new_y - old_y)
                except tk.TclError:
                    pass
            
            # Schedule next step
            self.canvas.after(step_duration, lambda: animate_step(step + 1))
        
        # Start animation
        animate_step(0)
    
    def _create_winner_celebration(self, x: int, y: int, pot_value: int):
        """Create celebration effect around winner."""
        theme, fonts = _tokens(self.canvas)
        
        # Celebration burst effect
        for i in range(8):
            angle = (i * 45) * math.pi / 180
            distance = 30
            star_x = x + distance * math.cos(angle)
            star_y = y + distance * math.sin(angle)
            
            # Create star burst
            star_id = self.canvas.create_text(
                star_x, star_y,
                text="‚ú®",
                font=("Arial", 16),
                fill=theme.get("celebration.color", "#FFD700"),
                tags=("celebration", "temp")
            )
            
            # Fade out after delay
            self.canvas.after(1000, lambda sid=star_id: self._fade_element(sid))
    
    def _fade_element(self, element_id: int):
        """Fade out and remove an element."""
        try:
            self.canvas.delete(element_id)
        except tk.TclError:
            pass


class BetDisplay:
    """Renders themed bet amounts with chip graphics."""
    
    def __init__(self, canvas):
        self.canvas = canvas
        self.chip_graphics = ChipGraphics(canvas)
    
    def render(self, x: int, y: int, amount: int, bet_type: str = "bet",
               tags: Tuple = ()) -> List[int]:
        """Render bet display with chips and text."""
        theme, fonts = _tokens(self.canvas)
        
        elements = []
        
        if amount > 0:
            # Render chip stack
            chip_elements = self.chip_graphics.render_chip_stack(
                x, y - 15, amount, bet_type, max_chips=3,
                tags=tags + ("bet_chips",)
            )
            elements.extend(chip_elements)
            
            # Render amount text
            text_color = theme.get("bet.text", "#FFFFFF")
            if bet_type == "call":
                text_color = theme.get("bet.call.text", "#9CA3AF")
            elif bet_type == "raise":
                text_color = theme.get("bet.raise.text", "#EF4444")
            
            text_id = self.canvas.create_text(
                x, y + 20,
                text=f"${amount:,}",
                font=fonts.get("body", ("Arial", 10, "bold")),
                fill=text_color,
                tags=tags + ("bet_text",)
            )
            elements.append(text_id)
        
        return elements


class WinnerBadge:
    """Renders themed winner announcement badges."""
    
    def __init__(self, canvas):
        self.canvas = canvas
    
    def render(self, x: int, y: int, player_name: str, amount: int,
               hand_description: str = "", tags: Tuple = ()) -> List[int]:
        """Render luxury winner badge with theme styling."""
        theme, fonts = _tokens(self.canvas)
        
        elements = []
        
        # Badge dimensions
        badge_width = 200
        badge_height = 80
        
        # Theme-aware colors
        badge_bg = theme.get("winner.bg", "#1F2937")
        badge_border = theme.get("winner.border", "#FFD700")
        badge_accent = theme.get("winner.accent", "#FEF3C7")
        
        # Main badge background with luxury styling
        badge_id = self.canvas.create_rectangle(
            x - badge_width//2, y - badge_height//2,
            x + badge_width//2, y + badge_height//2,
            fill=badge_bg,
            outline=badge_border,
            width=3,
            tags=tags + ("winner_badge",)
        )
        elements.append(badge_id)
        
        # Luxury gradient highlight
        highlight_id = self.canvas.create_rectangle(
            x - badge_width//2 + 3, y - badge_height//2 + 3,
            x + badge_width//2 - 3, y - badge_height//2 + 12,
            fill=badge_accent,
            outline="",
            tags=tags + ("winner_highlight",)
        )
        elements.append(highlight_id)
        
        # Winner crown symbol
        crown_id = self.canvas.create_text(
            x - badge_width//3, y - 10,
            text="üëë",
            font=("Arial", 20),
            tags=tags + ("winner_crown",)
        )
        elements.append(crown_id)
        
        # Winner text
        winner_text = f"WINNER: {player_name}"
        text_id = self.canvas.create_text(
            x, y - 15,
            text=winner_text,
            font=fonts.get("heading", ("Arial", 12, "bold")),
            fill=theme.get("winner.text", "#FFFFFF"),
            tags=tags + ("winner_text",)
        )
        elements.append(text_id)
        
        # Amount won
        amount_id = self.canvas.create_text(
            x, y + 5,
            text=f"${amount:,}",
            font=fonts.get("body", ("Arial", 14, "bold")),
            fill=theme.get("winner.amount", "#FFD700"),
            tags=tags + ("winner_amount",)
        )
        elements.append(amount_id)
        
        # Hand description (if provided)
        if hand_description:
            hand_id = self.canvas.create_text(
                x, y + 20,
                text=hand_description,
                font=fonts.get("caption", ("Arial", 9, "italic")),
                fill=theme.get("winner.description", "#D1D5DB"),
                tags=tags + ("winner_hand",)
            )
            elements.append(hand_id)
        
        return elements
    
    def animate_winner_announcement(self, x: int, y: int, player_name: str,
                                  amount: int, hand_description: str = "",
                                  duration: int = 3000):
        """Animate winner badge with entrance and exit effects."""
        # Create badge elements
        elements = self.render(x, y, player_name, amount, hand_description,
                             tags=("winner_animation",))
        
        # Entrance animation - scale up
        self._animate_scale(elements, 0.1, 1.0, 300)
        
        # Exit animation after duration
        self.canvas.after(duration, lambda: self._animate_fade_out(elements, 500))
    
    def _animate_scale(self, elements: List[int], start_scale: float,
                      end_scale: float, duration: int):
        """Animate scaling of elements."""
        steps = 15
        step_duration = duration // steps
        scale_step = (end_scale - start_scale) / steps
        
        def scale_step_func(step: int):
            if step >= steps:
                return
            
            current_scale = start_scale + scale_step * step
            
            for element_id in elements:
                try:
                    # Get element center
                    coords = self.canvas.coords(element_id)
                    if len(coords) >= 2:
                        if len(coords) == 4:  # Rectangle
                            center_x = (coords[0] + coords[2]) / 2
                            center_y = (coords[1] + coords[3]) / 2
                        else:  # Text or other
                            center_x, center_y = coords[0], coords[1]
                        
                        # Apply scaling (simplified - just adjust position)
                        # In a full implementation, you'd use canvas.scale()
                        pass
                except tk.TclError:
                    pass
            
            self.canvas.after(step_duration, lambda: scale_step_func(step + 1))
        
        scale_step_func(0)
    
    def _animate_fade_out(self, elements: List[int], duration: int):
        """Fade out and remove elements."""
        # Simplified fade - just remove after duration
        self.canvas.after(duration, lambda: self._remove_elements(elements))
    
    def _remove_elements(self, elements: List[int]):
        """Remove elements from canvas."""
        for element_id in elements:
            try:
                self.canvas.delete(element_id)
            except tk.TclError:
                pass
```

---

### community.py

**Path**: `backend/ui/tableview/components/community.py`

**Size**: 6.4 KB

```python
"""
Community Cards Component
Renders the community cards (flop, turn, river) on the poker table.
"""

import math
from typing import List, Tuple, Optional
from .sizing_utils import create_sizing_system


class Community:
    """Renders community cards on the poker table."""
    
    def __init__(self):
        self.community_cards = []
        self.sizing_system = None
    
    def render(self, state, canvas_manager, layer_manager) -> None:
        """Render community cards on the table with professional poker app behavior."""
        # Get canvas and dimensions
        canvas = canvas_manager.canvas
        w, h = canvas_manager.size()
        
        if w <= 1 or h <= 1:
            return
        
        # Get board cards from state
        board_cards = state.get("board", [])
        
        # Professional poker behavior: Always show 5 card positions
        # Show card backs initially, reveal as game progresses
        street = state.get("street", "PREFLOP")
        
        # Determine how many cards to show face-up based on street
        if street == "PREFLOP":
            revealed_cards = 0
        elif street == "FLOP":
            revealed_cards = 3
        elif street == "TURN":
            revealed_cards = 4
        elif street in ["RIVER", "SHOWDOWN"]:
            revealed_cards = 5
        else:
            revealed_cards = len(board_cards)  # Fallback
        
        # Get seats data for player count
        seats_data = state.get("seats", [])
        num_players = len(seats_data) if seats_data else 6
        
        # Initialize sizing system if not already done
        if not self.sizing_system:
            self.sizing_system = create_sizing_system(w, h, num_players)
        
        # Get card size from sizing system
        card_w, card_h = self.sizing_system.get_card_size()
        
        # Calculate table center and board position
        cx, cy = w // 2, int(h * 0.45)  # Board above center
        
        # Calculate spacing between cards
        spacing = self.sizing_system.get_spacing('card_gap')
        
        # Always render 5 card positions (professional poker standard)
        total_cards = 5
        total_width = total_cards * card_w + (total_cards - 1) * spacing
        start_x = cx - total_width // 2
        
        # Store positions for other components
        positions = []
        
        print(f"üÉè Community cards positioning: center=({cx},{cy}), card_size={card_w}x{card_h}, spacing={spacing}")
        print(f"üÉè Street: {street}, revealed: {revealed_cards}/{total_cards}")
        
        # Render all 5 card positions
        for i in range(total_cards):
            card_x = start_x + i * (card_w + spacing) + card_w // 2
            card_y = cy
            
            # Store position for other components
            positions.append((card_x, card_y))
            
            # Determine what to show for this card position
            if i < revealed_cards and i < len(board_cards):
                # Show face-up card
                card = board_cards[i]
                self._render_card(canvas, card_x, card_y, card, card_w, card_h, face_up=True)
            else:
                # Show card back
                self._render_card_back(canvas, card_x, card_y, card_w, card_h)
        
        print(f"üÉè Community rendering: {total_cards} positions, {revealed_cards} revealed, canvas: {w}x{h}")
        print(f"üÉè Board positions on {w}x{h}: center=({cx},{cy}), card_size={card_w}x{card_h}, positions={positions}")
    
    def _render_card(self, canvas, x: int, y: int, card: str, card_w: int, card_h: int, face_up: bool = True):
        """Render a single community card face-up."""
        # Get text sizes from sizing system
        rank_size = self.sizing_system.get_text_size('card_rank')
        suit_size = self.sizing_system.get_text_size('card_suit')
        
        # Create card background
        card_bg = canvas.create_rectangle(
            x - card_w // 2, y - card_h // 2,
            x + card_w // 2, y + card_h // 2,
            fill="#FFFFFF",
            outline="#000000",
            width=2,
            tags=("layer:community", "community_card")
        )
        
        # Parse and render card face
        if len(card) >= 2:
            rank = card[0]
            suit = card[1]
            
            # Render rank
            rank_text = canvas.create_text(
                x, y - card_h // 4,
                text=rank,
                font=("Arial", rank_size, "bold"),
                fill="#000000",
                tags=("layer:community", "community_card", "card_rank")
            )
            
            # Render suit
            suit_text = canvas.create_text(
                x, y + card_h // 4,
                text=suit,
                font=("Arial", suit_size, "bold"),
                fill=self._get_suit_color(suit),
                tags=("layer:community", "community_card", "card_suit")
            )
    
    def _render_card_back(self, canvas, x: int, y: int, card_w: int, card_h: int):
        """Render a card back (professional poker style)."""
        # Create card background with darker color for back
        card_bg = canvas.create_rectangle(
            x - card_w // 2, y - card_h // 2,
            x + card_w // 2, y + card_h // 2,
            fill="#8B0000",  # Dark red background
            outline="#000000",
            width=2,
            tags=("layer:community", "community_card_back")
        )
        
        # Add card back pattern (simple diamond pattern)
        # Inner border
        inner_border = canvas.create_rectangle(
            x - card_w // 2 + 4, y - card_h // 2 + 4,
            x + card_w // 2 - 4, y + card_h // 2 - 4,
            fill="",
            outline="#AA0000",
            width=1,
            tags=("layer:community", "community_card_back")
        )
        
        # Center diamond
        diamond_size = min(card_w, card_h) // 4
        canvas.create_polygon(
            x, y - diamond_size,  # Top
            x + diamond_size, y,  # Right
            x, y + diamond_size,  # Bottom
            x - diamond_size, y,  # Left
            fill="#AA0000",
            outline="#FFFFFF",
            width=1,
            tags=("layer:community", "community_card_back")
        )
    
    def _get_suit_color(self, suit: str) -> str:
        """Get color for card suit."""
        if suit in ['‚ô•', '‚ô¶']:
            return "#FF0000"  # Red for hearts and diamonds
        else:
            return "#000000"  # Black for clubs and spades

```

---

### dealer_button.py

**Path**: `backend/ui/tableview/components/dealer_button.py`

**Size**: 4.3 KB

```python
from ...state.selectors import (
    get_seat_positions,
    get_dealer_position,
)
from ...services.theme_manager import ThemeManager


def _tokens(canvas):
    # Prefer ThemeManager from widget tree
    w = canvas
    while w is not None:
        try:
            if hasattr(w, "services"):
                tm = w.services.get_app("theme")  # type: ignore[attr-defined]
                if isinstance(tm, ThemeManager):
                    return tm.get_theme(), tm.get_fonts()
        except Exception:
            pass
        w = getattr(w, "master", None)
    # Fallbacks
    return (
        {"dealer.buttonBg": "#FDE68A", "dealer.buttonFg": "#0B1220"}, 
        {"font.body": ("Arial", 12, "bold")}
    )


class DealerButton:
    def __init__(self):
        self._button_id = None
        self._text_id = None
    
    def render(self, state, canvas_manager, layer_manager) -> None:
        THEME, FONTS = _tokens(canvas_manager.canvas)
        c = canvas_manager.canvas
        w, h = canvas_manager.size()
        if w <= 1 or h <= 1:
            return
        
        # Get seat count from state - use direct seats array if available
        seats_data = state.get('seats', [])
        count = len(seats_data) if seats_data else 6  # Default to 6 seats
            
        dealer_pos = get_dealer_position(state)
        
        # Use consistent seat positions from geometry helper  
        positions = get_seat_positions(
            state, seat_count=count, 
            canvas_width=w, canvas_height=h
        )
        
        print(f"üè∑Ô∏è DealerButton on {w}x{h}: {count} seats, "
              f"dealer pos: {dealer_pos}")
            
        if dealer_pos < 0 or dealer_pos >= len(positions):
            print(f"üè∑Ô∏è Invalid dealer position {dealer_pos}, using 0")
            dealer_pos = 0
            
        seat_x, seat_y = positions[dealer_pos]
        
        # Position dealer button outside the seat, towards table center
        center_x, center_y = w // 2, int(h * 0.52)
        
        # Calculate direction from seat to center
        dx = center_x - seat_x
        dy = center_y - seat_y
        distance = (dx*dx + dy*dy) ** 0.5
        
        if distance > 0:
            # Normalize and position button closer to table center
            offset = 25  # Distance from seat center
            button_x = seat_x + (dx / distance) * offset
            button_y = seat_y + (dy / distance) * offset
        else:
            button_x, button_y = seat_x + 25, seat_y
        
        # Make dealer button more prominent
        button_radius = int(min(w, h) * 0.025)  # Larger button
        
        # Dealer button background with border
        if not self._button_id:
            self._button_id = c.create_oval(
                button_x - button_radius,
                button_y - button_radius,
                button_x + button_radius,
                button_y + button_radius,
                fill=THEME.get("dealer.buttonBg", "#FDE68A"),
                outline=THEME.get("dealer.buttonBorder", "#D97706"),
                width=2,
                tags=("layer:seats", "dealer_button"),
            )
        else:
            c.coords(
                self._button_id,
                button_x - button_radius,
                button_y - button_radius,
                button_x + button_radius,
                button_y + button_radius
            )
            c.itemconfig(
                self._button_id,
                fill=THEME.get("dealer.buttonBg", "#FDE68A"),
                outline=THEME.get("dealer.buttonBorder", "#D97706")
            )
        
        # Dealer button text
        if not self._text_id:
            self._text_id = c.create_text(
                button_x,
                button_y,
                text="D",
                font=FONTS.get("font.body", ("Arial", 14, "bold")),
                fill=THEME.get("dealer.buttonFg", "#0B1220"),
                tags=("layer:seats", "dealer_button_label"),
            )
        else:
            c.coords(self._text_id, button_x, button_y)
            c.itemconfig(
                self._text_id,
                fill=THEME.get("dealer.buttonFg", "#0B1220")
            )
        
        # Ensure proper layering
        c.addtag_withtag("layer:seats", self._button_id or "")
        c.addtag_withtag("layer:seats", self._text_id or "")


```

---

### enhanced_cards.py

**Path**: `backend/ui/tableview/components/enhanced_cards.py`

**Size**: 9.3 KB

```python
"""
Enhanced Card Graphics with Token-Driven Colors
Professional card rendering using the complete theme token system
"""

import math

class EnhancedCards:
    def __init__(self, theme_manager):
        self.theme = theme_manager
        
    # Suit symbols
    SUIT_SYMBOLS = {
        'h': '‚ô•', 'd': '‚ô¶', 'c': '‚ô£', 's': '‚ô†'
    }
    
    def draw_card_face(self, canvas, x, y, rank, suit, w=58, h=82, tags=None):
        """Draw a face-up card with token-driven colors"""
        tokens = self.theme.get_all_tokens()
        
        # Card colors from tokens
        bg = tokens.get("card.face.bg", "#F8F8FF")
        border = tokens.get("card.face.border", "#2F4F4F")
        pip_red = tokens.get("card.pip.red", "#DC2626")
        pip_black = tokens.get("card.pip.black", "#111827")
        
        # Determine suit color
        suit_color = pip_red if suit.lower() in ('h', 'd') else pip_black
        suit_symbol = self.SUIT_SYMBOLS.get(suit.lower(), '?')
        
        # Create tags
        card_tags = ["card_face"]
        if tags:
            card_tags.extend(tags)
        
        # Main card rectangle with rounded corners effect
        canvas.create_rectangle(
            x, y, x + w, y + h,
            fill=bg, outline=border, width=2,
            tags=tuple(card_tags)
        )
        
        # Inner border for depth
        canvas.create_rectangle(
            x + 2, y + 2, x + w - 2, y + h - 2,
            fill="", outline=border, width=1,
            tags=tuple(card_tags)
        )
        
        # Calculate font sizes based on card size
        rank_font_size = max(10, w // 5)
        suit_font_size = max(8, w // 6)
        center_font_size = max(14, w // 3)
        
        # Top-left rank and suit
        canvas.create_text(
            x + w//8, y + h//8,
            text=rank, font=("Inter", rank_font_size, "bold"),
            fill=suit_color, anchor="nw", tags=tuple(card_tags)
        )
        
        canvas.create_text(
            x + w//8, y + h//8 + rank_font_size + 2,
            text=suit_symbol, font=("Inter", suit_font_size, "bold"),
            fill=suit_color, anchor="nw", tags=tuple(card_tags)
        )
        
        # Center suit symbol (larger)
        canvas.create_text(
            x + w//2, y + h//2,
            text=suit_symbol, font=("Inter", center_font_size, "bold"),
            fill=suit_color, anchor="center", tags=tuple(card_tags)
        )
        
        # Bottom-right rank and suit (rotated appearance)
        canvas.create_text(
            x + w - w//8, y + h - h//8,
            text=rank, font=("Inter", rank_font_size, "bold"),
            fill=suit_color, anchor="se", tags=tuple(card_tags)
        )
        
        canvas.create_text(
            x + w - w//8, y + h - h//8 - rank_font_size - 2,
            text=suit_symbol, font=("Inter", suit_font_size, "bold"),
            fill=suit_color, anchor="se", tags=tuple(card_tags)
        )
        
        return card_tags
    
    def draw_card_back(self, canvas, x, y, w=58, h=82, tags=None):
        """Draw a face-down card back with theme integration"""
        tokens = self.theme.get_all_tokens()
        
        # Card back colors from tokens
        bg = tokens.get("card.back.bg", "#7F1D1D")
        border = tokens.get("card.back.border", "#2F4F4F")
        pattern = tokens.get("card.back.pattern", "#991B1B")
        
        # Create tags
        card_tags = ["card_back"]
        if tags:
            card_tags.extend(tags)
        
        # Main card rectangle
        canvas.create_rectangle(
            x, y, x + w, y + h,
            fill=bg, outline=border, width=2,
            tags=tuple(card_tags)
        )
        
        # Inner border for depth
        canvas.create_rectangle(
            x + 2, y + 2, x + w - 2, y + h - 2,
            fill="", outline=pattern, width=1,
            tags=tuple(card_tags)
        )
        
        # Diamond lattice pattern
        step = max(6, w // 8)
        for i in range(0, w + step, step):
            # Diagonal lines creating diamond pattern
            canvas.create_line(
                x + i, y, x, y + i,
                fill=pattern, width=1, tags=tuple(card_tags)
            )
            canvas.create_line(
                x + w - i, y, x + w, y + i,
                fill=pattern, width=1, tags=tuple(card_tags)
            )
            canvas.create_line(
                x + i, y + h, x, y + h - i,
                fill=pattern, width=1, tags=tuple(card_tags)
            )
            canvas.create_line(
                x + w - i, y + h, x + w, y + h - i,
                fill=pattern, width=1, tags=tuple(card_tags)
            )
        
        # Center decorative element
        center_size = min(w, h) // 4
        canvas.create_rectangle(
            x + w//2 - center_size//2, y + h//2 - center_size//4,
            x + w//2 + center_size//2, y + h//2 + center_size//4,
            fill="", outline=pattern, width=1,
            tags=tuple(card_tags)
        )
        
        return card_tags
    
    def draw_community_board(self, canvas, tokens, slots=5, card_w=58, gap=8):
        """Draw community card area with token-driven styling"""
        w = canvas.winfo_width()
        h = canvas.winfo_height()
        
        # Calculate board position
        x0, y0 = w * 0.5, h * 0.4
        total_w = slots * card_w + (slots - 1) * gap
        left = x0 - total_w / 2
        top = y0 - 4
        height = card_w * 0.2
        
        # Board colors from tokens
        slot_bg = tokens.get("board.slotBg", "#334155")
        border_color = tokens.get("board.border", "#475569")
        shadow_color = tokens.get("board.shadow", "#1E293B")
        
        # Clear previous board
        canvas.delete("board:underlay")
        
        # Shadow (offset slightly)
        canvas.create_rectangle(
            left - 8, top - 8, left + total_w + 12, top + height + 12,
            fill=shadow_color, outline="",
            tags=("board:underlay", "board_shadow")
        )
        
        # Main underlay
        canvas.create_rectangle(
            left - 10, top - 10, left + total_w + 10, top + height + 10,
            fill=slot_bg, outline=border_color, width=2,
            tags=("board:underlay", "board_main")
        )
        
        # Individual card slots
        for i in range(slots):
            slot_x = left + i * (card_w + gap)
            slot_y = top - card_w * 0.6
            
            # Slot outline
            canvas.create_rectangle(
                slot_x - 2, slot_y - 2, slot_x + card_w + 2, slot_y + card_w * 1.4 + 2,
                fill="", outline=border_color, width=1, stipple="gray25",
                tags=("board:underlay", f"slot_{i}")
            )
    
    def animate_card_flip(self, canvas, x, y, w, h, from_card, to_card, callback=None):
        """Animate card flip with token-aware colors"""
        flip_steps = 10
        
        def flip_step(step):
            if step >= flip_steps:
                if callback:
                    callback()
                return
            
            # Calculate flip progress (0 to 1)
            progress = step / flip_steps
            
            # Clear previous flip frame
            canvas.delete("card_flip")
            
            if progress < 0.5:
                # First half: shrink to nothing (show original card)
                scale = 1 - (progress * 2)
                scaled_w = int(w * scale)
                
                if scaled_w > 0:
                    if from_card and from_card != "XX":
                        rank, suit = from_card[:-1], from_card[-1]
                        self.draw_card_face(canvas, x + (w - scaled_w)//2, y, 
                                          rank, suit, scaled_w, h, ["card_flip"])
                    else:
                        self.draw_card_back(canvas, x + (w - scaled_w)//2, y, 
                                          scaled_w, h, ["card_flip"])
            else:
                # Second half: grow from nothing (show new card)
                scale = (progress - 0.5) * 2
                scaled_w = int(w * scale)
                
                if scaled_w > 0:
                    if to_card and to_card != "XX":
                        rank, suit = to_card[:-1], to_card[-1]
                        self.draw_card_face(canvas, x + (w - scaled_w)//2, y,
                                          rank, suit, scaled_w, h, ["card_flip"])
                    else:
                        self.draw_card_back(canvas, x + (w - scaled_w)//2, y,
                                          scaled_w, h, ["card_flip"])
            
            # Schedule next step
            canvas.after(40, lambda: flip_step(step + 1))
        
        flip_step(0)
    
    def add_card_glow(self, canvas, x, y, w, h, glow_type="soft"):
        """Add subtle glow effect around card"""
        tokens = self.theme.get_all_tokens()
        glow_color = tokens.get(f"glow.{glow_type}", tokens.get("a11y.focus", "#22C55E"))
        
        # Create glow effect with multiple rings
        for i in range(3):
            offset = (i + 1) * 2
            canvas.create_rectangle(
                x - offset, y - offset, x + w + offset, y + h + offset,
                fill="", outline=glow_color, width=1,
                tags=("card_glow",)
            )
    
    def clear_card_effects(self, canvas):
        """Clear all card animation and effect elements"""
        canvas.delete("card_flip")
        canvas.delete("card_glow")
```

---

### hand_progress.py

**Path**: `backend/ui/tableview/components/hand_progress.py`

**Size**: 3.8 KB

```python
"""
Hand Progress Indicator - Shows current street and progress through the hand
"""
from ...services.theme_manager import ThemeManager


def _tokens(canvas):
    # Prefer ThemeManager from widget tree
    w = canvas
    while w is not None:
        try:
            if hasattr(w, "services"):
                tm = w.services.get_app("theme")  # type: ignore[attr-defined]
                if isinstance(tm, ThemeManager):
                    return tm.get_theme(), tm.get_fonts()
        except Exception:
            pass
        w = getattr(w, "master", None)
    # Fallbacks
    return (
        {
            "progress.bg": "#1F2937",
            "progress.border": "#374151", 
            "progress.active": "#10B981",
            "progress.completed": "#6B7280",
            "progress.text": "#E5E7EB"
        }, 
        {"font.body": ("Arial", 10, "bold")}
    )


class HandProgress:
    def __init__(self):
        self._progress_elements = {}
    
    def render(self, state, canvas_manager, layer_manager) -> None:
        THEME, FONTS = _tokens(canvas_manager.canvas)
        c = canvas_manager.canvas
        w, h = canvas_manager.size()
        if w <= 1 or h <= 1:
            return
        
        # Clear previous elements
        for element_id in self._progress_elements.values():
            try:
                c.delete(element_id)
            except Exception:
                pass
        self._progress_elements = {}
        
        # Get current street from state
        current_street = state.get("street", "preflop").lower()
        streets = ["preflop", "flop", "turn", "river"]
        
        # Position at top of table
        start_x = w // 2 - 100
        start_y = int(h * 0.08)
        
        # Street progress indicators
        street_width = 50
        street_spacing = 10
        
        for i, street in enumerate(streets):
            x = start_x + i * (street_width + street_spacing)
            
            # Determine status
            current_index = streets.index(current_street) if current_street in streets else 0
            is_completed = i < current_index
            is_current = i == current_index
            
            # Street background
            if is_current:
                bg_color = THEME.get("progress.active", "#10B981")
            elif is_completed:
                bg_color = THEME.get("progress.completed", "#6B7280")
            else:
                bg_color = THEME.get("progress.bg", "#1F2937")
            
            self._progress_elements[f'street_bg_{i}'] = c.create_rectangle(
                x, start_y,
                x + street_width, start_y + 20,
                fill=bg_color,
                outline=THEME.get("progress.border", "#374151"),
                width=1,
                tags=("layer:progress", f"street_bg:{i}"),
            )
            
            # Street text
            text_color = "#FFFFFF" if (is_current or is_completed) else THEME.get("progress.text", "#E5E7EB")
            self._progress_elements[f'street_text_{i}'] = c.create_text(
                x + street_width//2,
                start_y + 10,
                text=street.title(),
                font=FONTS.get("font.body", ("Arial", 9, "bold")),
                fill=text_color,
                tags=("layer:progress", f"street_text:{i}"),
            )
        
        # Add street labels
        self._progress_elements['progress_label'] = c.create_text(
            start_x - 20,
            start_y + 10,
            text="Street:",
            font=FONTS.get("font.body", ("Arial", 10, "normal")),
            fill=THEME.get("progress.text", "#E5E7EB"),
            anchor="e",
            tags=("layer:progress", "progress_label"),
        )
        
        # Tag all elements
        for element_id in self._progress_elements.values():
            c.addtag_withtag("layer:progress", element_id)
```

---

### micro_interactions.py

**Path**: `backend/ui/tableview/components/micro_interactions.py`

**Size**: 11.0 KB

```python
"""
Micro-Interactions System
Subtle glows, pulses, and state transitions for premium feel
"""

import math
from ...services.theme_utils import ease_color_transition, lighten, alpha_over

class MicroInteractions:
    def __init__(self, theme_manager):
        self.theme = theme_manager
        self.active_pulses = {}
        self.active_glows = {}
        
    def pulse_seat_ring(self, canvas, seat_x, seat_y, seat_w, seat_h, duration_ms=1000):
        """Subtle pulsing ring around acting player seat"""
        tokens = self.theme.get_all_tokens()
        focus_color = tokens.get("a11y.focus", "#22C55E")
        
        pulse_id = f"seat_pulse_{seat_x}_{seat_y}"
        
        # Clear any existing pulse
        if pulse_id in self.active_pulses:
            canvas.after_cancel(self.active_pulses[pulse_id])
        
        frames = duration_ms // 50  # 20 FPS
        
        def pulse_step(frame):
            if frame >= frames:
                canvas.delete(f"pulse_{pulse_id}")
                if pulse_id in self.active_pulses:
                    del self.active_pulses[pulse_id]
                return
            
            # Calculate pulse intensity (sine wave)
            progress = (frame / frames) * 2 * math.pi
            intensity = (math.sin(progress) + 1) / 2  # 0 to 1
            
            # Clear previous pulse frame
            canvas.delete(f"pulse_{pulse_id}")
            
            # Draw pulsing ring with varying alpha
            ring_width = 2 + int(intensity * 2)  # 2-4px width
            alpha = 0.3 + (intensity * 0.4)  # 30-70% alpha
            
            # Create multiple rings for glow effect
            for i in range(3):
                offset = i * 2
                canvas.create_rectangle(
                    seat_x - seat_w//2 - offset, seat_y - seat_h//2 - offset,
                    seat_x + seat_w//2 + offset, seat_y + seat_h//2 + offset,
                    outline=focus_color, width=ring_width - i,
                    tags=(f"pulse_{pulse_id}",)
                )
            
            # Schedule next frame
            timer_id = canvas.after(50, lambda: pulse_step(frame + 1))
            self.active_pulses[pulse_id] = timer_id
        
        pulse_step(0)
    
    def flash_pot_increase(self, canvas, pot_x, pot_y, pot_w, pot_h):
        """Brief flash when pot amount increases"""
        tokens = self.theme.get_all_tokens()
        metal_color = tokens.get("table.inlay", "#C9A86A")
        flash_color = lighten(metal_color, 0.25)
        
        flash_frames = 8  # Quick flash
        
        def flash_step(frame):
            if frame >= flash_frames:
                canvas.delete("pot_flash")
                return
            
            # Fade from bright to normal
            progress = frame / flash_frames
            current_color = ease_color_transition(flash_color, metal_color, progress)
            
            # Clear previous flash
            canvas.delete("pot_flash")
            
            # Draw flash ring around pot
            canvas.create_rectangle(
                pot_x - pot_w//2 - 3, pot_y - pot_h//2 - 3,
                pot_x + pot_w//2 + 3, pot_y + pot_h//2 + 3,
                outline=current_color, width=2,
                tags=("pot_flash",)
            )
            
            canvas.after(60, lambda: flash_step(frame + 1))
        
        flash_step(0)
    
    def hover_glow(self, canvas, element_id, x, y, w, h, glow_type="soft"):
        """Add hover glow effect to UI element"""
        tokens = self.theme.get_all_tokens()
        glow_color = tokens.get(f"glow.{glow_type}", tokens.get("a11y.focus", "#22C55E"))
        
        glow_tag = f"hover_glow_{element_id}"
        
        # Clear existing glow
        canvas.delete(glow_tag)
        
        # Create soft glow with multiple rings
        for i in range(4):
            offset = (i + 1) * 2
            alpha = 1.0 - (i * 0.2)  # Fade outward
            
            canvas.create_rectangle(
                x - offset, y - offset, x + w + offset, y + h + offset,
                outline=glow_color, width=1,
                tags=(glow_tag,)
            )
    
    def remove_hover_glow(self, canvas, element_id):
        """Remove hover glow effect"""
        canvas.delete(f"hover_glow_{element_id}")
    
    def button_press_feedback(self, canvas, btn_x, btn_y, btn_w, btn_h):
        """Quick visual feedback for button press"""
        tokens = self.theme.get_all_tokens()
        active_color = tokens.get("btn.primary.activeBorder", "#FFD700")
        
        feedback_frames = 6
        
        def feedback_step(frame):
            if frame >= feedback_frames:
                canvas.delete("button_feedback")
                return
            
            # Quick expand and contract
            progress = frame / feedback_frames
            scale = 1.0 + (0.1 * math.sin(progress * math.pi))  # Slight scale pulse
            
            offset = int((scale - 1.0) * min(btn_w, btn_h) / 2)
            
            canvas.delete("button_feedback")
            canvas.create_rectangle(
                btn_x - offset, btn_y - offset,
                btn_x + btn_w + offset, btn_y + btn_h + offset,
                outline=active_color, width=2,
                tags=("button_feedback",)
            )
            
            canvas.after(30, lambda: feedback_step(frame + 1))
        
        feedback_step(0)
    
    def card_reveal_shimmer(self, canvas, card_x, card_y, card_w, card_h):
        """Subtle shimmer effect when card is revealed"""
        tokens = self.theme.get_all_tokens()
        shimmer_color = tokens.get("glow.medium", "#FFD700")
        
        shimmer_frames = 12
        
        def shimmer_step(frame):
            if frame >= shimmer_frames:
                canvas.delete("card_shimmer")
                return
            
            # Moving highlight across card
            progress = frame / shimmer_frames
            highlight_x = card_x + (progress * card_w)
            
            canvas.delete("card_shimmer")
            
            # Vertical highlight line
            canvas.create_line(
                highlight_x, card_y, highlight_x, card_y + card_h,
                fill=shimmer_color, width=2,
                tags=("card_shimmer",)
            )
            
            # Soft glow around line
            canvas.create_line(
                highlight_x - 1, card_y, highlight_x - 1, card_y + card_h,
                fill=shimmer_color, width=1,
                tags=("card_shimmer",)
            )
            canvas.create_line(
                highlight_x + 1, card_y, highlight_x + 1, card_y + card_h,
                fill=shimmer_color, width=1,
                tags=("card_shimmer",)
            )
            
            canvas.after(40, lambda: shimmer_step(frame + 1))
        
        shimmer_step(0)
    
    def dealer_button_move_trail(self, canvas, from_x, from_y, to_x, to_y):
        """Subtle trail effect when dealer button moves"""
        tokens = self.theme.get_all_tokens()
        trail_color = tokens.get("dealer.buttonBorder", "#C9A86A")
        
        trail_frames = 15
        
        def trail_step(frame):
            if frame >= trail_frames:
                canvas.delete("dealer_trail")
                return
            
            progress = frame / trail_frames
            
            # Create fading trail points
            for i in range(5):
                trail_progress = max(0, progress - (i * 0.1))
                if trail_progress <= 0:
                    continue
                
                trail_x = from_x + (to_x - from_x) * trail_progress
                trail_y = from_y + (to_y - from_y) * trail_progress
                
                # Fading circle
                alpha = (1.0 - i * 0.2) * (1.0 - progress)
                radius = 8 - i
                
                canvas.create_oval(
                    trail_x - radius, trail_y - radius,
                    trail_x + radius, trail_y + radius,
                    outline=trail_color, width=1,
                    tags=("dealer_trail",)
                )
            
            canvas.after(50, lambda: trail_step(frame + 1))
        
        trail_step(0)
    
    def winner_confetti_burst(self, canvas, center_x, center_y):
        """Celebration confetti burst for winner"""
        tokens = self.theme.get_all_tokens()
        colors = [
            tokens.get("chip.$25", "#2AA37A"),
            tokens.get("chip.$100", "#3C3A3A"),
            tokens.get("chip.$500", "#6C4AB6"),
            tokens.get("table.inlay", "#C9A86A"),
        ]
        
        # Create 20 confetti pieces
        confetti_pieces = []
        for i in range(20):
            angle = (i / 20) * 2 * math.pi
            velocity = 30 + (i % 3) * 10  # Varying speeds
            
            piece_data = {
                'x': center_x,
                'y': center_y,
                'vx': velocity * math.cos(angle),
                'vy': velocity * math.sin(angle),
                'color': colors[i % len(colors)],
                'size': 3 + (i % 2),
                'rotation': 0,
                'id': None
            }
            confetti_pieces.append(piece_data)
        
        confetti_frames = 30
        
        def confetti_step(frame):
            if frame >= confetti_frames:
                canvas.delete("confetti")
                return
            
            canvas.delete("confetti")
            
            for piece in confetti_pieces:
                # Update position
                piece['x'] += piece['vx'] * 0.8  # Slow down over time
                piece['y'] += piece['vy'] * 0.8
                piece['vy'] += 1  # Gravity
                piece['rotation'] += 10
                
                # Draw confetti piece
                size = piece['size']
                canvas.create_rectangle(
                    piece['x'] - size, piece['y'] - size,
                    piece['x'] + size, piece['y'] + size,
                    fill=piece['color'], outline="",
                    tags=("confetti",)
                )
            
            canvas.after(50, lambda: confetti_step(frame + 1))
        
        confetti_step(0)
    
    def stop_all_interactions(self):
        """Stop all active micro-interactions"""
        # Cancel all active pulses
        for pulse_id, timer_id in self.active_pulses.items():
            try:
                # Note: canvas.after_cancel would need canvas reference
                pass
            except:
                pass
        self.active_pulses.clear()
        self.active_glows.clear()
    
    def cleanup_effects(self, canvas):
        """Clean up all visual effects"""
        canvas.delete("pot_flash")
        canvas.delete("card_shimmer")
        canvas.delete("dealer_trail")
        canvas.delete("confetti")
        canvas.delete("button_feedback")
        
        # Clean up all hover glows
        for glow_id in list(self.active_glows.keys()):
            canvas.delete(f"hover_glow_{glow_id}")
        
        # Clean up all pulses
        for pulse_id in list(self.active_pulses.keys()):
            canvas.delete(f"pulse_{pulse_id}")
```

---

### player_highlighting.py

**Path**: `backend/ui/tableview/components/player_highlighting.py`

**Size**: 13.7 KB

```python
"""
Professional Player Seat Highlighting System
Implements industry-standard seat highlighting similar to PokerStars, 888poker, etc.
"""

import math
from typing import Dict, Any, List, Tuple, Optional


class PlayerHighlighting:
    """Professional-grade player seat highlighting system."""
    
    def __init__(self):
        self._highlight_elements = {}  # Store highlight elements per seat
        self._animation_state = 0  # For pulsing animations
        self._last_acting_player = None
        
    def render(self, state, canvas_manager, layer_manager) -> None:
        """Render professional seat highlighting."""
        canvas = canvas_manager.canvas
        w, h = canvas_manager.size()
        
        if w <= 1 or h <= 1:
            return
            
        # Get seats data
        seats_data = state.get("seats", [])
        if not seats_data:
            return
            
        # Get seat positions
        from ...state.selectors import get_seat_positions
        positions = get_seat_positions(state, seat_count=len(seats_data), 
                                     canvas_width=w, canvas_height=h)
        
        # Clear old highlights
        self._clear_all_highlights(canvas)
        
        # Render highlights for each seat
        for idx, (seat_data, (x, y)) in enumerate(zip(seats_data, positions)):
            self._render_seat_highlight(canvas, x, y, idx, seat_data, w, h)
            
        # Update animation state
        self._animation_state = (self._animation_state + 1) % 60
        
        # Schedule next animation frame if needed
        if any(seat.get('acting', False) for seat in seats_data):
            canvas.after(100, lambda: self._animate_highlights(canvas_manager))
    
    def _render_seat_highlight(self, canvas, x: int, y: int, idx: int, seat: Dict[str, Any], 
                              canvas_w: int, canvas_h: int) -> None:
        """Render highlighting for a single seat."""
        
        # Base seat circle - always visible for occupied seats
        if seat.get('name') or seat.get('stack', 0) > 0:
            self._render_base_seat_circle(canvas, x, y, idx, seat)
        
        # Player state highlighting
        if seat.get('acting', False):
            self._render_acting_player_highlight(canvas, x, y, idx, seat)
        elif seat.get('folded', False):
            self._render_folded_player_highlight(canvas, x, y, idx, seat)
        elif seat.get('all_in', False):
            self._render_all_in_player_highlight(canvas, x, y, idx, seat)
        elif seat.get('winner', False):
            self._render_winner_highlight(canvas, x, y, idx, seat)
        else:
            self._render_active_player_highlight(canvas, x, y, idx, seat)
            
        # Position indicator
        self._render_position_indicator(canvas, x, y, idx, seat)
        
        # Player info overlay
        self._render_player_info(canvas, x, y, idx, seat)
    
    def _render_base_seat_circle(self, canvas, x: int, y: int, idx: int, seat: Dict[str, Any]) -> None:
        """Render the base seat circle - professional style."""
        # Seat size based on canvas size
        seat_radius = 45
        
        # Base seat background - dark with subtle border
        base_circle = canvas.create_oval(
            x - seat_radius, y - seat_radius,
            x + seat_radius, y + seat_radius,
            fill="#1F2937",  # Dark gray background
            outline="#374151",  # Slightly lighter border
            width=3,
            tags=("layer:seats", f"seat_base:{idx}")
        )
        
        # Inner seat circle - slightly lighter
        inner_radius = seat_radius - 8
        inner_circle = canvas.create_oval(
            x - inner_radius, y - inner_radius,
            x + inner_radius, y + inner_radius,
            fill="#2D3748",  # Slightly lighter
            outline="",
            tags=("layer:seats", f"seat_inner:{idx}")
        )
        
        self._store_element(idx, 'base_circle', base_circle)
        self._store_element(idx, 'inner_circle', inner_circle)
    
    def _render_acting_player_highlight(self, canvas, x: int, y: int, idx: int, seat: Dict[str, Any]) -> None:
        """Render highlighting for the acting player - bright and pulsing."""
        # Pulsing outer ring - bright gold
        pulse_factor = 1.0 + 0.3 * math.sin(self._animation_state * 0.3)
        outer_radius = int(55 * pulse_factor)
        
        # Bright pulsing outer ring
        outer_ring = canvas.create_oval(
            x - outer_radius, y - outer_radius,
            x + outer_radius, y + outer_radius,
            fill="",
            outline="#FFD700",  # Bright gold
            width=5,
            tags=("layer:action", f"acting_outer:{idx}")
        )
        
        # Steady inner action ring
        action_ring = canvas.create_oval(
            x - 50, y - 50,
            x + 50, y + 50,
            fill="",
            outline="#FFA500",  # Orange
            width=3,
            tags=("layer:action", f"acting_inner:{idx}")
        )
        
        # Action indicator dot
        dot_radius = 8
        action_dot = canvas.create_oval(
            x - dot_radius, y - dot_radius,
            x + dot_radius, y + dot_radius,
            fill="#FF4444",  # Bright red
            outline="#FFFFFF",  # White outline
            width=2,
            tags=("layer:action", f"acting_dot:{idx}")
        )
        
        self._store_element(idx, 'acting_outer', outer_ring)
        self._store_element(idx, 'acting_inner', action_ring)
        self._store_element(idx, 'acting_dot', action_dot)
        
        # Action text
        self._render_action_text(canvas, x, y - 70, "YOUR TURN", "#FFD700")
    
    def _render_active_player_highlight(self, canvas, x: int, y: int, idx: int, seat: Dict[str, Any]) -> None:
        """Render highlighting for active (non-folded) players."""
        # Subtle green ring for active players
        active_ring = canvas.create_oval(
            x - 48, y - 48,
            x + 48, y + 48,
            fill="",
            outline="#10B981",  # Green
            width=2,
            tags=("layer:status", f"active_ring:{idx}")
        )
        
        self._store_element(idx, 'active_ring', active_ring)
    
    def _render_folded_player_highlight(self, canvas, x: int, y: int, idx: int, seat: Dict[str, Any]) -> None:
        """Render highlighting for folded players."""
        # Red ring for folded players
        folded_ring = canvas.create_oval(
            x - 48, y - 48,
            x + 48, y + 48,
            fill="",
            outline="#EF4444",  # Red
            width=2,
            tags=("layer:status", f"folded_ring:{idx}")
        )
        
        # Semi-transparent overlay to dim the seat
        overlay = canvas.create_oval(
            x - 45, y - 45,
            x + 45, y + 45,
            fill="#000000",
            stipple="gray50",  # Semi-transparent
            outline="",
            tags=("layer:status", f"folded_overlay:{idx}")
        )
        
        self._store_element(idx, 'folded_ring', folded_ring)
        self._store_element(idx, 'folded_overlay', overlay)
        
        # Status text
        self._render_status_text(canvas, x, y + 60, "FOLDED", "#EF4444")
    
    def _render_all_in_player_highlight(self, canvas, x: int, y: int, idx: int, seat: Dict[str, Any]) -> None:
        """Render highlighting for all-in players."""
        # Bright orange ring for all-in
        all_in_ring = canvas.create_oval(
            x - 50, y - 50,
            x + 50, y + 50,
            fill="",
            outline="#F59E0B",  # Orange
            width=4,
            tags=("layer:status", f"all_in_ring:{idx}")
        )
        
        self._store_element(idx, 'all_in_ring', all_in_ring)
        
        # Status text
        self._render_status_text(canvas, x, y + 60, "ALL IN", "#F59E0B")
    
    def _render_winner_highlight(self, canvas, x: int, y: int, idx: int, seat: Dict[str, Any]) -> None:
        """Render highlighting for winning players."""
        # Bright green celebration ring
        winner_ring = canvas.create_oval(
            x - 52, y - 52,
            x + 52, y + 52,
            fill="",
            outline="#22C55E",  # Bright green
            width=5,
            tags=("layer:status", f"winner_ring:{idx}")
        )
        
        # Inner celebration ring
        inner_winner = canvas.create_oval(
            x - 46, y - 46,
            x + 46, y + 46,
            fill="",
            outline="#16A34A",  # Darker green
            width=3,
            tags=("layer:status", f"winner_inner:{idx}")
        )
        
        self._store_element(idx, 'winner_ring', winner_ring)
        self._store_element(idx, 'winner_inner', inner_winner)
        
        # Winner text
        self._render_status_text(canvas, x, y + 60, "WINNER", "#22C55E")
    
    def _render_position_indicator(self, canvas, x: int, y: int, idx: int, seat: Dict[str, Any]) -> None:
        """Render position indicator (SB, BB, BTN, etc.)."""
        position = seat.get('position', '')
        if not position:
            return
            
        # Position badge
        badge_width = 30
        badge_height = 16
        
        # Position colors
        pos_colors = {
            'SB': '#3B82F6',  # Blue
            'BB': '#EF4444',  # Red
            'BTN': '#F59E0B', # Orange
            'CO': '#8B5CF6',  # Purple
            'MP': '#06B6D4',  # Cyan
            'UTG': '#10B981'  # Green
        }
        
        color = pos_colors.get(position, '#6B7280')  # Default gray
        
        # Badge background
        badge_bg = canvas.create_rectangle(
            x - badge_width//2, y - 25 - badge_height//2,
            x + badge_width//2, y - 25 + badge_height//2,
            fill=color,
            outline="#FFFFFF",
            width=1,
            tags=("layer:status", f"position_badge:{idx}")
        )
        
        # Badge text
        badge_text = canvas.create_text(
            x, y - 25,
            text=position,
            font=("Arial", 9, "bold"),
            fill="#FFFFFF",
            tags=("layer:status", f"position_text:{idx}")
        )
        
        self._store_element(idx, 'position_badge', badge_bg)
        self._store_element(idx, 'position_text', badge_text)
    
    def _render_player_info(self, canvas, x: int, y: int, idx: int, seat: Dict[str, Any]) -> None:
        """Render player name and stack info."""
        name = seat.get('name', f'Player {idx + 1}')
        stack = seat.get('stack', 0)
        
        # Player name
        name_text = canvas.create_text(
            x, y + 10,
            text=name,
            font=("Arial", 11, "bold"),
            fill="#F8FAFC",
            tags=("layer:seats", f"player_name:{idx}")
        )
        
        # Stack amount
        stack_text = canvas.create_text(
            x, y + 25,
            text=f"${stack:,}" if stack > 0 else "",
            font=("Arial", 9, "normal"),
            fill="#D1D5DB",
            tags=("layer:seats", f"player_stack:{idx}")
        )
        
        self._store_element(idx, 'name_text', name_text)
        self._store_element(idx, 'stack_text', stack_text)
    
    def _render_action_text(self, canvas, x: int, y: int, text: str, color: str) -> None:
        """Render action text with background."""
        # Text background
        bg_width = len(text) * 8 + 20
        bg_height = 20
        
        text_bg = canvas.create_rectangle(
            x - bg_width//2, y - bg_height//2,
            x + bg_width//2, y + bg_height//2,
            fill="#000000",
            outline=color,
            width=2,
            tags=("layer:action", "action_text_bg")
        )
        
        # Action text
        action_text = canvas.create_text(
            x, y,
            text=text,
            font=("Arial", 12, "bold"),
            fill=color,
            tags=("layer:action", "action_text")
        )
    
    def _render_status_text(self, canvas, x: int, y: int, text: str, color: str) -> None:
        """Render status text with background."""
        # Text background
        bg_width = len(text) * 7 + 16
        bg_height = 18
        
        text_bg = canvas.create_rectangle(
            x - bg_width//2, y - bg_height//2,
            x + bg_width//2, y + bg_height//2,
            fill="#1F2937",
            outline=color,
            width=1,
            tags=("layer:status", "status_text_bg")
        )
        
        # Status text
        status_text = canvas.create_text(
            x, y,
            text=text,
            font=("Arial", 10, "bold"),
            fill=color,
            tags=("layer:status", "status_text")
        )
    
    def _store_element(self, seat_idx: int, element_type: str, element_id: Any) -> None:
        """Store element ID for cleanup."""
        if seat_idx not in self._highlight_elements:
            self._highlight_elements[seat_idx] = {}
        self._highlight_elements[seat_idx][element_type] = element_id
    
    def _clear_all_highlights(self, canvas) -> None:
        """Clear all existing highlight elements."""
        for seat_elements in self._highlight_elements.values():
            for element_id in seat_elements.values():
                try:
                    canvas.delete(element_id)
                except Exception:
                    pass
        self._highlight_elements.clear()
    
    def _animate_highlights(self, canvas_manager) -> None:
        """Continue highlight animations."""
        try:
            # Trigger a re-render to update animations
            if hasattr(canvas_manager, 'parent') and hasattr(canvas_manager.parent, 'renderer_pipeline'):
                if hasattr(canvas_manager.parent, 'store'):
                    state = canvas_manager.parent.store.get_state()
                    if state:
                        canvas_manager.parent.renderer_pipeline.render_once(state)
        except Exception:
            pass  # Silently continue if animation fails
```

---

### pot_display.py

**Path**: `backend/ui/tableview/components/pot_display.py`

**Size**: 7.3 KB

```python
from ...services.theme_manager import ThemeManager
from .chip_graphics import ChipGraphics

try:
    from .premium_chips import draw_pot_chip, pulse_pot_glow
except Exception:
    def draw_pot_chip(canvas, x, y, theme, fonts, scale=1.0, tags=()):
        r = int(10*scale)
        canvas.create_oval(x-r, y-r, x+r, y+r, fill=theme.get("chip.gold","#D97706"), outline="black", width=1, tags=tags)
    def pulse_pot_glow(canvas, pot_bg_id, theme):
        # simple glow by toggling outline width
        try:
            w = int(canvas.itemcget(pot_bg_id, "width") or 2)
            canvas.itemconfig(pot_bg_id, width=(w%4)+1)
        except Exception:
            pass


def _tokens(canvas):
    # Prefer ThemeManager from widget tree
    w = canvas
    while w is not None:
        try:
            if hasattr(w, "services"):
                tm = w.services.get_app("theme")  # type: ignore[attr-defined]
                if isinstance(tm, ThemeManager):
                    return tm.get_theme(), tm.get_fonts()
        except Exception:
            pass
        w = getattr(w, "master", None)
    # Fallbacks
    return (
        {"pot.valueText": "#F8FAFC", "chip_gold": "#FFD700"}, 
        {"font.display": ("Arial", 28, "bold")}
    )


class PotDisplay:
    def __init__(self) -> None:
        self._pot_bg_id = None
        self._pot_text_id = None
        self._pot_label_id = None
        self._chip_graphics = None
        self._pot_chips = []  # Track pot chip elements

    def render(self, state, canvas_manager, layer_manager) -> None:
        THEME, FONTS = _tokens(canvas_manager.canvas)
        c = canvas_manager.canvas
        w, h = canvas_manager.size()
        if w <= 1 or h <= 1:
            return
        
        # Initialize chip graphics if needed
        if self._chip_graphics is None:
            self._chip_graphics = ChipGraphics(c)
        
        center_x, center_y = w // 2, int(h * 0.58)
        
        # Get pot amount from state - handle both formats
        pot_data = state.get("pot", {})
        if isinstance(pot_data, dict):
            amount = int(pot_data.get("amount", 0))
        else:
            amount = int(pot_data or 0)
        
        text_value = f"${amount:,}" if amount > 0 else "$0"

        # Use theme tokens (prefer badge keys; fall back to legacy)
        text_fill = THEME.get("pot.valueText", THEME.get("text.primary", "#F6EFDD"))
        bg_fill = (THEME.get("pot.badgeBg") or
                   THEME.get("pot.bg") or "#15212B")
        border_color = (THEME.get("pot.badgeRing") or
                        THEME.get("pot.border") or "#C9B47A")
        font = FONTS.get("font.display", ("Arial", 24, "bold"))
        label_font = FONTS.get("font.body", ("Arial", 12, "normal"))

        # Pot background (rounded rectangle)
        bg_width, bg_height = 120, 50
        if not self._pot_bg_id:
            self._pot_bg_id = c.create_rectangle(
                center_x - bg_width//2,
                center_y - bg_height//2,
                center_x + bg_width//2,
                center_y + bg_height//2,
                fill=bg_fill,
                outline=border_color,
                width=2,
                tags=("layer:pot", "pot_bg"),
            )
        else:
            # Update background position and colors
            c.coords(
                self._pot_bg_id,
                center_x - bg_width//2,
                center_y - bg_height//2,
                center_x + bg_width//2,
                center_y + bg_height//2
            )
            c.itemconfig(self._pot_bg_id, fill=bg_fill, outline=border_color)

        # Pot label ("POT")
        if not self._pot_label_id:
            self._pot_label_id = c.create_text(
                center_x,
                center_y - 15,
                text="POT",
                font=label_font,
                fill=THEME.get("pot.label", "#9CA3AF"),
                tags=("layer:pot", "pot_label"),
            )
        else:
            c.coords(self._pot_label_id, center_x, center_y - 15)
            c.itemconfig(self._pot_label_id, fill=THEME.get("pot.label", "#9CA3AF"))

        # Pot amount
        if not self._pot_text_id:
            self._pot_text_id = c.create_text(
                center_x,
                center_y + 5,
                text=text_value,
                font=font,
                fill=text_fill,
                tags=("layer:pot", "pot_text"),
            )
        else:
            c.coords(self._pot_text_id, center_x, center_y + 5)
            c.itemconfig(self._pot_text_id, text=text_value, fill=text_fill, font=font)
            
        # Clear old pot chips
        for chip_id in self._pot_chips:
            try:
                c.delete(chip_id)
            except Exception:
                pass
        self._pot_chips = []
        
        # Render premium pot chips if amount > 0
        if amount > 0:
            self._render_premium_pot_chips(c, center_x, center_y, amount, THEME)
        
        # Ensure proper layering
        c.addtag_withtag("layer:pot", self._pot_bg_id or "")
        c.addtag_withtag("layer:pot", self._pot_label_id or "")
        c.addtag_withtag("layer:pot", self._pot_text_id or "")
        for chip_id in self._pot_chips:
            c.addtag_withtag("layer:pot", chip_id)

    def _render_premium_pot_chips(self, canvas, center_x: int, center_y: int, 
                                  amount: int, tokens: dict) -> None:
        """Render premium pot chips in an elegant arrangement around the pot."""
        if amount <= 0:
            return
        
        # Elegant chip arrangement around the pot badge
        chip_positions = [
            (center_x - 35, center_y + 25),   # Left
            (center_x + 35, center_y + 25),   # Right  
            (center_x - 20, center_y + 40),   # Left-center
            (center_x + 20, center_y + 40),   # Right-center
            (center_x, center_y + 45),        # Center bottom
        ]
        
        # Determine number of chip positions based on pot size
        if amount < 100:
            positions = chip_positions[:1]  # Just center
        elif amount < 500:
            positions = chip_positions[:3]  # Left, right, center
        else:
            positions = chip_positions  # All positions for big pots
        
        # Draw premium pot chips at each position
        chip_r = 12  # Slightly smaller for elegant clustering
        for i, (chip_x, chip_y) in enumerate(positions):
            # Vary chip values for visual interest
            if i == 0:  # Center/first chip gets highest value
                chip_value = min(amount // 2, 1000)
            else:
                chip_value = min(amount // len(positions), 500)
            
            if chip_value > 0:
                # Add subtle breathing effect for large pots
                breathing = amount > 1000
                chip_id = draw_pot_chip(
                    canvas, chip_x, chip_y, chip_value, tokens,
                    r=chip_r, breathing=breathing,
                    tags=("layer:pot", "pot_chips", f"pot_chip_{i}")
                )
                self._pot_chips.append(chip_id)

    def pulse_pot_increase(self, center_pos: tuple) -> None:
        """Trigger a pulsing glow effect when the pot increases."""
        # Get theme tokens for glow effect
        THEME, _ = _tokens(self._canvas if hasattr(self, '_canvas') else None)
        if THEME:
            pulse_pot_glow(self._canvas, center_pos, THEME, r=20, pulses=2)


```

---

### premium_chips.py

**Path**: `backend/ui/tableview/components/premium_chips.py`

**Size**: 11.6 KB

```python
"""
Premium Casino Chip System
==========================

Theme-aware chip rendering with distinct visual types:
- Stack chips (player stacks): calm, readable, less saturated
- Bet/Call chips (flying chips): vivid with theme accent for motion tracking  
- Pot chips (pot visualization): prestigious metal-leaning design

Features:
- Consistent casino denominations with theme-tinted colors
- Radial stripe patterns for instant denomination recognition
- Hover states, glow effects, and animation support
- Automatic theme integration via token system
"""

import math
from typing import Tuple, List, Optional


# Standard casino denominations with base colors
CHIP_DENOMINATIONS = [
    (1,    "#2E86AB"),  # $1  ‚Äì blue
    (5,    "#B63D3D"),  # $5  ‚Äì red
    (25,   "#2AA37A"),  # $25 ‚Äì green
    (100,  "#3C3A3A"),  # $100 ‚Äì black/graphite
    (500,  "#6C4AB6"),  # $500 ‚Äì purple
    (1000, "#D1B46A"),  # $1k ‚Äì gold
]


def get_denom_color(amount: int) -> str:
    """Get the base color for a chip denomination."""
    for denom, color in CHIP_DENOMINATIONS:
        if amount <= denom:
            return color
    return CHIP_DENOMINATIONS[-1][1]  # Default to highest denom color


def draw_chip_base(canvas, x: int, y: int, r: int, face: str, edge: str, rim: str, 
                   denom_color: str, text: str, text_color: str, tags: tuple = ()) -> int:
    """
    Draw the base chip structure with radial stripes and denomination text.
    
    Args:
        canvas: Tkinter canvas widget
        x, y: Center coordinates
        r: Chip radius
        face: Base face color
        edge: Outer edge color  
        rim: Inner ring color
        denom_color: Denomination stripe color
        text: Text to display (e.g., "$25")
        text_color: Text color
        tags: Canvas tags for the chip elements
        
    Returns:
        Canvas item ID of the main chip disc
    """
    # Main chip disc
    chip_id = canvas.create_oval(
        x - r, y - r, x + r, y + r,
        fill=face, outline=edge, width=2,
        tags=tags
    )
    
    # Radial stripes (8 wedges) for denomination recognition
    for i in range(8):
        angle_start = i * 45  # 360/8 = 45 degrees per stripe
        angle_extent = 15     # Width of each stripe
        canvas.create_arc(
            x - r + 3, y - r + 3, x + r - 3, y + r - 3,
            start=angle_start, extent=angle_extent,
            outline="", fill=denom_color, width=0,
            tags=tags
        )
    
    # Inner ring for premium look
    inner_r = int(r * 0.70)
    canvas.create_oval(
        x - inner_r, y - inner_r, x + inner_r, y + inner_r,
        outline=rim, fill="", width=2,
        tags=tags
    )
    
    # Denomination text
    font_size = max(8, int(r * 0.4))  # Scale text with chip size
    canvas.create_text(
        x, y, text=text, fill=text_color,
        font=("Inter", font_size, "bold"),
        tags=tags
    )
    
    return chip_id


def draw_stack_chip(canvas, x: int, y: int, amount: int, tokens: dict, 
                    r: int = 14, tags: tuple = ()) -> int:
    """
    Draw a single stack chip (calm, readable design for player stacks).
    
    Args:
        canvas: Tkinter canvas widget
        x, y: Center coordinates
        amount: Dollar amount for denomination
        tokens: Theme token dictionary
        r: Chip radius
        tags: Canvas tags
        
    Returns:
        Canvas item ID of the chip
    """
    denom_color = get_denom_color(amount)
    return draw_chip_base(
        canvas, x, y, r,
        face=tokens.get("chip.stack.face", "#4A4A4A"),
        edge=tokens.get("chip.stack.edge", "#666666"), 
        rim=tokens.get("chip.stack.rim", "#888888"),
        denom_color=denom_color,
        text=f"${amount}",
        text_color=tokens.get("chip.stack.text", "#F8F7F4"),
        tags=tags
    )


def draw_bet_chip(canvas, x: int, y: int, amount: int, tokens: dict,
                  r: int = 14, hovering: bool = False, tags: tuple = ()) -> int:
    """
    Draw a bet/call chip (vivid design with theme accent for motion tracking).
    
    Args:
        canvas: Tkinter canvas widget
        x, y: Center coordinates
        amount: Dollar amount for denomination
        tokens: Theme token dictionary
        r: Chip radius
        hovering: Whether to show hover glow effect
        tags: Canvas tags
        
    Returns:
        Canvas item ID of the chip
    """
    denom_color = get_denom_color(amount)
    chip_id = draw_chip_base(
        canvas, x, y, r,
        face=tokens.get("chip.bet.face", "#6B4AB6"),
        edge=tokens.get("chip.bet.edge", "#8A6BC8"),
        rim=tokens.get("chip.bet.rim", "#A888CC"),
        denom_color=denom_color,
        text=f"${amount}",
        text_color=tokens.get("chip.bet.text", "#F8F7F4"),
        tags=tags
    )
    
    # Optional hover glow
    if hovering:
        glow_color = tokens.get("chip.bet.glow", "#A888CC")
        canvas.create_oval(
            x - r - 4, y - r - 4, x + r + 4, y + r + 4,
            outline=glow_color, fill="", width=2,
            tags=tags + ("glow",)
        )
    
    return chip_id


def draw_pot_chip(canvas, x: int, y: int, amount: int, tokens: dict,
                  r: int = 16, breathing: bool = False, tags: tuple = ()) -> int:
    """
    Draw a pot chip (prestigious metal-leaning design).
    
    Args:
        canvas: Tkinter canvas widget
        x, y: Center coordinates  
        amount: Dollar amount for denomination
        tokens: Theme token dictionary
        r: Chip radius (slightly larger than other chips)
        breathing: Whether to show breathing glow effect
        tags: Canvas tags
        
    Returns:
        Canvas item ID of the chip
    """
    denom_color = get_denom_color(amount)
    chip_id = draw_chip_base(
        canvas, x, y, r,
        face=tokens.get("chip.pot.face", "#D1B46A"),
        edge=tokens.get("chip.pot.edge", "#B8A157"),
        rim=tokens.get("chip.pot.rim", "#E6D078"),
        denom_color=denom_color,
        text=f"${amount}",
        text_color=tokens.get("chip.pot.text", "#0B0B0E"),
        tags=tags
    )
    
    # Optional breathing glow for pot increases
    if breathing:
        glow_color = tokens.get("chip.pot.glow", "#E6D078")
        canvas.create_oval(
            x - r - 5, y - r - 5, x + r + 5, y + r + 5,
            outline=glow_color, fill="", width=2,
            tags=tags + ("glow",)
        )
    
    return chip_id


def draw_chip_stack(canvas, x: int, y: int, total_amount: int, tokens: dict,
                    r: int = 14, max_height: int = 15, tags: tuple = ()) -> List[int]:
    """
    Draw a stack of chips representing a player's total amount.
    
    Args:
        canvas: Tkinter canvas widget
        x, y: Base center coordinates (bottom of stack)
        total_amount: Total dollar amount to represent
        tokens: Theme token dictionary
        r: Chip radius
        max_height: Maximum number of chips to show (for UI space)
        tags: Canvas tags
        
    Returns:
        List of canvas item IDs for all chips in the stack
    """
    if total_amount <= 0:
        return []
    
    # Break down amount into chip denominations (largest first)
    chip_plan = []
    remaining = total_amount
    
    for denom, _ in reversed(CHIP_DENOMINATIONS):
        if remaining >= denom:
            count = min(remaining // denom, max_height - len(chip_plan))
            chip_plan.extend([denom] * count)
            remaining -= denom * count
            
        if len(chip_plan) >= max_height:
            break
    
    # If we still have remaining amount and space, add smaller denominations
    if remaining > 0 and len(chip_plan) < max_height:
        # Fill remaining space with $1 chips
        remaining_space = max_height - len(chip_plan)
        chip_plan.extend([1] * min(remaining_space, remaining))
    
    # Draw soft shadow
    shadow_color = tokens.get("chip.stack.shadow", "#000000")
    canvas.create_oval(
        x - r - 4, y + 3, x + r + 4, y + 11,
        fill=shadow_color, outline="",
        tags=tags + ("shadow",)
    )
    
    # Draw chips from bottom to top
    chip_ids = []
    chip_spacing = 6  # Vertical spacing between chips
    
    for i, denom in enumerate(chip_plan):
        chip_y = y - (i * chip_spacing)
        chip_id = draw_stack_chip(
            canvas, x, chip_y, denom, tokens, r=r,
            tags=tags + (f"stack_chip_{i}",)
        )
        chip_ids.append(chip_id)
    
    return chip_ids


def animate_chip_bet(canvas, start_pos: Tuple[int, int], end_pos: Tuple[int, int],
                     amount: int, tokens: dict, r: int = 14, frames: int = 20,
                     callback: Optional[callable] = None) -> None:
    """
    Animate a chip flying from start to end position (bet ‚Üí pot).
    
    Args:
        canvas: Tkinter canvas widget
        start_pos: (x, y) starting coordinates
        end_pos: (x, y) ending coordinates
        amount: Dollar amount for the chip
        tokens: Theme token dictionary
        r: Chip radius
        frames: Number of animation frames
        callback: Optional function to call when animation completes
    """
    x0, y0 = start_pos
    x1, y1 = end_pos
    glow_color = tokens.get("chip.bet.glow", "#A888CC")
    
    def animate_frame(frame: int):
        if frame >= frames:
            if callback:
                callback()
            return
        
        # Cubic easing for smooth motion
        t = frame / frames
        ease_t = t * t * (3 - 2 * t)
        
        # Position with arc (parabolic path)
        x = x0 + (x1 - x0) * ease_t
        y = y0 + (y1 - y0) * ease_t - 20 * math.sin(math.pi * ease_t)
        
        # Clear previous frame
        canvas.delete("flying_chip")
        
        # Draw chip at current position
        draw_bet_chip(
            canvas, int(x), int(y), amount, tokens, r=r, hovering=True,
            tags=("flying_chip",)
        )
        
        # Schedule next frame
        canvas.after(50, lambda: animate_frame(frame + 1))
    
    # Start animation
    animate_frame(0)


def pulse_pot_glow(canvas, center_pos: Tuple[int, int], tokens: dict,
                   r: int = 18, pulses: int = 3) -> None:
    """
    Create a pulsing glow effect at the pot center when pot increases.
    
    Args:
        canvas: Tkinter canvas widget
        center_pos: (x, y) center coordinates
        tokens: Theme token dictionary
        r: Base radius for the pulse
        pulses: Number of pulse cycles
    """
    x, y = center_pos
    glow_color = tokens.get("chip.pot.glow", "#E6D078")
    
    pulse_sequence = [0.0, 0.4, 0.8, 1.0, 0.8, 0.4, 0.0]
    
    def animate_pulse(pulse_num: int, frame: int):
        if pulse_num >= pulses:
            canvas.delete("pot_pulse")
            return
            
        if frame >= len(pulse_sequence):
            # Move to next pulse
            canvas.after(100, lambda: animate_pulse(pulse_num + 1, 0))
            return
        
        # Clear previous pulse
        canvas.delete("pot_pulse")
        
        # Draw current pulse ring
        intensity = pulse_sequence[frame]
        pulse_r = r + int(8 * intensity)
        alpha_val = int(255 * (0.6 - 0.4 * intensity))  # Fade as it expands
        
        canvas.create_oval(
            x - pulse_r, y - pulse_r, x + pulse_r, y + pulse_r,
            outline=glow_color, fill="", width=max(1, int(3 * (1 - intensity))),
            tags=("pot_pulse",)
        )
        
        # Schedule next frame
        canvas.after(80, lambda: animate_pulse(pulse_num, frame + 1))
    
    # Start pulsing
    animate_pulse(0, 0)


def clear_chip_animations(canvas) -> None:
    """Clear all chip animation elements from the canvas."""
    canvas.delete("flying_chip")
    canvas.delete("pot_pulse")
    canvas.delete("glow")
```

---

### seats.py

**Path**: `backend/ui/tableview/components/seats.py`

**Size**: 11.8 KB

```python
"""
Player Seats Component
Renders player seats, hole cards, and stack information on the poker table.
"""

import math
from typing import List, Dict, Any, Optional
from .sizing_utils import create_sizing_system

# Fallback chip graphics if premium_chips module is not available
try:
    from .premium_chips import draw_chip_stack
except Exception:
    def draw_chip_stack(canvas, x, y, denom_key="chip.gold", text="", r=14, tags=None):
        fill = "#D97706"  # goldish
        canvas.create_oval(x-r, y-r, x+r, y+r, fill=fill, outline="black", width=1, tags=tags or ())

# Fallback theme if theme manager is not available
THEME = {
    "seat.bg": "#1F2937",
    "seat.border": "#6B7280",
    "card.faceFg": "#F8FAFC",
    "card.border": "#0B1220",
    "card.back.bg": "#8B0000",
    "card.back.border": "#2F4F4F",
    "card.back.pattern": "#AA0000",
    "stack.bg": "#10B981",
    "stack.border": "#059669",
}

# Fallback fonts
FONTS = {
    "font.body": ("Arial", 12, "bold"),
    "font.small": ("Arial", 10, "bold"),
}


class Seats:
    """Renders player seats, hole cards, and stack information."""
    
    def __init__(self):
        self.sizing_system = None
        self._stack_chips = {}
        self._blind_elements = {}
    
    def render(self, state, canvas_manager, layer_manager) -> None:
        """Render all player seats on the table."""
        # Get canvas and dimensions
        canvas = canvas_manager.canvas
        w, h = canvas_manager.size()
        
        if w <= 1 or h <= 1:
            return
        
        # Get seats data from state
        seats_data = state.get("seats", [])
        if not seats_data:
            return
        
        # Initialize sizing system if not already done
        if not self.sizing_system:
            num_players = len(seats_data)
            self.sizing_system = create_sizing_system(w, h, num_players)
        
        # Get card size from sizing system
        card_width, card_height = self.sizing_system.get_card_size()
        
        # Use consistent seat positions from geometry helper
        from ...state.selectors import get_seat_positions
        seat_positions = get_seat_positions(state, seat_count=len(seats_data), 
                                          canvas_width=w, canvas_height=h)
        
        print(f"ü™ë Seats rendering: {len(seats_data)} seats, canvas: {w}x{h}")
        print(f"ü™ë Using consistent seat positions from geometry helper")
        
        for idx, (x, y) in enumerate(seat_positions):
            print(f"ü™ë Seat {idx} position: ({x}, {y}) - within canvas bounds: {0 <= x <= w and 0 <= y <= h}")
        
        # Check if any seats are outside canvas bounds
        seats_outside = [(i, x, y) for i, (x, y) in enumerate(seat_positions) if not (0 <= x <= w and 0 <= y <= h)]
        if seats_outside:
            print(f"‚ö†Ô∏è Warning: {len(seats_outside)} seats are outside canvas bounds:")
            for i, x, y in seats_outside:
                print(f"   Seat {i}: ({x}, {y}) - canvas size: {w}x{h}")
        
        # Render each seat
        for idx, seat in enumerate(seats_data):
            x, y = seat_positions[idx]
            
            print(f"ü™ë Rendering seat {idx}: {seat.get('name', 'Unknown')} at ({x}, {y})")
            print(f"   Cards: {seat.get('cards', [])}")
            print(f"   Stack: {seat.get('stack', 0)}")
            print(f"   Position: {seat.get('position', '')}")
            
            # Render seat background
            self._render_seat_background(canvas, x, y, idx, seat)
            
            # Render player name
            self._render_player_name(canvas, x, y, idx, seat)
            
            # Render hole cards
            if seat.get('cards'):
                self._render_hole_cards(canvas, x, y, idx, seat, card_width, card_height)
            
            # Render player stack chips
            if seat.get('stack', 0) > 0:
                self._render_stack_chips(canvas, x, y, idx, seat)
            
            # Draw SB/BB indicators if applicable
            position = seat.get('position', '')
            if position in ['SB', 'BB']:
                self._draw_blind_indicator(canvas, x, y, position, seat, idx)
        
        print(f"ü™ë Calculated positions for {len(seats_data)} seats on {w}x{h} canvas")
        print(f"ü™ë Seat positions: {seat_positions}")
    
    def _render_seat_background(self, canvas, x: int, y: int, idx: int, seat: dict):
        """Render seat background circle."""
        # Get seat size from sizing system
        seat_size = self.sizing_system.get_chip_size('stack') * 2  # Seat is 2x stack chip size
        
        # Create seat background
        seat_bg = canvas.create_oval(
            x - seat_size, y - seat_size,
            x + seat_size, y + seat_size,
            fill=THEME.get("seat.bg", "#1F2937"),
            outline=THEME.get("seat.border", "#6B7280"),
            width=2,
            tags=("layer:seats", f"seat_bg:{idx}")
        )
        
        # Add seat number label
        label_y = y + seat_size + 15
        seat_label = canvas.create_text(
            x, label_y,
            text=f"Seat {idx + 1}",
            font=FONTS.get("font.small", ("Arial", 10, "bold")),
            fill="#FFFFFF",
            tags=("layer:seats", f"seat_label:{idx}"),
        )
    
    def _render_player_name(self, canvas, x: int, y: int, idx: int, seat: dict):
        """Render player name above the seat."""
        # Get text size from sizing system
        name_size = self.sizing_system.get_text_size('player_name')
        
        # Position name above seat
        name_y = y - 40
        
        name_text = canvas.create_text(
            x, name_y,
            text=seat.get('name', f'Player{idx + 1}'),
            font=("Arial", name_size, "bold"),
            fill="#FFFFFF",
            tags=("layer:seats", f"player_name:{idx}")
        )
    
    def _render_hole_cards(self, canvas, x: int, y: int, idx: int, seat: dict, 
                          card_width: int, card_height: int):
        """Render player's hole cards."""
        cards = seat.get('cards', [])
        if not cards:
            return
        
        # Get text sizes from sizing system
        rank_size = self.sizing_system.get_text_size('card_rank')
        suit_size = self.sizing_system.get_text_size('card_suit')
        
        # Calculate card positions (side by side)
        card_spacing = self.sizing_system.get_spacing('card_gap')
        total_width = len(cards) * card_width + (len(cards) - 1) * card_spacing
        start_x = x - total_width // 2
        
        print(f"üÉè Rendering {len(cards)} hole cards for seat {idx} at position ({x}, {y})")
        
        for i, card in enumerate(cards):
            card_x = start_x + i * (card_width + card_spacing) + card_width // 2
            card_y = y + 35  # Further below the seat for better visibility
            
            # Create card background
            card_bg = canvas.create_rectangle(
                card_x - card_width // 2, card_y - card_height // 2,
                card_x + card_width // 2, card_y + card_height // 2,
                fill=THEME.get("card.faceFg", "#F8FAFC"),
                outline=THEME.get("card.border", "#0B1220"),
                width=2,
                tags=("layer:hole_cards", f"hole_card:{idx}:{i}")
            )
            
            # Parse card
            if len(card) >= 2:
                rank = card[0]
                suit = card[1]
                
                # Render rank
                rank_text = canvas.create_text(
                    card_x, card_y - card_height // 4,
                    text=rank,
                    font=("Arial", rank_size, "bold"),
                    fill="#000000",
                    tags=("layer:hole_cards", f"hole_card:{idx}:{i}", "card_rank")
                )
                
                # Render suit
                suit_text = canvas.create_text(
                    card_x, card_y + card_height // 4,
                    text=suit,
                    font=("Arial", suit_size, "bold"),
                    fill=self._get_suit_color(suit),
                    tags=("layer:hole_cards", f"hole_card:{idx}:{i}", "card_suit")
                )
        
        print(f"üÉè Rendering cards for seat {idx}: {cards}, size: {card_width}x{card_height}, players: {self.sizing_system.num_players}")
    
    def _render_stack_chips(self, canvas, x: int, y: int, idx: int, seat: dict):
        """Render player's stack chips."""
        stack_amount = seat.get('stack', 0)
        if stack_amount <= 0:
            return
        
        # Get chip size from sizing system
        chip_size = self.sizing_system.get_chip_size('stack')
        
        # Position stack below the seat
        stack_x = x
        stack_y = y + 50
        
        # Create stack background
        stack_bg = canvas.create_oval(
            stack_x - chip_size, stack_y - chip_size,
            stack_x + chip_size, stack_y + chip_size,
            fill=THEME.get("stack.bg", "#10B981"),
            outline=THEME.get("stack.border", "#059669"),
            width=2,
            tags=("layer:stacks", f"stack_bg:{idx}")
        )
        
        # Create stack amount text
        stack_text_size = self.sizing_system.get_text_size('stack_amount')
        stack_text = canvas.create_text(
            stack_x, stack_y,
            text=f"${stack_amount}",
            font=("Arial", stack_text_size, "bold"),
            fill="#FFFFFF",
            tags=("layer:stacks", f"stack_text:{idx}")
        )
        
        # Store for cleanup
        self._stack_chips[idx] = [stack_bg, stack_text]
    
    def _draw_blind_indicator(self, canvas, x: int, y: int, position: str, seat: dict, idx: int):
        """Draw small blind or big blind indicator with chip graphics."""
        # Get chip size from sizing system
        chip_size = self.sizing_system.get_chip_size('bet')
        
        # Position blind indicator above the seat
        blind_x = x
        blind_y = y - 60
        
        # Get blind amount
        if position == 'SB':
            amount = seat.get('small_blind', 5)  # Default small blind
            color = "#F59E0B"  # Orange for small blind
            label = "SB"
        else:  # BB
            amount = seat.get('big_blind', 10)  # Default big blind
            color = "#EF4444"  # Red for big blind
            label = "BB"
        
        # Create blind chip background
        chip_bg = canvas.create_oval(
            blind_x - chip_size, blind_y - chip_size,
            blind_x + chip_size, blind_y + chip_size,
            fill=color,
            outline="#FFFFFF",
            width=2,
            tags=("layer:blinds", f"blind_chip:{idx}")
        )
        
        # Create blind amount text
        amount_text_size = self.sizing_system.get_text_size('blind_label')
        amount_text = canvas.create_text(
            blind_x, blind_y,
            text=f"${amount}",
            font=("Arial", amount_text_size, "bold"),
            fill="#FFFFFF",
            tags=("layer:blinds", f"blind_amount:{idx}")
        )
        
        # Create blind label (SB/BB)
        label_y = blind_y - chip_size - 10
        label_text = canvas.create_text(
            blind_x, label_y,
            text=label,
            font=("Arial", amount_text_size, "bold"),
            fill=color,
            tags=("layer:blinds", f"blind_label:{idx}")
        )
        
        # Store for cleanup
        if idx not in self._blind_elements:
            self._blind_elements[idx] = {}
        self._blind_elements[idx].update({
            'chip_bg': chip_bg,
            'amount_text': amount_text,
            'label_text': label_text
        })
    
    def _get_suit_color(self, suit: str) -> str:
        """Get color for card suit."""
        if suit in ['‚ô•', '‚ô¶']:
            return "#FF0000"  # Red for hearts and diamonds
        else:
            return "#000000"  # Black for clubs and spades
```

---

### sizing_utils.py

**Path**: `backend/ui/tableview/components/sizing_utils.py`

**Size**: 6.7 KB

```python
"""
Centralized Sizing System for Poker Table Elements
==================================================

Provides proportional sizing for all poker table elements based on:
- Number of players (2-3, 4-6, 7-9)
- Table dimensions (width/height)
- Element type (cards, chips, text, etc.)

Sizing Guidelines:
- 2-3 players: 6% of table size for cards
- 4-6 players: 5% of table size for cards  
- 7-9 players: 4% of table size for cards

Element Proportions:
- Pot chips: 50% of card size
- Player stack chips: 30% of card size
- Bet/call chips: 30% of card size
- Animation chips: 30% for bet->pot, 40% for pot->winner
- Text: Proportional to card size
- Spacing: Proportional to card size
"""

import math
from typing import Tuple, Dict, Any


class PokerTableSizing:
    """Centralized sizing system for poker table elements."""
    
    def __init__(self, table_width: int, table_height: int, num_players: int):
        """
        Initialize sizing system.
        
        Args:
            table_width: Table width in pixels
            table_height: Table height in pixels
            num_players: Number of players at the table
        """
        self.table_width = table_width
        self.table_height = table_height
        self.num_players = num_players
        
        # Calculate base card size based on player count
        self.card_size = self._calculate_card_size()
        
        # Calculate all other element sizes
        self._calculate_element_sizes()
    
    def _calculate_card_size(self) -> Tuple[int, int]:
        """Calculate card size based on player count and table dimensions."""
        # Use smaller dimension for proportional scaling
        table_size = min(self.table_width, self.table_height)
        
        # Determine card scale based on player count
        if self.num_players <= 3:
            card_scale = 0.06  # 6% for 2-3 players
        elif self.num_players <= 6:
            card_scale = 0.05  # 5% for 4-6 players
        else:
            card_scale = 0.04  # 4% for 7-9 players
        
        # Calculate card dimensions (maintain 2:3 aspect ratio)
        # Remove the 0.7 multiplier to get exact percentage of table size
        card_width = int(table_size * card_scale)          # Exact percentage of table size
        card_height = int(card_width * 1.5)                # Height ratio (2:3 aspect)
        
        # Ensure minimum sizes for readability
        card_width = max(40, card_width)                   # Increased minimum
        card_height = max(60, card_height)                 # Increased minimum
        
        return card_width, card_height
    
    def _calculate_element_sizes(self):
        """Calculate sizes for all poker table elements."""
        card_w, card_h = self.card_size
        
        # Chip sizes (based on card size)
        self.chip_sizes = {
            'pot': int(min(card_w, card_h) * 0.5),      # 50% of card size
            'stack': int(min(card_w, card_h) * 0.3),    # 30% of card size
            'bet': int(min(card_w, card_h) * 0.3),      # 30% of card size
            'animation_bet': int(min(card_w, card_h) * 0.3),  # 30% for bet->pot
            'animation_pot': int(min(card_w, card_h) * 0.4),  # 40% for pot->winner
        }
        
        # Text sizes (proportional to card size)
        self.text_sizes = {
            'card_rank': int(min(card_w, card_h) * 0.6),      # 60% of card size
            'card_suit': int(min(card_w, card_h) * 0.4),      # 40% of card size
            'bet_amount': int(min(card_w, card_h) * 0.5),     # 50% of card size
            'stack_amount': int(min(card_w, card_h) * 0.4),   # 40% of card size
            'player_name': int(min(card_w, card_h) * 0.35),   # 35% of card size
            'action_label': int(min(card_w, card_h) * 0.3),   # 30% of card size
            'blind_label': int(min(card_w, card_h) * 0.25),   # 25% of card size
        }
        
        # Spacing sizes (proportional to card size)
        self.spacing = {
            'card_gap': max(4, card_w // 8),           # Between community cards
            'seat_gap': max(8, card_w // 6),           # Between seats
            'chip_stack_gap': max(3, card_w // 12),    # Between stacked chips
            'text_margin': max(2, card_w // 16),       # Text margins
            'element_padding': max(4, card_w // 10),   # Element padding
        }
        
        # Animation timing (proportional to table size)
        table_size = min(self.table_width, self.table_height)
        self.animation_timing = {
            'frame_delay': max(40, table_size // 40),  # Animation frame delay (ms)
            'total_frames': max(20, table_size // 50), # Total animation frames
        }
    
    def get_card_size(self) -> Tuple[int, int]:
        """Get the calculated card size."""
        return self.card_size
    
    def get_chip_size(self, chip_type: str) -> int:
        """Get chip size for specific type."""
        return self.chip_sizes.get(chip_type, self.chip_sizes['bet'])
    
    def get_text_size(self, text_type: str) -> int:
        """Get text size for specific type."""
        return self.text_sizes.get(text_type, self.text_sizes['action_label'])
    
    def get_spacing(self, spacing_type: str) -> int:
        """Get spacing for specific type."""
        return self.spacing.get(spacing_type, self.spacing['element_padding'])
    
    def get_animation_timing(self, timing_type: str) -> int:
        """Get animation timing for specific type."""
        return self.animation_timing.get(timing_type, self.animation_timing['frame_delay'])
    
    def get_all_sizes(self) -> Dict[str, Any]:
        """Get all calculated sizes for debugging."""
        return {
            'card_size': self.card_size,
            'chip_sizes': self.chip_sizes,
            'text_sizes': self.text_sizes,
            'spacing': self.spacing,
            'animation_timing': self.animation_timing,
            'table_dimensions': (self.table_width, self.table_height),
            'num_players': self.num_players,
        }
    
    def print_sizing_info(self):
        """Print sizing information for debugging."""
        print(f"üéØ Poker Table Sizing System:")
        print(f"   Table: {self.table_width}x{self.table_height}")
        print(f"   Players: {self.num_players}")
        print(f"   Card size: {self.card_size[0]}x{self.card_size[1]}")
        print(f"   Chip sizes: {self.chip_sizes}")
        print(f"   Text sizes: {self.text_sizes}")
        print(f"   Spacing: {self.spacing}")
        print(f"   Animation timing: {self.animation_timing}")


def create_sizing_system(table_width: int, table_height: int, num_players: int) -> PokerTableSizing:
    """Factory function to create a sizing system."""
    return PokerTableSizing(table_width, table_height, num_players)
```

---

### table_center.py

**Path**: `backend/ui/tableview/components/table_center.py`

**Size**: 4.8 KB

```python
"""
Table Center Pattern Component
Renders subtle ellipse and micro-mosaic pattern at the center of the poker table
"""

import math

class TableCenter:
    def __init__(self, theme_manager):
        self.theme = theme_manager
        
    def render(self, canvas, state):
        """Render table center pattern with subtle ellipse and micro-mosaic"""
        w = canvas.winfo_width()
        h = canvas.winfo_height()
        
        if w <= 1 or h <= 1:
            return
            
        # Clear previous center elements
        canvas.delete("felt:center")
        
        # Get theme tokens
        tokens = self.theme.get_all_tokens()
        
        cx, cy = w // 2, h // 2
        
        # Main ellipse pattern (6% lighter than felt)
        ellipse_color = tokens.get("table.centerPattern", tokens.get("table.felt", "#1E4D2B"))
        
        # Subtle ellipse at center
        ellipse_w = min(w * 0.3, 210)
        ellipse_h = min(h * 0.15, 90)
        
        canvas.create_oval(
            cx - ellipse_w, cy - ellipse_h,
            cx + ellipse_w, cy + ellipse_h,
            fill=ellipse_color, outline="",
            tags=("felt:center", "table_pattern")
        )
        
        # Micro-mosaic pattern (thin arc strokes in metal at low alpha)
        inlay_color = tokens.get("table.inlay", "#C9A86A")
        
        # Create concentric arcs for mosaic effect
        base_radius = min(w, h) * 0.08  # Scale with table size
        
        for i, r_factor in enumerate([0.8, 1.0, 1.2]):
            r = int(base_radius * r_factor)
            
            # Create subtle arc pattern
            self._draw_mosaic_arc(canvas, cx, cy, r, inlay_color, i)
            
        # Optional: Add subtle radial lines
        if w > 800:  # Only on larger tables
            self._draw_radial_lines(canvas, cx, cy, base_radius, inlay_color)
    
    def _draw_mosaic_arc(self, canvas, cx, cy, radius, color, offset):
        """Draw a single mosaic arc with stipple pattern"""
        # Horizontal ellipse
        canvas.create_oval(
            cx - (radius * 2), cy - radius,
            cx + (radius * 2), cy + radius,
            outline=color, width=1, stipple="gray25",
            tags=("felt:center", "mosaic_arc")
        )
        
        # Add subtle cross-hatching for texture
        if offset % 2 == 0:
            # Vertical accent lines
            for angle in [30, 60, 120, 150]:
                x_offset = int(radius * 0.7 * math.cos(math.radians(angle)))
                y_offset = int(radius * 0.4 * math.sin(math.radians(angle)))
                
                canvas.create_line(
                    cx + x_offset - 5, cy + y_offset - 5,
                    cx + x_offset + 5, cy + y_offset + 5,
                    fill=color, width=1, stipple="gray12",
                    tags=("felt:center", "texture_line")
                )
    
    def _draw_radial_lines(self, canvas, cx, cy, base_radius, color):
        """Draw subtle radial lines for enhanced texture"""
        line_length = base_radius * 0.6
        
        # 8 radial lines at 45-degree intervals
        for angle in range(0, 360, 45):
            rad = math.radians(angle)
            
            # Inner point
            x1 = cx + int((base_radius * 0.3) * math.cos(rad))
            y1 = cy + int((base_radius * 0.3) * math.sin(rad))
            
            # Outer point
            x2 = cx + int((base_radius * 0.9) * math.cos(rad))
            y2 = cy + int((base_radius * 0.9) * math.sin(rad))
            
            canvas.create_line(
                x1, y1, x2, y2,
                fill=color, width=1, stipple="gray6",
                tags=("felt:center", "radial_line")
            )
    
    def animate_pulse(self, canvas):
        """Subtle pulse animation for dramatic moments"""
        tokens = self.theme.get_all_tokens()
        glow_color = tokens.get("glow.soft", tokens.get("table.inlay", "#C9A86A"))
        
        w, h = canvas.winfo_width(), canvas.winfo_height()
        cx, cy = w // 2, h // 2
        
        # Create expanding glow ring
        def pulse_step(radius, alpha_step):
            if alpha_step <= 0:
                canvas.delete("center_pulse")
                return
                
            # Calculate alpha for fade effect
            alpha = alpha_step / 10.0
            
            # Create glow ring
            canvas.create_oval(
                cx - radius, cy - radius//2,
                cx + radius, cy + radius//2,
                outline=glow_color, width=2,
                tags=("center_pulse",)
            )
            
            # Schedule next step
            canvas.after(50, lambda: pulse_step(radius + 5, alpha_step - 1))
        
        pulse_step(50, 10)
    
    def clear(self, canvas):
        """Clear all center pattern elements"""
        canvas.delete("felt:center")
        canvas.delete("center_pulse")
```

---

### table_felt.py

**Path**: `backend/ui/tableview/components/table_felt.py`

**Size**: 5.8 KB

```python
from ...services.theme_manager import ThemeManager


class TableFelt:
    def render(self, state, canvas_manager, layer_manager) -> None:
        # Persisted theme via ThemeManager
        # Note: We locate the theme service via the parent Frame stored on canvas
        # Find ThemeManager by walking up the widget tree
        theme_service = None
        w = canvas_manager.canvas
        while w is not None and theme_service is None:
            try:
                if hasattr(w, "services"):
                    theme_service = w.services.get_app("theme")  # type: ignore[attr-defined]
                    break
            except Exception:
                pass
            w = getattr(w, "master", None)
        if isinstance(theme_service, ThemeManager):
            THEME = theme_service.get_theme()
        else:
            THEME = {"table.felt": "#2B2F36", "table_rail": None}
        c = canvas_manager.canvas
        if c is None:
            return
        w, h = canvas_manager.size()
        
        # Validate dimensions; skip if not ready to avoid small remnants
        if w <= 100 or h <= 100:
            print(f"‚ö†Ô∏è TableFelt: Skipping render - invalid size {w}x{h}")
            return
            
        felt_color = THEME.get("table.felt", THEME.get("table_felt", "#1B4D3A"))
        rail_color = THEME.get("table.rail", THEME.get("table_rail", "#2E4F76"))
        edge_glow = THEME.get("table.edgeGlow", "#0B2F24")
        inlay_color = THEME.get("table.inlay", "#C6A664")
        
        print(f"üé® Professional TableFelt rendering: {w}x{h}, felt: {felt_color}, rail: {rail_color}")
        
        # === CLEAR OLD LAYERS TO PREVENT COLOR CARRY-OVER ===
        c.delete("layer:felt")
        c.delete("canvas_bg")
        c.delete("table_rail")
        c.delete("rail_accent")
        c.delete("felt_surface")
        c.delete("center_highlight")
        c.delete("edge_glow")
        
        # === PROFESSIONAL OVAL POKER TABLE (MATCHING OLD UI SCREENSHOT) ===
        
        # Get additional theme colors for professional look
        rail_highlight = THEME.get("table.railHighlight", "#DAA520")  # Gold accents
        center_color = THEME.get("table.center", "#154035")  # Center highlight
        
        # Table center and sizing for oval shape
        cx, cy = w//2, h//2
        
        # 1. Background canvas (very dark)  
        c.create_rectangle(
            0, 0, w, h,
            fill=THEME.get("primary_bg", "#0A1A0A"),
            outline="",
            tags=("layer:felt", "canvas_bg"),
        )
        
        # 2. Professional oval table rail (bronze/copper) - main table shape
        rail_width = min(w-60, int(h*1.6)) // 2  # Proper oval proportions
        rail_height = min(h-60, int(w*0.6)) // 2
        c.create_oval(
            cx - rail_width, cy - rail_height, 
            cx + rail_width, cy + rail_height,
            fill=rail_color,
            outline="",
            tags=("layer:felt", "table_rail"),
        )
        
        # 3. Gold accent lines on rail (matching screenshot)
        c.create_oval(
            cx - rail_width + 8, cy - rail_height + 8,
            cx + rail_width - 8, cy + rail_height - 8,
            fill="", 
            outline=rail_highlight, 
            width=3,
            tags=("layer:felt", "rail_accent"),
        )
        
        # 4. Outer edge glow (dark border for depth)
        felt_width = rail_width - 22
        felt_height = rail_height - 22
        c.create_oval(
            cx - felt_width - 2, cy - felt_height - 2,
            cx + felt_width + 2, cy + felt_height + 2,
            fill="", 
            outline=edge_glow, 
            width=2,
            tags=("layer:felt", "edge_glow"),
        )
        
        # 5. Main oval felt surface (deep professional green)
        c.create_oval(
            cx - felt_width, cy - felt_height,
            cx + felt_width, cy + felt_height,
            fill=felt_color,
            outline="",
            tags=("layer:felt", "felt_main"),
        )
        
        # 5.5. Soft edge vignette for Monet midnight gradient effect
        # Four translucent rectangles for velvet rim under low light
        vignette_width = 20
        c.create_rectangle(0, 0, w, vignette_width, 
                          fill=edge_glow, outline="", stipple="gray25", 
                          tags=("layer:felt", "vignette_top"))
        c.create_rectangle(0, h-vignette_width, w, h, 
                          fill=edge_glow, outline="", stipple="gray25", 
                          tags=("layer:felt", "vignette_bottom"))
        c.create_rectangle(0, 0, vignette_width, h, 
                          fill=edge_glow, outline="", stipple="gray25", 
                          tags=("layer:felt", "vignette_left"))
        c.create_rectangle(w-vignette_width, 0, w, h, 
                          fill=edge_glow, outline="", stipple="gray25", 
                          tags=("layer:felt", "vignette_right"))
        
        # 6. Subtle center oval for community cards (like screenshot)
        center_width = min(180, felt_width // 2)
        center_height = min(90, felt_height // 3)
        c.create_oval(
            cx - center_width, cy - center_height,
            cx + center_width, cy + center_height,
            fill="", 
            outline=center_color, 
            width=1,
            tags=("layer:felt", "center_oval"),
        )
        
        # 7. Professional inlay accents (6 decorative spots around table)
        import math
        for i, angle in enumerate([0, 60, 120, 180, 240, 300]):
            rad = math.radians(angle)
            accent_x = cx + (felt_width * 0.75) * math.cos(rad)
            accent_y = cy + (felt_height * 0.75) * math.sin(rad)
            c.create_oval(
                accent_x-4, accent_y-4, accent_x+4, accent_y+4,
                fill=inlay_color,
                outline="",
                tags=("layer:felt", f"inlay_accent_{i}"),
            )

```

---

### table_info.py

**Path**: `backend/ui/tableview/components/table_info.py`

**Size**: 4.0 KB

```python
"""
Table Info Display - Shows blinds, hand number, and other table information
"""
from ...services.theme_manager import ThemeManager


def _tokens(canvas):
    # Prefer ThemeManager from widget tree
    w = canvas
    while w is not None:
        try:
            if hasattr(w, "services"):
                tm = w.services.get_app("theme")  # type: ignore[attr-defined]
                if isinstance(tm, ThemeManager):
                    return tm.get_theme(), tm.get_fonts()
        except Exception:
            pass
        w = getattr(w, "master", None)
    # Fallbacks
    return (
        {
            "info.bg": "#111827",
            "info.border": "#374151", 
            "info.text": "#D1D5DB",
            "info.highlight": "#F59E0B"
        }, 
        {"font.body": ("Arial", 9, "normal")}
    )


class TableInfo:
    def __init__(self):
        self._info_elements = {}
    
    def render(self, state, canvas_manager, layer_manager) -> None:
        THEME, FONTS = _tokens(canvas_manager.canvas)
        c = canvas_manager.canvas
        w, h = canvas_manager.size()
        if w <= 1 or h <= 1:
            return
        
        # Clear previous elements
        for element_id in self._info_elements.values():
            try:
                c.delete(element_id)
            except Exception:
                pass
        self._info_elements = {}
        
        # Get hand info from state
        loaded_hand = state.get("review", {}).get("loaded_hand", {})
        if not loaded_hand:
            return
            
        # Position at bottom left of table
        info_x = 20
        info_y = h - 60
        info_width = 200
        info_height = 50
        
        # Background panel
        self._info_elements['info_bg'] = c.create_rectangle(
            info_x, info_y,
            info_x + info_width, info_y + info_height,
            fill=THEME.get("info.bg", "#111827"),
            outline=THEME.get("info.border", "#374151"),
            width=1,
            tags=("layer:info", "info_bg"),
        )
        
        # Hand ID
        hand_id = loaded_hand.get('hand_id', 'Unknown')
        self._info_elements['hand_id'] = c.create_text(
            info_x + 10,
            info_y + 12,
            text=f"Hand: {hand_id}",
            font=FONTS.get("font.body", ("Arial", 9, "bold")),
            fill=THEME.get("info.highlight", "#F59E0B"),
            anchor="w",
            tags=("layer:info", "hand_id"),
        )
        
        # Blinds info
        small_blind = loaded_hand.get('small_blind', 1)
        big_blind = loaded_hand.get('big_blind', 2)
        self._info_elements['blinds'] = c.create_text(
            info_x + 10,
            info_y + 25,
            text=f"Blinds: ${small_blind}/${big_blind}",
            font=FONTS.get("font.body", ("Arial", 9, "normal")),
            fill=THEME.get("info.text", "#D1D5DB"),
            anchor="w",
            tags=("layer:info", "blinds"),
        )
        
        # Number of players
        seats_data = state.get("seats", [])
        active_players = len([s for s in seats_data if s.get('name', '').strip() and not s.get('name', '').startswith('seat')])
        self._info_elements['players'] = c.create_text(
            info_x + 10,
            info_y + 38,
            text=f"Players: {active_players}",
            font=FONTS.get("font.body", ("Arial", 9, "normal")),
            fill=THEME.get("info.text", "#D1D5DB"),
            anchor="w",
            tags=("layer:info", "players"),
        )
        
        # Game type (top right corner)
        game_type = "No Limit Hold'em"  # Could be dynamic from hand data
        self._info_elements['game_type'] = c.create_text(
            w - 20,
            20,
            text=game_type,
            font=FONTS.get("font.body", ("Arial", 10, "bold")),
            fill=THEME.get("info.text", "#D1D5DB"),
            anchor="ne",
            tags=("layer:info", "game_type"),
        )
        
        # Tag all elements
        for element_id in self._info_elements.values():
            c.addtag_withtag("layer:info", element_id)
```

---

### token_driven_renderer.py

**Path**: `backend/ui/tableview/components/token_driven_renderer.py`

**Size**: 10.0 KB

```python
"""
Token-Driven Renderer Integration
Coordinates all enhanced components with the token system
"""

import math
from .table_center import TableCenter
from .enhanced_cards import EnhancedCards
from .chip_animations import ChipAnimations
from .micro_interactions import MicroInteractions

class TokenDrivenRenderer:
    """
    Main coordinator for all token-driven UI components
    Provides a unified interface for rendering poker table elements
    """
    
    def __init__(self, theme_manager):
        self.theme = theme_manager
        
        # Initialize all enhanced components
        self.table_center = TableCenter(theme_manager)
        self.enhanced_cards = EnhancedCards(theme_manager)
        self.chip_animations = ChipAnimations(theme_manager)
        self.micro_interactions = MicroInteractions(theme_manager)
        
    def render_complete_table(self, canvas, state):
        """Render complete poker table with all enhancements"""
        # Clear any existing elements
        self.clear_all_effects(canvas)
        
        # Get current tokens
        tokens = self.theme.get_all_tokens()
        
        # 1. Render table center pattern
        self.table_center.render(canvas, state)
        
        # 2. Render community board area
        self.enhanced_cards.draw_community_board(canvas, tokens)
        
        # 3. Render community cards if present
        community_cards = state.get("board", [])
        if community_cards:
            self._render_community_cards(canvas, community_cards, tokens)
        
        # 4. Render player seats with enhanced cards
        seats_data = state.get("seats", [])
        if seats_data:
            self._render_enhanced_seats(canvas, seats_data, tokens)
        
        # 5. Render pot with chip stacks
        pot_amount = state.get("pot", {}).get("total", 0)
        if pot_amount > 0:
            self._render_enhanced_pot(canvas, pot_amount, tokens)
    
    def _render_community_cards(self, canvas, cards, tokens):
        """Render community cards with enhanced graphics"""
        w, h = canvas.winfo_width(), canvas.winfo_height()
        board_x, board_y = w * 0.5, h * 0.4
        
        card_w, card_h = 58, 82
        gap = 8
        total_w = 5 * card_w + 4 * gap
        start_x = board_x - total_w / 2
        
        for i in range(5):
            card_x = start_x + i * (card_w + gap)
            card_y = board_y - card_h / 2
            
            if i < len(cards) and cards[i]:
                # Render face-up community card
                rank, suit = cards[i][:-1], cards[i][-1]
                self.enhanced_cards.draw_card_face(
                    canvas, card_x, card_y, rank, suit, card_w, card_h,
                    tags=[f"community_card_{i}"]
                )
            else:
                # Render empty slot
                self.enhanced_cards.draw_card_back(
                    canvas, card_x, card_y, card_w, card_h,
                    tags=[f"community_slot_{i}"]
                )
    
    def _render_enhanced_seats(self, canvas, seats_data, tokens):
        """Render player seats with enhanced hole cards"""
        w, h = canvas.winfo_width(), canvas.winfo_height()
        num_seats = len(seats_data)
        
        # Calculate seat positions (simplified - would use actual seat positioning logic)
        center_x, center_y = w // 2, h // 2
        radius = min(w, h) * 0.35
        
        for i, seat in enumerate(seats_data):
            if num_seats <= 1:
                continue
                
            # Calculate seat position
            angle = (i / num_seats) * 2 * 3.14159
            seat_x = center_x + radius * math.cos(angle)
            seat_y = center_y + radius * math.sin(angle)
            
            # Render hole cards if present
            cards = seat.get('cards', [])
            if cards and len(cards) >= 2:
                self._render_hole_cards(canvas, seat_x, seat_y, cards, num_seats)
            
            # Add micro-interactions for acting player
            if seat.get('acting', False):
                self.micro_interactions.pulse_seat_ring(
                    canvas, seat_x, seat_y, 120, 85
                )
    
    def _render_hole_cards(self, canvas, seat_x, seat_y, cards, num_players):
        """Render hole cards with dynamic sizing"""
        # Dynamic card sizing based on player count
        if num_players <= 3:
            card_w, card_h = 52, 75  # 6% scale
        elif num_players <= 6:
            card_w, card_h = 44, 64  # 5% scale
        else:
            card_w, card_h = 35, 51  # 4% scale
        
        gap = max(4, card_w // 8)
        
        for i, card in enumerate(cards[:2]):
            card_x = seat_x - (card_w + gap//2) + i * (card_w + gap)
            card_y = seat_y - card_h//2
            
            if card and card != "XX":
                # Face-up hole card
                rank, suit = card[:-1], card[-1]
                self.enhanced_cards.draw_card_face(
                    canvas, card_x, card_y, rank, suit, card_w, card_h,
                    tags=[f"hole_card_{seat_x}_{i}"]
                )
                
                # Add subtle shimmer for newly revealed cards
                if i == 0:  # Only shimmer first card to avoid overload
                    self.micro_interactions.card_reveal_shimmer(
                        canvas, card_x, card_y, card_w, card_h
                    )
            else:
                # Face-down hole card
                self.enhanced_cards.draw_card_back(
                    canvas, card_x, card_y, card_w, card_h,
                    tags=[f"hole_back_{seat_x}_{i}"]
                )
    
    def _render_enhanced_pot(self, canvas, pot_amount, tokens):
        """Render pot with chip stack visualization"""
        w, h = canvas.winfo_width(), canvas.winfo_height()
        pot_x, pot_y = w // 2, h // 2 - 50
        
        # Render chip stacks around pot area
        if pot_amount > 0:
            # Create multiple small stacks for visual appeal
            num_stacks = min(6, max(2, pot_amount // 100))
            
            for i in range(num_stacks):
                angle = (i / num_stacks) * 2 * 3.14159
                stack_x = pot_x + 25 * math.cos(angle)
                stack_y = pot_y + 15 * math.sin(angle)
                
                stack_amount = pot_amount // num_stacks
                self.chip_animations.draw_chip_stack(
                    canvas, stack_x, stack_y, stack_amount,
                    tags=[f"pot_stack_{i}"]
                )
    
    # Animation Methods
    def animate_bet_to_pot(self, canvas, from_x, from_y, amount, callback=None):
        """Animate bet chips flying to pot"""
        w, h = canvas.winfo_width(), canvas.winfo_height()
        pot_x, pot_y = w // 2, h // 2 - 50
        
        self.chip_animations.fly_chips_to_pot(
            canvas, from_x, from_y, pot_x, pot_y, amount, callback
        )
        
        # Flash pot when chips arrive
        if callback:
            original_callback = callback
            def enhanced_callback():
                self.micro_interactions.flash_pot_increase(canvas, pot_x, pot_y, 100, 60)
                if original_callback:
                    original_callback()
            callback = enhanced_callback
    
    def animate_pot_to_winner(self, canvas, winner_x, winner_y, amount, callback=None):
        """Animate pot chips flying to winner with celebration"""
        w, h = canvas.winfo_width(), canvas.winfo_height()
        pot_x, pot_y = w // 2, h // 2 - 50
        
        self.chip_animations.fly_pot_to_winner(
            canvas, pot_x, pot_y, winner_x, winner_y, amount, callback
        )
        
        # Add confetti burst
        self.micro_interactions.winner_confetti_burst(canvas, winner_x, winner_y)
    
    def animate_card_reveal(self, canvas, card_x, card_y, card_w, card_h, 
                          from_card, to_card, callback=None):
        """Animate card flip with shimmer effect"""
        self.enhanced_cards.animate_card_flip(
            canvas, card_x, card_y, card_w, card_h, from_card, to_card, callback
        )
    
    def animate_dealer_button_move(self, canvas, from_x, from_y, to_x, to_y, callback=None):
        """Animate dealer button movement with trail"""
        self.micro_interactions.dealer_button_move_trail(canvas, from_x, from_y, to_x, to_y)
        
        # Use existing dealer button animation if available
        # This would integrate with existing dealer button component
        if callback:
            canvas.after(800, callback)  # Match trail duration
    
    # Interaction Methods
    def add_hover_effect(self, canvas, element_id, x, y, w, h):
        """Add hover glow to UI element"""
        self.micro_interactions.hover_glow(canvas, element_id, x, y, w, h)
    
    def remove_hover_effect(self, canvas, element_id):
        """Remove hover glow from UI element"""
        self.micro_interactions.remove_hover_glow(canvas, element_id)
    
    def button_press_feedback(self, canvas, btn_x, btn_y, btn_w, btn_h):
        """Visual feedback for button press"""
        self.micro_interactions.button_press_feedback(canvas, btn_x, btn_y, btn_w, btn_h)
    
    def pulse_acting_player(self, canvas, seat_x, seat_y):
        """Start pulsing ring around acting player"""
        self.micro_interactions.pulse_seat_ring(canvas, seat_x, seat_y, 120, 85)
    
    # Cleanup Methods
    def clear_all_effects(self, canvas):
        """Clear all visual effects and animations"""
        self.table_center.clear(canvas)
        self.enhanced_cards.clear_card_effects(canvas)
        self.chip_animations.cleanup_temp_elements(canvas)
        self.micro_interactions.cleanup_effects(canvas)
    
    def stop_all_animations(self):
        """Stop all active animations"""
        self.chip_animations.stop_all_animations()
        self.micro_interactions.stop_all_interactions()
    
    # Theme Integration
    def on_theme_change(self):
        """Handle theme change - refresh all components"""
        # Components automatically pick up new theme via theme_manager
        # No additional action needed due to token-driven design
        pass
```

---

### layer_manager.py

**Path**: `backend/ui/tableview/layer_manager.py`

**Size**: 1.2 KB

```python
class LayerManager:
    ORDER = [
        "layer:felt",
        "layer:seats",       # seat backgrounds and player names
        "layer:hole_cards",  # player hole cards (must be above seats)
        "layer:stacks",      # player stacks (must be above hole cards)
        "layer:community",   # community cards and card backs
        "layer:bets",        # bet/call chip stacks (must be above community)
        "layer:pot",         # pot chips and display
        "layer:action",      # acting highlight ring and labels
        "layer:status",      # folded/winner labels
        "layer:overlay",     # overlays and UI elements
        # transient animation/helper tags kept last so they stay visible
        "temp_animation", "flying_chip", "motion_glow", "pot_pulse",
    ]

    def __init__(self, canvas, overlay):
        self.canvas = canvas
        self.overlay = overlay

    def raise_to_policy(self) -> None:
        c = self.canvas
        for tag in self.ORDER:
            try:
                c.tag_raise(tag)
            except Exception:
                pass
        if self.overlay is not None:
            try:
                self.overlay.lift(self.canvas)
            except Exception:
                pass


```

---

### renderer_pipeline.py

**Path**: `backend/ui/tableview/renderer_pipeline.py`

**Size**: 1.5 KB

```python
class RendererPipeline:
    def __init__(self, canvas_manager, layer_manager, components):
        self.cm = canvas_manager
        self.lm = layer_manager
        self.components = components

    def render_once(self, state, force=False):
        # Gate rendering until the canvas is created/sized to avoid small initial artifacts
        if not self.cm.is_ready() and not force:
            self.cm.defer_render(lambda: self.render_once(state, force=True))
            return

        c = self.cm.canvas
        if c is None:
            return

        w, h = self.cm.size()
        if w <= 100 or h <= 100:
            # Skip rendering on invalid size; a deferred render will occur on ready
            print(f"‚ö†Ô∏è Skipping render - invalid dimensions: {w}x{h}")
            return

        # Thorough clear to ensure no remnants from any previous pass
        try:
            c.delete("all")
        except Exception:
            pass

        # Render all components
        for component in self.components:
            try:
                component.render(state, self.cm, self.lm)
            except Exception as e:
                print(f"‚ö†Ô∏è Component {component.__class__.__name__} render error: {e}")

        # Apply layer ordering
        try:
            self.lm.raise_to_policy()
        except Exception as e:
            print(f"‚ö†Ô∏è Layer manager error: {e}")

        print(f"üé® Rendered poker table: {w}x{h} with {len(self.components)} components")


```

---

### __init__.py

**Path**: `backend/ui/tabs/__init__.py`

**Size**: 2 bytes

```python


```

---

### base_tab.py

**Path**: `backend/ui/tabs/base_tab.py`

**Size**: 893 bytes

```python
from tkinter import ttk
from typing import Callable, List


class BaseTab(ttk.Frame):
    def __init__(self, parent, session_id: str, services, store):
        super().__init__(parent)
        self.session_id = session_id
        self.services = services
        self.store = store
        self._unsubs: List[Callable[[], None]] = []

    def on_mount(self) -> None:
        pass

    def on_show(self) -> None:
        pass

    def on_hide(self) -> None:
        self._cleanup()

    def on_unmount(self) -> None:
        self._cleanup()

    def _cleanup(self) -> None:
        for unsub in self._unsubs:
            try:
                unsub()
            except Exception:
                pass
        self._unsubs.clear()
        try:
            timers = self.services.get_session(self.session_id, "timers")
            timers.cancel_all()
        except Exception:
            pass


```

---

### hands_review_tab_legacy.py

**Path**: `backend/ui/tabs/deprecated/hands_review_tab_legacy.py`

**Size**: 111.9 KB

```python
import tkinter as tk
from tkinter import ttk
import uuid
import time
from typing import Optional

# New UI Architecture imports
from ..state.actions import (
    SET_REVIEW_HANDS,
    SET_REVIEW_FILTER,
    SET_STUDY_MODE
)
from ..state.store import Store
from ..services.event_bus import EventBus
from ..services.service_container import ServiceContainer
from ..services.game_director import GameDirector
from ..services.effect_bus import EffectBus
from ..services.hands_repository import HandsRepository, HandsFilter, StudyMode
from ..services.hands_review_session_manager import HandsReviewSessionManager

# PPSM architecture - using HandsReviewSessionManager and PokerTableRenderer as per architecture guidelines

# Import enhanced button components
try:
    from ..components.enhanced_button import PrimaryButton, SecondaryButton
except ImportError:
    # Fallback to basic buttons if enhanced buttons not available
    PrimaryButton = SecondaryButton = tk.Button

# Import ActionBanner for visual feedback
try:
    from ..components.action_banner import ActionBanner
except ImportError:
    print("‚ö†Ô∏è ActionBanner not available, using fallback")
    ActionBanner = None

# Core imports - fail fast if not available
USE_DEV_STUBS = True  # Temporarily use stubs to fix console error

try:
    import sys
    import os
    sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))
    
    from core.hand_model import Hand
    from core.hand_model_decision_engine import HandModelDecisionEngine
    # PPSM imports instead of FPSM
    from core.pure_poker_state_machine import PurePokerStateMachine, GameConfig
    # HandsReviewBotSession removed - using PPSMHandsReviewBotSession below
    from core.session_logger import get_session_logger
            # Sound manager for poker table
    from utils.sound_manager import SoundManager
except ImportError as e:
    if not USE_DEV_STUBS:
        raise ImportError(f"Critical core modules not available: {e}. This will break hands review functionality.") from e
    print("‚ö†Ô∏è Using dev stubs due to import error:", e)
    
    # Minimal stubs for development only
    class Hand:
        def __init__(self, data):
            if isinstance(data, dict):
                self.hand_id = data.get("hand_id", "Unknown")
                self.players = data.get("players", [])
                self.pot_size = data.get("pot_size", 0)
                self.small_blind = data.get("small_blind", 5)
                self.big_blind = data.get("big_blind", 10)
                self.community_cards = data.get("community_cards", [])
                self.dealer = data.get("dealer", 0)
                self.__dict__.update(data)

        @classmethod
        def from_dict(cls, data):
            return cls(data)

    class HandModelDecisionEngine:
        def __init__(self, hand):
            pass

        def is_session_complete(self):
            return False

    class GameConfig:
        def __init__(self, **kwargs):
            pass

    def get_session_logger():
        class FallbackLogger:
            def log_system(self, *args, **kwargs):
                pass

        return FallbackLogger()


# Session manager will be initialized in the tab
# HandsReviewSessionManager handles all business logic per architecture guidelines

    




    """Concrete wrapper for HandModelDecisionEngine."""

    def __init__(self, hand):
        self.hand = hand
        try:
            if HandModelDecisionEngine and hand:
                self._engine = HandModelDecisionEngine.__new__(HandModelDecisionEngine)
                self._engine.hand = hand
                if hasattr(self._engine, "_organize_actions_by_street"):
                    self._engine.actions_by_street = (
                        self._engine._organize_actions_by_street()
                    )
                self._engine.current_action_index = 0
                if hasattr(self._engine, "_get_betting_actions"):
                    self._engine.actions_for_replay = (
                        self._engine._get_betting_actions()
                    )
                    self._engine.total_actions = len(self._engine.actions_for_replay)
                else:
                    self._engine.actions_for_replay = []
                    self._engine.total_actions = 0
            else:
                self._engine = None
        except Exception as e:
            print(f"‚ùå Error initializing decision engine: {e}")
            self._engine = None

    def get_decision(self, player_index: int, game_state):
        if self._engine and hasattr(self._engine, "get_decision"):
            return self._engine.get_decision(player_index, game_state)
        return {
            "action": "fold",
            "amount": 0,
            "explanation": "Default action",
            "confidence": 0.5,
        }

    def is_session_complete(self):
        if self._engine and hasattr(self._engine, "is_session_complete"):
            return self._engine.is_session_complete()
        return True

    def reset(self):
        if self._engine and hasattr(self._engine, "reset"):
            self._engine.reset()

    def get_session_info(self):
        if self._engine and hasattr(self._engine, "hand"):
            # Handle both fallback Hand class (hand.hand_id) and real Hand class (hand.metadata.hand_id)
            hand_id = "Unknown"
            if hasattr(self._engine.hand, "hand_id"):
                hand_id = self._engine.hand.hand_id
            elif hasattr(self._engine.hand, "metadata") and hasattr(
                self._engine.hand.metadata, "hand_id"
            ):
                hand_id = self._engine.hand.metadata.hand_id

            return {
                "hand_id": hand_id,
                "total_actions": getattr(self._engine, "total_actions", 0),
                "current_action": getattr(self._engine, "current_action_index", 0),
                "engine_type": "HandModelDecisionEngine",
            }
        return {
            "hand_id": "Unknown",
            "total_actions": 0,
            "current_action": 0,
            "engine_type": "Fallback",
        }


class HandsReviewTab(ttk.Frame):
    """Hands Review tab implementing the full PRD requirements."""

    def __init__(self, parent, services: ServiceContainer):
        super().__init__(parent)
        self.services = services
        self.session_id = f"hands_review_{uuid.uuid4().hex[:8]}"

        # Get app services
        self.event_bus: EventBus = services.get_app("event_bus")
        self.store: Store = services.get_app("store")
        self.theme = services.get_app("theme")
        self.hands_repository: HandsRepository = services.get_app("hands_repository")
        # Sounds are owned by EffectBus per architecture; no local fallback

        # Session state - using HandsReviewSessionManager per architecture guidelines
        self.session_manager: Optional[HandsReviewSessionManager] = None
        self.session_active = False
        
        # Use global services from service container for proper coordination
        self.game_director = self.services.get_app("game_director")
        if not self.game_director:
            # Create global GameDirector if not exists
            self.game_director = GameDirector(event_bus=self.event_bus)
            self.services.provide_app("game_director", self.game_director)
        
        # Use global EffectBus service for proper event coordination
        self.effect_bus = self.services.get_app("effect_bus")
        if not self.effect_bus:
            # Create global EffectBus if not exists
            self.effect_bus = EffectBus(
                game_director=self.game_director,
                event_bus=self.event_bus
            )
            self.services.provide_app("effect_bus", self.effect_bus)
        
        # Ensure proper connections for event coordination
        self.game_director.set_event_bus(self.event_bus)
        self.effect_bus.set_game_director(self.game_director)
        self.effect_bus.set_event_bus(self.event_bus)
        
        # Initialize HandsReviewSessionManager per architecture guidelines
        try:
            # Try direct import first
            try:
                from core.pure_poker_state_machine import PurePokerStateMachine, GameConfig
            except ImportError:
                # Fallback to relative import
                from ...core.pure_poker_state_machine import PurePokerStateMachine, GameConfig
                
            # Create a default game config for hands review
            game_config = GameConfig(
                num_players=6,  # Default to 6 players for hands review
                small_blind=1.0,
                big_blind=2.0,
                starting_stack=1000.0
            )
            
            ppsm = PurePokerStateMachine(config=game_config)
            self.session_manager = HandsReviewSessionManager(
                store=self.store,
                ppsm=ppsm,
                game_director=self.game_director,
                effect_bus=self.effect_bus,
                event_bus=self.event_bus
            )
            
            # ARCHITECTURE COMPLIANT: Register session with event controller
            try:
                hands_review_controller = self.services.get_app("hands_review_controller")
                if hands_review_controller:
                    self.event_bus.publish(
                        "hands_review:session_created",
                        {
                            "session_id": self.session_id,
                            "session_manager": self.session_manager
                        }
                    )
                    print(f"üéØ HandsReviewTab: Session {self.session_id} registered with event controller")
            except Exception as e:
                print(f"‚ö†Ô∏è HandsReviewTab: Failed to register session: {e}")
            print("üéØ HandsReviewTab: Session manager initialized per architecture guidelines")
        except Exception as e:
            print(f"‚ö†Ô∏è HandsReviewTab: Could not initialize session manager: {e}")
            self.session_manager = None

        # Setup UI
        self.on_mount()

        # Subscribe to events and store changes
        self._setup_event_subscriptions()
        self.store.subscribe(self._on_store_change)

        # Initialize GTO hands for PPSM testing
        self.loaded_gto_hands = []
        # GTO hands will be loaded in on_mount() to ensure proper UI initialization order

    def on_mount(self):
        """Set up the tab layout per PRD design."""
        # Two-column layout: Controls (20%) | Poker Table (80%)
        # Using 1:4 ratio for poker table emphasis
        self.grid_columnconfigure(0, weight=1)  # Library + Filters & Controls (20%)
        self.grid_columnconfigure(1, weight=4)  # Poker Table (80%)
        self.grid_rowconfigure(0, weight=1)

        # Create the two main sections
        self._create_combined_left_section()
        self._create_poker_table_section()
        
        # Load GTO hands for PPSM testing
        self._load_gto_hands()
        
        # Refresh hands list now that GTO hands are loaded
        self._refresh_hands_list()
        
        # Start main update loop for GameDirector and EffectBus
        self._start_update_loop()
        
        # Setup ActionBanner for visual feedback
        self._setup_action_banner()
        
        # Start the UI tick loop for GameDirector and EffectBus
        self._start_ui_tick_loop()

    def _create_combined_left_section(self):
        """Create the combined left section with hands library and controls."""
        # Get theme colors
        theme = self.theme.get_theme()

        # Main left frame
        left_frame = ttk.Frame(self)
        left_frame.grid(row=0, column=0, sticky="nsew", padx=(5, 2.5), pady=5)
        left_frame.grid_columnconfigure(0, weight=1)
        left_frame.grid_rowconfigure(0, weight=60)  # Hands library gets 60%
        left_frame.grid_rowconfigure(1, weight=40)  # Controls get 40%

        # Apply theme colors to main left frame
        try:
            left_frame.configure(background=theme.get("panel.bg", "#111827"))
        except Exception:
            pass

        # Create library section at top
        self._create_library_section_in_frame(left_frame)

        # Create filters/controls section at bottom
        self._create_filters_section_in_frame(left_frame)

    def _create_library_section_in_frame(self, parent):
        """Create the Library section within the given parent frame."""
        # Get theme colors
        theme = self.theme.get_theme()

        library_frame = ttk.LabelFrame(parent, text="üìö Hands Library", padding=10)
        library_frame.grid(row=0, column=0, sticky="nsew", pady=(0, 2.5))

        # Apply theme colors to the frame
        try:
            library_frame.configure(
                background=theme.get("panel.bg", "#111827"),
                foreground=theme.get("panel.sectionTitle", "#C7D2FE"),
            )
        except Exception:
            pass  # Fallback to default colors if theming fails
        library_frame.grid_columnconfigure(0, weight=1)
        library_frame.grid_rowconfigure(
            3, weight=1
        )  # Hands list gets most space (shifted down due to theme selector)

        # Theme selector (at top) - 5 Professional Casino Schemes
        theme_frame = ttk.LabelFrame(
            library_frame, text="üé® Professional Casino Themes", padding=5
        )
        theme_frame.grid(row=0, column=0, sticky="ew", pady=(0, 10))
        theme_frame.grid_columnconfigure(0, weight=1)

        theme_controls = ttk.Frame(theme_frame)
        theme_controls.grid(row=0, column=0, sticky="ew")

        current_theme = self.theme.current_profile_name()
        self.theme_var = tk.StringVar(value=current_theme)

        # All available themes from ThemeManager
        all_theme_names = self.theme.names()
        print(
            f"üé® HandsReviewTab: Found {len(all_theme_names)} themes: {all_theme_names}"
        )

        # Fallback if no themes found
        if not all_theme_names:
            print("‚ö†Ô∏è No themes found, forcing theme manager reload...")
            # Try to reload theme manager
            try:
                from ..services.theme_factory import build_all_themes

                themes = build_all_themes()
                print(f"üîÑ Force-built {len(themes)} themes: {list(themes.keys())}")
                # Register them with the theme manager
                for name, tokens in themes.items():
                    self.theme.register(name, tokens)
                all_theme_names = self.theme.names()
                print(
                    f"üé® After reload: {len(all_theme_names)} themes: {all_theme_names}"
                )
            except Exception as e:
                print(f"‚ùå Failed to reload themes: {e}")
                # Get actual theme names from config, with ultimate fallback
                default_theme_data = self.theme.get_available_themes()
                all_theme_names = (
                    list(default_theme_data.keys())
                    if default_theme_data
                    else ["Forest Green Professional üåø"]
                )

        # Theme icons are now embedded in theme names from JSON config
        # No need for separate THEME_ICONS or THEME_INTROS - all data comes from poker_themes.json

        # Create clean 4x4 grid layout for 16 themes with 20px font
        # Configure grid weights for even distribution
        for col_idx in range(4):
            theme_controls.grid_columnconfigure(col_idx, weight=1)

        for i, theme_name in enumerate(all_theme_names):
            row = i // 4  # 4 themes per row
            col = i % 4

            # Theme names from JSON config already include icons and formatting
            display_name = theme_name

            # Simple radiobutton with 20px font and equal spacing
            radio_btn = ttk.Radiobutton(
                theme_controls,
                text=display_name,
                variable=self.theme_var,
                value=theme_name,
                command=self._on_theme_change,
            )
            radio_btn.grid(row=row, column=col, sticky="w", padx=5, pady=3)

            # Configure font size to 20px and store reference for styling
            try:
                fonts = self.theme.get_fonts()
                radio_font = fonts.get(
                    "button", fonts.get("body", ("Inter", 20, "normal"))
                )
                radio_btn.configure(font=radio_font)
            except:
                # Fallback if font configuration fails
                pass

            # Store radio button reference for theme styling
            if not hasattr(self, "theme_radio_buttons"):
                self.theme_radio_buttons = []
            self.theme_radio_buttons.append(radio_btn)

            # Theme intro will update only on selection, not hover
            # Removed confusing hover effects that changed intro on mouse over

        # Apply initial theme styling to radio buttons
        self.after_idle(self._style_theme_radio_buttons)

        # Artistic Theme Info Panel - shows evocative descriptions (positioned AFTER theme controls)
        info_frame = ttk.Frame(theme_frame)
        info_frame.grid(row=1, column=0, sticky="ew", pady=(10, 0))
        info_frame.grid_columnconfigure(0, weight=1)

        # Luxury Museum Placard - Theme intro with elegant styling
        fonts = self.theme.get_fonts()
        # Use theme-aware font for luxury feel
        fonts = self.theme.get_fonts()
        intro_font = fonts.get("intro", fonts.get("body", ("Georgia", 16, "normal")))

        # Create luxury museum placard frame with theme-aware styling
        base_colors = self.theme.get_base_colors()
        placard_bg = base_colors.get("panel_bg", "#2A2A2A")
        placard_accent = base_colors.get("highlight", "#D4AF37")

        placard_frame = tk.Frame(
            info_frame,
            relief="raised",
            borderwidth=2,
            bg=placard_bg,
            highlightbackground=placard_accent,
            highlightcolor=placard_accent,
            highlightthickness=1,
        )
        # Use theme dimensions for consistent spacing
        dimensions = self.theme.get_dimensions()
        medium_pad = dimensions["padding"]["medium"]
        placard_frame.grid(
            row=0, column=0, sticky="ew", padx=medium_pad, pady=medium_pad
        )
        placard_frame.grid_columnconfigure(0, weight=1)

        # Store reference to placard frame for dynamic styling
        self.placard_frame = placard_frame

        # Get initial theme colors instead of hardcoding
        base_colors = self.theme.get_base_colors()
        initial_bg = base_colors.get("panel_bg", "#1A1A1A")
        initial_fg = base_colors.get("text", "#F5F5DC")

        intro_height = dimensions["text_height"][
            "medium"
        ]  # Use medium instead of small for theme intros
        self.theme_intro_label = tk.Text(
            placard_frame,
            height=intro_height,
            wrap=tk.WORD,
            relief="flat",
            borderwidth=0,
            font=intro_font,
            state="disabled",
            cursor="arrow",
            padx=dimensions["padding"]["xlarge"],
            pady=dimensions["padding"]["medium"],
            bg=initial_bg,
            fg=initial_fg,
        )  # Dynamic theme colors
        self.theme_intro_label.grid(row=0, column=0, sticky="ew")

        # Show current theme's introduction
        self._show_theme_intro(current_theme)

        # Library type selector
        type_frame = ttk.Frame(library_frame)
        type_frame.grid(row=2, column=0, sticky="ew", pady=(0, 10))
        type_frame.grid_columnconfigure(0, weight=1)

        self.library_type = tk.StringVar(value="legendary")
        ttk.Radiobutton(
            type_frame,
            text="üèÜ Legendary",
            variable=self.library_type,
            value="legendary",
            command=self._on_library_type_change,
        ).grid(row=0, column=0, sticky="w")
        ttk.Radiobutton(
            type_frame,
            text="ü§ñ Bot Sessions",
            variable=self.library_type,
            value="bot",
            command=self._on_library_type_change,
        ).grid(row=0, column=1, sticky="w")
        ttk.Radiobutton(
            type_frame,
            text="üì• Imported",
            variable=self.library_type,
            value="imported",
            command=self._on_library_type_change,
        ).grid(row=0, column=2, sticky="w")

        # Collections dropdown
        collections_frame = ttk.Frame(library_frame)
        collections_frame.grid(row=3, column=0, sticky="ew", pady=(0, 10))
        collections_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(collections_frame, text="Collection:").grid(
            row=0, column=0, sticky="w", padx=(0, 5)
        )
        self.collection_var = tk.StringVar(value="ü§ñ GTO Hands")
        self.collection_combo = ttk.Combobox(
            collections_frame, textvariable=self.collection_var, state="readonly"
        )
        self.collection_combo.grid(row=0, column=1, sticky="ew")
        self.collection_combo.bind("<<ComboboxSelected>>", self._on_collection_change)

        # Hands listbox
        hands_frame = ttk.Frame(library_frame)
        hands_frame.grid(row=4, column=0, sticky="nsew", pady=(0, 10))
        hands_frame.grid_columnconfigure(0, weight=1)
        hands_frame.grid_rowconfigure(0, weight=1)

        # Get fonts from theme
        fonts = self.theme.get_fonts()
        body_font = fonts.get("body", ("Consolas", 20))

        self.hands_listbox = tk.Listbox(
            hands_frame, font=body_font, selectmode=tk.SINGLE
        )
        self.hands_listbox.grid(row=0, column=0, sticky="nsew")
        self.hands_listbox.bind("<<ListboxSelect>>", self._on_hand_select)

        # Apply theme colors to listbox with dynamic selection highlight
        try:
            # Get theme-specific selection highlight
            current_theme_name = self.theme.current() or "Forest Green Professional üåø"
            # Get selection highlight from config-driven system
            base_colors = self.theme.get_base_colors()
            selection_highlight = {
                "color": base_colors.get(
                    "highlight", base_colors.get("accent", "#D4AF37")
                )
            }

            self.hands_listbox.configure(
                bg=theme.get("panel.bg", "#111827"),
                fg=theme.get("panel.fg", "#E5E7EB"),
                selectbackground=selection_highlight[
                    "color"
                ],  # Dynamic theme-specific highlight
                selectforeground=base_colors.get(
                    "highlight_text", base_colors.get("text", "#FFFFFF")
                ),  # Theme-aware text when highlighted
                highlightbackground=theme.get("panel.border", "#1F2937"),
                highlightcolor=theme.get("a11y.focusRing", "#22D3EE"),
            )
        except Exception:
            pass

        scrollbar = ttk.Scrollbar(
            hands_frame, orient="vertical", command=self.hands_listbox.yview
        )
        scrollbar.grid(row=0, column=1, sticky="ns")
        self.hands_listbox.configure(yscrollcommand=scrollbar.set)

        # Hand details text (smaller in the combined layout)
        details_frame = ttk.LabelFrame(library_frame, text="Hand Details", padding=5)
        details_frame.grid(row=5, column=0, sticky="ew")
        details_frame.grid_columnconfigure(0, weight=1)

        small_font = fonts.get("small", ("Consolas", 16))
        details_height = self.theme.get_dimensions()["text_height"]["medium"]
        self.details_text = tk.Text(
            details_frame, height=details_height, wrap=tk.WORD, font=small_font
        )
        self.details_text.grid(row=0, column=0, sticky="ew")

        # Apply theme colors to details text
        try:
            self.details_text.configure(
                bg=theme.get("panel.bg", "#111827"),
                fg=theme.get("panel.fg", "#E5E7EB"),
                insertbackground=theme.get("panel.fg", "#E5E7EB"),
                highlightbackground=theme.get("panel.border", "#1F2937"),
                highlightcolor=theme.get("a11y.focusRing", "#22D3EE"),
            )
        except Exception:
            pass

    def _create_filters_section_in_frame(self, parent):
        """Create the Filters & Controls section within the given parent frame."""
        # Get theme colors
        theme = self.theme.get_theme()

        filters_frame = ttk.LabelFrame(
            parent, text="üîç Filters & Study Mode", padding=10
        )
        filters_frame.grid(row=1, column=0, sticky="nsew", pady=(2.5, 0))

        # Apply theme colors to the frame
        try:
            filters_frame.configure(
                background=theme.get("panel.bg", "#111827"),
                foreground=theme.get("panel.sectionTitle", "#C7D2FE"),
            )
        except Exception:
            pass
        filters_frame.grid_columnconfigure(0, weight=1)

        # Study Mode selector
        study_frame = ttk.LabelFrame(filters_frame, text="Study Mode", padding=5)
        study_frame.grid(row=0, column=0, sticky="ew", pady=(0, 10))

        self.study_mode = tk.StringVar(value=StudyMode.REPLAY.value)
        ttk.Radiobutton(
            study_frame,
            text="üîÑ Replay",
            variable=self.study_mode,
            value=StudyMode.REPLAY.value,
            command=self._on_study_mode_change,
        ).grid(row=0, column=0, sticky="w")
        ttk.Radiobutton(
            study_frame,
            text="üìä Solver Diff",
            variable=self.study_mode,
            value=StudyMode.SOLVER_DIFF.value,
            command=self._on_study_mode_change,
        ).grid(row=1, column=0, sticky="w")
        ttk.Radiobutton(
            study_frame,
            text="üß† Recall Quiz",
            variable=self.study_mode,
            value=StudyMode.RECALL_QUIZ.value,
            command=self._on_study_mode_change,
        ).grid(row=2, column=0, sticky="w")
        ttk.Radiobutton(
            study_frame,
            text="‚ùì Explain Mistake",
            variable=self.study_mode,
            value=StudyMode.EXPLAIN_MISTAKE.value,
            command=self._on_study_mode_change,
        ).grid(row=3, column=0, sticky="w")

        # Filters section
        filter_frame = ttk.LabelFrame(filters_frame, text="Filters", padding=5)
        filter_frame.grid(row=1, column=0, sticky="ew", pady=(0, 10))
        filter_frame.grid_columnconfigure(1, weight=1)

        # Position filter
        ttk.Label(filter_frame, text="Position:").grid(
            row=0, column=0, sticky="w", padx=(0, 5)
        )
        self.position_var = tk.StringVar(value="All")
        position_combo = ttk.Combobox(
            filter_frame,
            textvariable=self.position_var,
            values=["All", "UTG", "MP", "CO", "BTN", "SB", "BB"],
            state="readonly",
            width=8,
        )
        position_combo.grid(row=0, column=1, sticky="w", pady=2)

        # Stack depth filter
        ttk.Label(filter_frame, text="Stack Depth:").grid(
            row=1, column=0, sticky="w", padx=(0, 5)
        )
        stack_frame = ttk.Frame(filter_frame)
        stack_frame.grid(row=1, column=1, sticky="w", pady=2)
        self.min_stack = tk.StringVar(value="20")
        self.max_stack = tk.StringVar(value="200")
        ttk.Entry(stack_frame, textvariable=self.min_stack, width=5).grid(
            row=0, column=0
        )
        ttk.Label(stack_frame, text=" - ").grid(row=0, column=1)
        ttk.Entry(stack_frame, textvariable=self.max_stack, width=5).grid(
            row=0, column=2
        )
        ttk.Label(stack_frame, text=" BB").grid(row=0, column=3)

        # Pot type filter
        ttk.Label(filter_frame, text="Pot Type:").grid(
            row=2, column=0, sticky="w", padx=(0, 5)
        )
        self.pot_type_var = tk.StringVar(value="All")
        pot_combo = ttk.Combobox(
            filter_frame,
            textvariable=self.pot_type_var,
            values=["All", "SRP", "3BP", "4BP+"],
            state="readonly",
            width=8,
        )
        pot_combo.grid(row=2, column=1, sticky="w", pady=2)

        # Search text
        ttk.Label(filter_frame, text="Search:").grid(
            row=3, column=0, sticky="w", padx=(0, 5)
        )
        self.search_var = tk.StringVar()
        search_entry = ttk.Entry(filter_frame, textvariable=self.search_var)
        search_entry.grid(row=3, column=1, sticky="ew", pady=2)
        search_entry.bind("<KeyRelease>", lambda e: self._apply_filters())

        # Apply filters button
        ttk.Button(
            filter_frame, text="Apply Filters", command=self._apply_filters
        ).grid(row=4, column=0, columnspan=2, pady=5)

        # Action buttons
        actions_frame = ttk.LabelFrame(filters_frame, text="Actions", padding=5)
        actions_frame.grid(row=2, column=0, sticky="ew", pady=(0, 10))
        actions_frame.grid_columnconfigure(0, weight=1)

        # Load button (main action) - Enhanced primary button
        self.load_btn = PrimaryButton(
            actions_frame,
            text="üî• LOAD HAND",
            command=self._load_selected_hand,
            theme_manager=self.theme,
        )
        self.load_btn.grid(row=0, column=0, sticky="ew", pady=5)

        # Enhanced button handles its own styling

        # Playback controls
        controls_frame = ttk.Frame(actions_frame)
        controls_frame.grid(row=1, column=0, sticky="ew", pady=5)
        controls_frame.grid_columnconfigure(1, weight=1)

        # Enhanced buttons handle their own styling

        # Enhanced secondary buttons for controls
        self.next_btn = SecondaryButton(
            controls_frame,
            text="Next ‚Üí",
            command=self._next_action,  # Use session manager method
            theme_manager=self.theme,
        )
        self.next_btn.grid(row=0, column=0, padx=(0, 5))

        self.auto_btn = SecondaryButton(
            controls_frame,
            text="Auto",
            command=self._toggle_auto_play,  # Use session manager method
            theme_manager=self.theme,
        )
        self.auto_btn.grid(row=0, column=1, padx=5)

        self.reset_btn = SecondaryButton(
            controls_frame,
            text="Reset",
            command=self._reset_hand,  # Use session manager method
            theme_manager=self.theme,
        )
        self.reset_btn.grid(row=0, column=2, padx=(5, 0))

        # Enhanced buttons handle their own styling

        # Status text
        status_frame = ttk.LabelFrame(filters_frame, text="Status", padding=5)
        status_frame.grid(row=3, column=0, sticky="nsew")
        status_frame.grid_columnconfigure(0, weight=1)
        status_frame.grid_rowconfigure(0, weight=1)

        fonts = self.theme.get_fonts()
        small_font = fonts.get("small", ("Consolas", 16))
        status_height = self.theme.get_dimensions()["text_height"]["large"]
        self.status_text = tk.Text(
            status_frame, height=status_height, wrap=tk.WORD, font=small_font
        )
        self.status_text.grid(row=0, column=0, sticky="nsew")

        # Apply theme colors to status text
        try:
            self.status_text.configure(
                bg=theme.get("panel.bg", "#111827"),
                fg=theme.get("panel.fg", "#E5E7EB"),
                insertbackground=theme.get("panel.fg", "#E5E7EB"),
                highlightbackground=theme.get("panel.border", "#1F2937"),
                highlightcolor=theme.get("a11y.focusRing", "#22D3EE"),
            )
        except Exception:
            pass

        # Poker Table Controls
        poker_frame = ttk.LabelFrame(actions_frame, text="üéÆ Poker Table Controls", padding=5)
        poker_frame.grid(row=2, column=0, sticky="ew", pady=(10, 0))
        poker_frame.grid_columnconfigure(1, weight=1)

        # Next Action button for poker table
        self.next_btn = SecondaryButton(
            poker_frame,
            text="‚ñ∂ Next Action",
            command=self._next_action,
            theme_manager=self.theme,
        )
        self.next_btn.grid(row=0, column=0, padx=(0, 5))

        # Reset button for poker table
        self.reset_btn = SecondaryButton(
            poker_frame,
            text="‚Ü© Reset Hand",
            command=self._reset_hand,
            theme_manager=self.theme,
        )
        self.reset_btn.grid(row=0, column=1, padx=5)

        # Progress display for poker table
        self.progress_label = ttk.Label(poker_frame, text="No hand loaded")
        self.progress_label.grid(row=1, column=0, columnspan=2, sticky="ew", pady=(5, 0))

        # Enhanced buttons handle their own styling

    def _create_poker_table_section(self):
        """Create poker table using PokerTableRenderer (right column)."""
        # Get theme colors for poker table
        theme = self.theme.get_theme()

        table_frame = ttk.LabelFrame(self, text="‚ô†Ô∏è Enhanced Poker Table", padding=5)
        table_frame.grid(row=0, column=1, sticky="nsew", padx=(2.5, 5), pady=5)
        table_frame.grid_columnconfigure(0, weight=1)
        table_frame.grid_rowconfigure(0, weight=1)

        # Apply theme colors to table frame
        try:
            table_frame.configure(
                background=theme.get("panel.bg", "#111827"),
                foreground=theme.get("panel.sectionTitle", "#C7D2FE"),
            )
        except Exception:
            pass

        # Create PokerTableRenderer directly in the table frame
        self._setup_poker_table(table_frame)
        
        print(f"üéØ HandsReviewTab: Table frame created and configured")
        print(f"   Frame size: {table_frame.winfo_width()}x{table_frame.winfo_height()}")
        print(f"   Table renderer created: {hasattr(self, 'table_renderer')}")

    def _setup_poker_table(self, parent_frame):
        """Set up the PokerTableRenderer with poker table display."""
        # Do not force early geometry; allow CanvasManager to handle readiness
        parent_frame.grid_propagate(False)
        frame_width = parent_frame.winfo_width()
        frame_height = parent_frame.winfo_height()
        table_width = max(1200, max(0, frame_width) - 20) if frame_width > 0 else 1200
        table_height = max(800, max(0, frame_height) - 20) if frame_height > 0 else 800
        
        # Calculate card size based on table dimensions
        card_width = max(40, int(table_width * 0.035))
        card_height = int(card_width * 1.45)
        
        print(f"üéØ HandsReviewTab: Initial frame {frame_width}x{frame_height}, desired table {table_width}x{table_height}")
        
        # Use PokerTableRenderer as per architecture guidelines
        from ..renderers.poker_table_renderer import PokerTableRenderer

        self.table_renderer = PokerTableRenderer(
            parent_frame,
            intent_handler=self._handle_renderer_intent,
            theme_manager=self.theme if hasattr(self, 'theme') else None,
        )
        self.table_renderer.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        parent_frame.grid_columnconfigure(0, weight=1)
        parent_frame.grid_rowconfigure(0, weight=1)
        
        # Access canvas manager through renderer for legacy compatibility
        self.canvas_manager = self.table_renderer.canvas_manager
        # layer_manager may not be available immediately due to deferred initialization
        if hasattr(self.table_renderer, 'layer_manager'):
            self.layer_manager = self.table_renderer.layer_manager
        else:
            self.layer_manager = None
        
        # Link EffectBus to renderer so animation bridge can draw chips
        try:
            if hasattr(self, 'effect_bus'):
                self.effect_bus.renderer = self.table_renderer
        except Exception:
            pass
        
        # Accumulate declarative effects per frame
        self._pending_effects = []
        
        # Store dimensions for state management
        self.table_width = table_width
        self.table_height = table_height
        self.card_width = card_width
        self.card_height = card_height
        
        # Initialize poker table state
        self._setup_poker_table_state()
        
        # Force table to expand to fill available space
        self._force_table_expansion()

        # Bind a one-time resize to trigger first render when ready via CanvasManager
        try:
            self._resize_bound = False
            def _on_parent_configure(event):
                if getattr(self, '_resize_bound', False):
                    return
                if event.width > 100 and event.height > 100:
                    self._resize_bound = True
                    self.table_width = event.width - 20
                    self.table_height = event.height - 20
                    try:
                        self._render_poker_table()
                    except Exception:
                        pass
            parent_frame.bind('<Configure>', _on_parent_configure)
        except Exception:
            pass
        
        print("üé® PokerTableRenderer components ready")

    def _retry_frame_sizing(self, parent_frame):
        """Retry getting frame dimensions after a delay."""
        try:
            # Get updated frame dimensions
            frame_width = parent_frame.winfo_width()
            frame_height = parent_frame.winfo_height()
            
            if frame_width > 100 and frame_height > 100:
                # Frame is now properly sized, update table dimensions
                table_width = frame_width - 20
                table_height = frame_height - 20
                
                # Update stored dimensions
                self.table_width = table_width
                self.table_height = table_height
                
                # Update canvas size
                if hasattr(self, 'canvas_manager') and self.canvas_manager:
                    self.canvas_manager.canvas.configure(
                        width=table_width, 
                        height=table_height
                    )
                
                print(f"üéØ HandsReviewTab: Retry successful, updated to {table_width}x{table_height}")
                
                # Force table expansion
                self._force_table_expansion()
            else:
                # Still too small, try again via GameDirector
                if hasattr(self, 'game_director') and self.game_director:
                    self.game_director.schedule(100, {
                        "type": "RETRY_FRAME_SIZING",
                        "callback": lambda: self._retry_frame_sizing(parent_frame)
                    })
                else:
                    # Fallback: use timing helper
                    if hasattr(self, 'timing_helper') and self.timing_helper:
                        self.timing_helper.schedule_event(
                            delay_ms=100,
                            timing_type="delayed_action",
                            callback=lambda: self._retry_frame_sizing(parent_frame),
                            component_name="hands_review_tab"
                        )
                
        except Exception as e:
            print(f"‚ö†Ô∏è HandsReviewTab: Retry sizing error: {e}")

    def _force_table_expansion(self):
        """Force the poker table to expand and fill the available space."""
        try:
            # Get the parent frame
            if hasattr(self, 'table_renderer') and self.table_renderer:
                parent_frame = self.table_renderer.master
                
                # Force geometry update
                parent_frame.update_idletasks()
                
                # Configure grid weights to ensure expansion
                parent_frame.grid_columnconfigure(0, weight=1)
                parent_frame.grid_rowconfigure(0, weight=1)
                
                # Force the table renderer to expand
                self.table_renderer.grid_configure(sticky="nsew")
                
                # Update canvas size to fill available space
                if hasattr(self, 'canvas_manager') and self.canvas_manager:
                    # Get current frame dimensions
                    frame_width = parent_frame.winfo_width()
                    frame_height = parent_frame.winfo_height()
                    
                    # Use reasonable dimensions if frame is too small
                    if frame_width <= 100 or frame_height <= 100:
                        frame_width = 800
                        frame_height = 600
                    
                    # Set canvas size to fill frame
                    canvas_width = frame_width - 20  # Leave padding
                    canvas_height = frame_height - 20
                    
                    self.canvas_manager.canvas.configure(
                        width=canvas_width, 
                        height=canvas_height
                    )
                    
                    # Update stored dimensions
                    self.table_width = canvas_width
                    self.table_height = canvas_height
                    
                    print(f"üéØ HandsReviewTab: Forced table expansion to {canvas_width}x{canvas_height}")
                    
        except Exception as e:
            print(f"‚ö†Ô∏è HandsReviewTab: Table expansion error: {e}")

    def _setup_poker_table_state(self):
        """Initialize state management for the poker table."""
        # Initialize display state for the poker table with placeholder data for visual testing
        self.display_state = {
            'table': {
                'width': self.table_width,
                'height': self.table_height
            },
            'pot': {
                'amount': 0.0,
                'side_pots': []
            },
            'seats': [
                # Placeholder seat 1 (top)
                {
                    'player_uid': 'placeholder_1',
                    'name': 'Player 1',
                    'starting_stack': 1000,
                    'current_stack': 1000,
                    'current_bet': 0,
                    'stack': 1000,
                    'bet': 0,
                    'cards': ['Ah', 'Kh'],  # Placeholder hole cards
                    'folded': False,
                    'all_in': False,
                    'acting': False,
                    'position': 0
                },
                # Placeholder seat 2 (bottom) 
                {
                    'player_uid': 'placeholder_2',
                    'name': 'Player 2',
                    'starting_stack': 1000,
                    'current_stack': 1000,
                    'current_bet': 0,
                    'stack': 1000,
                    'bet': 0,
                    'cards': ['Qd', 'Jd'],  # Placeholder hole cards
                    'folded': False,
                    'all_in': False,
                    'acting': False,
                    'position': 1
                }
            ],
            'board': [],  # Empty board initially (will show 5 card backs)
            'street': 'PREFLOP',  # Current street for community card rendering
            'dealer': {
                'position': 0
            },
            'action': {
                'current_player': -1,
                'action_type': None,
                'amount': 0.0,
                'highlight': False
            },
            'replay': {
                'active': False,
                'current_action': 0,
                'total_actions': 0,
                'description': "No hand loaded - showing placeholder state"
            }
        }
        
        print("üéØ HandsReviewTab state management ready with placeholder seats for visual testing")

    def _setup_event_subscriptions(self):
        """Subscribe to relevant events."""
        # Subscribe to review:load events as per architecture doc
        self.event_bus.subscribe(
            self.event_bus.topic(self.session_id, "review:load"),
            self._handle_load_hand_event,
        )

    def _refresh_hands_list(self):
        """Refresh the hands list based on current filters - prioritize GTO hands for PPSM."""
        # Check collection selection
        collection = getattr(self, 'collection_var', None)
        selected_collection = collection.get() if collection else "ü§ñ GTO Hands"
        
        # Load hands based on selection
        if selected_collection == "ü§ñ GTO Hands" and hasattr(self, 'loaded_gto_hands') and self.loaded_gto_hands:
            hands = self.loaded_gto_hands
            hands_source = "GTO"
        else:
            # Repository hands (legendary hands)
            hands = self.hands_repository.get_filtered_hands()
            hands_source = "Repository"

        print(f"üéØ HandsReviewTab: Loading {len(hands)} hands from {hands_source}")

        # Dispatch to store - convert Hand objects to dict format if needed
        hands_for_store = []
        for hand in hands:
            if hasattr(hand, 'metadata'):  # Hand object
                hands_for_store.append({
                    'hand_id': hand.metadata.get('hand_id', 'Unknown'),
                    'players': hand.seats,
                    'pot_size': hand.metadata.get('pot_size', 0)
                })
            else:  # Already dict format
                hands_for_store.append(hand)
                
        self.store.dispatch({"type": SET_REVIEW_HANDS, "hands": hands_for_store})

        # Update UI display
        self.hands_listbox.delete(0, tk.END)
        for i, hand in enumerate(hands):
            try:
                if hasattr(hand, 'metadata'):  # Hand object
                    hand_id = hand.metadata.get('hand_id', f'GTO_Hand_{i+1}')
                    players_count = len(hand.seats) if hasattr(hand, 'seats') else 2
                    display_text = f"{hand_id} | {players_count}p | PPSM Ready"
                else:  # Dict format
                    hand_id = hand.get("hand_id", f"Hand_{i+1}")
                    # GTO hands use 'seats', regular hands use 'players'
                    seats = hand.get("seats", [])
                    players = hand.get("players", [])
                    # Use whichever is available
                    players_count = len(seats) if seats else len(players)
                    pot_size = hand.get("pot_size", 0)
                    small_blind = hand.get("small_blind", 5)
                    big_blind = hand.get("big_blind", 10)
                    
                    details = f"Hand ID: {hand_id}\\n"
                    details += f"Players: {players_count}\\n"
                    details += f"Pot: ${pot_size}\\n"
                    details += f"Blinds: ${small_blind}/${big_blind}\\n"
                    details += f"Source: Repository"
                self.hands_listbox.insert(tk.END, display_text)
            except Exception as e:
                # Fallback display
                self.hands_listbox.insert(tk.END, f"Hand_{i+1} | PPSM")
                print(f"‚ö†Ô∏è Error displaying hand {i}: {e}")

        # Update collections - prioritize GTO hands
        gto_available = hasattr(self, 'loaded_gto_hands') and self.loaded_gto_hands
        if gto_available:
            collections = ["ü§ñ GTO Hands", "All Hands"] + list(
                self.hands_repository.get_collections().keys()
            )
        else:
            collections = ["All Hands"] + list(
                self.hands_repository.get_collections().keys()
            )
        self.collection_combo["values"] = collections

        # Update status with workflow guidance based on active source
        if hands_source == "GTO":
            self._update_status(
                f"ü§ñ GTO Library: {len(hands)} hands loaded for PPSM testing"
            )
        else:
            stats = self.hands_repository.get_stats()
            self._update_status(
                f"üìä Repository: {stats['total_hands']} total, {stats['filtered_hands']} filtered"
            )
        self._update_status(
            "üëÜ SELECT a hand from the list, then click 'LOAD HAND' to begin PPSM study"
        )
        
        # Refresh poker table widget to ensure proper sizing
        if hasattr(self, '_refresh_poker_table_widget'):
            self._refresh_poker_table_widget()

    def _on_theme_change(self):
        """Handle poker table theme change for poker table."""
        theme_name = self.theme_var.get()
        print(f"üé® HandsReviewTab: Switching to theme: {theme_name}")

        # Switch theme in the theme manager
        self.theme.set_profile(theme_name)

        # Update status to show theme change
        self._update_status(
            f"üé® Switched to {theme_name} theme - Poker table colors applied!"
        )

        # Force poker table refresh with new theme
        if hasattr(self, 'table_renderer') and hasattr(self, 'display_state'):
            self._render_poker_table()
            print(f"üé® HandsReviewTab: Re-rendered with {theme_name} theme")

        # Refresh widget sizing to ensure proper fit
        self._refresh_poker_table_widget()

        # Update artistic theme introduction
        self._show_theme_intro(theme_name)

    def _show_theme_intro(self, theme_name):
        """Show artistic introduction for the selected theme with luxury museum placard styling."""
        # Get theme metadata from config-driven system
        metadata = self.theme.get_theme_metadata(theme_name)
        main_desc = metadata.get(
            "intro", "A unique poker table theme with its own distinctive character."
        )
        persona = metadata.get("persona", "")

        # Update the intro label with luxury styling
        self.theme_intro_label.config(state="normal")
        self.theme_intro_label.delete(1.0, tk.END)

        # Insert main description with elegant styling
        self.theme_intro_label.insert(tk.END, main_desc)

        # Add poker persona in italic gold if present
        if persona:
            self.theme_intro_label.insert(tk.END, "\n\n")
            persona_start = self.theme_intro_label.index(tk.INSERT)
            # Format persona with attribution
            persona_text = f"‚Äî {persona} style ‚Äî"
            self.theme_intro_label.insert(tk.END, persona_text)
            persona_end = self.theme_intro_label.index(tk.INSERT)

            # Apply italic styling to persona
            self.theme_intro_label.tag_add("persona", persona_start, persona_end)
            fonts = self.theme.get_fonts()
            persona_font = fonts.get(
                "persona", fonts.get("intro", ("Georgia", 15, "italic"))
            )
            self.theme_intro_label.tag_config("persona", font=persona_font)

        self.theme_intro_label.config(state="disabled")

        # Apply DYNAMIC luxury museum placard styling based on current theme
        theme = self.theme.get_theme()

        # Dynamic theme-aware colors for museum placard
        # Use theme's panel colors but make them more luxurious
        base_bg = theme.get("panel.bg", "#1A1A1A")
        base_border = theme.get("panel.border", "#2A2A2A")
        accent_color = theme.get("table.inlay", theme.get("pot.badgeRing", "#D4AF37"))
        text_primary = theme.get("text.primary", "#F5F5DC")
        text_secondary = theme.get("text.secondary", "#E0E0C0")

        # Use hand-tuned JSON theme colors for perfect quality
        base_colors = self.theme.get_base_colors()

        # Use hand-tuned emphasis tokens for perfect theme-specific quality
        placard_bg = base_colors.get(
            "emphasis_bg_top", base_colors.get("felt", base_bg)
        )
        placard_border = base_colors.get(
            "emphasis_border", base_colors.get("rail", base_border)
        )
        text_color = base_colors.get(
            "emphasis_text", base_colors.get("text", text_primary)
        )
        persona_color = base_colors.get(
            "emphasis_accent_text", base_colors.get("accent", accent_color)
        )
        accent_glow = base_colors.get(
            "highlight", base_colors.get("metal", accent_color)
        )

        # Apply dynamic luxury styling
        self.theme_intro_label.config(
            bg=placard_bg,
            fg=text_color,
            insertbackground=text_color,
            selectbackground=accent_glow,
            selectforeground=base_colors.get("highlight_text", "#FFFFFF"),
        )

        # Style the placard frame with hand-tuned luxury border
        if hasattr(self, "placard_frame"):
            self.placard_frame.config(
                bg=placard_border,  # Hand-tuned theme border color
                relief="raised",
                borderwidth=2,  # Luxury feel
                highlightbackground=accent_glow,
                highlightcolor=accent_glow,
                highlightthickness=1,
            )

        # Apply theme-specific persona text color
        if persona:
            self.theme_intro_label.config(state="normal")
            self.theme_intro_label.tag_config("persona", foreground=persona_color)
            self.theme_intro_label.config(state="disabled")

    def _refresh_ui_colors(self):
        """Refresh poker table with new theme colors."""
        theme = self.theme.get_theme()
        print(f"üé® HandsReviewTab: Refreshing colors for {self.theme_var.get()} theme")

        # Update poker table canvas background with new theme
        if hasattr(self, "canvas_manager") and self.canvas_manager.canvas:
            # Update canvas background to match new theme
            self.canvas_manager.canvas.configure(
                bg=theme.get("table.felt", "#1E5B44")
            )
            print(f"üé® HandsReviewTab: Canvas background updated to {theme.get('table.felt', '#1E5B44')}")

        # Force poker table re-render with new theme
        if hasattr(self, 'table_renderer') and hasattr(self, 'display_state'):
            self._render_poker_table()
            print(f"üé® HandsReviewTab: Re-rendered with new theme colors")

        # Update enhanced buttons to refresh their theme
        for btn_name in ["load_btn", "next_btn", "auto_btn", "reset_btn"]:
            if hasattr(self, btn_name):
                btn = getattr(self, btn_name)
                if hasattr(btn, "refresh_theme"):
                    btn.refresh_theme()

        # Update artistic theme intro panel colors
        if hasattr(self, "theme_intro_label"):
            self._show_theme_intro(self.theme_var.get())

    def _on_library_type_change(self):
        """Handle library type change."""
        library_type = self.library_type.get()
        # TODO: Filter by library type
        self._refresh_hands_list()

    def _on_collection_change(self, event=None):
        """Handle collection selection change."""
        collection = self.collection_var.get()
        print(f"üéØ Collection changed to: {collection}")
        
        if collection == "ü§ñ GTO Hands":
            # GTO hands are handled in _refresh_hands_list()
            pass
        elif collection == "All Hands":
            self.hands_repository.set_filter(HandsFilter())  # Clear filter
        else:
            # TODO: Set filter for specific collection
            pass
        self._refresh_hands_list()

    def _on_hand_select(self, event):
        """Handle hand selection - prioritize GTO hands for PPSM."""
        selection = self.hands_listbox.curselection()
        if selection:
            index = selection[0]
            
            # Get hands from the same source as _refresh_hands_list
            collection = getattr(self, 'collection_var', None)
            selected_collection = collection.get() if collection else "ü§ñ GTO Hands"
            
            if selected_collection == "ü§ñ GTO Hands" and hasattr(self, 'loaded_gto_hands') and self.loaded_gto_hands:
                hands = self.loaded_gto_hands
                hands_source = "GTO"
            else:
                hands = self.hands_repository.get_filtered_hands()
                hands_source = "Repository"
                
            if index < len(hands):
                hand = hands[index]
                self._update_hand_details(hand)
                
                # Get hand ID based on format
                if hasattr(hand, 'metadata'):  # Hand object
                    hand_id = hand.metadata.get('hand_id', 'Unknown')
                else:  # Dict format
                    hand_id = hand.get("hand_id", "Unknown")
                    
                # Show that hand is selected and ready to load
                self._update_status(
                    f"‚úÖ Selected: {hand_id} ({hands_source}) - Click 'LOAD HAND' to start PPSM study"
                )

    def _update_hand_details(self, hand_data):
        """Update the hand details display - works with both Hand objects and dicts."""
        self.details_text.delete(1.0, tk.END)
        
        try:
            # Handle both Hand objects and dict format
            if hasattr(hand_data, 'metadata'):  # Hand object
                hand_id = hand_data.metadata.get('hand_id', 'Unknown')
                small_blind = hand_data.metadata.get('small_blind', 5)
                big_blind = hand_data.metadata.get('big_blind', 10)
                players_count = len(hand_data.seats) if hasattr(hand_data, 'seats') else 0
                
                details = f"Hand ID: {hand_id}\\n"
                details += f"Players: {players_count}\\n"
                details += f"Blinds: ${small_blind}/${big_blind}\\n"
                details += f"Engine: PPSM Ready\\n"
                details += f"Source: GTO Dataset"
                
            else:  # Dict format
                hand_id = hand_data.get("hand_id", "Unknown")
                # GTO hands use 'seats', regular hands use 'players'
                seats = hand_data.get("seats", [])
                players = hand_data.get("players", [])
                # Use whichever is available
                players_count = len(seats) if seats else len(players)
                pot_size = hand_data.get("pot_size", 0)
                small_blind = hand_data.get("small_blind", 5)
                big_blind = hand_data.get("big_blind", 10)
                
                details = f"Hand ID: {hand_id}\\n"
                details += f"Players: {players_count}\\n"
                details += f"Pot: ${pot_size}\\n"
                details += f"Blinds: ${small_blind}/${big_blind}\\n"
                details += f"Source: Repository"
                
        except Exception as e:
            details = f"Hand details unavailable: {e}"
            
        self.details_text.insert(1.0, details)

    def _on_study_mode_change(self):
        """Handle study mode change."""
        mode = self.study_mode.get()
        self.store.dispatch({"type": SET_STUDY_MODE, "mode": mode})
        self._update_status(f"üìö Study mode: {mode}")

    def _apply_filters(self):
        """Apply current filter settings."""
        filter_criteria = HandsFilter()

        # Apply position filter
        if self.position_var.get() != "All":
            filter_criteria.positions = [self.position_var.get()]

        # Apply stack depth filter
        try:
            filter_criteria.min_stack_depth = (
                int(self.min_stack.get()) if self.min_stack.get() else None
            )
            filter_criteria.max_stack_depth = (
                int(self.max_stack.get()) if self.max_stack.get() else None
            )
        except ValueError:
            pass

        # Apply pot type filter
        if self.pot_type_var.get() != "All":
            filter_criteria.pot_type = self.pot_type_var.get()

        # Apply search text
        filter_criteria.search_text = self.search_var.get()

        # Set filter and refresh
        self.hands_repository.set_filter(filter_criteria)
        self.store.dispatch(
            {"type": SET_REVIEW_FILTER, "filter": filter_criteria.__dict__}
        )
        self._refresh_hands_list()

    def _load_selected_hand(self):
        """Load the selected hand for PPSM study."""
        selection = self.hands_listbox.curselection()
        if not selection:
            self._update_status("‚ùå Please select a hand to load")
            return

        index = selection[0]
        
        # Get hands from the same source as _refresh_hands_list
        collection = getattr(self, 'collection_var', None)
        selected_collection = collection.get() if collection else "ü§ñ GTO Hands"
        
        if selected_collection == "ü§ñ GTO Hands" and hasattr(self, 'loaded_gto_hands') and self.loaded_gto_hands:
            hands = self.loaded_gto_hands
            hands_source = "GTO"
        else:
            hands = self.hands_repository.get_filtered_hands()
            hands_source = "Repository"
            
        if index >= len(hands):
            return

        hand_data = hands[index]
        
        print(f"üéØ Loading {hands_source} hand for PPSM study...")

        # Publish load event as per architecture doc
        self.event_bus.publish(
            self.event_bus.topic(self.session_id, "review:load"), hand_data
        )

    def _handle_load_hand_event(self, hand_data):
        """Handle the review:load event - pure UI logic only."""
        try:
            hand_id = hand_data.get("metadata", {}).get("hand_id", "Unknown")
            self._update_status(f"üîÑ Loading hand {hand_id}...")

            # Store hand data for reset functionality
            self.current_hand_data = hand_data

            # Use session manager to load hand (business logic)
            if self.session_manager:
                session_state = self.session_manager.load_hand(hand_data)
                
                # Update UI based on session state
                total_actions = session_state.total_actions
                if total_actions > 0:
                    self.progress_label.config(
                        text=f"Hand loaded: {total_actions} actions"
                    )
                    print(f"üéØ HandsReviewTab: Hand {hand_id} loaded with {total_actions} actions")
                else:
                    self.progress_label.config(text="No actions available")
                    print(f"‚ö†Ô∏è HandsReviewTab: Hand {hand_id} loaded but no actions found")
                
                self._update_status(f"‚úÖ Hand {hand_id} loaded via session manager")
            else:
                self._update_status(f"‚ùå Session manager not available")
                print(f"‚ùå HandsReviewTab: Session manager not available")

        except Exception as e:
            print(f"‚ùå HandsReviewTab: Error loading hand: {e}")
            self._update_status(f"‚ùå Error loading hand: {e}")

    def _toggle_auto_play(self):
        """Toggle poker table auto-play mode."""
        if not hasattr(self, 'hand_actions') or not self.hand_actions:
            print("‚ö†Ô∏è HandsReviewTab: No hand actions available for auto-play")
            return
        
        if not hasattr(self, 'auto_play_active'):
            self.auto_play_active = False
        
        self.auto_play_active = not self.auto_play_active
        
        if self.auto_play_active:
            print("üé¨ HandsReviewTab: Auto-play started")
            self.auto_btn.config(text="Stop Auto")
            self._run_auto_play()
        else:
            print("‚èπÔ∏è HandsReviewTab: Auto-play stopped")
            self.auto_btn.config(text="Auto")

    def _run_auto_play(self):
        """Run poker table auto-play using GameDirector."""
        if not hasattr(self, 'auto_play_active') or not self.auto_play_active:
            return
        
        if self.current_action_index >= len(self.hand_actions):
            self.auto_play_active = False
            self.auto_btn.config(text="Auto")
            print("‚úÖ HandsReviewTab: Auto-play complete")
            return
        
        # Use GameDirector for coordinated action execution
        if hasattr(self, 'game_director'):
            self.game_director.play()
            print("üé¨ GameDirector: Auto-play started")
        else:
            # ARCHITECTURE COMPLIANT: Use GameDirector for timing
            self._next_action()
            if hasattr(self, 'game_director') and self.game_director:
                self.game_director.schedule(1000, {
                    "type": "AUTO_PLAY_NEXT",
                    "callback": self._run_auto_play
                })
            else:
                print("‚ö†Ô∏è GameDirector not available for auto-play timing")



    def _update_status(self, message: str):
        """Update the status display."""
        self.status_text.insert(tk.END, f"\n{message}")
        self.status_text.see(tk.END)

    def _on_store_change(self, state):
        """Handle store state changes for poker table rendering."""
        try:
            # Check if we have poker table state to update
            if hasattr(self, 'display_state') and 'poker_table' in state:
                # Update local display state from store
                self.display_state.update(state['poker_table'])
                
                # Re-render the table with updated state
                self._render_poker_table()
                
                # Handle animation events
                if 'animation_event' in state.get('poker_table', {}):
                    self._handle_animation_event(
                        state['poker_table']['animation_event']
                    )
                    
                print("üîÑ HandsReviewTab: State updated from store")
        except Exception as e:
            print(f"‚ö†Ô∏è HandsReviewTab: Store change handling error: {e}")

    def _handle_animation_event(self, animation_event):
        """Handle animation events from the store."""
        try:
            if animation_event.get('action') == 'clear_highlight':
                self._clear_highlight()
                print("üé¨ HandsReviewTab: Animation event processed")
        except Exception as e:
            print(f"‚ö†Ô∏è HandsReviewTab: Animation event handling error: {e}")

    def _refresh_fonts(self):
        """Refresh fonts after theme changes."""
        fonts = self.theme.get_fonts()

        # Update listbox font
        if hasattr(self, "hands_listbox"):
            body_font = fonts.get("body", ("Consolas", 20))
            self.hands_listbox.configure(font=body_font)

        # Update text areas
        small_font = fonts.get("small", ("Consolas", 16))
        if hasattr(self, "details_text"):
            self.details_text.configure(font=small_font)
        if hasattr(self, "status_text"):
            self.status_text.configure(font=small_font)

        # Update theme intro label font (luxury serif)
        if hasattr(self, "theme_intro_label"):
            intro_font = fonts.get(
                "intro", fonts.get("body", ("Georgia", 16, "normal"))
            )
            self.theme_intro_label.configure(font=intro_font)
    
    def _start_update_loop(self):
        """Start the main update loop for GameDirector and EffectBus."""
        def update_loop():
            try:
                # Update GameDirector
                if hasattr(self, 'game_director'):
                    self.game_director.update()
                
                # Update EffectBus
                if hasattr(self, 'effect_bus'):
                    self.effect_bus.update()
                
                # Schedule next update (60 FPS)
                self.after(16, update_loop)
                
            except Exception as e:
                print(f"‚ö†Ô∏è Update loop error: {e}")
                # Continue update loop even if there's an error
                self.after(16, update_loop)
        
        # Start the update loop
        update_loop()
        print("üîÑ Update loop started for GameDirector and EffectBus")
    
    def _start_ui_tick_loop(self):
        """Start the UI tick loop for GameDirector and EffectBus every ~16ms."""
        def _tick():
            try:
                # Pump GameDirector and EffectBus every ~16ms (60 FPS)
                if hasattr(self, 'game_director'):
                    self.game_director.update(16.7)  # pump scheduled events
                if hasattr(self, 'effect_bus'):
                    self.effect_bus.update()  # if bus keeps any transient state
            except Exception as e:
                print(f"‚ö†Ô∏è UI tick loop error: {e}")
            finally:
                # Schedule next tick
                self.after(16, _tick)
        
        # Start the tick loop
        _tick()
        print("‚è±Ô∏è UI tick loop started for GameDirector and EffectBus (60 FPS)")

    def _handle_renderer_intent(self, intent: dict):
        """Handle intents emitted by PokerTableRenderer (state-driven).
        Currently forwards REQUEST_ANIMATION to EffectBus via event bus.
        """
        try:
            t = intent.get("type")
            if t == "REQUEST_ANIMATION" and hasattr(self, 'event_bus'):
                payload = intent.get("payload", {})
                name = payload.get("name")
                # Map declarative types to bridge names if not provided
                if not name:
                    et = payload.get("type")
                    if et == "CHIP_TO_POT":
                        name = "chips_to_pot"
                    elif et == "POT_TO_WINNER":
                        name = "pot_to_winner"
                self.event_bus.publish("effect_bus:animate", {"name": name, "args": payload})
        except Exception:
            pass
    
    def _setup_action_banner(self):
        """Setup ActionBanner and connect it to EffectBus events."""
        try:
            if ActionBanner:
                # Create ActionBanner at the top of the poker table section
                self.action_banner = ActionBanner(self)
                
                # Subscribe to EffectBus banner events
                if hasattr(self, 'event_bus'):
                    self.event_bus.subscribe("effect_bus:banner_show", self._handle_banner_event)

                # Subscribe to EffectBus animation events
                if hasattr(self, 'event_bus'):
                    self.event_bus.subscribe("effect_bus:animate", self._handle_effect_animate)
                    print("üéûÔ∏è Animation: Connected to EffectBus events")
                    print("üé≠ ActionBanner: Connected to EffectBus events")
                else:
                    print("‚ö†Ô∏è ActionBanner: No event bus available")
            else:
                print("‚ö†Ô∏è ActionBanner: Not available, skipping setup")
                
        except Exception as e:
            print(f"‚ö†Ô∏è ActionBanner: Setup error: {e}")
    
    def _handle_banner_event(self, event_data):
        """Handle banner events from EffectBus."""
        try:
            if hasattr(self, 'action_banner'):
                message = event_data.get('message', '')
                banner_type = event_data.get('banner_type', 'info')
                duration_ms = event_data.get('duration_ms', 3000)
                
                self.action_banner.show_banner(message, banner_type, duration_ms)
                print(f"üé≠ ActionBanner: Showing banner: {message}")
            else:
                print("‚ö†Ô∏è ActionBanner: Not available for banner event")
                
        except Exception as e:
            print(f"‚ö†Ô∏è ActionBanner: Banner event error: {e}")

        # Update enhanced button themes (handles both fonts and colors)
        enhanced_buttons = []
        if hasattr(self, "load_btn") and hasattr(self.load_btn, "refresh_theme"):
            enhanced_buttons.append(self.load_btn)
        if hasattr(self, "next_btn") and hasattr(self.next_btn, "refresh_theme"):
            enhanced_buttons.append(self.next_btn)
        if hasattr(self, "auto_btn") and hasattr(self.auto_btn, "refresh_theme"):
            enhanced_buttons.append(self.auto_btn)
        if hasattr(self, "reset_btn") and hasattr(self.reset_btn, "refresh_theme"):
            enhanced_buttons.append(self.reset_btn)

        for btn in enhanced_buttons:
            btn.refresh_theme()

    def _handle_effect_animate(self, payload):
        """Handle animation requests from EffectBus using ChipAnimations where possible."""
        try:
            name = (payload or {}).get("name")
            ms = int((payload or {}).get("ms", 300))
            if not getattr(self, "canvas_manager", None):
                return
            c = self.canvas_manager.canvas
            
            # Get theme manager from the correct location
            theme_manager = getattr(self, 'theme', None)
            if not theme_manager:
                print("‚ö†Ô∏è No theme manager available for animations")
                return
                
            from ..tableview.components.chip_animations import ChipAnimations
            anim = ChipAnimations(theme_manager)
            
            # Get proper pot center from display state
            pot_center = (self.canvas_manager.canvas.winfo_width() // 2, 
                         int(self.canvas_manager.canvas.winfo_height() * 0.52))
            
            # Get seat positions for proper animation coordinates
            seats = self.display_state.get("seats", [])
            if not seats:
                return
                
            # Get consistent seat positions for animation
            w, h = self.canvas_manager.size()
            from ..state.selectors import get_seat_positions
            seat_positions = get_seat_positions(self.display_state, seat_count=len(seats), 
                                              canvas_width=w, canvas_height=h)
            
            if name == "betting_action":
                # Handle betting actions (BET, RAISE, CALL, CHECK, FOLD)
                action_type = (payload or {}).get("action_type", "UNKNOWN")
                actor_uid = (payload or {}).get("actor_uid", "Unknown")
                
                print(f"üé¨ Betting action animation: {action_type} by {actor_uid}")
                
                # Find the acting player for source position with robust normalization
                def _norm(v):
                    return str(v).strip().lower()

                actor_norm = _norm(actor_uid)
                acting_seat = None

                # Build lookup maps
                uid_to_idx = { _norm(s.get('player_uid')): i for i, s in enumerate(seats) }
                name_to_idx = { _norm(s.get('name', '')): i for i, s in enumerate(seats) }

                # Prefer player_uid
                if actor_norm in uid_to_idx:
                    acting_seat = seats[uid_to_idx[actor_norm]]
                elif actor_norm in name_to_idx:
                    acting_seat = seats[name_to_idx[actor_norm]]
                
                if acting_seat:
                    # Get seat position using consistent positioning
                    seat_idx = seats.index(acting_seat)
                    if seat_idx < len(seat_positions):
                        sx, sy = seat_positions[seat_idx]
                        
                        print(f"üé¨ Animating {action_type} from seat {seat_idx} ({sx}, {sy}) to pot ({pot_center[0]}, {pot_center[1]})")
                        
                        # Different animation based on action type
                        if action_type in ["BET", "RAISE", "CALL"]:
                            # Animate chips to pot
                            anim.fly_chips_to_pot(c, sx, sy, pot_center[0], pot_center[1], amount=200, callback=None)
                        elif action_type == "CHECK":
                            # Visual feedback for check (no chips)
                            print(f"üé¨ Check action - no chip animation needed")
                        elif action_type == "FOLD":
                            # Visual feedback for fold (maybe card flip or seat dimming)
                            print(f"üé¨ Fold action - seat dimming effect")
                else:
                    print(f"‚ö†Ô∏è No seat found for actor {actor_uid} in betting action animation")
                    
            elif name == "chips_to_pot":
                # This should ONLY happen at end of street (DEAL_BOARD, DEAL_TURN, DEAL_RIVER)
                # NOT during betting rounds
                print(f"üé¨ End-of-street animation: chips flying to pot")
                
                # Find the acting player for source position
                acting_seat = None
                for seat in seats:
                    if seat.get('acting', False):
                        acting_seat = seat
                        break
                
                if acting_seat:
                    # Get seat position using consistent positioning
                    seat_idx = seats.index(acting_seat)
                    if seat_idx < len(seat_positions):
                        sx, sy = seat_positions[seat_idx]
                        
                        print(f"üé¨ Animating chips from seat {seat_idx} ({sx}, {sy}) to pot ({pot_center[0]}, {pot_center[1]})")
                        anim.fly_chips_to_pot(c, sx, sy, pot_center[0], pot_center[1], amount=200, callback=None)
                else:
                    print("‚ö†Ô∏è No acting seat found for chips_to_pot animation")
                    
            elif name == "pot_to_winner":
                # This is for showdown/end of hand
                print(f"üé¨ Showdown animation: pot flying to winner")
                
                # Find winner seat
                winner = None
                for seat in seats:
                    if not seat.get("folded", False):
                        winner = seat
                        break
                
                if winner:
                    # Get winner position using consistent positioning
                    winner_idx = seats.index(winner)
                    if winner_idx < len(seat_positions):
                        wx, wy = seat_positions[winner_idx]
                        
                        print(f"üé¨ Animating pot to winner {winner.get('name', 'Unknown')} at ({wx}, {wy})")
                        anim.fly_pot_to_winner(c, pot_center[0], pot_center[1], wx, wy, amount=200, callback=None)
                else:
                    print("‚ö†Ô∏è No winner found for pot_to_winner animation")
                    
        except Exception as e:
            print(f"‚ö†Ô∏è Animation handler error: {e}")
            import traceback
            traceback.print_exc()

    def _style_theme_radio_buttons(self):
        """Apply theme-specific styling to radio buttons to eliminate default green highlights."""
        if not hasattr(self, "theme_radio_buttons"):
            return

        try:
            # Get current theme and highlight colors
            current_theme_name = self.theme.current() or "Forest Green Professional üåø"
            theme = self.theme.get_theme()

            # Create a custom style for radio buttons
            style = ttk.Style()

            # Apply config-driven selection styling
            selection_styler = self.theme.get_selection_styler()
            if selection_styler:
                theme_id = self.theme.get_current_theme_id()
                selection_styler.apply_selection_styles(style, theme_id)

            # Get selection highlight colors (config-driven with legacy fallback)
            try:
                base_colors = self.theme.get_base_colors()
                selection_color = base_colors.get(
                    "highlight", base_colors.get("accent", "#D4AF37")
                )
                selection_glow = base_colors.get(
                    "metal", base_colors.get("accent", "#C9A34E")
                )
            except Exception:
                # Get selection highlight from config-driven system
                base_colors = self.theme.get_base_colors()
                selection_highlight = {
                    "color": base_colors.get(
                        "highlight", base_colors.get("accent", "#D4AF37")
                    )
                }
                selection_color = selection_highlight["color"]
                selection_glow = selection_highlight.get("glow", "#C9A34E")

            # Configure the radio button style with theme-specific colors
            style.configure(
                "Themed.TRadiobutton",
                background=theme.get("panel.bg", "#1F2937"),
                foreground=theme.get("panel.fg", "#E5E7EB"),
                focuscolor=selection_color,
            )

            # Configure the selection/active state colors
            style.map(
                "Themed.TRadiobutton",
                background=[
                    ("active", theme.get("panel.bg", "#1F2937")),
                    ("selected", theme.get("panel.bg", "#1F2937")),
                ],
                foreground=[
                    ("active", theme.get("panel.fg", "#E5E7EB")),
                    ("selected", theme.get("panel.fg", "#E5E7EB")),
                ],
                indicatorcolor=[
                    ("selected", selection_color),
                    ("active", selection_glow),
                    ("!selected", theme.get("panel.border", "#374151")),
                ],
            )

            # Apply the custom style to all radio buttons
            for radio_btn in self.theme_radio_buttons:
                if radio_btn.winfo_exists():
                    radio_btn.configure(style="Themed.TRadiobutton")

        except Exception as e:
            # Fallback styling if custom styling fails
            print(f"‚ö†Ô∏è Radio button styling failed: {e}")
            pass


    def _next_action(self):
        """Dispatch next action intent - pure UI logic only."""
        print("üéØ NEXT_ACTION: Button clicked!")

        # ARCHITECTURE COMPLIANT: Dispatch action to Store instead of direct service call
        try:
            self.store.dispatch({
                "type": "HANDS_REVIEW_NEXT_ACTION",
                "session_id": self.session_id,
                "timestamp": time.time()
            })
            print("üéØ NEXT_ACTION: Action dispatched to Store")
        except Exception as e:
            print(f"‚ö†Ô∏è NEXT_ACTION: Failed to dispatch action: {e}")
            self._update_status(f"‚ùå Error dispatching next action: {e}")
    
    def _render_table_with_state(self, session_state):
        """Render poker table with session state - pure UI logic only."""
        try:
            # Convert session state to PokerTableState
            from ..table.state import PokerTableState
            
            table_state = PokerTableState(
                table=session_state.table,
                seats=session_state.seats,
                board=session_state.board,
                pot=session_state.pot,
                dealer=session_state.dealer,
                action=session_state.action,
                animation=session_state.animation,
                effects=session_state.effects,
                street=session_state.street
            )
            
            # Render using PokerTableRenderer
            if hasattr(self, 'table_renderer') and self.table_renderer:
                self.table_renderer.render(table_state)
                print("üéØ HandsReviewTab: Table rendered with session state")
            else:
                print("‚ö†Ô∏è HandsReviewTab: Table renderer not available")
                
        except Exception as e:
            print(f"‚ö†Ô∏è HandsReviewTab: Error rendering table: {e}")

    def _reset_hand(self):
        """Reset the current hand to the beginning - pure UI logic only."""
        if not self.session_manager:
            self._update_status("‚ö†Ô∏è Session manager not available")
            return

        try:
            # Reset hand via session manager (business logic)
            if hasattr(self, "last_loaded_hand") and self.last_loaded_hand:
                session_state = self.session_manager.load_hand(self.last_loaded_hand)
                self._update_status("üîÑ Hand reset to beginning")
                
                # Render table with reset state
                self._render_table_with_state(session_state)
            else:
                self._update_status("‚ö†Ô∏è No hand to reset")
        except Exception as e:
            self._update_status(f"‚ùå Error resetting hand: {e}")

    def on_show(self):
        """Called when tab is shown - refresh display."""
        if hasattr(self, "renderer_pipeline"):
            state = self.store.get_state()
            self.renderer_pipeline.render_once(state)

    def dispose(self):
        """Clean up when tab is closed."""
        # ARCHITECTURE COMPLIANT: Notify event controller of session disposal
        try:
            if hasattr(self, 'event_bus') and self.event_bus:
                self.event_bus.publish(
                    "hands_review:session_disposed",
                    {"session_id": self.session_id}
                )
                print(f"üéØ HandsReviewTab: Session {self.session_id} disposal notified")
        except Exception as e:
            print(f"‚ö†Ô∏è HandsReviewTab: Failed to notify session disposal: {e}")
        
        # Clean up session manager if active
        if self.session_manager:
            self.session_manager.cleanup()
            self.session_manager = None
        self.services.dispose_session(self.session_id)

    def _load_gto_hands(self):
        """Load GTO hands for PPSM testing."""
        try:
            import json
            import os
            
            gto_hands_file = "gto_hands.json"
            print(f"üîç Looking for GTO hands file: {gto_hands_file}")
            
            if os.path.exists(gto_hands_file):
                print(f"üìÇ Found GTO hands file, loading...")
                with open(gto_hands_file, 'r') as f:
                    hands_data = json.load(f)
                    
                print(f"üìä Raw GTO hands data: {len(hands_data)} hands")
                    
                # Convert to Hand objects
                self.loaded_gto_hands = []
                for i, hand_data in enumerate(hands_data):
                    try:
                        hand = Hand(**hand_data)  # Create proper Hand object
                        self.loaded_gto_hands.append(hand)
                    except Exception as e:
                        print(f"‚ö†Ô∏è Error creating Hand object for hand {i}: {e}")
                        # Fallback: store as dict
                        self.loaded_gto_hands.append(hand_data)
                        
                print(f"‚úÖ Loaded {len(self.loaded_gto_hands)} GTO hands for PPSM testing")
            else:
                print(f"‚ö†Ô∏è GTO hands file not found: {gto_hands_file}")
                self.loaded_gto_hands = []
                
        except Exception as e:
            print(f"‚ö†Ô∏è Error loading GTO hands: {e}")
            self.loaded_gto_hands = []

    def _load_hand(self, hand_data):
        """Load hand data into poker table using new architecture."""
        try:
            # Store the hand data for reference
            self.current_hand_data = hand_data
            
            # Flatten hand actions for step-by-step replay
            self.hand_actions = self._flatten_hand_for_replay(hand_data)
            
            # Reset action index
            self.current_action_index = 0
            
            # Create display state from hand data
            new_display_state = self._create_display_state_from_hand(hand_data)
            
            # Update the existing display state with new data
            self.display_state.update(new_display_state)
            
            # Dispatch LOAD_REVIEW_HAND action to store
            self.store.dispatch({
                "type": "LOAD_REVIEW_HAND",
                "hand_data": hand_data,
                "flattened_actions": self.hand_actions
            })
            
            # Update progress display
            if self.hand_actions:
                progress_text = f"Action {self.current_action_index + 1}/{len(self.hand_actions)}"
                self.progress_label.config(text=progress_text)
                # Enable next button
                self.next_btn.config(state="normal")
                
                # Setup GameDirector for this hand
                if hasattr(self, 'game_director'):
                    self.game_director.set_total_steps(len(self.hand_actions))
                    self.game_director.set_advance_callback(self._execute_action_at_index)
                    print(f"üé¨ GameDirector: Configured for {len(self.hand_actions)} actions")
            
            # Render the table
            self._render_poker_table()
            
            # Refresh widget to ensure proper sizing
            self._refresh_poker_table_widget()
            
            print(f"‚úÖ HandsReviewTab: Hand loaded with {len(self.hand_actions)} actions")
        
        except Exception as e:
            print(f"‚ö†Ô∏è HandsReviewTab: Error loading hand: {e}")

    def _create_display_state_from_hand(self, hand_data):
        """Create display state from hand data for poker table."""
        try:
            # Debug: Log the raw hand data
            print(f"üéØ Creating display state from hand data:")
            print(f"   Hand data type: {type(hand_data)}")
            print(f"   Hand data keys: {list(hand_data.keys()) if hasattr(hand_data, 'keys') else 'N/A'}")
            
            # Handle both Hand objects and dict format
            if hasattr(hand_data, 'seats'):  # Hand object
                seats = hand_data.seats
                metadata = hand_data.metadata
                print(f"   Using Hand object: {len(seats)} seats")
            else:  # Dict format
                seats = hand_data.get('seats', [])
                metadata = hand_data.get('metadata', {})
                print(f"   Using dict format: {len(seats)} seats")
            
            print(f"   Raw seats data: {seats}")
            print(f"   Metadata: {metadata}")
            
            # Extract basic hand information
            small_blind = metadata.get('small_blind', 5) if metadata else 5
            big_blind = metadata.get('big_blind', 10) if metadata else 10
            
            print(f"   Extracted {len(seats)} seats, SB: {small_blind}, BB: {big_blind}")
            
            # Create initial display state with actual table dimensions
            display_state = {
                'table': {
                    'width': getattr(self, 'table_width', 800),
                    'height': getattr(self, 'table_height', 600),
                    'theme': 'luxury_noir'  # Default theme
                },
                'pot': {
                    'amount': 0,
                    'position': (400, 300)
                },
                'seats': [],
                'board': [],
                'dealer': {'position': 0},
                'action': {'type': None, 'player': None, 'amount': 0},
                'replay': {'current_step': 0, 'total_steps': 0}
            }
            
            # Set up seats from GTO hand data
            for i, seat in enumerate(seats):
                player_uid = seat.get('player_uid', f'player_{i}')
                name = seat.get('display_name', f'Player {i+1}')
                starting_stack = seat.get('starting_stack', 1000)
                
                # Calculate seat position (simplified for now)
                angle = (2 * 3.14159 * i) / len(seats)
                radius = 200
                x = 400 + int(radius * math.cos(angle))
                y = 300 + int(radius * math.sin(angle))
                
                # Get hole cards for this player from metadata
                if hasattr(hand_data, 'metadata') and hasattr(hand_data.metadata, 'hole_cards'):
                    hole_cards = hand_data.metadata.hole_cards.get(player_uid, [])
                else:
                    hole_cards = metadata.get('hole_cards', {}).get(player_uid, [])
                
                seat_data = {
                    'player_uid': player_uid,
                    'name': name,
                    'starting_stack': starting_stack,
                    'current_stack': starting_stack,
                    'current_bet': 0,
                    # Backwards-compatible keys used by renderer components
                    'stack': starting_stack,
                    'bet': 0,
                    'cards': hole_cards,  # Populate with actual hole cards
                    'folded': False,
                    'all_in': False,
                    'acting': False,
                    'position': i
                }
                
                # Set initial blinds based on seat order
                if i == 0:  # Small blind
                    seat_data['current_bet'] = small_blind
                    seat_data['current_stack'] -= small_blind
                    seat_data['bet'] = seat_data['current_bet']
                    seat_data['stack'] = seat_data['current_stack']
                    seat_data['position'] = 'SB'
                elif i == 1:  # Big blind
                    seat_data['current_bet'] = big_blind
                    seat_data['current_stack'] -= big_blind
                    seat_data['bet'] = seat_data['current_bet']
                    seat_data['stack'] = seat_data['current_stack']
                    seat_data['position'] = 'BB'
                
                display_state['seats'].append(seat_data)
                print(f"   ü™ë Created seat {i}: {name} at ({x}, {y}) with cards {hole_cards}")
            
            print(f"üéØ HandsReviewTab: Created display state with {len(display_state['seats'])} seats")
            for seat in display_state['seats']:
                print(f"  ü™ë {seat['name']}: {seat['cards']} (stack: {seat['current_stack']}, bet: {seat['current_bet']})")
            
            return display_state
            
        except Exception as e:
            print(f"‚ö†Ô∏è HandsReviewTab: Error creating display state: {e}")
            import traceback
            traceback.print_exc()
            return {}

    def _flatten_hand_for_replay(self, hand):
        """Produce a list of 'steps' to drive the poker table UI."""
        steps = []

        # Synthesize: deal hole cards
        holes = (hand.get("metadata", {}) or {}).get("hole_cards", {}) or {}
        steps.append({
            "type": "DEAL_HOLE",
            "desc": "üÉè Deal hole cards",
            "payload": {"hole_cards": holes},
        })

        streets = hand.get("streets", {}) or {}
        # Keep deterministic street order
        for street_name in ("PREFLOP", "FLOP", "TURN", "RIVER"):
            if street_name not in streets:
                continue
            s = streets[street_name] or {}
            actions = s.get("actions", []) or []
            board = s.get("board", []) or []

            # If board present, add board-deal step
            if street_name != "PREFLOP" and board:
                steps.append({
                    "type": "DEAL_BOARD",
                    "desc": f"üÇ† Deal {street_name} board: {', '.join(board)}",
                    "payload": {"street": street_name, "board": board},
                })

            for a in actions:
                # Handle different action types
                action_type = a.get("action", "UNKNOWN")
                actor = a.get("actor_uid", "Unknown")
                amount = a.get("amount", 0)
                
                if action_type == "POST_BLIND":
                    desc = f"{street_name}: {actor} ‚Üí {action_type} {amount}"
                elif action_type in ["BET", "RAISE", "CALL"]:
                    desc = f"{street_name}: {actor} ‚Üí {action_type} {amount}"
                elif action_type == "CHECK":
                    desc = f"{street_name}: {actor} ‚Üí {action_type}"
                elif action_type == "FOLD":
                    desc = f"{street_name}: {actor} ‚Üí {action_type}"
                else:
                    desc = f"{street_name}: {actor} ‚Üí {action_type} {amount if amount else ''}"
                
                steps.append({
                    "type": action_type,
                    "desc": desc,
                    "payload": {"street": street_name, **a},
                })

        # Terminal step
        steps.append({"type": "END_HAND", "desc": "‚úÖ End of hand", "payload": {}})
        return steps

    def _render_poker_table(self):
        """Render the poker table using the component pipeline."""
        try:
            # Debug: Log what's in the display state
            print(f"üéØ Rendering table with state:")
            print(f"   Seats: {len(self.display_state.get('seats', []))}")
            print(f"   Board: {self.display_state.get('board', [])}")
            print(f"   Pot: {self.display_state.get('pot', {}).get('amount', 0)}")
            
            if self.display_state.get('seats'):
                for i, seat in enumerate(self.display_state['seats']):
                    print(f"   Seat {i}: {seat}")
            
            # Build PokerTableState and render
            try:
                from ..table.state import PokerTableState
            except Exception:
                # Inline lightweight structure if import fails
                class PokerTableState(dict):
                    pass

            state = PokerTableState(
                table={"width": self.table_width, "height": self.table_height},
                seats=self.display_state.get('seats', []),
                board=self.display_state.get('board', []),
                pot=self.display_state.get('pot', {}),
                dealer={"position": self.display_state.get('dealer', 0)},
                action=self.display_state.get('action', {}),
                animation={},
                effects=list(self._pending_effects),
                street=self.display_state.get('street', 'PREFLOP'),  # Pass street for community cards
            )
            # Clear effects after issuing
            self._pending_effects.clear()
            
            # Let PokerTableRenderer handle its own readiness checking and deferral
            print("üéØ HandsReviewTab: Attempting to render via PokerTableRenderer")
                
            self.table_renderer.render(state)
            print("üé® HandsReviewTab: Table rendered successfully (state-driven)")
        except Exception as e:
            print(f"‚ö†Ô∏è HandsReviewTab: Render error: {e}")
            import traceback
            traceback.print_exc()


    
    def _execute_action_step(self, action):
        """Execute a single action step and update display state."""
        try:
            action_type = action.get('type', 'UNKNOWN')
            payload = action.get('payload', {})
            
            # Get player name for effects
            actor_uid = payload.get('actor_uid', 'Unknown')
            player_name = None
            for seat in self.display_state['seats']:
                if seat['player_uid'] == actor_uid:
                    player_name = seat.get('name', actor_uid)
                    break
            

            # Update acting highlight: set only the actor as acting
            try:
                for s in self.display_state.get('seats', []):
                    s['acting'] = (s.get('player_uid') == actor_uid)
            except Exception:
                pass
                
            # optional: re-render to reflect highlight immediately
            try:
                self.renderer_pipeline.render_once(self.display_state)
            except Exception:
                pass
            
            if action_type == "DEAL_HOLE":
                # Hole cards are already loaded in initial state
                print(f"üÉè HandsReviewTab: Hole cards dealt")
                
                # Add deal sound and animation effects
                if hasattr(self, 'effect_bus'):
                    self.effect_bus.add_poker_action_effects("DEAL_HOLE", player_name)
                
            elif action_type == "DEAL_BOARD":
                street = payload.get('street', 'UNKNOWN')
                board = payload.get('board', [])
                self.display_state['board'] = board
                self.display_state['street'] = street  # Update street for community card rendering
                print(f"üÇ† HandsReviewTab: Dealt {street} board: {board}")
                
                # Add deal sound and animation effects
                if hasattr(self, 'effect_bus'):
                    self.effect_bus.add_poker_action_effects("DEAL_BOARD", player_name)
                
                # Professional poker behavior: Animate chips to pot at end of street
                # This clears all bet chips from in front of players and moves them to pot
                if street in ["FLOP", "TURN", "RIVER"]:
                    try:
                        from ..state.selectors import get_seat_positions
                        w, h = self.table_renderer.canvas_manager.size() if hasattr(self, 'table_renderer') else (self.table_width, self.table_height)
                        positions = get_seat_positions(self.display_state, seat_count=len(self.display_state.get('seats', [])), canvas_width=w, canvas_height=h)
                        
                        # Find any seat with bets to animate from (use first betting seat)
                        for seat_idx, seat in enumerate(self.display_state.get('seats', [])):
                            if seat.get('current_bet', 0) > 0 and seat_idx < len(positions):
                                fx, fy = positions[seat_idx]
                                pot_x, pot_y = (w // 2, int(h * 0.58))
                                self._pending_effects.append({
                                    "type": "CHIP_TO_POT",
                                    "from_x": int(fx), "from_y": int(fy),
                                    "to_x": pot_x, "to_y": pot_y,
                                    "amount": seat.get('current_bet', 0),
                                })
                                print(f"üé¨ End-of-street: Moving chips from seat {seat_idx} to pot for {street}")
                                break
                    except Exception as e:
                        print(f"‚ö†Ô∏è Could not add end-of-street animation: {e}")
                
            elif action_type in ["BET", "RAISE", "CALL", "CHECK", "FOLD"]:
                amount = payload.get('amount', 0)
                
                # Update the appropriate seat's bet and stack
                for seat in self.display_state['seats']:
                    if seat['player_uid'] == actor_uid:
                        if action_type in ["BET", "RAISE"]:
                            # For BET/RAISE, amount is the total bet
                            seat['current_bet'] = amount
                            seat['current_stack'] = seat['starting_stack'] - amount
                            seat['last_action'] = action_type.lower()  # Add last_action for bet styling
                        elif action_type == "CALL":
                            # For CALL, amount is the total bet to match
                            seat['current_bet'] = amount
                            seat['current_stack'] = seat['starting_stack'] - amount
                            seat['last_action'] = "call"  # Add last_action for bet styling
                        elif action_type == "CHECK":
                            # CHECK doesn't change bet or stack
                            seat['last_action'] = "check"  # Add last_action for bet styling
                        elif action_type == "FOLD":
                            seat['folded'] = True
                            seat['last_action'] = "fold"  # Add last_action for bet styling
                            # Folded players keep their current bet
                        
                        # Set acting flag for highlighting on this seat only
                        seat['acting'] = True
                        break

                # Clear acting flag from other seats using different loop variable
                for s2 in self.display_state['seats']:
                    if s2.get('player_uid') != actor_uid:
                        s2['acting'] = False
                
                # Update pot amount
                if action_type in ["BET", "RAISE", "CALL"]:
                    total_pot = sum(seat['current_bet'] for seat in self.display_state['seats'])
                    self.display_state['pot']['amount'] = total_pot
                
                print(f"üéØ HandsReviewTab: {actor_uid} {action_type} {amount if amount else ''}")
                print(f"üéØ Seat state updated: current_bet={seat.get('current_bet', 0)}, last_action={seat.get('last_action', 'none')}")
                
                # Add action sound effects
                if hasattr(self, 'effect_bus'):
                    self.effect_bus.add_poker_action_effects(action_type, player_name)

                # Professional poker behavior: Only animate chips to pot at END of streets
                # Individual bets/calls just place chips in front of players
                # (CHIP_TO_POT animation will be triggered by DEAL_FLOP, DEAL_TURN, DEAL_RIVER actions)
                
                # Show action banner for immediate visual feedback
                if hasattr(self, 'action_banner'):
                    amount = payload.get('amount', 0)
                    self.action_banner.show_poker_action(action_type, player_name, amount)

                # Re-render immediately after state updates to ensure highlight and bets update
                try:
                    self.renderer_pipeline.render_once(self.display_state)
                except Exception:
                    pass
                
            elif action_type == "POST_BLIND":
                amount = payload.get('amount', 0)
                
                # Update seat bet and stack for blind posting
                for seat in self.display_state['seats']:
                    if seat['player_uid'] == actor_uid:
                        seat['current_bet'] = amount
                        seat['current_stack'] -= amount
                        break
                
                print(f"üí∞ HandsReviewTab: {actor_uid} posted blind: {amount}")
                
                # Add blind posting sounds (chips stay in front of player until street ends)
                if hasattr(self, 'effect_bus'):
                    self.effect_bus.add_poker_action_effects("POST_BLIND", player_name)
            
            # Re-render the table with updated state
            self._render_poker_table()
            
        except Exception as e:
            print(f"‚ö†Ô∏è HandsReviewTab: Error executing action step: {e}")
    
    def _execute_action_at_index(self, action_index: int):
        """Execute action at specific index - called by GameDirector."""
        try:
            if 0 <= action_index < len(self.hand_actions):
                self.current_action_index = action_index
                action = self.hand_actions[action_index]
                
                # Execute the action
                self._execute_action_step(action)
                
                # Update progress display
                progress_text = f"Action {self.current_action_index + 1}/{len(self.hand_actions)}"
                if hasattr(self, 'progress_label'):
                    self.progress_label.config(text=progress_text)
                
                print(f"üé¨ GameDirector: Executed action at index {action_index}")
            else:
                print(f"‚ö†Ô∏è GameDirector: Invalid action index {action_index}")
                
        except Exception as e:
            print(f"‚ö†Ô∏è GameDirector: Error executing action at index {action_index}: {e}")

    def _prev_action(self):
        """Execute previous action using proper Store-based architecture."""
        try:
            # Check if we have actions to execute
            if not hasattr(self, 'hand_actions') or not self.hand_actions:
                print("‚ö†Ô∏è HandsReviewTab: No hand actions available")
                return
            
            # Check if we can go to previous action
            if self.current_action_index <= 0:
                print("‚ö†Ô∏è HandsReviewTab: Already at first action")
                return
            
            # Move to previous action
            self.current_action_index -= 1
            action = self.hand_actions[self.current_action_index]
            
            # Execute the action to update display state
            self._execute_action_step(action)
            
            # Update progress display
            progress_text = f"Action {self.current_action_index + 1}/{len(self.hand_actions)}"
            if hasattr(self, 'progress_label'):
                self.progress_label.config(text=progress_text)
            
            # Dispatch action to store for state management
            self.store.dispatch({
                "type": "PREV_REVIEW_ACTION"
            })
            
            print(f"üé¨ HandsReviewTab: Executed previous action {self.current_action_index}: {action.get('type', 'UNKNOWN')}")
            
        except Exception as e:
            print(f"‚ö†Ô∏è HandsReviewTab: Error executing previous action: {e}")



    def _execute_action(self, action):
        """Execute action and update poker table state with rich UI/UX features."""
        # REMOVED: This method should not contain business logic
        # Business logic should be in PPSM or Store reducers
        # UI should only dispatch actions and render state
        pass

    def _play_sound(self, sound_type):
        """Play sound effects for poker table actions."""
        try:
            if hasattr(self, 'sound_manager') and self.sound_manager:
                # Map sound types to sound manager events
                sound_mapping = {
                    'card_deal': 'card_deal',
                    'chip_bet': 'chip_bet',
                    'player_bet': 'player_action_bet',
                    'player_call': 'player_action_call',
                    'player_check': 'player_action_check',
                    'player_fold': 'player_action_fold',
                    'hand_end': 'hand_end'
                }
                
                event_name = sound_mapping.get(sound_type, sound_type)
                self.sound_manager.play(event_name)
                print(f"üîä HandsReviewTab: Playing {sound_type} sound")
            else:
                print(f"üîá HandsReviewTab: No sound manager available for {sound_type}")
        except Exception as e:
            print(f"‚ö†Ô∏è HandsReviewTab: Sound error for {sound_type}: {e}")

    def _schedule_animation(self):
        """Schedule animation effects using event-driven system."""
        try:
            # Use event bus instead of direct UI timing (architectural compliance)
            if hasattr(self, 'event_bus'):
                self.event_bus.publish(
                    self.event_bus.topic(self.session_id, "poker_table:animation"),
                    {
                        "type": "SCHEDULE_HIGHLIGHT_CLEAR",
                        "delay_ms": 200,
                        "action": "clear_highlight"
                    }
                )
                print(f"üé¨ HandsReviewTab: Scheduled animation via event bus")
            else:
                print(f"‚ö†Ô∏è HandsReviewTab: No event bus available for animation")
        except Exception as e:
            print(f"‚ö†Ô∏è HandsReviewTab: Animation scheduling error: {e}")

    def _clear_highlight(self):
        """Clear player highlighting after animation."""
        try:
            if hasattr(self, 'display_state') and 'action' in self.display_state:
                self.display_state['action']['highlight'] = False
                # Re-render to show cleared highlight
                self._render_poker_table()
                print(f"üé¨ HandsReviewTab: Cleared action highlight")
        except Exception as e:
            print(f"‚ö†Ô∏è HandsReviewTab: Highlight clear error: {e}")

    def _refresh_poker_table_widget(self):
        """Refresh the poker table widget to ensure proper sizing and fit."""
        try:
            if hasattr(self, 'canvas_manager') and self.canvas_manager:
                # Force canvas to update its geometry
                self.canvas_manager.canvas.update_idletasks()
                
                # Get current frame dimensions
                parent_frame = self.canvas_manager.canvas.master
                frame_width = parent_frame.winfo_width()
                frame_height = parent_frame.winfo_height()
                
                # Recalculate table dimensions
                table_width = max(800, frame_width - 20)
                table_height = max(600, frame_height - 20)
                
                # Update canvas size
                self.canvas_manager.canvas.configure(width=table_width, height=table_height)
                
                # Update stored dimensions
                self.table_width = table_width
                self.table_height = table_height
                
                # Update display state
                if hasattr(self, 'display_state'):
                    self.display_state['table']['width'] = table_width
                    self.display_state['table']['height'] = table_height
                
                # Re-render with new dimensions
                self._render_poker_table()
                
                print(f"üîÑ HandsReviewTab: Widget refreshed to {table_width}x{table_height}")
        except Exception as e:
            print(f"‚ö†Ô∏è HandsReviewTab: Widget refresh error: {e}")
```

---

### gto_session_tab.py

**Path**: `backend/ui/tabs/gto_session_tab.py`

**Size**: 3.1 KB

```python
import tkinter as tk
from tkinter import ttk

from ..renderers.poker_table_renderer import PokerTableRenderer
from ..table.state import PokerTableState
from ..session.managers import GTOSessionManager


class GTOSessionTab(ttk.Frame):
    def __init__(self, parent, services):
        super().__init__(parent)
        self.services = services
        self.store = services.get_app("store")
        self.event_bus = services.get_app("event_bus")
        self.theme = services.get_app("theme")

        # Renderer
        self.table_renderer = PokerTableRenderer(
            self,
            intent_handler=self._handle_renderer_intent,
            theme_manager=self.theme,
        )
        self.table_renderer.pack(fill="both", expand=True)

        # EffectBus bridge
        try:
            from ..services.effect_bus import EffectBus
            self.effect_bus = EffectBus(event_bus=self.event_bus)
            self.effect_bus.renderer = self.table_renderer
        except Exception:
            self.effect_bus = None

        # PPSM + GTO engine (placeholder)
        self.ppsm = None
        try:
            # Add the backend directory to the path for imports
            import sys
            import os
            backend_path = os.path.join(os.path.dirname(__file__), '..', '..')
            if backend_path not in sys.path:
                sys.path.insert(0, backend_path)
            
            from core.pure_poker_state_machine import PurePokerStateMachine, GameConfig
            
            # Create default game config for GTO session
            config = GameConfig(
                num_players=6,  # GTO typically uses 6-max
                small_blind=1.0,
                big_blind=2.0,
                starting_stack=200.0
            )
            self.ppsm = PurePokerStateMachine(config)
        except Exception as e:
            print(f"‚ö†Ô∏è PPSM import failed: {e}")
            self.ppsm = None

        gto_engine = None  # hook your engine here

        from ..services.game_director import GameDirector
        self.game_director = GameDirector(event_bus=self.event_bus)

        self.manager = GTOSessionManager(
            store=self.store,
            ppsm=self.ppsm,
            game_director=self.game_director,
            effect_bus=self.effect_bus,
            theme_manager=self.theme,
            gto_engine=gto_engine,
        )
        self.manager.start()

        # Subscribe store ‚Üí renderer
        self.store.subscribe(self._on_store_change)

    def _on_store_change(self, state=None):
        state = state or self.store.get_state()
        table = state.get("table", {})
        if table:
            try:
                pts = PokerTableState(**table)
            except Exception:
                return
            self.table_renderer.render(pts)

    def _handle_renderer_intent(self, intent: dict):
        if intent.get("type") == "REQUEST_ANIMATION" and self.event_bus:
            payload = intent.get("payload", {})
            name = payload.get("name") or ("chips_to_pot" if payload.get("type") == "CHIP_TO_POT" else None)
            if name:
                self.event_bus.publish("effect_bus:animate", {"name": name, "args": payload})


```

---

### practice_session_tab.py

**Path**: `backend/ui/tabs/practice_session_tab.py`

**Size**: 3.1 KB

```python
import tkinter as tk
from tkinter import ttk

from ..renderers.poker_table_renderer import PokerTableRenderer
from ..table.state import PokerTableState
from ..session.managers import PracticeSessionManager


class PracticeSessionTab(ttk.Frame):
    def __init__(self, parent, services):
        super().__init__(parent)
        self.services = services
        self.store = services.get_app("store")
        self.event_bus = services.get_app("event_bus")
        self.theme = services.get_app("theme")

        # Renderer
        self.table_renderer = PokerTableRenderer(
            self,
            intent_handler=self._handle_renderer_intent,
            theme_manager=self.theme,
        )
        self.table_renderer.pack(fill="both", expand=True)

        # Connect EffectBus (if present) to renderer for animation bridge
        try:
            from ..services.effect_bus import EffectBus
            self.effect_bus = EffectBus(event_bus=self.event_bus)
            self.effect_bus.renderer = self.table_renderer
        except Exception:
            self.effect_bus = None

        # PPSM and manager
        self.ppsm = None
        try:
            # Add the backend directory to the path for imports
            import sys
            import os
            backend_path = os.path.join(os.path.dirname(__file__), '..', '..')
            if backend_path not in sys.path:
                sys.path.insert(0, backend_path)
            
            from core.pure_poker_state_machine import PurePokerStateMachine, GameConfig
            
            # Create default game config for practice session
            config = GameConfig(
                num_players=2,
                small_blind=1.0,
                big_blind=2.0,
                starting_stack=200.0
            )
            self.ppsm = PurePokerStateMachine(config)
        except Exception as e:
            print(f"‚ö†Ô∏è PPSM import failed: {e}")
            self.ppsm = None

        from ..services.game_director import GameDirector
        self.game_director = GameDirector(event_bus=self.event_bus)

        self.manager = PracticeSessionManager(
            store=self.store,
            ppsm=self.ppsm,
            game_director=self.game_director,
            effect_bus=self.effect_bus,
            theme_manager=self.theme,
        )
        self.manager.start()

        # Subscribe store ‚Üí renderer
        self.store.subscribe(self._on_store_change)

    def _on_store_change(self, state=None):
        state = state or self.store.get_state()
        table = state.get("table", {})
        if table:
            try:
                pts = PokerTableState(**table)
            except Exception:
                return
            self.table_renderer.render(pts)

    def _handle_renderer_intent(self, intent: dict):
        if intent.get("type") == "REQUEST_ANIMATION" and self.event_bus:
            payload = intent.get("payload", {})
            name = payload.get("name") or ("chips_to_pot" if payload.get("type") == "CHIP_TO_POT" else None)
            if name:
                self.event_bus.publish("effect_bus:animate", {"name": name, "args": payload})


```

---

### sound_settings_tab.py

**Path**: `backend/ui/tabs/sound_settings_tab.py`

**Size**: 33.4 KB

```python
"""
Sound Settings Editor Tab - Advanced sound customization interface.
Provides sound file selection, volume control, and sound management for all poker events.
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import json
import os
from typing import Dict, Any, Optional
from pathlib import Path


class SoundSettingsTab(ttk.Frame):
    """Advanced sound settings editor with file selection and preview capabilities."""
    
    def __init__(self, parent, services):
        super().__init__(parent)
        self.services = services
        
        # Sound configuration structure
        self.sound_categories = {
            "Player Actions": [
                "BET", "RAISE", "CALL", "CHECK", "FOLD", "ALL_IN"
            ],
            "Card Dealing": [
                "DEAL_HOLE", "DEAL_BOARD", "DEAL_FLOP", "DEAL_TURN", "DEAL_RIVER"
            ],
            "Game Events": [
                "SHOWDOWN", "END_HAND", "HAND_START", "ROUND_START", "ROUND_END"
            ],
            "Blinds & Chips": [
                "POST_BLIND", "POST_SMALL_BLIND", "POST_BIG_BLIND",
                "CHIP_BET", "CHIP_COLLECT", "POT_RAKE", "POT_SPLIT"
            ],
            "UI & Notifications": [
                "TURN_NOTIFY", "BUTTON_MOVE", "ACTION_TIMEOUT"
            ]
        }
        
        # Current editing state
        self.current_config = {}
        self.original_config = {}
        self.sound_widgets: Dict[str, Dict[str, tk.Widget]] = {}
        
        # Configuration file path
        self.config_file = os.path.join(
            os.path.dirname(__file__), '..', '..', 'sounds', 'poker_sound_config.json'
        )
        
        self._setup_ui()
        self._load_sound_config()
        
        # Apply sound configuration to EffectBus if available
        self._apply_sound_config_to_effect_bus()
    
    def _apply_sound_config_to_effect_bus(self):
        """Apply current sound configuration to EffectBus if available."""
        try:
            effect_bus = None
            if hasattr(self, 'services') and hasattr(self.services, 'get_app'):
                effect_bus = self.services.get_app('effect_bus')
            elif isinstance(self.services, dict) and 'effect_bus' in self.services:
                effect_bus = self.services['effect_bus']
            if effect_bus and hasattr(effect_bus, 'reload_sound_config'):
                effect_bus.reload_sound_config()
                print("‚úÖ EffectBus sound configuration applied on init")
            else:
                print("‚ö†Ô∏è EffectBus not available for init or reload method missing")
        except Exception as e:
            print(f"‚ö†Ô∏è Error applying sound config to EffectBus: {e}")
    
    def _reload_sounds(self):
        """Manually reload sound configuration and apply to EffectBus."""
        try:
            # Reload config from file
            self._load_sound_config()
            
            # Apply to EffectBus
            self._apply_sound_config_to_effect_bus()
            
            # Update info display
            self._update_config_info()
            
            messagebox.showinfo("Success", "Sound configuration reloaded successfully!")
            print("‚úÖ Sound configuration manually reloaded")
            
        except Exception as e:
            print(f"‚ö†Ô∏è Error reloading sounds: {e}")
            messagebox.showerror("Error", f"Failed to reload sounds: {e}")
    
    def _setup_ui(self):
        """Setup the sound settings editor interface."""
        # Configure grid
        self.grid_rowconfigure(0, weight=1)
        self.grid_columnconfigure(0, weight=0)  # Left panel
        self.grid_columnconfigure(1, weight=1)  # Right panel
        
        # Left Panel - Sound Management & Controls
        self._create_left_panel()
        
        # Right Panel - Sound Configuration Editor
        self._create_right_panel()
    
    def _create_left_panel(self):
        """Create left panel with sound management and controls."""
        left_frame = ttk.LabelFrame(self, text="Sound Management", padding=16)
        left_frame.grid(row=0, column=0, sticky="nsew", padx=(16, 8), pady=16)
        
        # Sound Configuration Info
        info_frame = ttk.LabelFrame(left_frame, text="Configuration Info", padding=16)
        info_frame.pack(fill="x", pady=(0, 16))
        
        self.config_info_text = tk.Text(info_frame, height=4, wrap=tk.WORD, 
                                       font=("Inter", 16), state="disabled")
        self.config_info_text.pack(fill="x")
        
        # Sound Controls
        controls_frame = ttk.LabelFrame(left_frame, text="Sound Controls", padding=16)
        controls_frame.pack(fill="x", pady=(0, 16))
        
        # Control buttons - inherit theme font size
        ttk.Button(controls_frame, text="Load Config", 
                  command=self._load_sound_config, 
                  style="Accent.TButton").pack(fill="x", pady=8)
        ttk.Button(controls_frame, text="Save Config", 
                  command=self._save_sound_config,
                  style="Accent.TButton").pack(fill="x", pady=8)
        ttk.Button(controls_frame, text="Reset to Defaults", 
                  command=self._reset_to_defaults,
                  style="Accent.TButton").pack(fill="x", pady=8)
        ttk.Button(controls_frame, text="Test All Sounds", 
                  command=self._test_all_sounds,
                  style="Accent.TButton").pack(fill="x", pady=8)
        ttk.Button(controls_frame, text="Reload Sounds", 
                  command=self._reload_sounds,
                  style="Accent.TButton").pack(fill="x", pady=8)
        
        # Global Sound Settings
        global_frame = ttk.LabelFrame(left_frame, text="Global Settings", padding=16)
        global_frame.pack(fill="x", pady=(0, 16))
        
        # Master volume - 18px font size per design requirements
        ttk.Label(global_frame, text="Master Volume:", 
                 font=("Inter", 18, "bold")).pack(anchor="w", pady=(0, 8))
        self.master_volume_var = tk.DoubleVar(value=1.0)
        volume_scale = ttk.Scale(global_frame, from_=0.0, to=1.0, 
                                variable=self.master_volume_var,
                                orient="horizontal", command=self._on_master_volume_change)
        volume_scale.pack(fill="x", pady=(0, 16))
        
        # Enable/disable sounds - inherit theme font size
        self.sounds_enabled_var = tk.BooleanVar(value=True)
        sounds_check = ttk.Checkbutton(global_frame, text="Enable Sounds",
                                      variable=self.sounds_enabled_var,
                                      command=self._on_sounds_enabled_change)
        sounds_check.pack(anchor="w", pady=4)
        
        # Voice announcements - inherit theme font size
        self.voice_enabled_var = tk.BooleanVar(value=True)
        voice_check = ttk.Checkbutton(global_frame, text="Enable Voice", 
                                     variable=self.voice_enabled_var,
                                     command=self._on_voice_enabled_change)
        voice_check.pack(anchor="w", pady=4)
        
        # Voice type selection
        voice_type_frame = ttk.Frame(global_frame)
        voice_type_frame.pack(fill="x", pady=(8, 0))
        
        ttk.Label(voice_type_frame, text="Voice Type:", 
                 font=("Inter", 18)).pack(side="left", padx=(0, 16))
        
        self.voice_type_var = tk.StringVar(value="announcer_female")
        voice_types = [
            ("Announcer Female", "announcer_female"),
            ("Announcer Male", "announcer_male"),
            ("Dealer Female", "dealer_female"),
            ("Dealer Male", "dealer_male"),
            ("Hostess Female", "hostess_female"),
            ("Tournament Female", "tournament_female")
        ]
        
        voice_combo = ttk.Combobox(voice_type_frame, 
                                   textvariable=self.voice_type_var,
                                   values=[name for name, _ in voice_types],
                                   state="readonly",
                                   font=("Inter", 16),
                                   width=20)
        voice_combo.pack(side="left", padx=(0, 16))
        
        # Bind the combobox to update the actual value
        def on_voice_type_change(event):
            selected_name = self.voice_type_var.get()
            for name, value in voice_types:
                if name == selected_name:
                    self.voice_type_var.set(value)
                    break
        
        voice_combo.bind('<<ComboboxSelected>>', on_voice_type_change)
        
        # Sound directory
        dir_frame = ttk.LabelFrame(left_frame, text="Sound Directory", padding=16)
        dir_frame.pack(fill="x", pady=(0, 16))
        
        self.sound_dir_var = tk.StringVar()
        ttk.Entry(dir_frame, textvariable=self.sound_dir_var, 
                 state="readonly", font=("Inter", 16)).pack(fill="x", pady=(0, 16))
        ttk.Button(dir_frame, text="Browse Directory", 
                  command=self._browse_sound_directory,
                  style="Accent.TButton").pack(fill="x")
    
    def _create_right_panel(self):
        """Create right panel with sound configuration editor."""
        right_frame = ttk.Frame(self)
        right_frame.grid(row=0, column=1, sticky="nsew", padx=(8, 16), pady=16)
        
        # Create scrollable canvas for sound settings
        canvas = tk.Canvas(right_frame)
        scrollbar = ttk.Scrollbar(right_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # Configure grid weights
        right_frame.grid_rowconfigure(0, weight=1)
        right_frame.grid_columnconfigure(0, weight=1)
        right_frame.grid_columnconfigure(1, weight=0)
        
        canvas.grid(row=0, column=0, sticky="nsew")
        scrollbar.grid(row=0, column=1, sticky="ns")
        
        # Create sound configuration sections
        self._create_sound_sections(scrollable_frame)
    
    def _create_sound_sections(self, parent):
        """Create sections for each sound category."""
        # Create two equal frames for better organization
        left_categories_frame = ttk.Frame(parent)
        left_categories_frame.pack(side="left", fill="both", expand=True, padx=(0, 8))
        
        right_categories_frame = ttk.Frame(parent)
        right_categories_frame.pack(side="right", fill="both", expand=True, padx=(8, 0))
        
        # Split categories between the two frames
        categories = list(self.sound_categories.items())
        mid_point = len(categories) // 2
        
        left_categories = categories[:mid_point]
        right_categories = categories[mid_point:]
        
        # Create left frame categories
        for category, events in left_categories:
            self._create_category_section(left_categories_frame, category, events)
        
        # Create right frame categories
        for category, events in right_categories:
            self._create_category_section(right_categories_frame, category, events)
    
    def _create_category_section(self, parent, category, events):
        """Create a single category section with proper 4-column layout."""
        # Category header - 20px font size per design requirements
        category_frame = ttk.LabelFrame(parent, text=category, padding=16)
        category_frame.pack(fill="x", pady=(0, 16), padx=16)
        
        # Create header row with column labels
        header_frame = ttk.Frame(category_frame)
        header_frame.pack(fill="x", pady=(0, 8))
        
        # Column headers - 20px font size
        ttk.Label(header_frame, text="Event Name", font=("Inter", 18, "bold")).pack(side="left", padx=(0, 16))
        ttk.Label(header_frame, text="Current File", font=("Inter", 18, "bold")).pack(side="left", padx=(0, 16))
        ttk.Label(header_frame, text="Browse", font=("Inter", 18, "bold")).pack(side="left", padx=(0, 16))
        ttk.Label(header_frame, text="Test", font=("Inter", 18, "bold")).pack(side="left", padx=(0, 16))
        
        # Create events using pack layout for each row
        for event in events:
            # Create a frame for each event row
            event_frame = ttk.Frame(category_frame)
            event_frame.pack(fill="x", pady=4)
            
            # Event label - 18px font size
            ttk.Label(event_frame, text=f"{event}:", 
                     font=("Inter", 18)).pack(side="left", padx=(0, 16))
            
            # Sound file entry
            sound_var = tk.StringVar()
            sound_entry = ttk.Entry(event_frame, textvariable=sound_var, 
                                   width=25, state="readonly", font=("Inter", 16))
            sound_entry.pack(side="left", padx=(0, 16))
            
            # Browse button
            browse_btn = ttk.Button(event_frame, text="Browse", 
                                   command=lambda e=event, var=sound_var: 
                                   self._browse_sound_file(e, var),
                                   style="Accent.TButton")
            browse_btn.pack(side="left", padx=(0, 16))
            
            # Test button
            test_btn = ttk.Button(event_frame, text="Test", 
                                 command=lambda e=event: self._test_sound(e),
                                 style="Accent.TButton")
            test_btn.pack(side="left", padx=(0, 16))
            
            # Store widgets for later access
            if category not in self.sound_widgets:
                self.sound_widgets[category] = {}
            self.sound_widgets[category][event] = {
                'entry': sound_entry,
                'var': sound_var,
                'browse': browse_btn,
                'test': test_btn
            }
    
    def _load_sound_config(self):
        """Load sound configuration from JSON file."""
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r') as f:
                    self.current_config = json.load(f)
                print(f"üîä SoundSettingsTab: Loaded config from {self.config_file}")
            else:
                # Create default configuration
                self.current_config = self._create_default_config()
                print(f"üîä SoundSettingsTab: Created default config")
            
            # Store original for comparison
            self.original_config = self.current_config.copy()
            
            # Update UI with loaded config
            self._update_ui_from_config()
            
            # Update info display
            self._update_config_info()
            
        except Exception as e:
            print(f"‚ö†Ô∏è SoundSettingsTab: Error loading config: {e}")
            messagebox.showerror("Error", f"Failed to load sound configuration: {e}")
    
    def _create_default_config(self):
        """Create default sound configuration."""
        default_config = {
            "master_volume": 1.0,
            "sounds_enabled": True,
            "voice_enabled": True,
            "voice_type": "announcer_female",
            "sound_directory": os.path.join(
                os.path.dirname(__file__), '..', '..', 'sounds'
            ),
            "sounds": {}
        }
        
        # Add default sound mappings for all events
        for category, events in self.sound_categories.items():
            for event in events:
                # Map to common sound files
                if "BET" in event or "RAISE" in event:
                    default_config["sounds"][event] = "player_bet.wav"
                elif "CALL" in event:
                    default_config["sounds"][event] = "player_call.wav"
                elif "CHECK" in event:
                    default_config["sounds"][event] = "player_check.wav"
                elif "FOLD" in event:
                    default_config["sounds"][event] = "player_fold.wav"
                elif "DEAL" in event:
                    default_config["sounds"][event] = "card_deal.wav"
                elif "SHOWDOWN" in event or "END_HAND" in event:
                    default_config["sounds"][event] = "winner_announce.wav"
                elif "BLIND" in event or "CHIP" in event:
                    default_config["sounds"][event] = "chip_bet.wav"
                else:
                    default_config["sounds"][event] = "turn_notify.wav"
        
        return default_config
    
    def _update_ui_from_config(self):
        """Update UI widgets with loaded configuration."""
        try:
            # Update global settings
            self.master_volume_var.set(self.current_config.get("master_volume", 1.0))
            self.sounds_enabled_var.set(self.current_config.get("sounds_enabled", True))
            self.voice_enabled_var.set(self.current_config.get("voice_enabled", True))
            
            # Update voice type selection
            voice_type = self.current_config.get("voice_type", "announcer_female")
            # Find the display name for the voice type
            voice_types = [
                ("Announcer Female", "announcer_female"),
                ("Announcer Male", "announcer_male"),
                ("Dealer Female", "dealer_female"),
                ("Dealer Male", "dealer_male"),
                ("Hostess Female", "hostess_female"),
                ("Tournament Female", "tournament_female")
            ]
            for display_name, value in voice_types:
                if value == voice_type:
                    self.voice_type_var.set(display_name)
                    break
            
            self.sound_dir_var.set(self.current_config.get("sound_directory", ""))
            
            # Update sound file entries
            sounds = self.current_config.get("sounds", {})
            for category, events in self.sound_categories.items():
                for event in events:
                    if event in self.sound_widgets.get(category, {}):
                        widget = self.sound_widgets[category][event]
                        sound_file = sounds.get(event, "")
                        widget['var'].set(sound_file)
            
        except Exception as e:
            print(f"‚ö†Ô∏è SoundSettingsTab: Error updating UI: {e}")
    
    def _update_config_info(self):
        """Update configuration info display."""
        try:
            config = self.current_config
            info_text = f"Configuration: {os.path.basename(self.config_file)}\n"
            info_text += f"Sound Directory: {config.get('sound_directory', 'Not set')}\n"
            info_text += f"Total Events: {len(config.get('sounds', {}))}\n"
            info_text += f"Master Volume: {config.get('master_volume', 1.0):.1f}\n"
            info_text += f"Sounds Enabled: {config.get('sounds_enabled', True)}\n"
            info_text += f"Voice Enabled: {config.get('voice_enabled', True)}\n"
            info_text += f"Voice Type: {config.get('voice_type', 'announcer_female')}"
            
            self.config_info_text.config(state="normal")
            self.config_info_text.delete(1.0, tk.END)
            self.config_info_text.insert(1.0, info_text)
            self.config_info_text.config(state="disabled")
            
        except Exception as e:
            print(f"‚ö†Ô∏è SoundSettingsTab: Error updating info: {e}")
    
    def _save_sound_config(self):
        """Save current sound configuration to JSON file."""
        try:
            # Update config from UI
            self._update_config_from_ui()
            
            # Ensure directory exists
            os.makedirs(os.path.dirname(self.config_file), exist_ok=True)
            
            # Save to file
            with open(self.config_file, 'w') as f:
                json.dump(self.current_config, f, indent=2)
            
            # Update original config
            self.original_config = self.current_config.copy()
            
            print(f"üîä SoundSettingsTab: Saved config to {self.config_file}")
            
            # Reload EffectBus configuration to pick up new sounds
            try:
                from ..services.effect_bus import EffectBus
                # Get the global EffectBus instance if available
                if hasattr(self, 'services') and 'effect_bus' in self.services:
                    effect_bus = self.services['effect_bus']
                    if hasattr(effect_bus, 'reload_sound_config'):
                        effect_bus.reload_sound_config()
                        print("‚úÖ EffectBus sound configuration reloaded")
                    else:
                        print("‚ö†Ô∏è EffectBus reload method not available")
                else:
                    print("‚ö†Ô∏è EffectBus service not available for reload")
            except Exception as e:
                print(f"‚ö†Ô∏è Error reloading EffectBus: {e}")
            
            messagebox.showinfo("Success", "Sound configuration saved and reloaded successfully!")
            
            # Update info display
            self._update_config_info()
            
        except Exception as e:
            print(f"‚ö†Ô∏è SoundSettingsTab: Error saving config: {e}")
            messagebox.showerror("Error", f"Failed to save sound configuration: {e}")
    
    def _update_config_from_ui(self):
        """Update configuration from UI widget values."""
        try:
            # Update global settings
            self.current_config["master_volume"] = self.master_volume_var.get()
            self.current_config["sounds_enabled"] = self.sounds_enabled_var.get()
            self.current_config["voice_enabled"] = self.voice_enabled_var.get()
            
            # Update voice type
            voice_type = self.voice_type_var.get()
            # Convert display name back to config value
            voice_types = [
                ("Announcer Female", "announcer_female"),
                ("Announcer Male", "announcer_male"),
                ("Dealer Female", "dealer_female"),
                ("Dealer Male", "dealer_male"),
                ("Hostess Female", "hostess_female"),
                ("Tournament Female", "tournament_female")
            ]
            for display_name, value in voice_types:
                if display_name == voice_type:
                    self.current_config["voice_type"] = value
                    break
            
            self.current_config["sound_directory"] = self.sound_dir_var.get()
            
            # Update sound mappings
            if "sounds" not in self.current_config:
                self.current_config["sounds"] = {}
            
            for category, events in self.sound_categories.items():
                for event in events:
                    if event in self.sound_widgets.get(category, {}):
                        widget = self.sound_widgets[category][event]
                        sound_file = widget['var'].get()
                        self.current_config["sounds"][event] = sound_file
            
        except Exception as e:
            print(f"‚ö†Ô∏è SoundSettingsTab: Error updating config from UI: {e}")
    
    def _reset_to_defaults(self):
        """Reset configuration to default values."""
        try:
            if messagebox.askyesno("Reset Configuration", 
                                 "Are you sure you want to reset to default values?"):
                self.current_config = self._create_default_config()
                self._update_ui_from_config()
                self._update_config_info()
                print(f"üîä SoundSettingsTab: Reset to defaults")
                messagebox.showinfo("Success", "Configuration reset to defaults!")
                
        except Exception as e:
            print(f"‚ö†Ô∏è SoundSettingsTab: Error resetting config: {e}")
            messagebox.showerror("Error", f"Failed to reset configuration: {e}")
    
    def _browse_sound_directory(self):
        """Browse for sound directory."""
        try:
            directory = filedialog.askdirectory(
                title="Select Sound Directory",
                initialdir=self.sound_dir_var.get() or os.getcwd()
            )
            if directory:
                self.sound_dir_var.set(directory)
                print(f"üîä SoundSettingsTab: Selected sound directory: {directory}")
                
        except Exception as e:
            print(f"‚ö†Ô∏è SoundSettingsTab: Error browsing directory: {e}")
    
    def _browse_sound_file(self, event, sound_var):
        """Browse for sound file for specific event."""
        try:
            # Get current sound directory
            sound_dir = self.sound_dir_var.get()
            if not sound_dir or not os.path.exists(sound_dir):
                sound_dir = os.getcwd()
            
            # Browse for sound file
            filename = filedialog.askopenfilename(
                title=f"Select sound file for {event}",
                initialdir=sound_dir,
                filetypes=[
                    ("Sound files", "*.wav *.mp3 *.ogg"),
                    ("WAV files", "*.wav"),
                    ("MP3 files", "*.mp3"),
                    ("OGG files", "*.ogg"),
                    ("All files", "*.*")
                ]
            )
            
            if filename:
                # Store relative path if in sound directory, otherwise absolute
                if sound_dir and filename.startswith(sound_dir):
                    rel_path = os.path.relpath(filename, sound_dir)
                    sound_var.set(rel_path)
                else:
                    sound_var.set(filename)
                
                print(f"üîä SoundSettingsTab: Selected sound for {event}: {filename}")
                
        except Exception as e:
            print(f"‚ö†Ô∏è SoundSettingsTab: Error browsing sound file: {e}")
    
    def _test_sound(self, event):
        """Test sound for specific event."""
        try:
            # Get sound file from UI
            sound_file = None
            for category, events in self.sound_categories.items():
                if event in self.sound_widgets.get(category, {}):
                    sound_file = self.sound_widgets[category][event]['var'].get()
                    break
            
            if not sound_file:
                messagebox.showwarning("Warning", f"No sound file configured for {event}")
                return
            
            # Build full path
            sound_dir = self.sound_dir_var.get()
            if sound_dir and not os.path.isabs(sound_file):
                full_path = os.path.join(sound_dir, sound_file)
            else:
                full_path = sound_file
            
            if not os.path.exists(full_path):
                messagebox.showerror("Error", f"Sound file not found: {full_path}")
                return
            
            # Test sound playback
            self._play_test_sound(full_path)
            print(f"üîä SoundSettingsTab: Testing sound for {event}: {full_path}")
            
        except Exception as e:
            print(f"‚ö†Ô∏è SoundSettingsTab: Error testing sound: {e}")
            messagebox.showerror("Error", f"Failed to test sound: {e}")
    
    def _play_test_sound(self, sound_file):
        """Play test sound file."""
        try:
            import pygame
            if pygame.mixer.get_init():
                sound = pygame.mixer.Sound(sound_file)
                sound.play()
                print(f"üîä SoundSettingsTab: Playing test sound: {sound_file}")
            else:
                messagebox.showwarning("Warning", "Audio system not initialized")
                
        except ImportError:
            messagebox.showwarning("Warning", "Pygame not available for sound testing")
        except Exception as e:
            print(f"‚ö†Ô∏è SoundSettingsTab: Error playing test sound: {e}")
            messagebox.showerror("Error", f"Failed to play sound: {e}")
    
    def _test_all_sounds(self):
        """Test all configured sounds."""
        try:
            # Get all configured sounds
            sounds_to_test = []
            for category, events in self.sound_categories.items():
                for event in events:
                    if event in self.sound_widgets.get(category, {}):
                        sound_file = self.sound_widgets[category][event]['var'].get()
                        if sound_file:
                            sound_dir = self.sound_dir_var.get()
                            if sound_dir and not os.path.isabs(sound_file):
                                full_path = os.path.join(sound_dir, sound_file)
                            else:
                                full_path = sound_file
                            
                            if os.path.exists(full_path):
                                sounds_to_test.append((event, full_path))
            
            if not sounds_to_test:
                messagebox.showinfo("Info", "No sounds configured to test")
                return
            
            # Test each sound with a small delay
            self._test_sounds_sequence(sounds_to_test)
            
        except Exception as e:
            print(f"‚ö†Ô∏è SoundSettingsTab: Error testing all sounds: {e}")
            messagebox.showerror("Error", f"Failed to test sounds: {e}")
    
    def _test_sounds_sequence(self, sounds_to_test):
        """Test sounds in sequence with delays."""
        try:
            import pygame
            if not pygame.mixer.get_init():
                messagebox.showwarning("Warning", "Audio system not initialized")
                return
            
            # Create a simple test sequence
            test_window = tk.Toplevel(self)
            test_window.title("Testing Sounds")
            test_window.geometry("300x200")
            
            progress_label = ttk.Label(test_window, text="Testing sounds...")
            progress_label.pack(pady=20)
            
            progress_bar = ttk.Progressbar(test_window, maximum=len(sounds_to_test))
            progress_bar.pack(fill="x", padx=20, pady=10)
            
            def play_next_sound(index=0):
                if index >= len(sounds_to_test):
                    test_window.destroy()
                    messagebox.showinfo("Complete", "Sound testing completed!")
                    return
                
                event, sound_file = sounds_to_test[index]
                progress_label.config(text=f"Testing: {event}")
                progress_bar["value"] = index + 1
                
                try:
                    sound = pygame.mixer.Sound(sound_file)
                    sound.play()
                    print(f"üîä SoundSettingsTab: Testing {event}: {sound_file}")
                except Exception as e:
                    print(f"‚ö†Ô∏è SoundSettingsTab: Error testing {event}: {e}")
                
                # Schedule next sound after delay
                test_window.after(1000, lambda: play_next_sound(index + 1))
            
            # Start testing
            play_next_sound()
            
        except ImportError:
            messagebox.showwarning("Warning", "Pygame not available for sound testing")
        except Exception as e:
            print(f"‚ö†Ô∏è SoundSettingsTab: Error in sound sequence: {e}")
    
    def _on_master_volume_change(self, value):
        """Handle master volume change."""
        try:
            volume = float(value)
            self.current_config["master_volume"] = volume
            print(f"üîä SoundSettingsTab: Master volume changed to {volume}")
        except Exception as e:
            print(f"‚ö†Ô∏è SoundSettingsTab: Error updating master volume: {e}")
    
    def _on_sounds_enabled_change(self):
        """Handle sounds enabled change."""
        try:
            enabled = self.sounds_enabled_var.get()
            self.current_config["sounds_enabled"] = enabled
            print(f"üîä SoundSettingsTab: Sounds {'enabled' if enabled else 'disabled'}")
        except Exception as e:
            print(f"‚ö†Ô∏è SoundSettingsTab: Error updating sounds enabled: {e}")
    
    def _on_voice_enabled_change(self):
        """Handle voice enabled change."""
        try:
            enabled = self.voice_enabled_var.get()
            self.current_config["voice_enabled"] = enabled
            print(f"üîä SoundSettingsTab: Voice {'enabled' if enabled else 'disabled'}")
        except Exception as e:
            print(f"‚ö†Ô∏è SoundSettingsTab: Error updating voice enabled: {e}")
    
    def get_sound_config(self):
        """Get current sound configuration for external use."""
        return self.current_config.copy()
    
    def apply_sound_config(self):
        """Apply current sound configuration to EffectBus."""
        try:
            if hasattr(self.services, 'effect_bus'):
                # Update EffectBus with new configuration
                effect_bus = self.services.effect_bus
                
                # Update sound mappings
                sounds = self.current_config.get("sounds", {})
                for event, sound_file in sounds.items():
                    if hasattr(effect_bus, 'sound_mapping'):
                        effect_bus.sound_mapping[event] = sound_file
                
                # Update global settings
                if hasattr(effect_bus, 'enabled'):
                    effect_bus.enabled = self.current_config.get("sounds_enabled", True)
                
                print(f"üîä SoundSettingsTab: Applied sound config to EffectBus")
                
        except Exception as e:
            print(f"‚ö†Ô∏è SoundSettingsTab: Error applying config: {e}")
```

---

### theme_editor_tab.py

**Path**: `backend/ui/tabs/theme_editor_tab.py`

**Size**: 21.7 KB

```python
"""
Theme Editor Tab - Advanced theme customization interface.
Provides real-time color editing, hue adjustment, and theme management.
"""

import tkinter as tk
from tkinter import ttk, colorchooser, filedialog, messagebox
from typing import Dict, Any, Optional
from ui.services.advanced_theme_manager import AdvancedThemeManager


class ThemeEditorTab(ttk.Frame):
    """Advanced theme editor with real-time preview and color customization."""
    
    def __init__(self, parent, services):
        super().__init__(parent)
        self.services = services
        self.theme_manager = AdvancedThemeManager()
        
        # Current editing state
        self.current_theme_id: Optional[str] = None
        self.preview_mode = False
        self.color_widgets: Dict[str, Dict[str, tk.Widget]] = {}
        
        self._setup_ui()
        self._load_initial_theme()
    
    def _setup_ui(self):
        """Setup the theme editor interface."""
        # Configure grid
        self.grid_rowconfigure(0, weight=1)
        self.grid_columnconfigure(0, weight=0)  # Left panel
        self.grid_columnconfigure(1, weight=1)  # Right panel
        
        # Left Panel - Theme Selection & Controls
        self._create_left_panel()
        
        # Right Panel - Color Editor
        self._create_right_panel()
    
    def _create_left_panel(self):
        """Create left panel with theme selection and management."""
        left_frame = ttk.LabelFrame(self, text="Theme Management", padding=10)
        left_frame.grid(row=0, column=0, sticky="nsew", padx=(5, 2), pady=5)
        
        # Theme Selection
        ttk.Label(left_frame, text="Select Theme:").pack(anchor="w", pady=(0, 5))
        
        self.theme_var = tk.StringVar()
        self.theme_combo = ttk.Combobox(left_frame, textvariable=self.theme_var, 
                                       state="readonly", width=30)
        self.theme_combo.pack(fill="x", pady=(0, 10))
        self.theme_combo.bind("<<ComboboxSelected>>", self._on_theme_select)
        
        # Theme Info Display
        info_frame = ttk.LabelFrame(left_frame, text="Theme Info", padding=5)
        info_frame.pack(fill="x", pady=(0, 10))
        
        self.theme_info_text = tk.Text(info_frame, height=4, wrap=tk.WORD, 
                                      font=("Arial", 10), state="disabled")
        self.theme_info_text.pack(fill="x")
        
        # Theme Controls
        controls_frame = ttk.LabelFrame(left_frame, text="Theme Controls", padding=5)
        controls_frame.pack(fill="x", pady=(0, 10))
        
        # Control buttons in grid
        ttk.Button(controls_frame, text="New Theme", 
                  command=self._create_new_theme).grid(row=0, column=0, sticky="ew", padx=2, pady=2)
        ttk.Button(controls_frame, text="Duplicate", 
                  command=self._duplicate_theme).grid(row=0, column=1, sticky="ew", padx=2, pady=2)
        ttk.Button(controls_frame, text="Save Changes", 
                  command=self._save_theme).grid(row=1, column=0, sticky="ew", padx=2, pady=2)
        ttk.Button(controls_frame, text="Revert", 
                  command=self._revert_theme).grid(row=1, column=1, sticky="ew", padx=2, pady=2)
        
        controls_frame.grid_columnconfigure(0, weight=1)
        controls_frame.grid_columnconfigure(1, weight=1)
        
        # Global Adjustments
        global_frame = ttk.LabelFrame(left_frame, text="Global Adjustments", padding=5)
        global_frame.pack(fill="x", pady=(0, 10))
        
        # Hue adjustment
        ttk.Label(global_frame, text="Hue Shift:").pack(anchor="w")
        self.hue_var = tk.DoubleVar()
        hue_scale = ttk.Scale(global_frame, from_=-180, to=180, variable=self.hue_var,
                             orient="horizontal", command=self._on_hue_change)
        hue_scale.pack(fill="x", pady=(0, 5))
        
        # Saturation adjustment  
        ttk.Label(global_frame, text="Saturation:").pack(anchor="w")
        self.saturation_var = tk.DoubleVar()
        sat_scale = ttk.Scale(global_frame, from_=-0.5, to=0.5, variable=self.saturation_var,
                             orient="horizontal", command=self._on_saturation_change)
        sat_scale.pack(fill="x", pady=(0, 5))
        
        # Lightness adjustment
        ttk.Label(global_frame, text="Lightness:").pack(anchor="w")
        self.lightness_var = tk.DoubleVar()
        light_scale = ttk.Scale(global_frame, from_=-0.3, to=0.3, variable=self.lightness_var,
                               orient="horizontal", command=self._on_lightness_change)
        light_scale.pack(fill="x", pady=(0, 5))
        
        # Reset button
        ttk.Button(global_frame, text="Reset Adjustments", 
                  command=self._reset_adjustments).pack(fill="x", pady=(5, 0))
        
        # Import/Export
        io_frame = ttk.LabelFrame(left_frame, text="Import/Export", padding=5)
        io_frame.pack(fill="x")
        
        ttk.Button(io_frame, text="Import Theme", 
                  command=self._import_theme).pack(fill="x", pady=2)
        ttk.Button(io_frame, text="Export Theme", 
                  command=self._export_theme).pack(fill="x", pady=2)
    
    def _create_right_panel(self):
        """Create right panel with color editor."""
        right_frame = ttk.LabelFrame(self, text="Color Palette Editor", padding=10)
        right_frame.grid(row=0, column=1, sticky="nsew", padx=(2, 5), pady=5)
        
        # Create scrollable frame for color controls
        canvas = tk.Canvas(right_frame)
        scrollbar = ttk.Scrollbar(right_frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        self.color_editor_frame = scrollable_frame
        
        # Color categories
        self._create_color_section("Core Colors", [
            ("felt", "Table Felt"),
            ("rail", "Table Rail"), 
            ("metal", "Metal Accents"),
            ("accent", "Accent Color"),
            ("raise", "Raise Color"),
            ("call", "Call Color")
        ])
        
        self._create_color_section("Text & Highlighting", [
            ("text", "Primary Text"),
            ("highlight", "Selection Highlight"),
            ("highlight_text", "Selection Text"),
            ("emphasis_text", "Emphasis Text")
        ])
        
        self._create_color_section("Emphasis Bar (Theme Intro)", [
            ("emphasis_bg_top", "Background Top"),
            ("emphasis_bg_bottom", "Background Bottom"),
            ("emphasis_border", "Border Color"),
            ("emphasis_accent_text", "Accent Text")
        ])
        
        self._create_color_section("Chips & Betting", [
            ("chip_face", "Chip Face"),
            ("bet_face", "Bet Chip Face"),
            ("pot_face", "Pot Chip Face"),
            ("neutral", "Neutral Color")
        ])
    
    def _create_color_section(self, section_name: str, color_items: list):
        """Create a section of color controls."""
        section_frame = ttk.LabelFrame(self.color_editor_frame, text=section_name, padding=5)
        section_frame.pack(fill="x", pady=5)
        
        for color_key, display_name in color_items:
            self._create_color_control(section_frame, color_key, display_name)
    
    def _create_color_control(self, parent, color_key: str, display_name: str):
        """Create a color control widget."""
        control_frame = ttk.Frame(parent)
        control_frame.pack(fill="x", pady=2)
        control_frame.grid_columnconfigure(1, weight=1)
        
        # Color preview box
        color_box = tk.Frame(control_frame, width=30, height=20, relief="solid", bd=1)
        color_box.grid(row=0, column=0, padx=(0, 5))
        
        # Color label
        ttk.Label(control_frame, text=display_name).grid(row=0, column=1, sticky="w")
        
        # Color value entry
        color_var = tk.StringVar()
        color_entry = ttk.Entry(control_frame, textvariable=color_var, width=10)
        color_entry.grid(row=0, column=2, padx=5)
        color_entry.bind("<Return>", lambda e: self._on_color_entry_change(color_key, color_var.get()))
        
        # Color picker button
        ttk.Button(control_frame, text="Pick", width=6,
                  command=lambda: self._pick_color(color_key)).grid(row=0, column=3, padx=(5, 0))
        
        # Contrast info (for text colors)
        if "text" in color_key.lower():
            contrast_label = ttk.Label(control_frame, text="", font=("Arial", 8))
            contrast_label.grid(row=0, column=4, padx=(10, 0))
            
            # Store references
            if color_key not in self.color_widgets:
                self.color_widgets[color_key] = {}
            self.color_widgets[color_key]["contrast_label"] = contrast_label
        
        # Store widget references
        if color_key not in self.color_widgets:
            self.color_widgets[color_key] = {}
        self.color_widgets[color_key].update({
            "color_box": color_box,
            "color_var": color_var,
            "color_entry": color_entry
        })
    
    def _load_initial_theme(self):
        """Load initial theme data."""
        theme_names = self.theme_manager.get_theme_names()
        self.theme_combo['values'] = theme_names
        
        if theme_names:
            self.theme_var.set(theme_names[0])
            self._on_theme_select()
    
    def _on_theme_select(self, event=None):
        """Handle theme selection."""
        theme_name = self.theme_var.get()
        theme = self.theme_manager.get_theme_by_name(theme_name)
        
        if theme:
            self.current_theme_id = theme['id']
            self._update_theme_info(theme)
            self._update_color_controls(theme['palette'])
            self._reset_adjustments()
    
    def _update_theme_info(self, theme: Dict[str, Any]):
        """Update theme information display."""
        self.theme_info_text.config(state="normal")
        self.theme_info_text.delete(1.0, tk.END)
        
        info_text = f"ID: {theme['id']}\\n"
        info_text += f"Intro: {theme.get('intro', 'No description')}\\n"
        info_text += f"Persona: {theme.get('persona', 'Unknown')}"
        
        self.theme_info_text.insert(1.0, info_text)
        self.theme_info_text.config(state="disabled")
    
    def _update_color_controls(self, palette: Dict[str, str]):
        """Update all color control widgets with palette values."""
        for color_key, widgets in self.color_widgets.items():
            color_value = palette.get(color_key, "#000000")
            
            # Update color box
            widgets["color_box"].config(bg=color_value)
            
            # Update entry
            widgets["color_var"].set(color_value)
            
            # Update contrast info if applicable
            if "contrast_label" in widgets:
                self._update_contrast_info(color_key, palette)
    
    def _update_contrast_info(self, text_color_key: str, palette: Dict[str, str]):
        """Update contrast information for text colors."""
        if text_color_key not in self.color_widgets:
            return
        
        widgets = self.color_widgets[text_color_key]
        if "contrast_label" not in widgets:
            return
        
        text_color = palette.get(text_color_key, "#FFFFFF")
        
        # Determine appropriate background color for contrast check
        bg_color = "#000000"  # Default
        if "emphasis" in text_color_key:
            bg_color = palette.get("emphasis_bg_top", palette.get("felt", "#000000"))
        elif text_color_key == "text":
            bg_color = palette.get("felt", "#000000")
        elif text_color_key == "highlight_text":
            bg_color = palette.get("highlight", "#000000")
        
        ratio = self.theme_manager.calculate_contrast_ratio(bg_color, text_color)
        
        # Format contrast info
        if ratio >= 7.0:
            status = "AAA"
            color = "green"
        elif ratio >= 4.5:
            status = "AA"
            color = "orange"
        else:
            status = "FAIL"
            color = "red"
        
        widgets["contrast_label"].config(
            text=f"{ratio:.1f}:1 ({status})",
            foreground=color
        )
    
    def _pick_color(self, color_key: str):
        """Open color picker for a specific color."""
        if not self.current_theme_id:
            return
        
        current_color = self.color_widgets[color_key]["color_var"].get()
        
        # Open color chooser
        color_result = colorchooser.askcolor(
            color=current_color,
            title=f"Choose {color_key.replace('_', ' ').title()} Color"
        )
        
        if color_result[1]:  # User selected a color
            new_color = color_result[1].upper()
            self._update_color(color_key, new_color)
    
    def _on_color_entry_change(self, color_key: str, new_color: str):
        """Handle manual color entry changes."""
        if new_color.startswith('#') and len(new_color) == 7:
            self._update_color(color_key, new_color.upper())
    
    def _update_color(self, color_key: str, new_color: str):
        """Update a color and refresh the UI."""
        if not self.current_theme_id:
            return
        
        # Update in theme manager
        self.theme_manager.update_color(self.current_theme_id, color_key, new_color)
        
        # Update UI widgets
        widgets = self.color_widgets[color_key]
        widgets["color_box"].config(bg=new_color)
        widgets["color_var"].set(new_color)
        
        # Update contrast info if applicable
        if "contrast_label" in widgets:
            palette = self.theme_manager.get_palette(self.current_theme_id)
            self._update_contrast_info(color_key, palette)
        
        # Trigger live preview if enabled
        if self.preview_mode:
            self._apply_preview()
    
    def _on_hue_change(self, value):
        """Handle global hue adjustment."""
        if not self.current_theme_id or not self.preview_mode:
            return
        
        hue_shift = float(value)
        self.theme_manager.adjust_hue(self.current_theme_id, hue_shift)
        self._refresh_all_color_controls()
    
    def _on_saturation_change(self, value):
        """Handle global saturation adjustment."""
        if not self.current_theme_id or not self.preview_mode:
            return
        
        sat_delta = float(value)
        self.theme_manager.adjust_saturation(self.current_theme_id, sat_delta)
        self._refresh_all_color_controls()
    
    def _on_lightness_change(self, value):
        """Handle global lightness adjustment."""
        if not self.current_theme_id or not self.preview_mode:
            return
        
        light_delta = float(value)
        self.theme_manager.adjust_lightness(self.current_theme_id, light_delta)
        self._refresh_all_color_controls()
    
    def _refresh_all_color_controls(self):
        """Refresh all color control widgets after global adjustments."""
        if self.current_theme_id:
            palette = self.theme_manager.get_palette(self.current_theme_id)
            self._update_color_controls(palette)
    
    def _reset_adjustments(self):
        """Reset global adjustment sliders."""
        self.hue_var.set(0)
        self.saturation_var.set(0)
        self.lightness_var.set(0)
    
    def _create_new_theme(self):
        """Create a new custom theme."""
        dialog = ThemeNameDialog(self, "Create New Theme")
        if dialog.result:
            name = dialog.result
            base_theme_id = self.current_theme_id
            
            new_theme_id = self.theme_manager.create_theme(name, base_theme_id)
            
            # Refresh theme list and select new theme
            self._refresh_theme_list()
            
            # Find and select the new theme
            theme_names = self.theme_manager.get_theme_names()
            for theme_name in theme_names:
                theme = self.theme_manager.get_theme_by_name(theme_name)
                if theme and theme['id'] == new_theme_id:
                    self.theme_var.set(theme_name)
                    self._on_theme_select()
                    break
    
    def _duplicate_theme(self):
        """Duplicate the current theme."""
        if not self.current_theme_id:
            return
        
        current_theme = self.theme_manager.get_theme_by_id(self.current_theme_id)
        if not current_theme:
            return
        
        dialog = ThemeNameDialog(self, f"Duplicate '{current_theme['name']}'")
        if dialog.result:
            name = dialog.result
            new_theme_id = self.theme_manager.duplicate_theme(self.current_theme_id, name)
            
            if new_theme_id:
                self._refresh_theme_list()
                # Select the new duplicated theme
                theme_names = self.theme_manager.get_theme_names()
                for theme_name in theme_names:
                    theme = self.theme_manager.get_theme_by_name(theme_name)
                    if theme and theme['id'] == new_theme_id:
                        self.theme_var.set(theme_name)
                        self._on_theme_select()
                        break
    
    def _save_theme(self):
        """Save current theme changes."""
        if not self.current_theme_id:
            return
        
        if self.theme_manager.save_theme(self.current_theme_id):
            messagebox.showinfo("Success", f"Theme saved successfully!")
        else:
            messagebox.showerror("Error", "Failed to save theme.")
    
    def _revert_theme(self):
        """Revert current theme to saved state."""
        if not self.current_theme_id:
            return
        
        if self.theme_manager.has_unsaved_changes(self.current_theme_id):
            result = messagebox.askyesno("Revert Changes", 
                                       "Are you sure you want to revert all unsaved changes?")
            if result:
                self.theme_manager.revert_changes(self.current_theme_id)
                self._on_theme_select()  # Refresh display
        else:
            messagebox.showinfo("No Changes", "No unsaved changes to revert.")
    
    def _import_theme(self):
        """Import theme from file."""
        file_path = filedialog.askopenfilename(
            title="Import Theme File",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )
        
        if file_path:
            imported_ids = self.theme_manager.import_theme(file_path)
            if imported_ids:
                self._refresh_theme_list()
                messagebox.showinfo("Success", f"Imported {len(imported_ids)} theme(s)!")
            else:
                messagebox.showerror("Error", "Failed to import theme file.")
    
    def _export_theme(self):
        """Export current theme to file."""
        if not self.current_theme_id:
            return
        
        current_theme = self.theme_manager.get_theme_by_id(self.current_theme_id)
        if not current_theme:
            return
        
        file_path = filedialog.asksaveasfilename(
            title="Export Theme",
            defaultextension=".json",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")],
            initialvalue=f"{current_theme['name'].replace(' ', '_')}.json"
        )
        
        if file_path:
            if self.theme_manager.export_theme(self.current_theme_id, file_path):
                messagebox.showinfo("Success", "Theme exported successfully!")
            else:
                messagebox.showerror("Error", "Failed to export theme.")
    
    def _refresh_theme_list(self):
        """Refresh the theme selection combobox."""
        theme_names = self.theme_manager.get_theme_names()
        self.theme_combo['values'] = theme_names
    
    def _apply_preview(self):
        """Apply current theme as preview (if preview mode is enabled)."""
        # This would integrate with the main theme system
        # For now, just update the display
        pass


class ThemeNameDialog:
    """Simple dialog for entering theme names."""
    
    def __init__(self, parent, title: str):
        self.result = None
        
        # Create dialog window
        self.dialog = tk.Toplevel(parent)
        self.dialog.title(title)
        self.dialog.geometry("300x120")
        self.dialog.transient(parent)
        self.dialog.grab_set()
        
        # Center on parent
        self.dialog.geometry("+%d+%d" % (
            parent.winfo_rootx() + 50,
            parent.winfo_rooty() + 50
        ))
        
        # Create UI
        ttk.Label(self.dialog, text="Theme Name:").pack(pady=10)
        
        self.name_var = tk.StringVar()
        entry = ttk.Entry(self.dialog, textvariable=self.name_var, width=30)
        entry.pack(pady=5)
        entry.focus()
        
        # Buttons
        button_frame = ttk.Frame(self.dialog)
        button_frame.pack(pady=10)
        
        ttk.Button(button_frame, text="OK", command=self._ok_clicked).pack(side="left", padx=5)
        ttk.Button(button_frame, text="Cancel", command=self._cancel_clicked).pack(side="left", padx=5)
        
        # Bind Enter key
        entry.bind("<Return>", lambda e: self._ok_clicked())
        
        # Wait for dialog to close
        self.dialog.wait_window()
    
    def _ok_clicked(self):
        """Handle OK button click."""
        name = self.name_var.get().strip()
        if name:
            self.result = name
        self.dialog.destroy()
    
    def _cancel_clicked(self):
        """Handle Cancel button click."""
        self.dialog.destroy()
```

---

### theme_manager.py

**Path**: `backend/ui/theme_manager.py`

**Size**: 33.7 KB

```python
"""
Theme Manager UI for live editing of poker themes.
Supports color picking, HSL nudging, preview, and save/import/export.
"""

import tkinter as tk
from tkinter import ttk, colorchooser, filedialog, messagebox
import colorsys
import copy
import json
import pathlib
from typing import Dict, Any, Optional, Callable

from .services.theme_loader_consolidated import (
    get_consolidated_theme_loader,
    load_themes,
    save_themes,
)


def hex_to_rgbf(hex_color: str) -> tuple[float, float, float]:
    """Convert hex color to RGB float tuple (0-1 range)."""
    hex_color = hex_color.lstrip("#")
    if len(hex_color) == 3:
        hex_color = "".join([c * 2 for c in hex_color])
    return tuple(int(hex_color[i : i + 2], 16) / 255.0 for i in (0, 2, 4))


def rgbf_to_hex(rgb: tuple[float, float, float]) -> str:
    """Convert RGB float tuple to hex color."""
    return "#%02X%02X%02X" % tuple(int(max(0, min(1, x)) * 255) for x in rgb)


def apply_hsl_nudge(
    hex_color: str, dh: float = 0.0, ds: float = 0.0, dl: float = 0.0
) -> str:
    """
    Apply HSL nudges to a hex color.

    Args:
        hex_color: Input color in hex format
        dh: Hue delta (-0.5 to 0.5)
        ds: Saturation delta (-0.5 to 0.5)
        dl: Lightness delta (-0.5 to 0.5)

    Returns:
        Modified color in hex format
    """
    try:
        r, g, b = hex_to_rgbf(hex_color)
        h, l, s = colorsys.rgb_to_hls(r, g, b)

        # Apply nudges with wrapping/clamping
        h = (h + dh) % 1.0
        s = max(0, min(1, s + ds))
        l = max(0, min(1, l + dl))

        R, G, B = colorsys.hls_to_rgb(h, l, s)
        return rgbf_to_hex((R, G, B))

    except Exception:
        # Return original color if conversion fails
        return hex_color


# Editable palette keys (all the important colors)
EDITABLE_KEYS = [
    # Core table colors
    "felt",
    "rail",
    "metal",
    "accent",
    "raise",
    "call",
    "neutral",
    "text",
    # Highlighting and selection
    "highlight",
    "highlight_text",
    # Emphasis bar colors
    "emphasis_bg_top",
    "emphasis_bg_bottom",
    "emphasis_border",
    "emphasis_text",
    "emphasis_accent_text",
    # Chip styling
    "chip_face",
    "chip_edge",
    "chip_rim",
    "chip_text",
    # Bet chip styling
    "bet_face",
    "bet_edge",
    "bet_rim",
    "bet_text",
    "bet_glow",
    # Pot chip styling
    "pot_face",
    "pot_edge",
    "pot_rim",
    "pot_text",
    "pot_glow",
]


class ThemeManager(tk.Toplevel):
    """Advanced Theme Manager with live preview and HSL nudging."""

    def __init__(self, master, on_theme_change: Optional[Callable] = None):
        """
        Initialize Theme Manager.

        Args:
            master: Parent window
            on_theme_change: Callback when theme is saved/changed
        """
        super().__init__(master)
        self.title("üé® Theme Manager - Poker Pro Trainer")
        self.geometry("900x700")

        self.on_theme_change = on_theme_change
        self.live_preview_enabled = (
            False  # Disable auto live preview - use Apply button instead
        )
        self.live_preview_var = tk.BooleanVar(
            value=False
        )  # Tkinter variable for live preview toggle
        self.original_theme = None  # Store original theme for revert on close

        # Load theme configuration (uses existing poker_themes.json as default)
        self.theme_loader = get_consolidated_theme_loader()
        self.config = self.theme_loader.load_themes()
        self.themes = self.config["themes"]
        self.current_index = 0
        self.working_theme = copy.deepcopy(self.themes[self.current_index])
        self.original_theme = copy.deepcopy(
            self.working_theme
        )  # Store original for revert

        # HSL nudge values
        self.hue_var = tk.DoubleVar(value=0.0)
        self.sat_var = tk.DoubleVar(value=0.0)
        self.light_var = tk.DoubleVar(value=0.0)

        # Setup UI
        self._create_ui()
        self._refresh_fields()

        # Make window modal
        self.transient(master)
        self.grab_set()

        # Center on parent
        self.geometry("+%d+%d" % (master.winfo_rootx() + 50, master.winfo_rooty() + 50))

    def _create_ui(self):
        """Create the Theme Manager UI."""
        # Main layout: left panel (themes) | right panel (editor)
        self.columnconfigure(1, weight=1)
        self.rowconfigure(0, weight=1)

        # Left panel - Theme list
        self._create_theme_list_panel()

        # Right panel - Editor
        self._create_editor_panel()

    def _create_theme_list_panel(self):
        """Create the theme list panel."""
        left_frame = ttk.LabelFrame(self, text="üé® Available Themes", padding=10)
        left_frame.grid(row=0, column=0, sticky="nsew", padx=(10, 5), pady=10)
        left_frame.rowconfigure(0, weight=1)

        # Theme listbox with scrollbar
        list_frame = ttk.Frame(left_frame)
        list_frame.grid(row=0, column=0, sticky="nsew")
        list_frame.columnconfigure(0, weight=1)
        list_frame.rowconfigure(0, weight=1)

        self.theme_listbox = tk.Listbox(list_frame, width=25, font=("Inter", 11))
        self.theme_listbox.grid(row=0, column=0, sticky="nsew")
        self.theme_listbox.bind("<<ListboxSelect>>", self._on_theme_select)

        scrollbar = ttk.Scrollbar(
            list_frame, orient="vertical", command=self.theme_listbox.yview
        )
        scrollbar.grid(row=0, column=1, sticky="ns")
        self.theme_listbox.configure(yscrollcommand=scrollbar.set)

        # Populate theme list
        for theme in self.themes:
            self.theme_listbox.insert(tk.END, theme["name"])

        # Select first theme
        self.theme_listbox.selection_set(0)

        # Theme info
        info_frame = ttk.LabelFrame(left_frame, text="Theme Info", padding=5)
        info_frame.grid(row=1, column=0, sticky="ew", pady=(10, 0))
        info_frame.columnconfigure(0, weight=1)

        self.theme_intro_text = tk.Text(
            info_frame, height=4, wrap=tk.WORD, font=("Georgia", 10), state="disabled"
        )
        self.theme_intro_text.grid(row=0, column=0, sticky="ew")

    def _create_editor_panel(self):
        """Create the theme editor panel."""
        right_frame = ttk.Frame(self)
        right_frame.grid(row=0, column=1, sticky="nsew", padx=(5, 10), pady=10)
        right_frame.columnconfigure(0, weight=1)
        right_frame.rowconfigure(1, weight=1)

        # Theme name and basic info
        info_frame = ttk.LabelFrame(right_frame, text="Theme Details", padding=10)
        info_frame.grid(row=0, column=0, sticky="ew", pady=(0, 10))
        info_frame.columnconfigure(1, weight=1)

        ttk.Label(info_frame, text="Name:").grid(
            row=0, column=0, sticky="w", padx=(0, 10)
        )
        self.name_var = tk.StringVar()
        ttk.Entry(info_frame, textvariable=self.name_var).grid(
            row=0, column=1, sticky="ew"
        )

        ttk.Label(info_frame, text="ID:").grid(
            row=1, column=0, sticky="w", padx=(0, 10), pady=(5, 0)
        )
        self.id_var = tk.StringVar()
        ttk.Entry(info_frame, textvariable=self.id_var).grid(
            row=1, column=1, sticky="ew", pady=(5, 0)
        )

        # Color editor in scrollable frame
        canvas_frame = ttk.LabelFrame(right_frame, text="Color Palette", padding=5)
        canvas_frame.grid(row=1, column=0, sticky="nsew", pady=(0, 10))
        canvas_frame.columnconfigure(0, weight=1)
        canvas_frame.rowconfigure(0, weight=1)

        # Create scrollable canvas for color entries
        canvas = tk.Canvas(canvas_frame, height=300)
        scrollbar_v = ttk.Scrollbar(
            canvas_frame, orient="vertical", command=canvas.yview
        )
        scrollable_frame = ttk.Frame(canvas)

        canvas.grid(row=0, column=0, sticky="nsew")
        scrollbar_v.grid(row=0, column=1, sticky="ns")

        canvas.configure(yscrollcommand=scrollbar_v.set)
        canvas_window = canvas.create_window(
            (0, 0), window=scrollable_frame, anchor="nw"
        )

        # Color entries
        self.color_entries = {}
        scrollable_frame.columnconfigure(1, weight=1)

        for i, key in enumerate(EDITABLE_KEYS):
            # Label
            ttk.Label(scrollable_frame, text=key.replace("_", " ").title() + ":").grid(
                row=i, column=0, sticky="w", padx=(5, 10), pady=2
            )

            # Color entry
            entry = ttk.Entry(scrollable_frame, width=10)
            entry.grid(row=i, column=1, sticky="ew", padx=(0, 5), pady=2)
            entry.bind("<KeyRelease>", lambda e, k=key: self._on_color_change(k))

            # Color picker button
            color_btn = tk.Button(
                scrollable_frame,
                text="üé®",
                width=3,
                command=lambda k=key: self._pick_color(k),
            )
            color_btn.grid(row=i, column=2, padx=(5, 5), pady=2)

            # Color preview
            preview = tk.Label(
                scrollable_frame, text="  ", width=4, relief="solid", borderwidth=1
            )
            preview.grid(row=i, column=3, padx=(0, 5), pady=2)

            self.color_entries[key] = {
                "entry": entry,
                "button": color_btn,
                "preview": preview,
            }

        # Update scroll region when frame changes
        def configure_scroll(event):
            canvas.configure(scrollregion=canvas.bbox("all"))
            # Update canvas window width to match canvas
            canvas_width = canvas.winfo_width()
            canvas.itemconfig(canvas_window, width=canvas_width)

        scrollable_frame.bind("<Configure>", configure_scroll)
        canvas.bind("<Configure>", configure_scroll)

        # HSL nudge controls
        hsl_frame = ttk.LabelFrame(
            right_frame, text="Global HSL Adjustments", padding=10
        )
        hsl_frame.grid(row=2, column=0, sticky="ew", pady=(0, 10))
        hsl_frame.columnconfigure(1, weight=1)

        # Hue slider
        ttk.Label(hsl_frame, text="Hue:").grid(
            row=0, column=0, sticky="w", padx=(0, 10)
        )
        hue_scale = ttk.Scale(
            hsl_frame,
            from_=-0.5,
            to=0.5,
            orient="horizontal",
            variable=self.hue_var,
            length=200,
        )
        hue_scale.grid(row=0, column=1, sticky="ew", padx=(0, 10))
        ttk.Label(hsl_frame, textvariable=self.hue_var).grid(row=0, column=2)

        # Saturation slider
        ttk.Label(hsl_frame, text="Saturation:").grid(
            row=1, column=0, sticky="w", padx=(0, 10), pady=(5, 0)
        )
        sat_scale = ttk.Scale(
            hsl_frame,
            from_=-0.5,
            to=0.5,
            orient="horizontal",
            variable=self.sat_var,
            length=200,
        )
        sat_scale.grid(row=1, column=1, sticky="ew", padx=(0, 10), pady=(5, 0))
        ttk.Label(hsl_frame, textvariable=self.sat_var).grid(
            row=1, column=2, pady=(5, 0)
        )

        # Lightness slider
        ttk.Label(hsl_frame, text="Lightness:").grid(
            row=2, column=0, sticky="w", padx=(0, 10), pady=(5, 0)
        )
        light_scale = ttk.Scale(
            hsl_frame,
            from_=-0.5,
            to=0.5,
            orient="horizontal",
            variable=self.light_var,
            length=200,
        )
        light_scale.grid(row=2, column=1, sticky="ew", padx=(0, 10), pady=(5, 0))
        ttk.Label(hsl_frame, textvariable=self.light_var).grid(
            row=2, column=2, pady=(5, 0)
        )

        # Apply HSL button
        ttk.Button(
            hsl_frame,
            text="Apply HSL to All Colors",
            command=self._apply_hsl_to_palette,
        ).grid(row=3, column=0, columnspan=3, pady=(10, 0))

        # Preview controls
        preview_frame = ttk.LabelFrame(right_frame, text="Preview & Apply", padding=10)
        preview_frame.grid(row=3, column=0, sticky="ew", pady=(10, 0))
        preview_frame.columnconfigure(0, weight=1)

        # Apply button (main action)
        apply_btn = ttk.Button(
            preview_frame,
            text="üî¥ Apply to Main App",
            command=self._apply_theme_to_main_app,
            style="Accent.TButton",
        )
        apply_btn.grid(row=0, column=0, sticky="ew", pady=(0, 5))

        # Status label
        self.apply_status = ttk.Label(
            preview_frame, text="üí° Click 'Apply' to preview changes in main app"
        )
        self.apply_status.grid(row=1, column=0, sticky="w")

        # Live preview toggle
        live_preview_check = ttk.Checkbutton(
            preview_frame,
            text="‚ö° Live Preview (real-time changes)",
            variable=self.live_preview_var,
            command=self._on_live_preview_toggle,
        )
        live_preview_check.grid(row=2, column=0, sticky="w", pady=(5, 0))

        # Action buttons
        action_frame = ttk.Frame(right_frame)
        action_frame.grid(row=4, column=0, sticky="ew")

        # Primary actions
        ttk.Button(action_frame, text="üíæ Save", command=self._save_theme).pack(
            side="left", padx=(0, 5)
        )
        ttk.Button(
            action_frame, text="üíæ Save As...", command=self._save_as_theme
        ).pack(side="left", padx=5)
        ttk.Button(action_frame, text="üîÑ Reset", command=self._reset_theme).pack(
            side="left", padx=5
        )

        # Close button
        ttk.Button(
            action_frame, text="‚ùå Close", command=self._close_theme_manager
        ).pack(side="right", padx=(5, 0))

        # File operations
        ttk.Button(action_frame, text="üì§ Export...", command=self._export_themes).pack(
            side="right", padx=5
        )
        ttk.Button(action_frame, text="üì• Import...", command=self._import_themes).pack(
            side="right", padx=5
        )

    def _on_theme_select(self, event=None):
        """Handle theme selection from list."""
        selection = self.theme_listbox.curselection()
        if not selection:
            return

        self.current_index = selection[0]
        self.working_theme = copy.deepcopy(self.themes[self.current_index])
        self.original_theme = copy.deepcopy(
            self.working_theme
        )  # Update original for new selection
        self._refresh_fields()

        # Update status for new theme selection
        theme_name = self.working_theme.get("name", "Unknown")
        self.apply_status.config(
            text=f"üí° Selected '{theme_name}' - click 'Apply' to preview"
        )

    def _refresh_fields(self):
        """Refresh all UI fields with current theme data."""
        theme = self.working_theme

        # Update theme info
        self.name_var.set(theme.get("name", ""))
        self.id_var.set(theme.get("id", ""))

        # Update theme intro text
        intro = theme.get("intro", "")
        persona = theme.get("persona", "")
        full_text = intro
        if persona:
            full_text += f"\n\n{persona}"

        self.theme_intro_text.config(state="normal")
        self.theme_intro_text.delete(1.0, tk.END)
        self.theme_intro_text.insert(1.0, full_text)
        self.theme_intro_text.config(state="disabled")

        # Update color fields
        palette = theme.get("palette", {})
        for key, widgets in self.color_entries.items():
            color = palette.get(key, "#FFFFFF")
            widgets["entry"].delete(0, tk.END)
            widgets["entry"].insert(0, color)

            # Update color preview
            try:
                widgets["preview"].config(bg=color)
                # Set text color for contrast
                r, g, b = hex_to_rgbf(color)
                brightness = (r * 299 + g * 587 + b * 114) / 1000
                text_color = "#000000" if brightness > 0.5 else "#FFFFFF"
                widgets["preview"].config(fg=text_color)
            except Exception:
                widgets["preview"].config(bg="#FFFFFF", fg="#000000")

        # Reset HSL sliders
        self.hue_var.set(0.0)
        self.sat_var.set(0.0)
        self.light_var.set(0.0)

    def _on_color_change(self, key: str):
        """Handle color entry change."""
        entry = self.color_entries[key]["entry"]
        color = entry.get()

        # Update working theme
        if "palette" not in self.working_theme:
            self.working_theme["palette"] = {}
        self.working_theme["palette"][key] = color

        # Update preview
        self._update_color_preview(key, color)

        # Apply live preview if enabled
        if self.live_preview_enabled:
            self._apply_live_preview()
        else:
            # Update status to show changes are ready to apply
            self.apply_status.config(
                text="üîÑ Changes ready - click 'Apply' to preview in main app"
            )

    def _update_color_preview(self, key: str, color: str):
        """Update color preview for a key."""
        try:
            preview = self.color_entries[key]["preview"]
            preview.config(bg=color)

            # Set text color for contrast
            r, g, b = hex_to_rgbf(color)
            brightness = (r * 299 + g * 587 + b * 114) / 1000
            text_color = "#000000" if brightness > 0.5 else "#FFFFFF"
            preview.config(fg=text_color)
        except Exception:
            pass

    def _pick_color(self, key: str):
        """Open color picker for a key."""
        current_color = self.color_entries[key]["entry"].get()

        # Open color chooser
        rgb, hex_color = colorchooser.askcolor(
            color=current_color, title=f"Pick color for {key.replace('_', ' ').title()}"
        )

        if hex_color:
            # Update entry and working theme
            self.color_entries[key]["entry"].delete(0, tk.END)
            self.color_entries[key]["entry"].insert(0, hex_color.upper())

            if "palette" not in self.working_theme:
                self.working_theme["palette"] = {}
            self.working_theme["palette"][key] = hex_color.upper()

            # Update preview
            self._update_color_preview(key, hex_color)

            # Update status to show changes are ready to apply
            self.apply_status.config(
                text="üîÑ Changes ready - click 'Apply' to preview in main app"
            )

    def _apply_hsl_to_palette(self):
        """Apply HSL nudges to all palette colors."""
        dh = self.hue_var.get()
        ds = self.sat_var.get()
        dl = self.light_var.get()

        palette = self.working_theme.get("palette", {})

        for key in EDITABLE_KEYS:
            current_color = palette.get(key, "#FFFFFF")
            if current_color.startswith("#"):
                new_color = apply_hsl_nudge(current_color, dh, ds, dl)
                palette[key] = new_color

                # Update UI
                self.color_entries[key]["entry"].delete(0, tk.END)
                self.color_entries[key]["entry"].insert(0, new_color)
                self._update_color_preview(key, new_color)

        # Reset sliders
        self.hue_var.set(0.0)
        self.sat_var.set(0.0)
        self.light_var.set(0.0)

        # Update status to show changes are ready to apply
        self.apply_status.config(
            text="üîÑ HSL changes ready - click 'Apply' to preview in main app"
        )

    def _save_theme(self):
        """Save current theme changes."""
        # Update theme with current field values
        self.working_theme["name"] = self.name_var.get()
        self.working_theme["id"] = self.id_var.get()

        # Update palette from entries
        if "palette" not in self.working_theme:
            self.working_theme["palette"] = {}

        for key, widgets in self.color_entries.items():
            self.working_theme["palette"][key] = widgets["entry"].get()

        # Update themes list
        self.themes[self.current_index] = self.working_theme

        # Save to current file (or default)
        if self.theme_loader.save_themes(self.config):
            current_file = self.theme_loader.get_current_file()
            file_name = current_file.name if current_file else "default themes"

            # CRITICAL: Update the main app's theme system with saved changes
            print("üîÑ Applying saved theme changes to main app...")

            # Force complete refresh of main application
            if self.on_theme_change:
                print("üîÑ Triggering theme refresh callback...")
                self.on_theme_change()
                print("‚úÖ Theme refresh callback completed")

            messagebox.showinfo(
                "Theme Manager",
                f"Theme saved to {file_name}!\n\nChanges have been applied to the main application.",
            )

            # Update status and offer to close
            self.apply_status.config(text="‚úÖ Theme saved! Changes are now permanent.")

            # Ask if user wants to close after saving
            if messagebox.askyesno(
                "Theme Saved", "Theme saved successfully!\n\nClose Theme Manager?"
            ):
                self.destroy()
        else:
            messagebox.showerror("Theme Manager", "Failed to save theme.")

    def _save_as_theme(self):
        """Save as new theme."""
        name = self._prompt_for_text("New Theme Name", "Enter name for new theme:")
        if not name:
            return

        # Create new theme
        new_theme = copy.deepcopy(self.working_theme)
        new_theme["name"] = name
        new_theme["id"] = name.lower().replace(" ", "-").replace("_", "-")

        # Update palette from entries
        if "palette" not in new_theme:
            new_theme["palette"] = {}

        for key, widgets in self.color_entries.items():
            new_theme["palette"][key] = widgets["entry"].get()

        # Add to themes list
        self.themes.append(new_theme)
        self.theme_listbox.insert(tk.END, name)

        # Select new theme
        self.theme_listbox.selection_clear(0, tk.END)
        self.theme_listbox.selection_set(tk.END)
        self.current_index = len(self.themes) - 1

        # Save to current file
        if self.theme_loader.save_themes(self.config):
            # CRITICAL: Update the main app's theme system with new theme
            print("üîÑ Applying new theme to main app...")

            # Force complete refresh of main application
            if self.on_theme_change:
                print("üîÑ Triggering theme refresh callback...")
                self.on_theme_change()
                print("‚úÖ Theme refresh callback completed")

            messagebox.showinfo(
                "Theme Manager",
                f"New theme '{name}' created successfully!\n\nChanges have been applied to the main application.",
            )

            # Update status
            self.apply_status.config(text=f"‚úÖ New theme '{name}' created and saved!")

            # Ask if user wants to close after saving
            if messagebox.askyesno(
                "New Theme Created",
                f"New theme '{name}' created successfully!\n\nClose Theme Manager?",
            ):
                self.destroy()
        else:
            messagebox.showerror("Theme Manager", "Failed to save new theme.")

    def _reset_theme(self):
        """Reset theme to original state."""
        if messagebox.askyesno(
            "Reset Theme",
            "Reset theme to original state? This will lose any unsaved changes.",
        ):
            # Reload from current file
            self.config = self.theme_loader.reload()
            self.themes = self.config["themes"]

            # Reset to current theme
            if self.current_index < len(self.themes):
                self.working_theme = copy.deepcopy(self.themes[self.current_index])
                self._refresh_fields()

    def _export_themes(self):
        """Export themes to JSON file."""
        current_file = self.theme_loader.get_current_file()
        initial_name = current_file.stem if current_file else "poker_themes"

        filename = filedialog.asksaveasfilename(
            defaultextension=".json",
            initialvalue=f"{initial_name}_export.json",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")],
            title="Export Themes",
        )

        if filename:
            if self.theme_loader.save_to_file(self.config, filename):
                messagebox.showinfo("Theme Manager", f"Themes exported to {filename}")
            else:
                messagebox.showerror("Theme Manager", "Export failed")

    def _import_themes(self):
        """Import themes from JSON file."""
        filename = filedialog.askopenfilename(
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")],
            title="Load Theme File",
        )

        if filename:
            try:
                # Load themes from selected file
                imported_config = self.theme_loader.load_from_file(filename)

                # Validate structure
                if "themes" not in imported_config:
                    messagebox.showerror(
                        "Theme Manager", "Invalid theme file: missing 'themes' key"
                    )
                    return

                # Replace current config
                self.config = imported_config
                self.themes = self.config["themes"]

                # Refresh theme list
                self.theme_listbox.delete(0, tk.END)
                for theme in self.themes:
                    self.theme_listbox.insert(tk.END, theme.get("name", "Unknown"))

                # Select first theme
                if self.themes:
                    self.theme_listbox.selection_set(0)
                    self.current_index = 0
                    self.working_theme = copy.deepcopy(self.themes[0])
                    self._refresh_fields()

                file_name = pathlib.Path(filename).name
                messagebox.showinfo(
                    "Theme Manager",
                    f"Loaded {len(self.themes)} themes from {file_name}",
                )

            except Exception as e:
                messagebox.showerror("Theme Manager", f"Failed to load theme file: {e}")

    def _prompt_for_text(self, title: str, prompt: str) -> Optional[str]:
        """Show a simple text input dialog."""
        dialog = tk.Toplevel(self)
        dialog.title(title)
        dialog.geometry("300x150")
        dialog.transient(self)
        dialog.grab_set()

        # Center on parent
        dialog.geometry(
            "+%d+%d"
            % (
                self.winfo_rootx() + self.winfo_width() // 2 - 150,
                self.winfo_rooty() + self.winfo_height() // 2 - 75,
            )
        )

        result = {"value": None}

        # Prompt label
        ttk.Label(dialog, text=prompt).pack(pady=10)

        # Entry field
        entry_var = tk.StringVar()
        entry = ttk.Entry(dialog, textvariable=entry_var, width=30)
        entry.pack(pady=5)
        entry.focus_set()

        # Buttons
        button_frame = ttk.Frame(dialog)
        button_frame.pack(pady=10)

        def on_ok():
            result["value"] = entry_var.get().strip()
            dialog.destroy()

        def on_cancel():
            dialog.destroy()

        ttk.Button(button_frame, text="OK", command=on_ok).pack(side="left", padx=5)
        ttk.Button(button_frame, text="Cancel", command=on_cancel).pack(
            side="left", padx=5
        )

        # Bind Enter key
        entry.bind("<Return>", lambda e: on_ok())

        # Wait for dialog to close
        self.wait_window(dialog)

        return result["value"] if result["value"] else None

    def _apply_theme_to_main_app(self):
        """Apply current theme changes to main app for preview (without saving)."""
        try:
            # Update working theme with current field values
            self.working_theme["name"] = self.name_var.get()
            self.working_theme["id"] = self.id_var.get()

            if "palette" not in self.working_theme:
                self.working_theme["palette"] = {}

            for key, widgets in self.color_entries.items():
                self.working_theme["palette"][key] = widgets["entry"].get()

            # Build theme tokens directly from the working theme data
            try:
                from .services.theme_derive import derive_tokens
                from .services.theme_loader import get_theme_loader
                
                # Get defaults for theme building
                loader = get_theme_loader()
                defaults = loader.get_defaults()
                
                # Build complete theme tokens from our working palette
                palette = self.working_theme.get("palette", {})
                theme_tokens = derive_tokens(palette)
                
                # Get the theme manager from main app and directly register the updated theme
                if self.on_theme_change:
                    print("üîÑ Applying theme changes to main app...")
                    
                    # Instead of rebuilding all themes, directly update the current theme
                    # This will be handled by the callback which rebuilds everything
                    # But first, temporarily update the theme in memory so the rebuild picks it up
                    original_theme = copy.deepcopy(self.themes[self.current_index])
                    self.themes[self.current_index] = copy.deepcopy(self.working_theme)
                    
                    # Temporarily save to disk so the rebuild can find the updated theme
                    temp_saved = self.theme_loader.save_themes(self.config)
                    
                    if temp_saved:
                        # Trigger the main app refresh
                        self.on_theme_change()
                        print("‚úÖ Theme applied to main app")

                        theme_name = self.working_theme.get("name", "Unknown")
                        self.apply_status.config(
                            text=f"‚úÖ '{theme_name}' applied! Save to make permanent."
                        )
                    else:
                        # Restore original theme if temp save failed
                        self.themes[self.current_index] = original_theme
                        self.apply_status.config(text="‚ùå Error applying theme - temp save failed")
                else:
                    self.apply_status.config(text="‚ö†Ô∏è No main app connection")
                    
            except ImportError as e:
                print(f"‚ö†Ô∏è Could not import theme building modules: {e}")
                self.apply_status.config(text="‚ùå Theme building system not available")

        except Exception as e:
            print(f"‚ùå Error applying theme to main app: {e}")
            self.apply_status.config(text="‚ùå Error applying theme")

    def _apply_live_preview(self):
        """Apply live preview if enabled."""
        if self.live_preview_enabled and self.on_theme_change:
            try:
                # Update working theme with current UI values
                self._update_working_theme_from_ui()
                # Apply to main app
                self._apply_theme_to_main_app()
                print("‚ö° Live preview applied")
            except Exception as e:
                print(f"‚ùå Live preview error: {e}")

    def _on_live_preview_toggle(self):
        """Handle live preview toggle."""
        self.live_preview_enabled = self.live_preview_var.get()
        print(
            f"üîÑ Live preview {'enabled' if self.live_preview_enabled else 'disabled'}"
        )

        # If turning on live preview, apply current state immediately
        if self.live_preview_enabled:
            self._apply_live_preview()

    def _update_working_theme_from_ui(self):
        """Update working theme with current UI values."""
        if "palette" not in self.working_theme:
            self.working_theme["palette"] = {}

        # Update from color entries
        for key, widgets in self.color_entries.items():
            self.working_theme["palette"][key] = widgets["entry"].get()

    def _close_theme_manager(self):
        """Close Theme Manager and revert to original theme if not saved."""
        try:
            # Check if there are unsaved changes
            has_changes = False
            if self.original_theme and self.working_theme:
                # Compare palettes to see if there are changes
                original_palette = self.original_theme.get("palette", {})
                working_palette = self.working_theme.get("palette", {})

                for key in EDITABLE_KEYS:
                    if original_palette.get(key) != working_palette.get(key):
                        has_changes = True
                        break

            # If there are unsaved changes, ask user
            if has_changes:
                from tkinter import messagebox

                response = messagebox.askyesnocancel(
                    "Unsaved Changes",
                    "You have unsaved theme changes.\n\n"
                    "‚Ä¢ Yes: Save changes and close\n"
                    "‚Ä¢ No: Discard changes and close\n"
                    "‚Ä¢ Cancel: Keep editing",
                )

                if response is None:  # Cancel
                    return
                elif response:  # Yes - save
                    self._save_theme()
                    # Don't close yet - let save complete
                    return
                else:  # No - discard
                    # Revert to original theme in main app
                    if self.original_theme:
                        self.themes[self.current_index] = copy.deepcopy(
                            self.original_theme
                        )
                        if self.on_theme_change:
                            print("üîÑ Reverting to original theme...")
                            self.on_theme_change()

            # Close the dialog
            self.destroy()

        except Exception as e:
            print(f"‚ùå Error closing theme manager: {e}")
            # Force close anyway
            self.destroy()
```

---

## CONFIGURATION & DATA

### theme_manager.data.json

**Path**: `.mypy_cache/3.13/backend/theme_system_package/source_files/ui/services/theme_manager.data.json`

**Size**: 18.8 KB

```json
{".class":"MypyFile","_fullname":"backend.theme_system_package.source_files.ui.services.theme_manager","future_import_flags":["annotations"],"is_partial_stub_package":false,"is_stub":false,"names":{".class":"SymbolTable","Any":{".class":"SymbolTableNode","cross_ref":"typing.Any","kind":"Gdef"},"Callable":{".class":"SymbolTableNode","cross_ref":"typing.Callable","kind":"Gdef"},"Dict":{".class":"SymbolTableNode","cross_ref":"typing.Dict","kind":"Gdef"},"List":{".class":"SymbolTableNode","cross_ref":"typing.List","kind":"Gdef"},"ThemeManager":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["builtins.object"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager","name":"ThemeManager","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"backend.theme_system_package.source_files.ui.services.theme_manager","mro":["backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager","builtins.object"],"names":{".class":"SymbolTable","CONFIG_PATH":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_inferred","has_explicit_value"],"fullname":"backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager.CONFIG_PATH","name":"CONFIG_PATH","type":"builtins.str"}},"__init__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_builtin_packs":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager._builtin_packs","name":"_builtin_packs","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_builtin_packs of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_current":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager._current","name":"_current","type":{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}}},"_fonts":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager._fonts","name":"_fonts","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"_load_config":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager._load_config","name":"_load_config","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_load_config of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_save_config":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager._save_config","name":"_save_config","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_save_config of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_subs":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager._subs","name":"_subs","type":{".class":"Instance","args":[{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}],"extra_attrs":null,"type_ref":"builtins.list"}}},"_theme":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager._theme","name":"_theme","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"_themes":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager._themes","name":"_themes","type":{".class":"Instance","args":["builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"current_profile_name":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager.current_profile_name","name":"current_profile_name","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"current_profile_name of ThemeManager","ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,1],"arg_names":["self","token","default"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager.get","name":"get","type":{".class":"CallableType","arg_kinds":[0,0,1],"arg_names":["self","token","default"],"arg_types":["backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager","builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get of ThemeManager","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_fonts":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager.get_fonts","name":"get_fonts","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_fonts of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_theme":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager.get_theme","name":"get_theme","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_theme of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"names":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager.names","name":"names","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"names of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"builtins.list"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"register":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":["self","name","tokens"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager.register","name":"register","type":{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":["self","name","tokens"],"arg_types":["backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager","builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"register of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"set_fonts":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","fonts"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager.set_fonts","name":"set_fonts","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","fonts"],"arg_types":["backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"set_fonts of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"set_profile":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","name"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager.set_profile","name":"set_profile","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","name"],"arg_types":["backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"set_profile of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"subscribe":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","fn"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager.subscribe","name":"subscribe","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","fn"],"arg_types":["backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager",{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"subscribe of ThemeManager","ret_type":{".class":"CallableType","arg_kinds":[],"arg_names":[],"arg_types":[],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager.Self","id":0,"name":"Self","namespace":"","upper_bound":"backend.theme_system_package.source_files.ui.services.theme_manager.ThemeManager","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"__annotations__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.theme_system_package.source_files.ui.services.theme_manager.__annotations__","name":"__annotations__","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"__doc__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.theme_system_package.source_files.ui.services.theme_manager.__doc__","name":"__doc__","type":"builtins.str"}},"__file__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.theme_system_package.source_files.ui.services.theme_manager.__file__","name":"__file__","type":"builtins.str"}},"__name__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.theme_system_package.source_files.ui.services.theme_manager.__name__","name":"__name__","type":"builtins.str"}},"__package__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.theme_system_package.source_files.ui.services.theme_manager.__package__","name":"__package__","type":"builtins.str"}},"__spec__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.theme_system_package.source_files.ui.services.theme_manager.__spec__","name":"__spec__","type":"_frozen_importlib.ModuleSpec"}},"annotations":{".class":"SymbolTableNode","cross_ref":"__future__.annotations","kind":"Gdef"},"importlib":{".class":"SymbolTableNode","cross_ref":"importlib","kind":"Gdef"},"json":{".class":"SymbolTableNode","cross_ref":"json","kind":"Gdef"},"os":{".class":"SymbolTableNode","cross_ref":"os","kind":"Gdef"}},"path":"/Users/yeogirlyun/Python/Poker/backend/theme_system_package/source_files/ui/services/theme_manager.py"}
```

---

### theme_manager.meta.json

**Path**: `.mypy_cache/3.13/backend/theme_system_package/source_files/ui/services/theme_manager.meta.json`

**Size**: 1.8 KB

```json
{"data_mtime":1755414375,"dep_lines":[1,3,4,5,6,1,1,1,1,1,1,1,1,1],"dep_prios":[5,5,10,10,10,5,30,30,30,30,30,30,30,30],"dependencies":["__future__","typing","importlib","json","os","builtins","_collections_abc","_frozen_importlib","_io","_typeshed","abc","io","json.decoder","types"],"hash":"c84c69729ffbaf3b874abb603fa33198e6f1b83c","id":"backend.theme_system_package.source_files.ui.services.theme_manager","ignore_all":true,"interface_hash":"f08ac020e5c44fe14eb89eca310fd9a4bd6a99ff","mtime":1755398678,"options":{"allow_redefinition":false,"allow_untyped_globals":false,"always_false":[],"always_true":[],"bazel":false,"check_untyped_defs":false,"disable_bytearray_promotion":false,"disable_error_code":[],"disable_memoryview_promotion":false,"disabled_error_codes":[],"disallow_any_decorated":false,"disallow_any_explicit":false,"disallow_any_expr":false,"disallow_any_generics":false,"disallow_any_unimported":false,"disallow_incomplete_defs":false,"disallow_subclassing_any":false,"disallow_untyped_calls":false,"disallow_untyped_decorators":false,"disallow_untyped_defs":false,"enable_error_code":[],"enabled_error_codes":[],"extra_checks":false,"follow_imports":"normal","follow_imports_for_stubs":false,"follow_untyped_imports":false,"ignore_errors":false,"ignore_missing_imports":false,"implicit_optional":false,"implicit_reexport":true,"local_partial_types":false,"mypyc":false,"old_type_inference":false,"platform":"darwin","plugins":[],"strict_concatenate":false,"strict_equality":false,"strict_optional":true,"warn_no_return":true,"warn_return_any":false,"warn_unreachable":false,"warn_unused_ignores":false},"path":"/Users/yeogirlyun/Python/Poker/backend/theme_system_package/source_files/ui/services/theme_manager.py","plugin_data":null,"size":46765,"suppressed":[],"version_id":"1.14.1"}
```

---

### theme_system_package.data.json

**Path**: `.mypy_cache/3.13/backend/theme_system_package.data.json`

**Size**: 1.5 KB

```json
{".class":"MypyFile","_fullname":"backend.theme_system_package","future_import_flags":[],"is_partial_stub_package":false,"is_stub":false,"names":{".class":"SymbolTable","__annotations__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.theme_system_package.__annotations__","name":"__annotations__","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"__doc__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.theme_system_package.__doc__","name":"__doc__","type":"builtins.str"}},"__file__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.theme_system_package.__file__","name":"__file__","type":"builtins.str"}},"__name__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.theme_system_package.__name__","name":"__name__","type":"builtins.str"}},"__package__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.theme_system_package.__package__","name":"__package__","type":"builtins.str"}},"__spec__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.theme_system_package.__spec__","name":"__spec__","type":"_frozen_importlib.ModuleSpec"}}},"path":"/Users/yeogirlyun/Python/Poker/backend/theme_system_package"}
```

---

### theme_system_package.meta.json

**Path**: `.mypy_cache/3.13/backend/theme_system_package.meta.json`

**Size**: 1.5 KB

```json
{"data_mtime":1755414375,"dep_lines":[1,1,1,1],"dep_prios":[5,30,30,30],"dependencies":["builtins","_frozen_importlib","abc","typing"],"hash":"","id":"backend.theme_system_package","ignore_all":true,"interface_hash":"a466ea7dcc2ae89a0977a7db5f1997b3ff7a2a41","mtime":1755398669,"options":{"allow_redefinition":false,"allow_untyped_globals":false,"always_false":[],"always_true":[],"bazel":false,"check_untyped_defs":false,"disable_bytearray_promotion":false,"disable_error_code":[],"disable_memoryview_promotion":false,"disabled_error_codes":[],"disallow_any_decorated":false,"disallow_any_explicit":false,"disallow_any_expr":false,"disallow_any_generics":false,"disallow_any_unimported":false,"disallow_incomplete_defs":false,"disallow_subclassing_any":false,"disallow_untyped_calls":false,"disallow_untyped_decorators":false,"disallow_untyped_defs":false,"enable_error_code":[],"enabled_error_codes":[],"extra_checks":false,"follow_imports":"normal","follow_imports_for_stubs":false,"follow_untyped_imports":false,"ignore_errors":false,"ignore_missing_imports":false,"implicit_optional":false,"implicit_reexport":true,"local_partial_types":false,"mypyc":false,"old_type_inference":false,"platform":"darwin","plugins":[],"strict_concatenate":false,"strict_equality":false,"strict_optional":true,"warn_no_return":true,"warn_return_any":false,"warn_unreachable":false,"warn_unused_ignores":false},"path":"/Users/yeogirlyun/Python/Poker/backend/theme_system_package","plugin_data":null,"size":128,"suppressed":[],"version_id":"1.14.1"}
```

---

### theme_derive.data.json

**Path**: `.mypy_cache/3.13/backend/ui/services/theme_derive.data.json`

**Size**: 13.5 KB

```json
{".class":"MypyFile","_fullname":"backend.ui.services.theme_derive","future_import_flags":[],"is_partial_stub_package":false,"is_stub":false,"names":{".class":"SymbolTable","Any":{".class":"SymbolTableNode","cross_ref":"typing.Any","kind":"Gdef"},"Dict":{".class":"SymbolTableNode","cross_ref":"typing.Dict","kind":"Gdef"},"__annotations__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_derive.__annotations__","name":"__annotations__","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"__doc__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_derive.__doc__","name":"__doc__","type":"builtins.str"}},"__file__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_derive.__file__","name":"__file__","type":"builtins.str"}},"__name__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_derive.__name__","name":"__name__","type":"builtins.str"}},"__package__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_derive.__package__","name":"__package__","type":"builtins.str"}},"__spec__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_derive.__spec__","name":"__spec__","type":"_frozen_importlib.ModuleSpec"}},"alpha_over":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":["src","dst","alpha"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_derive.alpha_over","name":"alpha_over","type":{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":["src","dst","alpha"],"arg_types":["builtins.str","builtins.str","builtins.float"],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"alpha_over","ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"clamp":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["x"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_derive.clamp","name":"clamp","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["x"],"arg_types":["builtins.float"],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"clamp","ret_type":"builtins.int","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"darken":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["hex_color","t"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_derive.darken","name":"darken","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["hex_color","t"],"arg_types":["builtins.str","builtins.float"],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"darken","ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"derive_tokens":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["palette"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_derive.derive_tokens","name":"derive_tokens","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["palette"],"arg_types":[{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"derive_tokens","ret_type":{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_chip_styles":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["defaults","palette"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_derive.get_chip_styles","name":"get_chip_styles","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["defaults","palette"],"arg_types":[{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_chip_styles","ret_type":{".class":"Instance","args":["builtins.str",{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_emphasis_bar_style":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["defaults","palette"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_derive.get_emphasis_bar_style","name":"get_emphasis_bar_style","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["defaults","palette"],"arg_types":[{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_emphasis_bar_style","ret_type":{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_player_state_style":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["defaults","palette"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_derive.get_player_state_style","name":"get_player_state_style","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["defaults","palette"],"arg_types":[{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_player_state_style","ret_type":{".class":"Instance","args":["builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_selection_style":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["defaults","palette"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_derive.get_selection_style","name":"get_selection_style","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["defaults","palette"],"arg_types":[{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_selection_style","ret_type":{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"hex_to_rgb":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["hex_color"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_derive.hex_to_rgb","name":"hex_to_rgb","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["hex_color"],"arg_types":["builtins.str"],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"hex_to_rgb","ret_type":{".class":"TupleType","implicit":false,"items":["builtins.int","builtins.int","builtins.int"],"partial_fallback":{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.tuple"}},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"lighten":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["hex_color","t"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_derive.lighten","name":"lighten","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["hex_color","t"],"arg_types":["builtins.str","builtins.float"],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"lighten","ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"mix":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":["color_a","color_b","t"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_derive.mix","name":"mix","type":{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":["color_a","color_b","t"],"arg_types":["builtins.str","builtins.str","builtins.float"],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"mix","ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"resolve_token_references":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["config","palette"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_derive.resolve_token_references","name":"resolve_token_references","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["config","palette"],"arg_types":[{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"resolve_token_references","ret_type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"rgb_to_hex":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["rgb_tuple"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_derive.rgb_to_hex","name":"rgb_to_hex","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["rgb_tuple"],"arg_types":[{".class":"TupleType","implicit":false,"items":["builtins.float","builtins.float","builtins.float"],"partial_fallback":{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.tuple"}}],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"rgb_to_hex","ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"path":"/Users/yeogirlyun/Python/Poker/backend/ui/services/theme_derive.py"}
```

---

### theme_derive.meta.json

**Path**: `.mypy_cache/3.13/backend/ui/services/theme_derive.meta.json`

**Size**: 1.6 KB

```json
{"data_mtime":1755416417,"dep_lines":[6,1,1,1,1,1,1],"dep_prios":[5,5,30,30,30,30,30],"dependencies":["typing","builtins","_collections_abc","_frozen_importlib","_typeshed","abc","types"],"hash":"e7f3b0a4a86ecd271d15aa15826fe19f51df9a98","id":"backend.ui.services.theme_derive","ignore_all":false,"interface_hash":"ff7e67a434f9d3e91f67f20cd80be636335f28d6","mtime":1755417258,"options":{"allow_redefinition":false,"allow_untyped_globals":false,"always_false":[],"always_true":[],"bazel":false,"check_untyped_defs":false,"disable_bytearray_promotion":false,"disable_error_code":[],"disable_memoryview_promotion":false,"disabled_error_codes":[],"disallow_any_decorated":false,"disallow_any_explicit":false,"disallow_any_expr":false,"disallow_any_generics":false,"disallow_any_unimported":false,"disallow_incomplete_defs":false,"disallow_subclassing_any":false,"disallow_untyped_calls":false,"disallow_untyped_decorators":false,"disallow_untyped_defs":false,"enable_error_code":[],"enabled_error_codes":[],"extra_checks":false,"follow_imports":"normal","follow_imports_for_stubs":false,"follow_untyped_imports":false,"ignore_errors":false,"ignore_missing_imports":false,"implicit_optional":false,"implicit_reexport":true,"local_partial_types":false,"mypyc":false,"old_type_inference":false,"platform":"darwin","plugins":[],"strict_concatenate":false,"strict_equality":false,"strict_optional":true,"warn_no_return":true,"warn_return_any":false,"warn_unreachable":false,"warn_unused_ignores":false},"path":"/Users/yeogirlyun/Python/Poker/backend/ui/services/theme_derive.py","plugin_data":null,"size":8054,"suppressed":[],"version_id":"1.14.1"}
```

---

### theme_factory.data.json

**Path**: `.mypy_cache/3.13/backend/ui/services/theme_factory.data.json`

**Size**: 10.2 KB

```json
{".class":"MypyFile","_fullname":"backend.ui.services.theme_factory","future_import_flags":[],"is_partial_stub_package":false,"is_stub":false,"names":{".class":"SymbolTable","THEME_BASES":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_inferred","has_explicit_value"],"fullname":"backend.ui.services.theme_factory.THEME_BASES","name":"THEME_BASES","type":{".class":"Instance","args":["builtins.str",{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"__annotations__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_factory.__annotations__","name":"__annotations__","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"__doc__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_factory.__doc__","name":"__doc__","type":"builtins.str"}},"__file__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_factory.__file__","name":"__file__","type":"builtins.str"}},"__name__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_factory.__name__","name":"__name__","type":"builtins.str"}},"__package__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_factory.__package__","name":"__package__","type":"builtins.str"}},"__spec__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_factory.__spec__","name":"__spec__","type":"_frozen_importlib.ModuleSpec"}},"_get_emphasis_background":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["base"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_factory._get_emphasis_background","name":"_get_emphasis_background","type":null}},"_get_emphasis_border":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["base"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_factory._get_emphasis_border","name":"_get_emphasis_border","type":null}},"_get_emphasis_glow":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["base"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_factory._get_emphasis_glow","name":"_get_emphasis_glow","type":null}},"_get_emphasis_highlight":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["base"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_factory._get_emphasis_highlight","name":"_get_emphasis_highlight","type":null}},"_get_emphasis_text_color":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["base"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_factory._get_emphasis_text_color","name":"_get_emphasis_text_color","type":null}},"_get_theme_emphasis_colors":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["theme_name"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_factory._get_theme_emphasis_colors","name":"_get_theme_emphasis_colors","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["theme_name"],"arg_types":["builtins.str"],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_get_theme_emphasis_colors","ret_type":{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_get_theme_selection_highlight":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["theme_name"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_factory._get_theme_selection_highlight","name":"_get_theme_selection_highlight","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["theme_name"],"arg_types":["builtins.str"],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_get_theme_selection_highlight","ret_type":{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"alpha_over":{".class":"SymbolTableNode","cross_ref":"backend.ui.services.theme_utils.alpha_over","kind":"Gdef"},"build_all_themes":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[],"arg_names":[],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_factory.build_all_themes","name":"build_all_themes","type":null}},"build_theme":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["base"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_factory.build_theme","name":"build_theme","type":null}},"build_theme_from_config":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["theme_id"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_factory.build_theme_from_config","name":"build_theme_from_config","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["theme_id"],"arg_types":["builtins.str"],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"build_theme_from_config","ret_type":{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"darken":{".class":"SymbolTableNode","cross_ref":"backend.ui.services.theme_utils.darken","kind":"Gdef"},"derive_chip_tokens":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,0,0,0,0],"arg_names":["tokens","felt","metal","accent","raise_c","call_c","neutral"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_factory.derive_chip_tokens","name":"derive_chip_tokens","type":null}},"derive_tokens":{".class":"SymbolTableNode","cross_ref":"backend.ui.services.theme_derive.derive_tokens","kind":"Gdef"},"get_available_theme_names":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[],"arg_names":[],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_factory.get_available_theme_names","name":"get_available_theme_names","type":{".class":"CallableType","arg_kinds":[],"arg_names":[],"arg_types":[],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_available_theme_names","ret_type":{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"builtins.list"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_chip_styles":{".class":"SymbolTableNode","cross_ref":"backend.ui.services.theme_derive.get_chip_styles","kind":"Gdef"},"get_emphasis_bar_style":{".class":"SymbolTableNode","cross_ref":"backend.ui.services.theme_derive.get_emphasis_bar_style","kind":"Gdef"},"get_player_state_style":{".class":"SymbolTableNode","cross_ref":"backend.ui.services.theme_derive.get_player_state_style","kind":"Gdef"},"get_selection_style":{".class":"SymbolTableNode","cross_ref":"backend.ui.services.theme_derive.get_selection_style","kind":"Gdef"},"get_theme_by_name":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["theme_name"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_factory.get_theme_by_name","name":"get_theme_by_name","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["theme_name"],"arg_types":["builtins.str"],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_theme_by_name","ret_type":{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_theme_loader":{".class":"SymbolTableNode","cross_ref":"backend.ui.services.theme_loader.get_theme_loader","kind":"Gdef"},"lighten":{".class":"SymbolTableNode","cross_ref":"backend.ui.services.theme_utils.lighten","kind":"Gdef"},"mix":{".class":"SymbolTableNode","cross_ref":"backend.ui.services.theme_utils.mix","kind":"Gdef"}},"path":"/Users/yeogirlyun/Python/Poker/backend/ui/services/theme_factory.py"}
```

---

### theme_factory.meta.json

**Path**: `.mypy_cache/3.13/backend/ui/services/theme_factory.meta.json`

**Size**: 1.7 KB

```json
{"data_mtime":1755440995,"dep_lines":[7,8,9,1,1,1,1],"dep_prios":[5,5,5,5,30,30,30],"dependencies":["backend.ui.services.theme_utils","backend.ui.services.theme_loader","backend.ui.services.theme_derive","builtins","_frozen_importlib","abc","typing"],"hash":"7417b4f0fbb03e0ae0a59520e0cb7f3e9f270ba4","id":"backend.ui.services.theme_factory","ignore_all":true,"interface_hash":"f9c347062637bc4ecff76e2907ce0535156bb5da","mtime":1755433550,"options":{"allow_redefinition":false,"allow_untyped_globals":false,"always_false":[],"always_true":[],"bazel":false,"check_untyped_defs":false,"disable_bytearray_promotion":false,"disable_error_code":[],"disable_memoryview_promotion":false,"disabled_error_codes":[],"disallow_any_decorated":false,"disallow_any_explicit":false,"disallow_any_expr":false,"disallow_any_generics":false,"disallow_any_unimported":false,"disallow_incomplete_defs":false,"disallow_subclassing_any":false,"disallow_untyped_calls":false,"disallow_untyped_decorators":false,"disallow_untyped_defs":false,"enable_error_code":[],"enabled_error_codes":[],"extra_checks":false,"follow_imports":"normal","follow_imports_for_stubs":false,"follow_untyped_imports":false,"ignore_errors":false,"ignore_missing_imports":false,"implicit_optional":false,"implicit_reexport":true,"local_partial_types":false,"mypyc":false,"old_type_inference":false,"platform":"darwin","plugins":[],"strict_concatenate":false,"strict_equality":false,"strict_optional":true,"warn_no_return":true,"warn_return_any":false,"warn_unreachable":false,"warn_unused_ignores":false},"path":"/Users/yeogirlyun/Python/Poker/backend/ui/services/theme_factory.py","plugin_data":null,"size":27780,"suppressed":[],"version_id":"1.14.1"}
```

---

### theme_loader.data.json

**Path**: `.mypy_cache/3.13/backend/ui/services/theme_loader.data.json`

**Size**: 13.0 KB

```json
{".class":"MypyFile","_fullname":"backend.ui.services.theme_loader","future_import_flags":[],"is_partial_stub_package":false,"is_stub":false,"names":{".class":"SymbolTable","Any":{".class":"SymbolTableNode","cross_ref":"typing.Any","kind":"Gdef"},"Dict":{".class":"SymbolTableNode","cross_ref":"typing.Dict","kind":"Gdef"},"Optional":{".class":"SymbolTableNode","cross_ref":"typing.Optional","kind":"Gdef"},"Path":{".class":"SymbolTableNode","cross_ref":"pathlib.Path","kind":"Gdef"},"ThemeLoader":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["builtins.object"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"backend.ui.services.theme_loader.ThemeLoader","name":"ThemeLoader","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_loader.ThemeLoader","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"backend.ui.services.theme_loader","mro":["backend.ui.services.theme_loader.ThemeLoader","builtins.object"],"names":{".class":"SymbolTable","__init__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,1],"arg_names":["self","theme_pack_path"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_loader.ThemeLoader.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0,1],"arg_names":["self","theme_pack_path"],"arg_types":["backend.ui.services.theme_loader.ThemeLoader",{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":false}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of ThemeLoader","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_defaults":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_loader.ThemeLoader._defaults","name":"_defaults","type":{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},{".class":"NoneType"}],"uses_pep604_syntax":false}}},"_get_fallback_config":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_loader.ThemeLoader._get_fallback_config","name":"_get_fallback_config","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_loader.ThemeLoader"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_get_fallback_config of ThemeLoader","ret_type":{".class":"TupleType","implicit":false,"items":[{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},{".class":"Instance","args":["builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.dict"}],"partial_fallback":{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.tuple"}},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_get_fallback_theme":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_loader.ThemeLoader._get_fallback_theme","name":"_get_fallback_theme","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_loader.ThemeLoader"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_get_fallback_theme of ThemeLoader","ret_type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_loaded":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.services.theme_loader.ThemeLoader._loaded","name":"_loaded","type":"builtins.bool"}},"_themes":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_loader.ThemeLoader._themes","name":"_themes","type":{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.dict"},{".class":"NoneType"}],"uses_pep604_syntax":false}}},"get_defaults":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_loader.ThemeLoader.get_defaults","name":"get_defaults","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_loader.ThemeLoader"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_defaults of ThemeLoader","ret_type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_theme_by_id":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","theme_id"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_loader.ThemeLoader.get_theme_by_id","name":"get_theme_by_id","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","theme_id"],"arg_types":["backend.ui.services.theme_loader.ThemeLoader","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_theme_by_id of ThemeLoader","ret_type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_theme_list":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_loader.ThemeLoader.get_theme_list","name":"get_theme_list","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_loader.ThemeLoader"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_theme_list of ThemeLoader","ret_type":{".class":"Instance","args":[{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.list"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"load_theme_pack":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_loader.ThemeLoader.load_theme_pack","name":"load_theme_pack","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_loader.ThemeLoader"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"load_theme_pack of ThemeLoader","ret_type":{".class":"TupleType","implicit":false,"items":[{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},{".class":"Instance","args":["builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.dict"}],"partial_fallback":{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.tuple"}},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"reload":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_loader.ThemeLoader.reload","name":"reload","type":null}},"theme_pack_path":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.services.theme_loader.ThemeLoader.theme_pack_path","name":"theme_pack_path","type":"builtins.str"}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"backend.ui.services.theme_loader.ThemeLoader.Self","id":0,"name":"Self","namespace":"","upper_bound":"backend.ui.services.theme_loader.ThemeLoader","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"Tuple":{".class":"SymbolTableNode","cross_ref":"typing.Tuple","kind":"Gdef"},"__annotations__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_loader.__annotations__","name":"__annotations__","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"__doc__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_loader.__doc__","name":"__doc__","type":"builtins.str"}},"__file__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_loader.__file__","name":"__file__","type":"builtins.str"}},"__name__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_loader.__name__","name":"__name__","type":"builtins.str"}},"__package__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_loader.__package__","name":"__package__","type":"builtins.str"}},"__spec__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_loader.__spec__","name":"__spec__","type":"_frozen_importlib.ModuleSpec"}},"_theme_loader":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_inferred","has_explicit_value"],"fullname":"backend.ui.services.theme_loader._theme_loader","name":"_theme_loader","type":{".class":"NoneType"}}},"get_theme_loader":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[],"arg_names":[],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_loader.get_theme_loader","name":"get_theme_loader","type":{".class":"CallableType","arg_kinds":[],"arg_names":[],"arg_types":[],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_theme_loader","ret_type":"backend.ui.services.theme_loader.ThemeLoader","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"json":{".class":"SymbolTableNode","cross_ref":"json","kind":"Gdef"}},"path":"/Users/yeogirlyun/Python/Poker/backend/ui/services/theme_loader.py"}
```

---

### theme_loader.meta.json

**Path**: `.mypy_cache/3.13/backend/ui/services/theme_loader.meta.json`

**Size**: 1.7 KB

```json
{"data_mtime":1755663719,"dep_lines":[6,7,8,1,1,1,1,1,1,1,1,1],"dep_prios":[10,5,5,5,30,30,30,30,30,30,30,30],"dependencies":["json","typing","pathlib","builtins","_collections_abc","_frozen_importlib","_io","_typeshed","abc","io","json.decoder","os"],"hash":"1e961861c91b37e2ab1e902c16674ad50e72a06d","id":"backend.ui.services.theme_loader","ignore_all":true,"interface_hash":"f2d5e882a6aa250d9b63b9ab3eb0200f046b7f3b","mtime":1755440553,"options":{"allow_redefinition":false,"allow_untyped_globals":false,"always_false":[],"always_true":[],"bazel":false,"check_untyped_defs":false,"disable_bytearray_promotion":false,"disable_error_code":[],"disable_memoryview_promotion":false,"disabled_error_codes":[],"disallow_any_decorated":false,"disallow_any_explicit":false,"disallow_any_expr":false,"disallow_any_generics":false,"disallow_any_unimported":false,"disallow_incomplete_defs":false,"disallow_subclassing_any":false,"disallow_untyped_calls":false,"disallow_untyped_decorators":false,"disallow_untyped_defs":false,"enable_error_code":[],"enabled_error_codes":[],"extra_checks":false,"follow_imports":"normal","follow_imports_for_stubs":false,"follow_untyped_imports":false,"ignore_errors":false,"ignore_missing_imports":false,"implicit_optional":false,"implicit_reexport":true,"local_partial_types":false,"mypyc":false,"old_type_inference":false,"platform":"darwin","plugins":[],"strict_concatenate":false,"strict_equality":false,"strict_optional":true,"warn_no_return":true,"warn_return_any":false,"warn_unreachable":false,"warn_unused_ignores":false},"path":"/Users/yeogirlyun/Python/Poker/backend/ui/services/theme_loader.py","plugin_data":null,"size":7042,"suppressed":[],"version_id":"1.14.1"}
```

---

### theme_loader_consolidated.data.json

**Path**: `.mypy_cache/3.13/backend/ui/services/theme_loader_consolidated.data.json`

**Size**: 17.4 KB

```json
{".class":"MypyFile","_fullname":"backend.ui.services.theme_loader_consolidated","future_import_flags":[],"is_partial_stub_package":false,"is_stub":false,"names":{".class":"SymbolTable","Any":{".class":"SymbolTableNode","cross_ref":"typing.Any","kind":"Gdef"},"ConsolidatedThemeLoader":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["builtins.object"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader","name":"ConsolidatedThemeLoader","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"backend.ui.services.theme_loader_consolidated","mro":["backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader","builtins.object"],"names":{".class":"SymbolTable","__init__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader.__init__","name":"__init__","type":null}},"_config":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader._config","name":"_config","type":{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},{".class":"NoneType"}],"uses_pep604_syntax":false}}},"_current_file":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader._current_file","name":"_current_file","type":{".class":"UnionType","items":["pathlib.Path",{".class":"NoneType"}],"uses_pep604_syntax":false}}},"_loaded":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader._loaded","name":"_loaded","type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1}}},"get_current_file":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader.get_current_file","name":"get_current_file","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_current_file of ConsolidatedThemeLoader","ret_type":{".class":"UnionType","items":["pathlib.Path",{".class":"NoneType"}],"uses_pep604_syntax":false},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_defaults":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader.get_defaults","name":"get_defaults","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_defaults of ConsolidatedThemeLoader","ret_type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_theme_by_id":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","theme_id"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader.get_theme_by_id","name":"get_theme_by_id","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","theme_id"],"arg_types":["backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_theme_by_id of ConsolidatedThemeLoader","ret_type":{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},{".class":"NoneType"}],"uses_pep604_syntax":false},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_theme_list":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader.get_theme_list","name":"get_theme_list","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_theme_list of ConsolidatedThemeLoader","ret_type":{".class":"Instance","args":[{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.list"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"load_from_file":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","file_path"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader.load_from_file","name":"load_from_file","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","file_path"],"arg_types":["backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"load_from_file of ConsolidatedThemeLoader","ret_type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"load_themes":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,1],"arg_names":["self","file_path"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader.load_themes","name":"load_themes","type":{".class":"CallableType","arg_kinds":[0,1],"arg_names":["self","file_path"],"arg_types":["backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader",{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":false}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"load_themes of ConsolidatedThemeLoader","ret_type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"reload":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,1],"arg_names":["self","file_path"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader.reload","name":"reload","type":{".class":"CallableType","arg_kinds":[0,1],"arg_names":["self","file_path"],"arg_types":["backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader",{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":false}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"reload of ConsolidatedThemeLoader","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"save_themes":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,1],"arg_names":["self","config","file_path"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader.save_themes","name":"save_themes","type":{".class":"CallableType","arg_kinds":[0,0,1],"arg_names":["self","config","file_path"],"arg_types":["backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":false}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"save_themes of ConsolidatedThemeLoader","ret_type":"builtins.bool","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"save_to_file":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":["self","config","file_path"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader.save_to_file","name":"save_to_file","type":{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":["self","config","file_path"],"arg_types":["backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"save_to_file of ConsolidatedThemeLoader","ret_type":"builtins.bool","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader.Self","id":0,"name":"Self","namespace":"","upper_bound":"backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"DEFAULT_THEME_FILE":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_inferred","has_explicit_value"],"fullname":"backend.ui.services.theme_loader_consolidated.DEFAULT_THEME_FILE","name":"DEFAULT_THEME_FILE","type":"pathlib.Path"}},"Dict":{".class":"SymbolTableNode","cross_ref":"typing.Dict","kind":"Gdef"},"EMBEDDED_FALLBACK":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_inferred","has_explicit_value"],"fullname":"backend.ui.services.theme_loader_consolidated.EMBEDDED_FALLBACK","name":"EMBEDDED_FALLBACK","type":{".class":"Instance","args":["builtins.str",{".class":"Instance","args":[{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Collection"}],"extra_attrs":null,"type_ref":"typing.Collection"}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"Optional":{".class":"SymbolTableNode","cross_ref":"typing.Optional","kind":"Gdef"},"Tuple":{".class":"SymbolTableNode","cross_ref":"typing.Tuple","kind":"Gdef"},"__annotations__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_loader_consolidated.__annotations__","name":"__annotations__","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"__doc__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_loader_consolidated.__doc__","name":"__doc__","type":"builtins.str"}},"__file__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_loader_consolidated.__file__","name":"__file__","type":"builtins.str"}},"__name__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_loader_consolidated.__name__","name":"__name__","type":"builtins.str"}},"__package__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_loader_consolidated.__package__","name":"__package__","type":"builtins.str"}},"__spec__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_loader_consolidated.__spec__","name":"__spec__","type":"_frozen_importlib.ModuleSpec"}},"_theme_loader":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready","has_explicit_value"],"fullname":"backend.ui.services.theme_loader_consolidated._theme_loader","name":"_theme_loader","type":{".class":"UnionType","items":["backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader",{".class":"NoneType"}],"uses_pep604_syntax":false}}},"get_consolidated_theme_loader":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[],"arg_names":[],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_loader_consolidated.get_consolidated_theme_loader","name":"get_consolidated_theme_loader","type":{".class":"CallableType","arg_kinds":[],"arg_names":[],"arg_types":[],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_consolidated_theme_loader","ret_type":"backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"json":{".class":"SymbolTableNode","cross_ref":"json","kind":"Gdef"},"load_themes":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[],"arg_names":[],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_loader_consolidated.load_themes","name":"load_themes","type":{".class":"CallableType","arg_kinds":[],"arg_names":[],"arg_types":[],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"load_themes","ret_type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"pathlib":{".class":"SymbolTableNode","cross_ref":"pathlib","kind":"Gdef"},"save_themes":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,1],"arg_names":["config","file_path"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_loader_consolidated.save_themes","name":"save_themes","type":{".class":"CallableType","arg_kinds":[0,1],"arg_names":["config","file_path"],"arg_types":[{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":false}],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"save_themes","ret_type":"builtins.bool","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"path":"/Users/yeogirlyun/Python/Poker/backend/ui/services/theme_loader_consolidated.py"}
```

---

### theme_loader_consolidated.meta.json

**Path**: `.mypy_cache/3.13/backend/ui/services/theme_loader_consolidated.meta.json`

**Size**: 1.7 KB

```json
{"data_mtime":1755663719,"dep_lines":[6,7,8,1,1,1,1,1,1,1],"dep_prios":[10,10,5,5,30,30,30,30,30,30],"dependencies":["json","pathlib","typing","builtins","_frozen_importlib","_typeshed","abc","json.decoder","json.encoder","os"],"hash":"9fef30297c739c3f7497e45eaba1a454e09a0139","id":"backend.ui.services.theme_loader_consolidated","ignore_all":true,"interface_hash":"85353f8468833f584d676ba77c6d1dfe30139e10","mtime":1755433841,"options":{"allow_redefinition":false,"allow_untyped_globals":false,"always_false":[],"always_true":[],"bazel":false,"check_untyped_defs":false,"disable_bytearray_promotion":false,"disable_error_code":[],"disable_memoryview_promotion":false,"disabled_error_codes":[],"disallow_any_decorated":false,"disallow_any_explicit":false,"disallow_any_expr":false,"disallow_any_generics":false,"disallow_any_unimported":false,"disallow_incomplete_defs":false,"disallow_subclassing_any":false,"disallow_untyped_calls":false,"disallow_untyped_decorators":false,"disallow_untyped_defs":false,"enable_error_code":[],"enabled_error_codes":[],"extra_checks":false,"follow_imports":"normal","follow_imports_for_stubs":false,"follow_untyped_imports":false,"ignore_errors":false,"ignore_missing_imports":false,"implicit_optional":false,"implicit_reexport":true,"local_partial_types":false,"mypyc":false,"old_type_inference":false,"platform":"darwin","plugins":[],"strict_concatenate":false,"strict_equality":false,"strict_optional":true,"warn_no_return":true,"warn_return_any":false,"warn_unreachable":false,"warn_unused_ignores":false},"path":"/Users/yeogirlyun/Python/Poker/backend/ui/services/theme_loader_consolidated.py","plugin_data":null,"size":8891,"suppressed":[],"version_id":"1.14.1"}
```

---

### theme_manager.data.json

**Path**: `.mypy_cache/3.13/backend/ui/services/theme_manager.data.json`

**Size**: 27.0 KB

```json
{".class":"MypyFile","_fullname":"backend.ui.services.theme_manager","future_import_flags":["annotations"],"is_partial_stub_package":false,"is_stub":false,"names":{".class":"SymbolTable","Any":{".class":"SymbolTableNode","cross_ref":"typing.Any","kind":"Gdef"},"Callable":{".class":"SymbolTableNode","cross_ref":"typing.Callable","kind":"Gdef"},"DEFAULT_THEME_NAME":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready","is_inferred","has_explicit_value"],"fullname":"backend.ui.services.theme_manager.DEFAULT_THEME_NAME","name":"DEFAULT_THEME_NAME","type":"builtins.str"}},"Dict":{".class":"SymbolTableNode","cross_ref":"typing.Dict","kind":"Gdef"},"List":{".class":"SymbolTableNode","cross_ref":"typing.List","kind":"Gdef"},"TOKEN_DRIVEN_THEMES_AVAILABLE":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready","is_inferred","has_explicit_value"],"fullname":"backend.ui.services.theme_manager.TOKEN_DRIVEN_THEMES_AVAILABLE","name":"TOKEN_DRIVEN_THEMES_AVAILABLE","type":"builtins.bool"}},"ThemeManager":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["builtins.object"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"backend.ui.services.theme_manager.ThemeManager","name":"ThemeManager","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"backend.ui.services.theme_manager","mro":["backend.ui.services.theme_manager.ThemeManager","builtins.object"],"names":{".class":"SymbolTable","CONFIG_PATH":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_inferred","has_explicit_value"],"fullname":"backend.ui.services.theme_manager.ThemeManager.CONFIG_PATH","name":"CONFIG_PATH","type":"builtins.str"}},"__init__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_builtin_packs":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager._builtin_packs","name":"_builtin_packs","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_builtin_packs of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_current":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager.ThemeManager._current","name":"_current","type":{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}}},"_current_profile":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.services.theme_manager.ThemeManager._current_profile","name":"_current_profile","type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1}}},"_fonts":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager.ThemeManager._fonts","name":"_fonts","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"_legacy_builtin_packs":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager._legacy_builtin_packs","name":"_legacy_builtin_packs","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_legacy_builtin_packs of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_load_config":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager._load_config","name":"_load_config","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_load_config of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_save_config":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager._save_config","name":"_save_config","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_save_config of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_subs":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager.ThemeManager._subs","name":"_subs","type":{".class":"Instance","args":[{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}],"extra_attrs":null,"type_ref":"builtins.list"}}},"_theme":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager.ThemeManager._theme","name":"_theme","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"_themes":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager.ThemeManager._themes","name":"_themes","type":{".class":"Instance","args":["builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"current":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.current","name":"current","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"current of ThemeManager","ret_type":{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"current_profile_name":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.current_profile_name","name":"current_profile_name","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"current_profile_name of ThemeManager","ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,1],"arg_names":["self","token","default"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.get","name":"get","type":{".class":"CallableType","arg_kinds":[0,0,1],"arg_names":["self","token","default"],"arg_types":["backend.ui.services.theme_manager.ThemeManager","builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get of ThemeManager","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_all_tokens":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.get_all_tokens","name":"get_all_tokens","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_all_tokens of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_base_colors":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.get_base_colors","name":"get_base_colors","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_base_colors of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_current_theme_id":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.get_current_theme_id","name":"get_current_theme_id","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_current_theme_id of ThemeManager","ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_dimensions":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.get_dimensions","name":"get_dimensions","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_dimensions of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_emphasis_bar_styler":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.get_emphasis_bar_styler","name":"get_emphasis_bar_styler","type":null}},"get_fonts":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.get_fonts","name":"get_fonts","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_fonts of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_selection_styler":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.get_selection_styler","name":"get_selection_styler","type":null}},"get_state_styler":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.get_state_styler","name":"get_state_styler","type":null}},"get_theme":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.get_theme","name":"get_theme","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_theme of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_theme_metadata":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","theme_name"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.get_theme_metadata","name":"get_theme_metadata","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","theme_name"],"arg_types":["backend.ui.services.theme_manager.ThemeManager","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_theme_metadata of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"names":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.names","name":"names","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"names of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"builtins.list"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"register":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":["self","name","tokens"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.register","name":"register","type":{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":["self","name","tokens"],"arg_types":["backend.ui.services.theme_manager.ThemeManager","builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"register of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"register_all":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","packs"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.register_all","name":"register_all","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","packs"],"arg_types":["backend.ui.services.theme_manager.ThemeManager",{".class":"Instance","args":["builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"register_all of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"reload":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.reload","name":"reload","type":null}},"set_fonts":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","fonts"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.set_fonts","name":"set_fonts","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","fonts"],"arg_types":["backend.ui.services.theme_manager.ThemeManager",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"set_fonts of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"set_profile":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","name"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.set_profile","name":"set_profile","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","name"],"arg_types":["backend.ui.services.theme_manager.ThemeManager","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"set_profile of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"subscribe":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","fn"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.subscribe","name":"subscribe","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","fn"],"arg_types":["backend.ui.services.theme_manager.ThemeManager",{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"subscribe of ThemeManager","ret_type":{".class":"CallableType","arg_kinds":[],"arg_names":[],"arg_types":[],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"backend.ui.services.theme_manager.ThemeManager.Self","id":0,"name":"Self","namespace":"","upper_bound":"backend.ui.services.theme_manager.ThemeManager","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"__annotations__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__annotations__","name":"__annotations__","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"__doc__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__doc__","name":"__doc__","type":"builtins.str"}},"__file__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__file__","name":"__file__","type":"builtins.str"}},"__name__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__name__","name":"__name__","type":"builtins.str"}},"__package__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__package__","name":"__package__","type":"builtins.str"}},"__spec__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__spec__","name":"__spec__","type":"_frozen_importlib.ModuleSpec"}},"annotations":{".class":"SymbolTableNode","cross_ref":"__future__.annotations","kind":"Gdef"},"build_all_themes":{".class":"SymbolTableNode","cross_ref":"backend.ui.services.theme_factory.build_all_themes","kind":"Gdef"},"get_emphasis_bar_styler":{".class":"SymbolTableNode","cross_ref":"backend.ui.services.state_styler.get_emphasis_bar_styler","kind":"Gdef"},"get_selection_styler":{".class":"SymbolTableNode","cross_ref":"backend.ui.services.state_styler.get_selection_styler","kind":"Gdef"},"get_state_styler":{".class":"SymbolTableNode","cross_ref":"backend.ui.services.state_styler.get_state_styler","kind":"Gdef"},"get_theme_loader":{".class":"SymbolTableNode","cross_ref":"backend.ui.services.theme_loader.get_theme_loader","kind":"Gdef"},"importlib":{".class":"SymbolTableNode","cross_ref":"importlib","kind":"Gdef"},"json":{".class":"SymbolTableNode","cross_ref":"json","kind":"Gdef"},"os":{".class":"SymbolTableNode","cross_ref":"os","kind":"Gdef"}},"path":"/Users/yeogirlyun/Python/Poker/backend/ui/services/theme_manager.py"}
```

---

### theme_manager.meta.json

**Path**: `.mypy_cache/3.13/backend/ui/services/theme_manager.meta.json`

**Size**: 1.8 KB

```json
{"data_mtime":1755440527,"dep_lines":[10,11,12,1,3,4,5,6,1,1,1,1,1,1,1,1,1,1],"dep_prios":[5,5,5,5,5,10,10,10,5,30,30,30,30,30,30,30,30,30],"dependencies":["backend.ui.services.theme_factory","backend.ui.services.theme_loader","backend.ui.services.state_styler","__future__","typing","importlib","json","os","builtins","_collections_abc","_frozen_importlib","_io","_typeshed","abc","io","json.decoder","json.encoder","types"],"hash":"6a0a43dd421aca4cea44faf4e3897b365baddfba","id":"backend.ui.services.theme_manager","ignore_all":true,"interface_hash":"f49a4ebd210b685152e865d8bb9b352bec719e85","mtime":1755571656,"options":{"allow_redefinition":false,"allow_untyped_globals":false,"always_false":[],"always_true":[],"bazel":false,"check_untyped_defs":false,"disable_bytearray_promotion":false,"disable_error_code":[],"disable_memoryview_promotion":false,"disabled_error_codes":[],"disallow_any_decorated":false,"disallow_any_explicit":false,"disallow_any_expr":false,"disallow_any_generics":false,"disallow_any_unimported":false,"disallow_incomplete_defs":false,"disallow_subclassing_any":false,"disallow_untyped_calls":false,"disallow_untyped_decorators":false,"disallow_untyped_defs":false,"enable_error_code":[],"enabled_error_codes":[],"extra_checks":false,"follow_imports":"normal","follow_imports_for_stubs":false,"follow_untyped_imports":false,"ignore_errors":false,"ignore_missing_imports":false,"implicit_optional":false,"implicit_reexport":true,"local_partial_types":false,"mypyc":false,"old_type_inference":false,"platform":"darwin","plugins":[],"strict_concatenate":false,"strict_equality":false,"strict_optional":true,"warn_no_return":true,"warn_return_any":false,"warn_unreachable":false,"warn_unused_ignores":false},"path":"/Users/yeogirlyun/Python/Poker/backend/ui/services/theme_manager.py","plugin_data":null,"size":14253,"suppressed":[],"version_id":"1.14.1"}
```

---

### theme_manager_clean.data.json

**Path**: `.mypy_cache/3.13/backend/ui/services/theme_manager_clean.data.json`

**Size**: 26.3 KB

```json
{".class":"MypyFile","_fullname":"backend.ui.services.theme_manager_clean","future_import_flags":["annotations"],"is_partial_stub_package":false,"is_stub":false,"names":{".class":"SymbolTable","Any":{".class":"SymbolTableNode","cross_ref":"typing.Any","kind":"Gdef"},"Callable":{".class":"SymbolTableNode","cross_ref":"typing.Callable","kind":"Gdef"},"DEFAULT_THEME_NAME":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready","is_inferred","has_explicit_value"],"fullname":"backend.ui.services.theme_manager_clean.DEFAULT_THEME_NAME","name":"DEFAULT_THEME_NAME","type":"builtins.str"}},"Dict":{".class":"SymbolTableNode","cross_ref":"typing.Dict","kind":"Gdef"},"List":{".class":"SymbolTableNode","cross_ref":"typing.List","kind":"Gdef"},"TOKEN_DRIVEN_THEMES_AVAILABLE":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready","is_inferred","has_explicit_value"],"fullname":"backend.ui.services.theme_manager_clean.TOKEN_DRIVEN_THEMES_AVAILABLE","name":"TOKEN_DRIVEN_THEMES_AVAILABLE","type":"builtins.bool"}},"ThemeManager":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["builtins.object"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"backend.ui.services.theme_manager_clean.ThemeManager","name":"ThemeManager","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"backend.ui.services.theme_manager_clean","mro":["backend.ui.services.theme_manager_clean.ThemeManager","builtins.object"],"names":{".class":"SymbolTable","CONFIG_PATH":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_inferred","has_explicit_value"],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager.CONFIG_PATH","name":"CONFIG_PATH","type":"builtins.str"}},"__init__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager_clean.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_builtin_packs":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager._builtin_packs","name":"_builtin_packs","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager_clean.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_builtin_packs of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_current":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager._current","name":"_current","type":{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}}},"_fonts":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager._fonts","name":"_fonts","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"_legacy_builtin_packs":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager._legacy_builtin_packs","name":"_legacy_builtin_packs","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager_clean.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_legacy_builtin_packs of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_load_config":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager._load_config","name":"_load_config","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager_clean.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_load_config of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_save_config":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager._save_config","name":"_save_config","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager_clean.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_save_config of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_subs":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager._subs","name":"_subs","type":{".class":"Instance","args":[{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["backend.ui.services.theme_manager_clean.ThemeManager"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}],"extra_attrs":null,"type_ref":"builtins.list"}}},"_theme":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager._theme","name":"_theme","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"_themes":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager._themes","name":"_themes","type":{".class":"Instance","args":["builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"current":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager.current","name":"current","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager_clean.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"current of ThemeManager","ret_type":{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"current_profile_name":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager.current_profile_name","name":"current_profile_name","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager_clean.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"current_profile_name of ThemeManager","ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,1],"arg_names":["self","token","default"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager.get","name":"get","type":{".class":"CallableType","arg_kinds":[0,0,1],"arg_names":["self","token","default"],"arg_types":["backend.ui.services.theme_manager_clean.ThemeManager","builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get of ThemeManager","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_all_tokens":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager.get_all_tokens","name":"get_all_tokens","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager_clean.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_all_tokens of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_base_colors":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager.get_base_colors","name":"get_base_colors","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager_clean.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_base_colors of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_current_theme_id":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager.get_current_theme_id","name":"get_current_theme_id","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager_clean.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_current_theme_id of ThemeManager","ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_emphasis_bar_styler":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager.get_emphasis_bar_styler","name":"get_emphasis_bar_styler","type":null}},"get_fonts":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager.get_fonts","name":"get_fonts","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager_clean.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_fonts of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_selection_styler":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager.get_selection_styler","name":"get_selection_styler","type":null}},"get_state_styler":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager.get_state_styler","name":"get_state_styler","type":null}},"get_theme":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager.get_theme","name":"get_theme","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager_clean.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_theme of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_theme_metadata":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","theme_name"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager.get_theme_metadata","name":"get_theme_metadata","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","theme_name"],"arg_types":["backend.ui.services.theme_manager_clean.ThemeManager","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_theme_metadata of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"names":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager.names","name":"names","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager_clean.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"names of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"builtins.list"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"register":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":["self","name","tokens"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager.register","name":"register","type":{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":["self","name","tokens"],"arg_types":["backend.ui.services.theme_manager_clean.ThemeManager","builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"register of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"register_all":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","packs"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager.register_all","name":"register_all","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","packs"],"arg_types":["backend.ui.services.theme_manager_clean.ThemeManager",{".class":"Instance","args":["builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"register_all of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"set_fonts":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","fonts"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager.set_fonts","name":"set_fonts","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","fonts"],"arg_types":["backend.ui.services.theme_manager_clean.ThemeManager",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"set_fonts of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"set_profile":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","name"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager.set_profile","name":"set_profile","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","name"],"arg_types":["backend.ui.services.theme_manager_clean.ThemeManager","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"set_profile of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"subscribe":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","fn"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager_clean.ThemeManager.subscribe","name":"subscribe","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","fn"],"arg_types":["backend.ui.services.theme_manager_clean.ThemeManager",{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["backend.ui.services.theme_manager_clean.ThemeManager"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"subscribe of ThemeManager","ret_type":{".class":"CallableType","arg_kinds":[],"arg_names":[],"arg_types":[],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"backend.ui.services.theme_manager_clean.ThemeManager.Self","id":0,"name":"Self","namespace":"","upper_bound":"backend.ui.services.theme_manager_clean.ThemeManager","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"__annotations__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager_clean.__annotations__","name":"__annotations__","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"__doc__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager_clean.__doc__","name":"__doc__","type":"builtins.str"}},"__file__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager_clean.__file__","name":"__file__","type":"builtins.str"}},"__name__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager_clean.__name__","name":"__name__","type":"builtins.str"}},"__package__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager_clean.__package__","name":"__package__","type":"builtins.str"}},"__spec__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager_clean.__spec__","name":"__spec__","type":"_frozen_importlib.ModuleSpec"}},"annotations":{".class":"SymbolTableNode","cross_ref":"__future__.annotations","kind":"Gdef"},"build_all_themes":{".class":"SymbolTableNode","cross_ref":"backend.ui.services.theme_factory.build_all_themes","kind":"Gdef"},"build_theme_from_config":{".class":"SymbolTableNode","cross_ref":"backend.ui.services.theme_factory.build_theme_from_config","kind":"Gdef"},"get_available_theme_names":{".class":"SymbolTableNode","cross_ref":"backend.ui.services.theme_factory.get_available_theme_names","kind":"Gdef"},"get_emphasis_bar_styler":{".class":"SymbolTableNode","cross_ref":"backend.ui.services.state_styler.get_emphasis_bar_styler","kind":"Gdef"},"get_selection_styler":{".class":"SymbolTableNode","cross_ref":"backend.ui.services.state_styler.get_selection_styler","kind":"Gdef"},"get_state_styler":{".class":"SymbolTableNode","cross_ref":"backend.ui.services.state_styler.get_state_styler","kind":"Gdef"},"get_theme_by_name":{".class":"SymbolTableNode","cross_ref":"backend.ui.services.theme_factory.get_theme_by_name","kind":"Gdef"},"get_theme_loader":{".class":"SymbolTableNode","cross_ref":"backend.ui.services.theme_loader.get_theme_loader","kind":"Gdef"},"importlib":{".class":"SymbolTableNode","cross_ref":"importlib","kind":"Gdef"},"json":{".class":"SymbolTableNode","cross_ref":"json","kind":"Gdef"},"os":{".class":"SymbolTableNode","cross_ref":"os","kind":"Gdef"}},"path":"/Users/yeogirlyun/Python/Poker/backend/ui/services/theme_manager_clean.py"}
```

---

### theme_manager_clean.meta.json

**Path**: `.mypy_cache/3.13/backend/ui/services/theme_manager_clean.meta.json`

**Size**: 1.8 KB

```json
{"data_mtime":1755428798,"dep_lines":[10,11,12,1,3,4,5,6,1,1,1,1,1,1,1,1,1,1],"dep_prios":[5,5,5,5,5,10,10,10,5,30,30,30,30,30,30,30,30,30],"dependencies":["backend.ui.services.theme_factory","backend.ui.services.theme_loader","backend.ui.services.state_styler","__future__","typing","importlib","json","os","builtins","_collections_abc","_frozen_importlib","_io","_typeshed","abc","io","json.decoder","json.encoder","types"],"hash":"c049765a8661e5cf9cfc50496ccbd03cbd5f9902","id":"backend.ui.services.theme_manager_clean","ignore_all":false,"interface_hash":"1d35a62925bff9b1ba4578e56ca54ab2ff2272fc","mtime":1755428897,"options":{"allow_redefinition":false,"allow_untyped_globals":false,"always_false":[],"always_true":[],"bazel":false,"check_untyped_defs":false,"disable_bytearray_promotion":false,"disable_error_code":[],"disable_memoryview_promotion":false,"disabled_error_codes":[],"disallow_any_decorated":false,"disallow_any_explicit":false,"disallow_any_expr":false,"disallow_any_generics":false,"disallow_any_unimported":false,"disallow_incomplete_defs":false,"disallow_subclassing_any":false,"disallow_untyped_calls":false,"disallow_untyped_decorators":false,"disallow_untyped_defs":false,"enable_error_code":[],"enabled_error_codes":[],"extra_checks":false,"follow_imports":"normal","follow_imports_for_stubs":false,"follow_untyped_imports":false,"ignore_errors":false,"ignore_missing_imports":false,"implicit_optional":false,"implicit_reexport":true,"local_partial_types":false,"mypyc":false,"old_type_inference":false,"platform":"darwin","plugins":[],"strict_concatenate":false,"strict_equality":false,"strict_optional":true,"warn_no_return":true,"warn_return_any":false,"warn_unreachable":false,"warn_unused_ignores":false},"path":"/Users/yeogirlyun/Python/Poker/backend/ui/services/theme_manager_clean.py","plugin_data":null,"size":10626,"suppressed":[],"version_id":"1.14.1"}
```

---

### theme_utils.data.json

**Path**: `.mypy_cache/3.13/backend/ui/services/theme_utils.data.json`

**Size**: 4.8 KB

```json
{".class":"MypyFile","_fullname":"backend.ui.services.theme_utils","future_import_flags":[],"is_partial_stub_package":false,"is_stub":false,"names":{".class":"SymbolTable","__annotations__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_utils.__annotations__","name":"__annotations__","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"__doc__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_utils.__doc__","name":"__doc__","type":"builtins.str"}},"__file__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_utils.__file__","name":"__file__","type":"builtins.str"}},"__name__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_utils.__name__","name":"__name__","type":"builtins.str"}},"__package__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_utils.__package__","name":"__package__","type":"builtins.str"}},"__spec__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_utils.__spec__","name":"__spec__","type":"_frozen_importlib.ModuleSpec"}},"adjust_saturation":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["h","factor"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_utils.adjust_saturation","name":"adjust_saturation","type":null}},"alpha_over":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":["src","dst","a"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_utils.alpha_over","name":"alpha_over","type":null}},"clamp":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["x"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_utils.clamp","name":"clamp","type":null}},"darken":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["h","t"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_utils.darken","name":"darken","type":null}},"ease_color_transition":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":["color_a","color_b","progress"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_utils.ease_color_transition","name":"ease_color_transition","type":null}},"ease_in_out_cubic":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["t"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_utils.ease_in_out_cubic","name":"ease_in_out_cubic","type":null}},"get_contrast_color":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,1,1],"arg_names":["bg_hex","light_text","dark_text"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_utils.get_contrast_color","name":"get_contrast_color","type":null}},"hex_to_rgb":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["h"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_utils.hex_to_rgb","name":"hex_to_rgb","type":null}},"lighten":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["h","t"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_utils.lighten","name":"lighten","type":null}},"mix":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":["a","b","t"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_utils.mix","name":"mix","type":null}},"rgb_to_hex":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["t"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_utils.rgb_to_hex","name":"rgb_to_hex","type":null}}},"path":"/Users/yeogirlyun/Python/Poker/backend/ui/services/theme_utils.py"}
```

---

### theme_utils.meta.json

**Path**: `.mypy_cache/3.13/backend/ui/services/theme_utils.meta.json`

**Size**: 1.6 KB

```json
{"data_mtime":1755408319,"dep_lines":[1,1,1,1,1,1],"dep_prios":[5,30,30,30,30,30],"dependencies":["builtins","_collections_abc","_frozen_importlib","_typeshed","abc","typing"],"hash":"a2757d345e023d352fb4404917d842b0dc452262","id":"backend.ui.services.theme_utils","ignore_all":false,"interface_hash":"8a861053ff1de425efe8f4cbdbb808c707b6471c","mtime":1755411505,"options":{"allow_redefinition":false,"allow_untyped_globals":false,"always_false":[],"always_true":[],"bazel":false,"check_untyped_defs":false,"disable_bytearray_promotion":false,"disable_error_code":[],"disable_memoryview_promotion":false,"disabled_error_codes":[],"disallow_any_decorated":false,"disallow_any_explicit":false,"disallow_any_expr":false,"disallow_any_generics":false,"disallow_any_unimported":false,"disallow_incomplete_defs":false,"disallow_subclassing_any":false,"disallow_untyped_calls":false,"disallow_untyped_decorators":false,"disallow_untyped_defs":false,"enable_error_code":[],"enabled_error_codes":[],"extra_checks":false,"follow_imports":"normal","follow_imports_for_stubs":false,"follow_untyped_imports":false,"ignore_errors":false,"ignore_missing_imports":false,"implicit_optional":false,"implicit_reexport":true,"local_partial_types":false,"mypyc":false,"old_type_inference":false,"platform":"darwin","plugins":[],"strict_concatenate":false,"strict_equality":false,"strict_optional":true,"warn_no_return":true,"warn_return_any":false,"warn_unreachable":false,"warn_unused_ignores":false},"path":"/Users/yeogirlyun/Python/Poker/backend/ui/services/theme_utils.py","plugin_data":null,"size":2296,"suppressed":[],"version_id":"1.14.1"}
```

---

### theme_editor_tab.data.json

**Path**: `.mypy_cache/3.13/backend/ui/tabs/theme_editor_tab.data.json`

**Size**: 24.6 KB

```json
{".class":"MypyFile","_fullname":"backend.ui.tabs.theme_editor_tab","future_import_flags":[],"is_partial_stub_package":false,"is_stub":false,"names":{".class":"SymbolTable","AdvancedThemeManager":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_suppressed_import","is_ready","is_inferred"],"fullname":"backend.ui.tabs.theme_editor_tab.AdvancedThemeManager","name":"AdvancedThemeManager","type":{".class":"AnyType","missing_import_name":"backend.ui.tabs.theme_editor_tab.AdvancedThemeManager","source_any":null,"type_of_any":3}}},"Any":{".class":"SymbolTableNode","cross_ref":"typing.Any","kind":"Gdef"},"Dict":{".class":"SymbolTableNode","cross_ref":"typing.Dict","kind":"Gdef"},"Optional":{".class":"SymbolTableNode","cross_ref":"typing.Optional","kind":"Gdef"},"ThemeEditorTab":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["tkinter.ttk.Frame"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab","name":"ThemeEditorTab","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"backend.ui.tabs.theme_editor_tab","mro":["backend.ui.tabs.theme_editor_tab.ThemeEditorTab","tkinter.ttk.Frame","tkinter.ttk.Widget","tkinter.Widget","tkinter.BaseWidget","tkinter.Misc","tkinter.Pack","tkinter.Place","tkinter.Grid","builtins.object"],"names":{".class":"SymbolTable","__init__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":["self","parent","services"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab.__init__","name":"__init__","type":null}},"_apply_preview":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab._apply_preview","name":"_apply_preview","type":null}},"_create_color_control":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,0],"arg_names":["self","parent","color_key","display_name"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab._create_color_control","name":"_create_color_control","type":{".class":"CallableType","arg_kinds":[0,0,0,0],"arg_names":["self","parent","color_key","display_name"],"arg_types":["backend.ui.tabs.theme_editor_tab.ThemeEditorTab",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1},"builtins.str","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_create_color_control of ThemeEditorTab","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_create_color_section":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":["self","section_name","color_items"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab._create_color_section","name":"_create_color_section","type":{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":["self","section_name","color_items"],"arg_types":["backend.ui.tabs.theme_editor_tab.ThemeEditorTab","builtins.str",{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4}],"extra_attrs":null,"type_ref":"builtins.list"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_create_color_section of ThemeEditorTab","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_create_left_panel":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab._create_left_panel","name":"_create_left_panel","type":null}},"_create_new_theme":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab._create_new_theme","name":"_create_new_theme","type":null}},"_create_right_panel":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab._create_right_panel","name":"_create_right_panel","type":null}},"_duplicate_theme":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab._duplicate_theme","name":"_duplicate_theme","type":null}},"_export_theme":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab._export_theme","name":"_export_theme","type":null}},"_import_theme":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab._import_theme","name":"_import_theme","type":null}},"_load_initial_theme":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab._load_initial_theme","name":"_load_initial_theme","type":null}},"_on_color_entry_change":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":["self","color_key","new_color"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab._on_color_entry_change","name":"_on_color_entry_change","type":{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":["self","color_key","new_color"],"arg_types":["backend.ui.tabs.theme_editor_tab.ThemeEditorTab","builtins.str","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_on_color_entry_change of ThemeEditorTab","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_on_hue_change":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","value"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab._on_hue_change","name":"_on_hue_change","type":null}},"_on_lightness_change":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","value"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab._on_lightness_change","name":"_on_lightness_change","type":null}},"_on_saturation_change":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","value"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab._on_saturation_change","name":"_on_saturation_change","type":null}},"_on_theme_select":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,1],"arg_names":["self","event"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab._on_theme_select","name":"_on_theme_select","type":null}},"_pick_color":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","color_key"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab._pick_color","name":"_pick_color","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","color_key"],"arg_types":["backend.ui.tabs.theme_editor_tab.ThemeEditorTab","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_pick_color of ThemeEditorTab","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_refresh_all_color_controls":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab._refresh_all_color_controls","name":"_refresh_all_color_controls","type":null}},"_refresh_theme_list":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab._refresh_theme_list","name":"_refresh_theme_list","type":null}},"_reset_adjustments":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab._reset_adjustments","name":"_reset_adjustments","type":null}},"_revert_theme":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab._revert_theme","name":"_revert_theme","type":null}},"_save_theme":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab._save_theme","name":"_save_theme","type":null}},"_setup_ui":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab._setup_ui","name":"_setup_ui","type":null}},"_update_color":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":["self","color_key","new_color"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab._update_color","name":"_update_color","type":{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":["self","color_key","new_color"],"arg_types":["backend.ui.tabs.theme_editor_tab.ThemeEditorTab","builtins.str","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_update_color of ThemeEditorTab","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_update_color_controls":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","palette"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab._update_color_controls","name":"_update_color_controls","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","palette"],"arg_types":["backend.ui.tabs.theme_editor_tab.ThemeEditorTab",{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_update_color_controls of ThemeEditorTab","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_update_contrast_info":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":["self","text_color_key","palette"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab._update_contrast_info","name":"_update_contrast_info","type":{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":["self","text_color_key","palette"],"arg_types":["backend.ui.tabs.theme_editor_tab.ThemeEditorTab","builtins.str",{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_update_contrast_info of ThemeEditorTab","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_update_theme_info":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","theme"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab._update_theme_info","name":"_update_theme_info","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","theme"],"arg_types":["backend.ui.tabs.theme_editor_tab.ThemeEditorTab",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_update_theme_info of ThemeEditorTab","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"color_editor_frame":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab.color_editor_frame","name":"color_editor_frame","type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1}}},"color_widgets":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab.color_widgets","name":"color_widgets","type":{".class":"Instance","args":["builtins.str",{".class":"Instance","args":["builtins.str","tkinter.Widget"],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"current_theme_id":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab.current_theme_id","name":"current_theme_id","type":{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":false}}},"hue_var":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab.hue_var","name":"hue_var","type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1}}},"lightness_var":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab.lightness_var","name":"lightness_var","type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1}}},"preview_mode":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab.preview_mode","name":"preview_mode","type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1}}},"saturation_var":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab.saturation_var","name":"saturation_var","type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1}}},"services":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab.services","name":"services","type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1}}},"theme_combo":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab.theme_combo","name":"theme_combo","type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1}}},"theme_info_text":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab.theme_info_text","name":"theme_info_text","type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1}}},"theme_manager":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab.theme_manager","name":"theme_manager","type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1}}},"theme_var":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab.theme_var","name":"theme_var","type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab.Self","id":0,"name":"Self","namespace":"","upper_bound":"backend.ui.tabs.theme_editor_tab.ThemeEditorTab","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"ThemeNameDialog":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["builtins.object"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"backend.ui.tabs.theme_editor_tab.ThemeNameDialog","name":"ThemeNameDialog","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeNameDialog","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"backend.ui.tabs.theme_editor_tab","mro":["backend.ui.tabs.theme_editor_tab.ThemeNameDialog","builtins.object"],"names":{".class":"SymbolTable","__init__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":["self","parent","title"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeNameDialog.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":["self","parent","title"],"arg_types":["backend.ui.tabs.theme_editor_tab.ThemeNameDialog",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1},"builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of ThemeNameDialog","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_cancel_clicked":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeNameDialog._cancel_clicked","name":"_cancel_clicked","type":null}},"_ok_clicked":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeNameDialog._ok_clicked","name":"_ok_clicked","type":null}},"dialog":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeNameDialog.dialog","name":"dialog","type":"tkinter.Toplevel"}},"name_var":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeNameDialog.name_var","name":"name_var","type":"tkinter.StringVar"}},"result":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.tabs.theme_editor_tab.ThemeNameDialog.result","name":"result","type":{".class":"NoneType"}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"backend.ui.tabs.theme_editor_tab.ThemeNameDialog.Self","id":0,"name":"Self","namespace":"","upper_bound":"backend.ui.tabs.theme_editor_tab.ThemeNameDialog","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"__annotations__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.tabs.theme_editor_tab.__annotations__","name":"__annotations__","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"__doc__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.tabs.theme_editor_tab.__doc__","name":"__doc__","type":"builtins.str"}},"__file__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.tabs.theme_editor_tab.__file__","name":"__file__","type":"builtins.str"}},"__name__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.tabs.theme_editor_tab.__name__","name":"__name__","type":"builtins.str"}},"__package__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.tabs.theme_editor_tab.__package__","name":"__package__","type":"builtins.str"}},"__spec__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.tabs.theme_editor_tab.__spec__","name":"__spec__","type":"_frozen_importlib.ModuleSpec"}},"colorchooser":{".class":"SymbolTableNode","cross_ref":"tkinter.colorchooser","kind":"Gdef"},"filedialog":{".class":"SymbolTableNode","cross_ref":"tkinter.filedialog","kind":"Gdef"},"messagebox":{".class":"SymbolTableNode","cross_ref":"tkinter.messagebox","kind":"Gdef"},"tk":{".class":"SymbolTableNode","cross_ref":"tkinter","kind":"Gdef"},"ttk":{".class":"SymbolTableNode","cross_ref":"tkinter.ttk","kind":"Gdef"}},"path":"/Users/yeogirlyun/Python/Poker/backend/ui/tabs/theme_editor_tab.py"}
```

---

### theme_editor_tab.meta.json

**Path**: `.mypy_cache/3.13/backend/ui/tabs/theme_editor_tab.meta.json`

**Size**: 1.7 KB

```json
{"data_mtime":1755662864,"dep_lines":[7,7,7,7,6,8,1,1,1,1,1,9],"dep_prios":[10,10,10,10,10,5,5,30,30,30,30,5],"dependencies":["tkinter.ttk","tkinter.colorchooser","tkinter.filedialog","tkinter.messagebox","tkinter","typing","builtins","_frozen_importlib","_tkinter","abc","tkinter.font"],"hash":"9de8adfe6ce6cfb3bc2849a2ad325cc51a787a61","id":"backend.ui.tabs.theme_editor_tab","ignore_all":true,"interface_hash":"7385ea548f3e5bde8d5d811fef4a31d1a4f5573d","mtime":1755432988,"options":{"allow_redefinition":false,"allow_untyped_globals":false,"always_false":[],"always_true":[],"bazel":false,"check_untyped_defs":false,"disable_bytearray_promotion":false,"disable_error_code":[],"disable_memoryview_promotion":false,"disabled_error_codes":[],"disallow_any_decorated":false,"disallow_any_explicit":false,"disallow_any_expr":false,"disallow_any_generics":false,"disallow_any_unimported":false,"disallow_incomplete_defs":false,"disallow_subclassing_any":false,"disallow_untyped_calls":false,"disallow_untyped_decorators":false,"disallow_untyped_defs":false,"enable_error_code":[],"enabled_error_codes":[],"extra_checks":false,"follow_imports":"normal","follow_imports_for_stubs":false,"follow_untyped_imports":false,"ignore_errors":false,"ignore_missing_imports":false,"implicit_optional":false,"implicit_reexport":true,"local_partial_types":false,"mypyc":false,"old_type_inference":false,"platform":"darwin","plugins":[],"strict_concatenate":false,"strict_equality":false,"strict_optional":true,"warn_no_return":true,"warn_return_any":false,"warn_unreachable":false,"warn_unused_ignores":false},"path":"/Users/yeogirlyun/Python/Poker/backend/ui/tabs/theme_editor_tab.py","plugin_data":null,"size":22230,"suppressed":["ui.services.advanced_theme_manager"],"version_id":"1.14.1"}
```

---

### theme_manager.data.json

**Path**: `.mypy_cache/3.13/backend/ui/theme_manager.data.json`

**Size**: 22.1 KB

```json
{".class":"MypyFile","_fullname":"backend.ui.theme_manager","future_import_flags":[],"is_partial_stub_package":false,"is_stub":false,"names":{".class":"SymbolTable","Any":{".class":"SymbolTableNode","cross_ref":"typing.Any","kind":"Gdef"},"Callable":{".class":"SymbolTableNode","cross_ref":"typing.Callable","kind":"Gdef"},"Dict":{".class":"SymbolTableNode","cross_ref":"typing.Dict","kind":"Gdef"},"EDITABLE_KEYS":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_inferred","has_explicit_value"],"fullname":"backend.ui.theme_manager.EDITABLE_KEYS","name":"EDITABLE_KEYS","type":{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"builtins.list"}}},"Optional":{".class":"SymbolTableNode","cross_ref":"typing.Optional","kind":"Gdef"},"ThemeManager":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["tkinter.Toplevel"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"backend.ui.theme_manager.ThemeManager","name":"ThemeManager","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"backend.ui.theme_manager.ThemeManager","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"backend.ui.theme_manager","mro":["backend.ui.theme_manager.ThemeManager","tkinter.Toplevel","tkinter.BaseWidget","tkinter.Misc","tkinter.Wm","builtins.object"],"names":{".class":"SymbolTable","__init__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,1],"arg_names":["self","master","on_theme_change"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.theme_manager.ThemeManager.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0,0,1],"arg_names":["self","master","on_theme_change"],"arg_types":["backend.ui.theme_manager.ThemeManager",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1},{".class":"UnionType","items":[{".class":"CallableType","arg_kinds":[2,4],"arg_names":[null,null],"arg_types":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4}],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":true,"name":null,"ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"NoneType"}],"uses_pep604_syntax":false}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_apply_hsl_to_palette":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.theme_manager.ThemeManager._apply_hsl_to_palette","name":"_apply_hsl_to_palette","type":null}},"_apply_live_preview":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.theme_manager.ThemeManager._apply_live_preview","name":"_apply_live_preview","type":null}},"_apply_theme_to_main_app":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.theme_manager.ThemeManager._apply_theme_to_main_app","name":"_apply_theme_to_main_app","type":null}},"_close_theme_manager":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.theme_manager.ThemeManager._close_theme_manager","name":"_close_theme_manager","type":null}},"_create_editor_panel":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.theme_manager.ThemeManager._create_editor_panel","name":"_create_editor_panel","type":null}},"_create_theme_list_panel":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.theme_manager.ThemeManager._create_theme_list_panel","name":"_create_theme_list_panel","type":null}},"_create_ui":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.theme_manager.ThemeManager._create_ui","name":"_create_ui","type":null}},"_export_themes":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.theme_manager.ThemeManager._export_themes","name":"_export_themes","type":null}},"_import_themes":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.theme_manager.ThemeManager._import_themes","name":"_import_themes","type":null}},"_on_color_change":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","key"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.theme_manager.ThemeManager._on_color_change","name":"_on_color_change","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","key"],"arg_types":["backend.ui.theme_manager.ThemeManager","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_on_color_change of ThemeManager","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_on_live_preview_toggle":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.theme_manager.ThemeManager._on_live_preview_toggle","name":"_on_live_preview_toggle","type":null}},"_on_theme_select":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,1],"arg_names":["self","event"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.theme_manager.ThemeManager._on_theme_select","name":"_on_theme_select","type":null}},"_pick_color":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","key"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.theme_manager.ThemeManager._pick_color","name":"_pick_color","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","key"],"arg_types":["backend.ui.theme_manager.ThemeManager","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_pick_color of ThemeManager","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_prompt_for_text":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":["self","title","prompt"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.theme_manager.ThemeManager._prompt_for_text","name":"_prompt_for_text","type":{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":["self","title","prompt"],"arg_types":["backend.ui.theme_manager.ThemeManager","builtins.str","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_prompt_for_text of ThemeManager","ret_type":{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":false},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_refresh_fields":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.theme_manager.ThemeManager._refresh_fields","name":"_refresh_fields","type":null}},"_reset_theme":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.theme_manager.ThemeManager._reset_theme","name":"_reset_theme","type":null}},"_save_as_theme":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.theme_manager.ThemeManager._save_as_theme","name":"_save_as_theme","type":null}},"_save_theme":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.theme_manager.ThemeManager._save_theme","name":"_save_theme","type":null}},"_update_color_preview":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":["self","key","color"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.theme_manager.ThemeManager._update_color_preview","name":"_update_color_preview","type":{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":["self","key","color"],"arg_types":["backend.ui.theme_manager.ThemeManager","builtins.str","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_update_color_preview of ThemeManager","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_update_working_theme_from_ui":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.theme_manager.ThemeManager._update_working_theme_from_ui","name":"_update_working_theme_from_ui","type":null}},"apply_status":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.theme_manager.ThemeManager.apply_status","name":"apply_status","type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1}}},"color_entries":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.theme_manager.ThemeManager.color_entries","name":"color_entries","type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1}}},"current_index":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.theme_manager.ThemeManager.current_index","name":"current_index","type":"builtins.int"}},"hue_var":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.theme_manager.ThemeManager.hue_var","name":"hue_var","type":"tkinter.DoubleVar"}},"id_var":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.theme_manager.ThemeManager.id_var","name":"id_var","type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1}}},"light_var":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.theme_manager.ThemeManager.light_var","name":"light_var","type":"tkinter.DoubleVar"}},"live_preview_enabled":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.theme_manager.ThemeManager.live_preview_enabled","name":"live_preview_enabled","type":"builtins.bool"}},"live_preview_var":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.theme_manager.ThemeManager.live_preview_var","name":"live_preview_var","type":"tkinter.BooleanVar"}},"name_var":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.theme_manager.ThemeManager.name_var","name":"name_var","type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1}}},"on_theme_change":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.theme_manager.ThemeManager.on_theme_change","name":"on_theme_change","type":{".class":"UnionType","items":[{".class":"CallableType","arg_kinds":[2,4],"arg_names":[null,null],"arg_types":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4}],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":true,"name":null,"ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"NoneType"}],"uses_pep604_syntax":false}}},"original_theme":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.theme_manager.ThemeManager.original_theme","name":"original_theme","type":{".class":"UnionType","items":[{".class":"AnyType","missing_import_name":null,"source_any":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":5},"type_of_any":7},{".class":"NoneType"}],"uses_pep604_syntax":false}}},"sat_var":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.theme_manager.ThemeManager.sat_var","name":"sat_var","type":"tkinter.DoubleVar"}},"theme_intro_text":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.theme_manager.ThemeManager.theme_intro_text","name":"theme_intro_text","type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1}}},"theme_listbox":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.theme_manager.ThemeManager.theme_listbox","name":"theme_listbox","type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1}}},"theme_loader":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.theme_manager.ThemeManager.theme_loader","name":"theme_loader","type":"backend.ui.services.theme_loader_consolidated.ConsolidatedThemeLoader"}},"themes":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.theme_manager.ThemeManager.themes","name":"themes","type":{".class":"AnyType","missing_import_name":null,"source_any":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":5},"type_of_any":7}}},"working_theme":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.theme_manager.ThemeManager.working_theme","name":"working_theme","type":{".class":"AnyType","missing_import_name":null,"source_any":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":5},"type_of_any":7}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"backend.ui.theme_manager.ThemeManager.Self","id":0,"name":"Self","namespace":"","upper_bound":"backend.ui.theme_manager.ThemeManager","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"__annotations__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.theme_manager.__annotations__","name":"__annotations__","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"__doc__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.theme_manager.__doc__","name":"__doc__","type":"builtins.str"}},"__file__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.theme_manager.__file__","name":"__file__","type":"builtins.str"}},"__name__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.theme_manager.__name__","name":"__name__","type":"builtins.str"}},"__package__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.theme_manager.__package__","name":"__package__","type":"builtins.str"}},"__spec__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.theme_manager.__spec__","name":"__spec__","type":"_frozen_importlib.ModuleSpec"}},"apply_hsl_nudge":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,1,1,1],"arg_names":["hex_color","dh","ds","dl"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.theme_manager.apply_hsl_nudge","name":"apply_hsl_nudge","type":{".class":"CallableType","arg_kinds":[0,1,1,1],"arg_names":["hex_color","dh","ds","dl"],"arg_types":["builtins.str","builtins.float","builtins.float","builtins.float"],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"apply_hsl_nudge","ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"colorchooser":{".class":"SymbolTableNode","cross_ref":"tkinter.colorchooser","kind":"Gdef"},"colorsys":{".class":"SymbolTableNode","cross_ref":"colorsys","kind":"Gdef"},"copy":{".class":"SymbolTableNode","cross_ref":"copy","kind":"Gdef"},"filedialog":{".class":"SymbolTableNode","cross_ref":"tkinter.filedialog","kind":"Gdef"},"get_consolidated_theme_loader":{".class":"SymbolTableNode","cross_ref":"backend.ui.services.theme_loader_consolidated.get_consolidated_theme_loader","kind":"Gdef"},"hex_to_rgbf":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["hex_color"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.theme_manager.hex_to_rgbf","name":"hex_to_rgbf","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["hex_color"],"arg_types":["builtins.str"],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"hex_to_rgbf","ret_type":{".class":"TupleType","implicit":false,"items":["builtins.float","builtins.float","builtins.float"],"partial_fallback":{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.tuple"}},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"json":{".class":"SymbolTableNode","cross_ref":"json","kind":"Gdef"},"load_themes":{".class":"SymbolTableNode","cross_ref":"backend.ui.services.theme_loader_consolidated.load_themes","kind":"Gdef"},"messagebox":{".class":"SymbolTableNode","cross_ref":"tkinter.messagebox","kind":"Gdef"},"pathlib":{".class":"SymbolTableNode","cross_ref":"pathlib","kind":"Gdef"},"rgbf_to_hex":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["rgb"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.theme_manager.rgbf_to_hex","name":"rgbf_to_hex","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["rgb"],"arg_types":[{".class":"TupleType","implicit":false,"items":["builtins.float","builtins.float","builtins.float"],"partial_fallback":{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.tuple"}}],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"rgbf_to_hex","ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"save_themes":{".class":"SymbolTableNode","cross_ref":"backend.ui.services.theme_loader_consolidated.save_themes","kind":"Gdef"},"tk":{".class":"SymbolTableNode","cross_ref":"tkinter","kind":"Gdef"},"ttk":{".class":"SymbolTableNode","cross_ref":"tkinter.ttk","kind":"Gdef"}},"path":"/Users/yeogirlyun/Python/Poker/backend/ui/theme_manager.py"}
```

---

### theme_manager.meta.json

**Path**: `.mypy_cache/3.13/backend/ui/theme_manager.meta.json`

**Size**: 1.9 KB

```json
{"data_mtime":1755476450,"dep_lines":[14,820,821,7,7,7,7,6,8,9,10,11,12,1,1,1,1,1,1,1,1],"dep_prios":[5,20,20,10,10,10,10,10,10,10,10,10,5,5,30,30,30,30,30,30,30],"dependencies":["backend.ui.services.theme_loader_consolidated","backend.ui.services.theme_derive","backend.ui.services.theme_loader","tkinter.ttk","tkinter.colorchooser","tkinter.filedialog","tkinter.messagebox","tkinter","colorsys","copy","json","pathlib","typing","builtins","_frozen_importlib","_tkinter","_typeshed","abc","backend.ui.services","os","tkinter.font"],"hash":"b9a6bf634135e68f51d940023a0fb69d8de635c2","id":"backend.ui.theme_manager","ignore_all":true,"interface_hash":"9a726fa30732b5581c47eee348dae5c4e7ba6eaa","mtime":1755440994,"options":{"allow_redefinition":false,"allow_untyped_globals":false,"always_false":[],"always_true":[],"bazel":false,"check_untyped_defs":false,"disable_bytearray_promotion":false,"disable_error_code":[],"disable_memoryview_promotion":false,"disabled_error_codes":[],"disallow_any_decorated":false,"disallow_any_explicit":false,"disallow_any_expr":false,"disallow_any_generics":false,"disallow_any_unimported":false,"disallow_incomplete_defs":false,"disallow_subclassing_any":false,"disallow_untyped_calls":false,"disallow_untyped_decorators":false,"disallow_untyped_defs":false,"enable_error_code":[],"enabled_error_codes":[],"extra_checks":false,"follow_imports":"normal","follow_imports_for_stubs":false,"follow_untyped_imports":false,"ignore_errors":false,"ignore_missing_imports":false,"implicit_optional":false,"implicit_reexport":true,"local_partial_types":false,"mypyc":false,"old_type_inference":false,"platform":"darwin","plugins":[],"strict_concatenate":false,"strict_equality":false,"strict_optional":true,"warn_no_return":true,"warn_return_any":false,"warn_unreachable":false,"warn_unused_ignores":false},"path":"/Users/yeogirlyun/Python/Poker/backend/ui/theme_manager.py","plugin_data":null,"size":34471,"suppressed":[],"version_id":"1.14.1"}
```

---

### theme_emphasis.data.json

**Path**: `.mypy_cache/3.13/backend/utils/theme_emphasis.data.json`

**Size**: 5.6 KB

```json
{".class":"MypyFile","_fullname":"backend.utils.theme_emphasis","future_import_flags":[],"is_partial_stub_package":false,"is_stub":false,"names":{".class":"SymbolTable","__annotations__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.utils.theme_emphasis.__annotations__","name":"__annotations__","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"__doc__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.utils.theme_emphasis.__doc__","name":"__doc__","type":"builtins.str"}},"__file__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.utils.theme_emphasis.__file__","name":"__file__","type":"builtins.str"}},"__name__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.utils.theme_emphasis.__name__","name":"__name__","type":"builtins.str"}},"__package__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.utils.theme_emphasis.__package__","name":"__package__","type":"builtins.str"}},"__spec__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.utils.theme_emphasis.__spec__","name":"__spec__","type":"_frozen_importlib.ModuleSpec"}},"_adjust_lightness":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["hex_color","delta"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.utils.theme_emphasis._adjust_lightness","name":"_adjust_lightness","type":null}},"_blend":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,1],"arg_names":["rgb_a","rgb_b","t"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.utils.theme_emphasis._blend","name":"_blend","type":null}},"_clamp01":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["x"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.utils.theme_emphasis._clamp01","name":"_clamp01","type":null}},"_contrast_ratio":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["rgb1","rgb2"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.utils.theme_emphasis._contrast_ratio","name":"_contrast_ratio","type":null}},"_ensure_text_contrast":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,1],"arg_names":["bg_hex","prefer_hex","alt_hex","min_ratio"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.utils.theme_emphasis._ensure_text_contrast","name":"_ensure_text_contrast","type":null}},"_hex_to_rgb":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["hex_str"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.utils.theme_emphasis._hex_to_rgb","name":"_hex_to_rgb","type":null}},"_hsl01_to_rgb_hex":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":["h","s","l"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.utils.theme_emphasis._hsl01_to_rgb_hex","name":"_hsl01_to_rgb_hex","type":null}},"_rel_luminance":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["rgb"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.utils.theme_emphasis._rel_luminance","name":"_rel_luminance","type":null}},"_rgb_to_hex":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["rgb"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.utils.theme_emphasis._rgb_to_hex","name":"_rgb_to_hex","type":null}},"_rgb_to_hsl01":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["rgb"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.utils.theme_emphasis._rgb_to_hsl01","name":"_rgb_to_hsl01","type":null}},"_shift_toward":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,1,1],"arg_names":["hsl_src","hsl_target","hue_deg","sat_boost"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.utils.theme_emphasis._shift_toward","name":"_shift_toward","type":null}},"_srgb_to_linear":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["c"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.utils.theme_emphasis._srgb_to_linear","name":"_srgb_to_linear","type":null}},"build_emphasis_tokens":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["palette"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.utils.theme_emphasis.build_emphasis_tokens","name":"build_emphasis_tokens","type":null}},"hls_to_rgb":{".class":"SymbolTableNode","cross_ref":"colorsys.hls_to_rgb","kind":"Gdef"},"rgb_to_hls":{".class":"SymbolTableNode","cross_ref":"colorsys.rgb_to_hls","kind":"Gdef"}},"path":"/Users/yeogirlyun/Python/Poker/backend/utils/theme_emphasis.py"}
```

---

### theme_emphasis.meta.json

**Path**: `.mypy_cache/3.13/backend/utils/theme_emphasis.meta.json`

**Size**: 1.6 KB

```json
{"data_mtime":1755432088,"dep_lines":[3,1,1,1,1,1,1],"dep_prios":[5,5,30,30,30,30,30],"dependencies":["colorsys","builtins","_collections_abc","_frozen_importlib","_typeshed","abc","typing"],"hash":"915f4b48ca502d76cfa311e9491f47f291690c23","id":"backend.utils.theme_emphasis","ignore_all":false,"interface_hash":"7717ce67869cb3ec44f67e50d5d7884cab40ab0a","mtime":1755432273,"options":{"allow_redefinition":false,"allow_untyped_globals":false,"always_false":[],"always_true":[],"bazel":false,"check_untyped_defs":false,"disable_bytearray_promotion":false,"disable_error_code":[],"disable_memoryview_promotion":false,"disabled_error_codes":[],"disallow_any_decorated":false,"disallow_any_explicit":false,"disallow_any_expr":false,"disallow_any_generics":false,"disallow_any_unimported":false,"disallow_incomplete_defs":false,"disallow_subclassing_any":false,"disallow_untyped_calls":false,"disallow_untyped_decorators":false,"disallow_untyped_defs":false,"enable_error_code":[],"enabled_error_codes":[],"extra_checks":false,"follow_imports":"normal","follow_imports_for_stubs":false,"follow_untyped_imports":false,"ignore_errors":false,"ignore_missing_imports":false,"implicit_optional":false,"implicit_reexport":true,"local_partial_types":false,"mypyc":false,"old_type_inference":false,"platform":"darwin","plugins":[],"strict_concatenate":false,"strict_equality":false,"strict_optional":true,"warn_no_return":true,"warn_return_any":false,"warn_unreachable":false,"warn_unused_ignores":false},"path":"/Users/yeogirlyun/Python/Poker/backend/utils/theme_emphasis.py","plugin_data":null,"size":5197,"suppressed":[],"version_id":"1.14.1"}
```

---

### configparser.data.json

**Path**: `.mypy_cache/3.13/configparser.data.json`

**Size**: 178.2 KB

```json
{".class":"MypyFile","_fullname":"configparser","future_import_flags":[],"is_partial_stub_package":false,"is_stub":true,"names":{".class":"SymbolTable","Any":{".class":"SymbolTableNode","cross_ref":"typing.Any","kind":"Gdef","module_hidden":true,"module_public":false},"BasicInterpolation":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["configparser.Interpolation"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"configparser.BasicInterpolation","name":"BasicInterpolation","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"configparser.BasicInterpolation","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"configparser","mro":["configparser.BasicInterpolation","configparser.Interpolation","builtins.object"],"names":{".class":"SymbolTable"},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser.BasicInterpolation.Self","id":0,"name":"Self","namespace":"","upper_bound":"configparser.BasicInterpolation","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"Callable":{".class":"SymbolTableNode","cross_ref":"typing.Callable","kind":"Gdef","module_hidden":true,"module_public":false},"ClassVar":{".class":"SymbolTableNode","cross_ref":"typing.ClassVar","kind":"Gdef","module_hidden":true,"module_public":false},"ConfigParser":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["configparser.RawConfigParser"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"configparser.ConfigParser","name":"ConfigParser","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"configparser.ConfigParser","has_param_spec_type":false,"metaclass_type":"abc.ABCMeta","metadata":{},"module_name":"configparser","mro":["configparser.ConfigParser","configparser.RawConfigParser","typing.MutableMapping","typing.Mapping","typing.Collection","typing.Iterable","typing.Container","builtins.object"],"names":{".class":"SymbolTable","get":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"OverloadedFuncDef","deprecated":null,"flags":[],"fullname":"configparser.ConfigParser.get","impl":null,"items":[{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,5,5],"arg_names":["self","section","option","raw","vars"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated"],"fullname":"configparser.ConfigParser.get","name":"get","type":{".class":"CallableType","arg_kinds":[0,0,0,5,5],"arg_names":["self","section","option","raw","vars"],"arg_types":["configparser.ConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get of ConfigParser","ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"configparser.ConfigParser.get","name":"get","type":{".class":"CallableType","arg_kinds":[0,0,0,5,5],"arg_names":["self","section","option","raw","vars"],"arg_types":["configparser.ConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get of ConfigParser","ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,5,5,3],"arg_names":["self","section","option","raw","vars","fallback"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated"],"fullname":"configparser.ConfigParser.get","name":"get","type":{".class":"CallableType","arg_kinds":[0,0,0,5,5,3],"arg_names":["self","section","option","raw","vars","fallback"],"arg_types":["configparser.ConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.ConfigParser.get","upper_bound":"builtins.object","values":[],"variance":0}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get of ConfigParser","ret_type":{".class":"UnionType","items":["builtins.str",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.ConfigParser.get","upper_bound":"builtins.object","values":[],"variance":0}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.ConfigParser.get","upper_bound":"builtins.object","values":[],"variance":0}]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"configparser.ConfigParser.get","name":"get","type":{".class":"CallableType","arg_kinds":[0,0,0,5,5,3],"arg_names":["self","section","option","raw","vars","fallback"],"arg_types":["configparser.ConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.ConfigParser.get","upper_bound":"builtins.object","values":[],"variance":0}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get of ConfigParser","ret_type":{".class":"UnionType","items":["builtins.str",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.ConfigParser.get","upper_bound":"builtins.object","values":[],"variance":0}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.ConfigParser.get","upper_bound":"builtins.object","values":[],"variance":0}]}}}],"type":{".class":"Overloaded","items":[{".class":"CallableType","arg_kinds":[0,0,0,5,5],"arg_names":["self","section","option","raw","vars"],"arg_types":["configparser.ConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get of ConfigParser","ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"CallableType","arg_kinds":[0,0,0,5,5,3],"arg_names":["self","section","option","raw","vars","fallback"],"arg_types":["configparser.ConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.ConfigParser.get","upper_bound":"builtins.object","values":[],"variance":0}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get of ConfigParser","ret_type":{".class":"UnionType","items":["builtins.str",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.ConfigParser.get","upper_bound":"builtins.object","values":[],"variance":0}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.ConfigParser.get","upper_bound":"builtins.object","values":[],"variance":0}]}]}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser.ConfigParser.Self","id":0,"name":"Self","namespace":"","upper_bound":"configparser.ConfigParser","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"ConverterMapping":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":[{".class":"Instance","args":["builtins.str",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._ConverterCallback"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"extra_attrs":null,"type_ref":"typing.MutableMapping"}],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"configparser.ConverterMapping","name":"ConverterMapping","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"configparser.ConverterMapping","has_param_spec_type":false,"metaclass_type":"abc.ABCMeta","metadata":{},"module_name":"configparser","mro":["configparser.ConverterMapping","typing.MutableMapping","typing.Mapping","typing.Collection","typing.Iterable","typing.Container","builtins.object"],"names":{".class":"SymbolTable","GETTERCRE":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_classvar","is_ready"],"fullname":"configparser.ConverterMapping.GETTERCRE","name":"GETTERCRE","type":{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"re.Pattern"}}},"__delitem__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":[null,null],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.ConverterMapping.__delitem__","name":"__delitem__","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":["configparser.ConverterMapping","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__delitem__ of ConverterMapping","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"__getitem__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":[null,null],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.ConverterMapping.__getitem__","name":"__getitem__","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":["configparser.ConverterMapping","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__getitem__ of ConverterMapping","ret_type":{".class":"TypeAliasType","args":[],"type_ref":"configparser._ConverterCallback"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"__init__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","parser"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.ConverterMapping.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","parser"],"arg_types":["configparser.ConverterMapping","configparser.RawConfigParser"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of ConverterMapping","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"__iter__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":[null],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.ConverterMapping.__iter__","name":"__iter__","type":{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["configparser.ConverterMapping"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__iter__ of ConverterMapping","ret_type":{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Iterator"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"__len__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":[null],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.ConverterMapping.__len__","name":"__len__","type":{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["configparser.ConverterMapping"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__len__ of ConverterMapping","ret_type":"builtins.int","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"__setitem__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":[null,null,null],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.ConverterMapping.__setitem__","name":"__setitem__","type":{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":[null,null,null],"arg_types":["configparser.ConverterMapping","builtins.str",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._ConverterCallback"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__setitem__ of ConverterMapping","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser.ConverterMapping.Self","id":0,"name":"Self","namespace":"","upper_bound":"configparser.ConverterMapping","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"DEFAULTSECT":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","final_value":"DEFAULT","flags":["is_final","is_ready","is_inferred","has_explicit_value"],"fullname":"configparser.DEFAULTSECT","name":"DEFAULTSECT","type":{".class":"Instance","args":[],"extra_attrs":null,"last_known_value":{".class":"LiteralType","fallback":"builtins.str","value":"DEFAULT"},"type_ref":"builtins.str"}}},"DuplicateOptionError":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["configparser.Error"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"configparser.DuplicateOptionError","name":"DuplicateOptionError","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"configparser.DuplicateOptionError","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"configparser","mro":["configparser.DuplicateOptionError","configparser.Error","builtins.Exception","builtins.BaseException","builtins.object"],"names":{".class":"SymbolTable","__init__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,1,1],"arg_names":["self","section","option","source","lineno"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.DuplicateOptionError.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0,0,0,1,1],"arg_names":["self","section","option","source","lineno"],"arg_types":["configparser.DuplicateOptionError","builtins.str","builtins.str",{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"UnionType","items":["builtins.int",{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of DuplicateOptionError","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"lineno":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready"],"fullname":"configparser.DuplicateOptionError.lineno","name":"lineno","type":{".class":"UnionType","items":["builtins.int",{".class":"NoneType"}],"uses_pep604_syntax":true}}},"option":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready"],"fullname":"configparser.DuplicateOptionError.option","name":"option","type":"builtins.str"}},"section":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready"],"fullname":"configparser.DuplicateOptionError.section","name":"section","type":"builtins.str"}},"source":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready"],"fullname":"configparser.DuplicateOptionError.source","name":"source","type":{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser.DuplicateOptionError.Self","id":0,"name":"Self","namespace":"","upper_bound":"configparser.DuplicateOptionError","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"DuplicateSectionError":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["configparser.Error"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"configparser.DuplicateSectionError","name":"DuplicateSectionError","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"configparser.DuplicateSectionError","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"configparser","mro":["configparser.DuplicateSectionError","configparser.Error","builtins.Exception","builtins.BaseException","builtins.object"],"names":{".class":"SymbolTable","__init__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,1,1],"arg_names":["self","section","source","lineno"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.DuplicateSectionError.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0,0,1,1],"arg_names":["self","section","source","lineno"],"arg_types":["configparser.DuplicateSectionError","builtins.str",{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"UnionType","items":["builtins.int",{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of DuplicateSectionError","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"lineno":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready"],"fullname":"configparser.DuplicateSectionError.lineno","name":"lineno","type":{".class":"UnionType","items":["builtins.int",{".class":"NoneType"}],"uses_pep604_syntax":true}}},"section":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready"],"fullname":"configparser.DuplicateSectionError.section","name":"section","type":"builtins.str"}},"source":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready"],"fullname":"configparser.DuplicateSectionError.source","name":"source","type":{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser.DuplicateSectionError.Self","id":0,"name":"Self","namespace":"","upper_bound":"configparser.DuplicateSectionError","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"Error":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["builtins.Exception"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"configparser.Error","name":"Error","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"configparser.Error","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"configparser","mro":["configparser.Error","builtins.Exception","builtins.BaseException","builtins.object"],"names":{".class":"SymbolTable","__init__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,1],"arg_names":["self","msg"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.Error.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0,1],"arg_names":["self","msg"],"arg_types":["configparser.Error","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of Error","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"message":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready"],"fullname":"configparser.Error.message","name":"message","type":"builtins.str"}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser.Error.Self","id":0,"name":"Self","namespace":"","upper_bound":"configparser.Error","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"ExtendedInterpolation":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["configparser.Interpolation"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"configparser.ExtendedInterpolation","name":"ExtendedInterpolation","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"configparser.ExtendedInterpolation","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"configparser","mro":["configparser.ExtendedInterpolation","configparser.Interpolation","builtins.object"],"names":{".class":"SymbolTable"},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser.ExtendedInterpolation.Self","id":0,"name":"Self","namespace":"","upper_bound":"configparser.ExtendedInterpolation","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"Final":{".class":"SymbolTableNode","cross_ref":"typing.Final","kind":"Gdef","module_hidden":true,"module_public":false},"Interpolation":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["builtins.object"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"configparser.Interpolation","name":"Interpolation","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"configparser.Interpolation","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"configparser","mro":["configparser.Interpolation","builtins.object"],"names":{".class":"SymbolTable","before_get":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,0,0,0],"arg_names":["self","parser","section","option","value","defaults"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.Interpolation.before_get","name":"before_get","type":{".class":"CallableType","arg_kinds":[0,0,0,0,0,0],"arg_names":["self","parser","section","option","value","defaults"],"arg_types":["configparser.Interpolation",{".class":"TypeAliasType","args":[],"type_ref":"configparser._Parser"},"builtins.str","builtins.str","builtins.str",{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"before_get of Interpolation","ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"before_read":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,0,0],"arg_names":["self","parser","section","option","value"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.Interpolation.before_read","name":"before_read","type":{".class":"CallableType","arg_kinds":[0,0,0,0,0],"arg_names":["self","parser","section","option","value"],"arg_types":["configparser.Interpolation",{".class":"TypeAliasType","args":[],"type_ref":"configparser._Parser"},"builtins.str","builtins.str","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"before_read of Interpolation","ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"before_set":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,0,0],"arg_names":["self","parser","section","option","value"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.Interpolation.before_set","name":"before_set","type":{".class":"CallableType","arg_kinds":[0,0,0,0,0],"arg_names":["self","parser","section","option","value"],"arg_types":["configparser.Interpolation",{".class":"TypeAliasType","args":[],"type_ref":"configparser._Parser"},"builtins.str","builtins.str","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"before_set of Interpolation","ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"before_write":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,0,0],"arg_names":["self","parser","section","option","value"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.Interpolation.before_write","name":"before_write","type":{".class":"CallableType","arg_kinds":[0,0,0,0,0],"arg_names":["self","parser","section","option","value"],"arg_types":["configparser.Interpolation",{".class":"TypeAliasType","args":[],"type_ref":"configparser._Parser"},"builtins.str","builtins.str","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"before_write of Interpolation","ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser.Interpolation.Self","id":0,"name":"Self","namespace":"","upper_bound":"configparser.Interpolation","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"InterpolationDepthError":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["configparser.InterpolationError"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"configparser.InterpolationDepthError","name":"InterpolationDepthError","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"configparser.InterpolationDepthError","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"configparser","mro":["configparser.InterpolationDepthError","configparser.InterpolationError","configparser.Error","builtins.Exception","builtins.BaseException","builtins.object"],"names":{".class":"SymbolTable","__init__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,0],"arg_names":["self","option","section","rawval"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.InterpolationDepthError.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0,0,0,0],"arg_names":["self","option","section","rawval"],"arg_types":["configparser.InterpolationDepthError","builtins.str","builtins.str","builtins.object"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of InterpolationDepthError","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser.InterpolationDepthError.Self","id":0,"name":"Self","namespace":"","upper_bound":"configparser.InterpolationDepthError","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"InterpolationError":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["configparser.Error"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"configparser.InterpolationError","name":"InterpolationError","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"configparser.InterpolationError","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"configparser","mro":["configparser.InterpolationError","configparser.Error","builtins.Exception","builtins.BaseException","builtins.object"],"names":{".class":"SymbolTable","__init__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,0],"arg_names":["self","option","section","msg"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.InterpolationError.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0,0,0,0],"arg_names":["self","option","section","msg"],"arg_types":["configparser.InterpolationError","builtins.str","builtins.str","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of InterpolationError","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"option":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready"],"fullname":"configparser.InterpolationError.option","name":"option","type":"builtins.str"}},"section":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready"],"fullname":"configparser.InterpolationError.section","name":"section","type":"builtins.str"}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser.InterpolationError.Self","id":0,"name":"Self","namespace":"","upper_bound":"configparser.InterpolationError","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"InterpolationMissingOptionError":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["configparser.InterpolationError"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"configparser.InterpolationMissingOptionError","name":"InterpolationMissingOptionError","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"configparser.InterpolationMissingOptionError","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"configparser","mro":["configparser.InterpolationMissingOptionError","configparser.InterpolationError","configparser.Error","builtins.Exception","builtins.BaseException","builtins.object"],"names":{".class":"SymbolTable","__init__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,0,0],"arg_names":["self","option","section","rawval","reference"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.InterpolationMissingOptionError.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0,0,0,0,0],"arg_names":["self","option","section","rawval","reference"],"arg_types":["configparser.InterpolationMissingOptionError","builtins.str","builtins.str","builtins.object","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of InterpolationMissingOptionError","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"reference":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready"],"fullname":"configparser.InterpolationMissingOptionError.reference","name":"reference","type":"builtins.str"}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser.InterpolationMissingOptionError.Self","id":0,"name":"Self","namespace":"","upper_bound":"configparser.InterpolationMissingOptionError","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"InterpolationSyntaxError":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["configparser.InterpolationError"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"configparser.InterpolationSyntaxError","name":"InterpolationSyntaxError","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"configparser.InterpolationSyntaxError","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"configparser","mro":["configparser.InterpolationSyntaxError","configparser.InterpolationError","configparser.Error","builtins.Exception","builtins.BaseException","builtins.object"],"names":{".class":"SymbolTable"},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser.InterpolationSyntaxError.Self","id":0,"name":"Self","namespace":"","upper_bound":"configparser.InterpolationSyntaxError","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"ItemsView":{".class":"SymbolTableNode","cross_ref":"typing.ItemsView","kind":"Gdef","module_hidden":true,"module_public":false},"Iterable":{".class":"SymbolTableNode","cross_ref":"typing.Iterable","kind":"Gdef","module_hidden":true,"module_public":false},"Iterator":{".class":"SymbolTableNode","cross_ref":"typing.Iterator","kind":"Gdef","module_hidden":true,"module_public":false},"Literal":{".class":"SymbolTableNode","cross_ref":"typing.Literal","kind":"Gdef","module_hidden":true,"module_public":false},"MAX_INTERPOLATION_DEPTH":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","final_value":10,"flags":["is_final","is_ready","is_inferred","has_explicit_value"],"fullname":"configparser.MAX_INTERPOLATION_DEPTH","name":"MAX_INTERPOLATION_DEPTH","type":{".class":"Instance","args":[],"extra_attrs":null,"last_known_value":{".class":"LiteralType","fallback":"builtins.int","value":10},"type_ref":"builtins.int"}}},"Mapping":{".class":"SymbolTableNode","cross_ref":"typing.Mapping","kind":"Gdef","module_hidden":true,"module_public":false},"MaybeNone":{".class":"SymbolTableNode","cross_ref":"_typeshed.MaybeNone","kind":"Gdef","module_hidden":true,"module_public":false},"MissingSectionHeaderError":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["configparser.ParsingError"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"configparser.MissingSectionHeaderError","name":"MissingSectionHeaderError","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"configparser.MissingSectionHeaderError","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"configparser","mro":["configparser.MissingSectionHeaderError","configparser.ParsingError","configparser.Error","builtins.Exception","builtins.BaseException","builtins.object"],"names":{".class":"SymbolTable","__init__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,0],"arg_names":["self","filename","lineno","line"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.MissingSectionHeaderError.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0,0,0,0],"arg_names":["self","filename","lineno","line"],"arg_types":["configparser.MissingSectionHeaderError","builtins.str","builtins.int","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of MissingSectionHeaderError","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"line":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready"],"fullname":"configparser.MissingSectionHeaderError.line","name":"line","type":"builtins.str"}},"lineno":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready"],"fullname":"configparser.MissingSectionHeaderError.lineno","name":"lineno","type":"builtins.int"}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser.MissingSectionHeaderError.Self","id":0,"name":"Self","namespace":"","upper_bound":"configparser.MissingSectionHeaderError","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"MultilineContinuationError":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["configparser.ParsingError"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"configparser.MultilineContinuationError","name":"MultilineContinuationError","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"configparser.MultilineContinuationError","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"configparser","mro":["configparser.MultilineContinuationError","configparser.ParsingError","configparser.Error","builtins.Exception","builtins.BaseException","builtins.object"],"names":{".class":"SymbolTable","__init__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,0],"arg_names":["self","filename","lineno","line"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.MultilineContinuationError.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0,0,0,0],"arg_names":["self","filename","lineno","line"],"arg_types":["configparser.MultilineContinuationError","builtins.str","builtins.int","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of MultilineContinuationError","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"line":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready"],"fullname":"configparser.MultilineContinuationError.line","name":"line","type":"builtins.str"}},"lineno":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready"],"fullname":"configparser.MultilineContinuationError.lineno","name":"lineno","type":"builtins.int"}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser.MultilineContinuationError.Self","id":0,"name":"Self","namespace":"","upper_bound":"configparser.MultilineContinuationError","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"MutableMapping":{".class":"SymbolTableNode","cross_ref":"typing.MutableMapping","kind":"Gdef","module_hidden":true,"module_public":false},"NoOptionError":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["configparser.Error"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"configparser.NoOptionError","name":"NoOptionError","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"configparser.NoOptionError","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"configparser","mro":["configparser.NoOptionError","configparser.Error","builtins.Exception","builtins.BaseException","builtins.object"],"names":{".class":"SymbolTable","__init__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":["self","option","section"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.NoOptionError.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":["self","option","section"],"arg_types":["configparser.NoOptionError","builtins.str","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of NoOptionError","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"option":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready"],"fullname":"configparser.NoOptionError.option","name":"option","type":"builtins.str"}},"section":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready"],"fullname":"configparser.NoOptionError.section","name":"section","type":"builtins.str"}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser.NoOptionError.Self","id":0,"name":"Self","namespace":"","upper_bound":"configparser.NoOptionError","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"NoSectionError":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["configparser.Error"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"configparser.NoSectionError","name":"NoSectionError","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"configparser.NoSectionError","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"configparser","mro":["configparser.NoSectionError","configparser.Error","builtins.Exception","builtins.BaseException","builtins.object"],"names":{".class":"SymbolTable","__init__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","section"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.NoSectionError.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","section"],"arg_types":["configparser.NoSectionError","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of NoSectionError","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"section":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready"],"fullname":"configparser.NoSectionError.section","name":"section","type":"builtins.str"}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser.NoSectionError.Self","id":0,"name":"Self","namespace":"","upper_bound":"configparser.NoSectionError","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"ParsingError":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["configparser.Error"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"configparser.ParsingError","name":"ParsingError","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"configparser.ParsingError","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"configparser","mro":["configparser.ParsingError","configparser.Error","builtins.Exception","builtins.BaseException","builtins.object"],"names":{".class":"SymbolTable","__init__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,2],"arg_names":["self","source","args"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.ParsingError.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0,0,2],"arg_names":["self","source","args"],"arg_types":["configparser.ParsingError","builtins.str","builtins.object"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of ParsingError","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"append":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":["self","lineno","line"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.ParsingError.append","name":"append","type":{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":["self","lineno","line"],"arg_types":["configparser.ParsingError","builtins.int","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"append of ParsingError","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"combine":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","others"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.ParsingError.combine","name":"combine","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","others"],"arg_types":["configparser.ParsingError",{".class":"Instance","args":["configparser.ParsingError"],"extra_attrs":null,"type_ref":"typing.Iterable"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"combine of ParsingError","ret_type":"configparser.ParsingError","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"errors":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready"],"fullname":"configparser.ParsingError.errors","name":"errors","type":{".class":"Instance","args":[{".class":"TupleType","implicit":false,"items":["builtins.int","builtins.str"],"partial_fallback":{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.tuple"}}],"extra_attrs":null,"type_ref":"builtins.list"}}},"source":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready"],"fullname":"configparser.ParsingError.source","name":"source","type":"builtins.str"}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser.ParsingError.Self","id":0,"name":"Self","namespace":"","upper_bound":"configparser.ParsingError","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"Pattern":{".class":"SymbolTableNode","cross_ref":"re.Pattern","kind":"Gdef","module_hidden":true,"module_public":false},"RawConfigParser":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":[{".class":"Instance","args":["builtins.str",{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"}],"extra_attrs":null,"type_ref":"typing.MutableMapping"}],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"configparser.RawConfigParser","name":"RawConfigParser","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"configparser.RawConfigParser","has_param_spec_type":false,"metaclass_type":"abc.ABCMeta","metadata":{},"module_name":"configparser","mro":["configparser.RawConfigParser","typing.MutableMapping","typing.Mapping","typing.Collection","typing.Iterable","typing.Container","builtins.object"],"names":{".class":"SymbolTable","BOOLEAN_STATES":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_classvar","is_ready"],"fullname":"configparser.RawConfigParser.BOOLEAN_STATES","name":"BOOLEAN_STATES","type":{".class":"Instance","args":["builtins.str","builtins.bool"],"extra_attrs":null,"type_ref":"typing.Mapping"}}},"NONSPACECRE":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_classvar","is_ready"],"fullname":"configparser.RawConfigParser.NONSPACECRE","name":"NONSPACECRE","type":{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"re.Pattern"}}},"OPTCRE":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_classvar","is_ready"],"fullname":"configparser.RawConfigParser.OPTCRE","name":"OPTCRE","type":{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"re.Pattern"}}},"OPTCRE_NV":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_classvar","is_ready"],"fullname":"configparser.RawConfigParser.OPTCRE_NV","name":"OPTCRE_NV","type":{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"re.Pattern"}}},"SECTCRE":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready"],"fullname":"configparser.RawConfigParser.SECTCRE","name":"SECTCRE","type":{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"re.Pattern"}}},"_OPT_NV_TMPL":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_classvar","is_ready"],"fullname":"configparser.RawConfigParser._OPT_NV_TMPL","name":"_OPT_NV_TMPL","type":"builtins.str"}},"_OPT_TMPL":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_classvar","is_ready"],"fullname":"configparser.RawConfigParser._OPT_TMPL","name":"_OPT_TMPL","type":"builtins.str"}},"_SECT_TMPL":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_classvar","is_ready"],"fullname":"configparser.RawConfigParser._SECT_TMPL","name":"_SECT_TMPL","type":"builtins.str"}},"__contains__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":[null,null],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.RawConfigParser.__contains__","name":"__contains__","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":["configparser.RawConfigParser","builtins.object"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__contains__ of RawConfigParser","ret_type":"builtins.bool","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"__delitem__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":[null,null],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.RawConfigParser.__delitem__","name":"__delitem__","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":["configparser.RawConfigParser","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__delitem__ of RawConfigParser","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"__getitem__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":[null,null],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.RawConfigParser.__getitem__","name":"__getitem__","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":["configparser.RawConfigParser","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__getitem__ of RawConfigParser","ret_type":"configparser.SectionProxy","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"__init__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"OverloadedFuncDef","deprecated":null,"flags":[],"fullname":"configparser.RawConfigParser.__init__","impl":null,"items":[{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,1,1,3,5,5,5,5,5,5,5,5,5],"arg_names":["self","defaults","dict_type","allow_no_value","delimiters","comment_prefixes","inline_comment_prefixes","strict","empty_lines_in_values","default_section","interpolation","converters","allow_unnamed_section"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated"],"fullname":"configparser.RawConfigParser.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0,1,1,3,5,5,5,5,5,5,5,5,5],"arg_names":["self","defaults","dict_type","allow_no_value","delimiters","comment_prefixes","inline_comment_prefixes","strict","empty_lines_in_values","default_section","interpolation","converters","allow_unnamed_section"],"arg_types":["configparser.RawConfigParser",{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str",{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}],"extra_attrs":null,"type_ref":"typing.Mapping"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeType","item":{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"typing.Mapping"}},{".class":"LiteralType","fallback":"builtins.bool","value":true},{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Sequence"},{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Sequence"},{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Sequence"},{".class":"NoneType"}],"uses_pep604_syntax":true},"builtins.bool","builtins.bool","builtins.str",{".class":"UnionType","items":["configparser.Interpolation",{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeAliasType","args":[],"type_ref":"configparser._ConvertersMap"},"builtins.bool"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of RawConfigParser","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"configparser.RawConfigParser.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0,1,1,3,5,5,5,5,5,5,5,5,5],"arg_names":["self","defaults","dict_type","allow_no_value","delimiters","comment_prefixes","inline_comment_prefixes","strict","empty_lines_in_values","default_section","interpolation","converters","allow_unnamed_section"],"arg_types":["configparser.RawConfigParser",{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str",{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}],"extra_attrs":null,"type_ref":"typing.Mapping"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeType","item":{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"typing.Mapping"}},{".class":"LiteralType","fallback":"builtins.bool","value":true},{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Sequence"},{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Sequence"},{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Sequence"},{".class":"NoneType"}],"uses_pep604_syntax":true},"builtins.bool","builtins.bool","builtins.str",{".class":"UnionType","items":["configparser.Interpolation",{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeAliasType","args":[],"type_ref":"configparser._ConvertersMap"},"builtins.bool"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of RawConfigParser","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,0,5,5,5,5,5,5,5,5,5],"arg_names":["self","defaults","dict_type","allow_no_value","delimiters","comment_prefixes","inline_comment_prefixes","strict","empty_lines_in_values","default_section","interpolation","converters","allow_unnamed_section"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated"],"fullname":"configparser.RawConfigParser.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0,0,0,0,5,5,5,5,5,5,5,5,5],"arg_names":["self","defaults","dict_type","allow_no_value","delimiters","comment_prefixes","inline_comment_prefixes","strict","empty_lines_in_values","default_section","interpolation","converters","allow_unnamed_section"],"arg_types":["configparser.RawConfigParser",{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str",{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}],"extra_attrs":null,"type_ref":"typing.Mapping"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeType","item":{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"typing.Mapping"}},{".class":"LiteralType","fallback":"builtins.bool","value":true},{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Sequence"},{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Sequence"},{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Sequence"},{".class":"NoneType"}],"uses_pep604_syntax":true},"builtins.bool","builtins.bool","builtins.str",{".class":"UnionType","items":["configparser.Interpolation",{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeAliasType","args":[],"type_ref":"configparser._ConvertersMap"},"builtins.bool"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of RawConfigParser","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"configparser.RawConfigParser.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0,0,0,0,5,5,5,5,5,5,5,5,5],"arg_names":["self","defaults","dict_type","allow_no_value","delimiters","comment_prefixes","inline_comment_prefixes","strict","empty_lines_in_values","default_section","interpolation","converters","allow_unnamed_section"],"arg_types":["configparser.RawConfigParser",{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str",{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}],"extra_attrs":null,"type_ref":"typing.Mapping"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeType","item":{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"typing.Mapping"}},{".class":"LiteralType","fallback":"builtins.bool","value":true},{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Sequence"},{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Sequence"},{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Sequence"},{".class":"NoneType"}],"uses_pep604_syntax":true},"builtins.bool","builtins.bool","builtins.str",{".class":"UnionType","items":["configparser.Interpolation",{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeAliasType","args":[],"type_ref":"configparser._ConvertersMap"},"builtins.bool"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of RawConfigParser","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,1,1,1,5,5,5,5,5,5,5,5,5],"arg_names":["self","defaults","dict_type","allow_no_value","delimiters","comment_prefixes","inline_comment_prefixes","strict","empty_lines_in_values","default_section","interpolation","converters","allow_unnamed_section"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated"],"fullname":"configparser.RawConfigParser.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0,1,1,1,5,5,5,5,5,5,5,5,5],"arg_names":["self","defaults","dict_type","allow_no_value","delimiters","comment_prefixes","inline_comment_prefixes","strict","empty_lines_in_values","default_section","interpolation","converters","allow_unnamed_section"],"arg_types":["configparser.RawConfigParser",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeType","item":{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"typing.Mapping"}},"builtins.bool",{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Sequence"},{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Sequence"},{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Sequence"},{".class":"NoneType"}],"uses_pep604_syntax":true},"builtins.bool","builtins.bool","builtins.str",{".class":"UnionType","items":["configparser.Interpolation",{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeAliasType","args":[],"type_ref":"configparser._ConvertersMap"},"builtins.bool"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of RawConfigParser","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"configparser.RawConfigParser.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0,1,1,1,5,5,5,5,5,5,5,5,5],"arg_names":["self","defaults","dict_type","allow_no_value","delimiters","comment_prefixes","inline_comment_prefixes","strict","empty_lines_in_values","default_section","interpolation","converters","allow_unnamed_section"],"arg_types":["configparser.RawConfigParser",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeType","item":{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"typing.Mapping"}},"builtins.bool",{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Sequence"},{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Sequence"},{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Sequence"},{".class":"NoneType"}],"uses_pep604_syntax":true},"builtins.bool","builtins.bool","builtins.str",{".class":"UnionType","items":["configparser.Interpolation",{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeAliasType","args":[],"type_ref":"configparser._ConvertersMap"},"builtins.bool"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of RawConfigParser","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}],"type":{".class":"Overloaded","items":[{".class":"CallableType","arg_kinds":[0,1,1,3,5,5,5,5,5,5,5,5,5],"arg_names":["self","defaults","dict_type","allow_no_value","delimiters","comment_prefixes","inline_comment_prefixes","strict","empty_lines_in_values","default_section","interpolation","converters","allow_unnamed_section"],"arg_types":["configparser.RawConfigParser",{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str",{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}],"extra_attrs":null,"type_ref":"typing.Mapping"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeType","item":{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"typing.Mapping"}},{".class":"LiteralType","fallback":"builtins.bool","value":true},{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Sequence"},{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Sequence"},{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Sequence"},{".class":"NoneType"}],"uses_pep604_syntax":true},"builtins.bool","builtins.bool","builtins.str",{".class":"UnionType","items":["configparser.Interpolation",{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeAliasType","args":[],"type_ref":"configparser._ConvertersMap"},"builtins.bool"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of RawConfigParser","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"CallableType","arg_kinds":[0,0,0,0,5,5,5,5,5,5,5,5,5],"arg_names":["self","defaults","dict_type","allow_no_value","delimiters","comment_prefixes","inline_comment_prefixes","strict","empty_lines_in_values","default_section","interpolation","converters","allow_unnamed_section"],"arg_types":["configparser.RawConfigParser",{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str",{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}],"extra_attrs":null,"type_ref":"typing.Mapping"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeType","item":{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"typing.Mapping"}},{".class":"LiteralType","fallback":"builtins.bool","value":true},{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Sequence"},{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Sequence"},{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Sequence"},{".class":"NoneType"}],"uses_pep604_syntax":true},"builtins.bool","builtins.bool","builtins.str",{".class":"UnionType","items":["configparser.Interpolation",{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeAliasType","args":[],"type_ref":"configparser._ConvertersMap"},"builtins.bool"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of RawConfigParser","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"CallableType","arg_kinds":[0,1,1,1,5,5,5,5,5,5,5,5,5],"arg_names":["self","defaults","dict_type","allow_no_value","delimiters","comment_prefixes","inline_comment_prefixes","strict","empty_lines_in_values","default_section","interpolation","converters","allow_unnamed_section"],"arg_types":["configparser.RawConfigParser",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeType","item":{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"typing.Mapping"}},"builtins.bool",{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Sequence"},{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Sequence"},{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Sequence"},{".class":"NoneType"}],"uses_pep604_syntax":true},"builtins.bool","builtins.bool","builtins.str",{".class":"UnionType","items":["configparser.Interpolation",{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeAliasType","args":[],"type_ref":"configparser._ConvertersMap"},"builtins.bool"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of RawConfigParser","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}]}}},"__iter__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":[null],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.RawConfigParser.__iter__","name":"__iter__","type":{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["configparser.RawConfigParser"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__iter__ of RawConfigParser","ret_type":{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Iterator"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"__len__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":[null],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.RawConfigParser.__len__","name":"__len__","type":{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["configparser.RawConfigParser"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__len__ of RawConfigParser","ret_type":"builtins.int","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"__setitem__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":[null,null,null],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.RawConfigParser.__setitem__","name":"__setitem__","type":{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":[null,null,null],"arg_types":["configparser.RawConfigParser","builtins.str",{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__setitem__ of RawConfigParser","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_get_conv":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,0,5,5,5],"arg_names":["self","section","option","conv","raw","vars","fallback"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.RawConfigParser._get_conv","name":"_get_conv","type":{".class":"CallableType","arg_kinds":[0,0,0,0,5,5,5],"arg_names":["self","section","option","conv","raw","vars","fallback"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.str",{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["builtins.str"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser._get_conv","upper_bound":"builtins.object","values":[],"variance":0},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},"builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser._get_conv","upper_bound":"builtins.object","values":[],"variance":0}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_get_conv of RawConfigParser","ret_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser._get_conv","upper_bound":"builtins.object","values":[],"variance":0},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser._get_conv","upper_bound":"builtins.object","values":[],"variance":0}]}}},"add_section":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","section"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.RawConfigParser.add_section","name":"add_section","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","section"],"arg_types":["configparser.RawConfigParser","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"add_section of RawConfigParser","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"converters":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_property","is_decorated"],"fullname":"configparser.RawConfigParser.converters","name":"converters","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["configparser.RawConfigParser"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"converters of RawConfigParser","ret_type":"configparser.ConverterMapping","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":false,"var":{".class":"Var","flags":["is_initialized_in_class","is_property","is_ready","is_inferred"],"fullname":"configparser.RawConfigParser.converters","name":"converters","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["configparser.RawConfigParser"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"converters of RawConfigParser","ret_type":"configparser.ConverterMapping","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"default_section":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready"],"fullname":"configparser.RawConfigParser.default_section","name":"default_section","type":"builtins.str"}},"defaults":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.RawConfigParser.defaults","name":"defaults","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["configparser.RawConfigParser"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"defaults of RawConfigParser","ret_type":{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"OverloadedFuncDef","deprecated":null,"flags":[],"fullname":"configparser.RawConfigParser.get","impl":null,"items":[{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,5,5],"arg_names":["self","section","option","raw","vars"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated"],"fullname":"configparser.RawConfigParser.get","name":"get","type":{".class":"CallableType","arg_kinds":[0,0,0,5,5],"arg_names":["self","section","option","raw","vars"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get of RawConfigParser","ret_type":{".class":"UnionType","items":["builtins.str",{".class":"TypeAliasType","args":[],"type_ref":"_typeshed.MaybeNone"}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"configparser.RawConfigParser.get","name":"get","type":{".class":"CallableType","arg_kinds":[0,0,0,5,5],"arg_names":["self","section","option","raw","vars"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get of RawConfigParser","ret_type":{".class":"UnionType","items":["builtins.str",{".class":"TypeAliasType","args":[],"type_ref":"_typeshed.MaybeNone"}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,5,5,3],"arg_names":["self","section","option","raw","vars","fallback"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated"],"fullname":"configparser.RawConfigParser.get","name":"get","type":{".class":"CallableType","arg_kinds":[0,0,0,5,5,3],"arg_names":["self","section","option","raw","vars","fallback"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.get","upper_bound":"builtins.object","values":[],"variance":0}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get of RawConfigParser","ret_type":{".class":"UnionType","items":["builtins.str",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.get","upper_bound":"builtins.object","values":[],"variance":0},{".class":"TypeAliasType","args":[],"type_ref":"_typeshed.MaybeNone"}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.get","upper_bound":"builtins.object","values":[],"variance":0}]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"configparser.RawConfigParser.get","name":"get","type":{".class":"CallableType","arg_kinds":[0,0,0,5,5,3],"arg_names":["self","section","option","raw","vars","fallback"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.get","upper_bound":"builtins.object","values":[],"variance":0}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get of RawConfigParser","ret_type":{".class":"UnionType","items":["builtins.str",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.get","upper_bound":"builtins.object","values":[],"variance":0},{".class":"TypeAliasType","args":[],"type_ref":"_typeshed.MaybeNone"}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.get","upper_bound":"builtins.object","values":[],"variance":0}]}}}],"type":{".class":"Overloaded","items":[{".class":"CallableType","arg_kinds":[0,0,0,5,5],"arg_names":["self","section","option","raw","vars"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get of RawConfigParser","ret_type":{".class":"UnionType","items":["builtins.str",{".class":"TypeAliasType","args":[],"type_ref":"_typeshed.MaybeNone"}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"CallableType","arg_kinds":[0,0,0,5,5,3],"arg_names":["self","section","option","raw","vars","fallback"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.get","upper_bound":"builtins.object","values":[],"variance":0}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get of RawConfigParser","ret_type":{".class":"UnionType","items":["builtins.str",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.get","upper_bound":"builtins.object","values":[],"variance":0},{".class":"TypeAliasType","args":[],"type_ref":"_typeshed.MaybeNone"}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.get","upper_bound":"builtins.object","values":[],"variance":0}]}]}}},"getboolean":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"OverloadedFuncDef","deprecated":null,"flags":[],"fullname":"configparser.RawConfigParser.getboolean","impl":null,"items":[{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,5,5],"arg_names":["self","section","option","raw","vars"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated"],"fullname":"configparser.RawConfigParser.getboolean","name":"getboolean","type":{".class":"CallableType","arg_kinds":[0,0,0,5,5],"arg_names":["self","section","option","raw","vars"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getboolean of RawConfigParser","ret_type":"builtins.bool","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"configparser.RawConfigParser.getboolean","name":"getboolean","type":{".class":"CallableType","arg_kinds":[0,0,0,5,5],"arg_names":["self","section","option","raw","vars"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getboolean of RawConfigParser","ret_type":"builtins.bool","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,5,5,5],"arg_names":["self","section","option","raw","vars","fallback"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated"],"fullname":"configparser.RawConfigParser.getboolean","name":"getboolean","type":{".class":"CallableType","arg_kinds":[0,0,0,5,5,5],"arg_names":["self","section","option","raw","vars","fallback"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.getboolean","upper_bound":"builtins.object","values":[],"variance":0}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getboolean of RawConfigParser","ret_type":{".class":"UnionType","items":["builtins.bool",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.getboolean","upper_bound":"builtins.object","values":[],"variance":0}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.getboolean","upper_bound":"builtins.object","values":[],"variance":0}]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"configparser.RawConfigParser.getboolean","name":"getboolean","type":{".class":"CallableType","arg_kinds":[0,0,0,5,5,5],"arg_names":["self","section","option","raw","vars","fallback"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.getboolean","upper_bound":"builtins.object","values":[],"variance":0}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getboolean of RawConfigParser","ret_type":{".class":"UnionType","items":["builtins.bool",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.getboolean","upper_bound":"builtins.object","values":[],"variance":0}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.getboolean","upper_bound":"builtins.object","values":[],"variance":0}]}}}],"type":{".class":"Overloaded","items":[{".class":"CallableType","arg_kinds":[0,0,0,5,5],"arg_names":["self","section","option","raw","vars"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getboolean of RawConfigParser","ret_type":"builtins.bool","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"CallableType","arg_kinds":[0,0,0,5,5,5],"arg_names":["self","section","option","raw","vars","fallback"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.getboolean","upper_bound":"builtins.object","values":[],"variance":0}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getboolean of RawConfigParser","ret_type":{".class":"UnionType","items":["builtins.bool",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.getboolean","upper_bound":"builtins.object","values":[],"variance":0}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.getboolean","upper_bound":"builtins.object","values":[],"variance":0}]}]}}},"getfloat":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"OverloadedFuncDef","deprecated":null,"flags":[],"fullname":"configparser.RawConfigParser.getfloat","impl":null,"items":[{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,5,5],"arg_names":["self","section","option","raw","vars"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated"],"fullname":"configparser.RawConfigParser.getfloat","name":"getfloat","type":{".class":"CallableType","arg_kinds":[0,0,0,5,5],"arg_names":["self","section","option","raw","vars"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getfloat of RawConfigParser","ret_type":"builtins.float","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"configparser.RawConfigParser.getfloat","name":"getfloat","type":{".class":"CallableType","arg_kinds":[0,0,0,5,5],"arg_names":["self","section","option","raw","vars"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getfloat of RawConfigParser","ret_type":"builtins.float","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,5,5,5],"arg_names":["self","section","option","raw","vars","fallback"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated"],"fullname":"configparser.RawConfigParser.getfloat","name":"getfloat","type":{".class":"CallableType","arg_kinds":[0,0,0,5,5,5],"arg_names":["self","section","option","raw","vars","fallback"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.getfloat","upper_bound":"builtins.object","values":[],"variance":0}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getfloat of RawConfigParser","ret_type":{".class":"UnionType","items":["builtins.float",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.getfloat","upper_bound":"builtins.object","values":[],"variance":0}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.getfloat","upper_bound":"builtins.object","values":[],"variance":0}]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"configparser.RawConfigParser.getfloat","name":"getfloat","type":{".class":"CallableType","arg_kinds":[0,0,0,5,5,5],"arg_names":["self","section","option","raw","vars","fallback"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.getfloat","upper_bound":"builtins.object","values":[],"variance":0}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getfloat of RawConfigParser","ret_type":{".class":"UnionType","items":["builtins.float",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.getfloat","upper_bound":"builtins.object","values":[],"variance":0}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.getfloat","upper_bound":"builtins.object","values":[],"variance":0}]}}}],"type":{".class":"Overloaded","items":[{".class":"CallableType","arg_kinds":[0,0,0,5,5],"arg_names":["self","section","option","raw","vars"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getfloat of RawConfigParser","ret_type":"builtins.float","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"CallableType","arg_kinds":[0,0,0,5,5,5],"arg_names":["self","section","option","raw","vars","fallback"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.getfloat","upper_bound":"builtins.object","values":[],"variance":0}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getfloat of RawConfigParser","ret_type":{".class":"UnionType","items":["builtins.float",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.getfloat","upper_bound":"builtins.object","values":[],"variance":0}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.getfloat","upper_bound":"builtins.object","values":[],"variance":0}]}]}}},"getint":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"OverloadedFuncDef","deprecated":null,"flags":[],"fullname":"configparser.RawConfigParser.getint","impl":null,"items":[{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,5,5],"arg_names":["self","section","option","raw","vars"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated"],"fullname":"configparser.RawConfigParser.getint","name":"getint","type":{".class":"CallableType","arg_kinds":[0,0,0,5,5],"arg_names":["self","section","option","raw","vars"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getint of RawConfigParser","ret_type":"builtins.int","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"configparser.RawConfigParser.getint","name":"getint","type":{".class":"CallableType","arg_kinds":[0,0,0,5,5],"arg_names":["self","section","option","raw","vars"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getint of RawConfigParser","ret_type":"builtins.int","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,5,5,5],"arg_names":["self","section","option","raw","vars","fallback"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated"],"fullname":"configparser.RawConfigParser.getint","name":"getint","type":{".class":"CallableType","arg_kinds":[0,0,0,5,5,5],"arg_names":["self","section","option","raw","vars","fallback"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.getint","upper_bound":"builtins.object","values":[],"variance":0}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getint of RawConfigParser","ret_type":{".class":"UnionType","items":["builtins.int",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.getint","upper_bound":"builtins.object","values":[],"variance":0}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.getint","upper_bound":"builtins.object","values":[],"variance":0}]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"configparser.RawConfigParser.getint","name":"getint","type":{".class":"CallableType","arg_kinds":[0,0,0,5,5,5],"arg_names":["self","section","option","raw","vars","fallback"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.getint","upper_bound":"builtins.object","values":[],"variance":0}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getint of RawConfigParser","ret_type":{".class":"UnionType","items":["builtins.int",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.getint","upper_bound":"builtins.object","values":[],"variance":0}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.getint","upper_bound":"builtins.object","values":[],"variance":0}]}}}],"type":{".class":"Overloaded","items":[{".class":"CallableType","arg_kinds":[0,0,0,5,5],"arg_names":["self","section","option","raw","vars"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getint of RawConfigParser","ret_type":"builtins.int","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"CallableType","arg_kinds":[0,0,0,5,5,5],"arg_names":["self","section","option","raw","vars","fallback"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.getint","upper_bound":"builtins.object","values":[],"variance":0}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getint of RawConfigParser","ret_type":{".class":"UnionType","items":["builtins.int",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.getint","upper_bound":"builtins.object","values":[],"variance":0}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.RawConfigParser.getint","upper_bound":"builtins.object","values":[],"variance":0}]}]}}},"has_option":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":["self","section","option"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.RawConfigParser.has_option","name":"has_option","type":{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":["self","section","option"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"has_option of RawConfigParser","ret_type":"builtins.bool","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"has_section":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","section"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.RawConfigParser.has_section","name":"has_section","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","section"],"arg_types":["configparser.RawConfigParser","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"has_section of RawConfigParser","ret_type":"builtins.bool","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"items":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"OverloadedFuncDef","deprecated":null,"flags":[],"fullname":"configparser.RawConfigParser.items","impl":null,"items":[{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,5,5],"arg_names":["self","raw","vars"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated"],"fullname":"configparser.RawConfigParser.items","name":"items","type":{".class":"CallableType","arg_kinds":[0,5,5],"arg_names":["self","raw","vars"],"arg_types":["configparser.RawConfigParser","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"items of RawConfigParser","ret_type":{".class":"Instance","args":["builtins.str","configparser.SectionProxy"],"extra_attrs":null,"type_ref":"typing.ItemsView"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"configparser.RawConfigParser.items","name":"items","type":{".class":"CallableType","arg_kinds":[0,5,5],"arg_names":["self","raw","vars"],"arg_types":["configparser.RawConfigParser","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"items of RawConfigParser","ret_type":{".class":"Instance","args":["builtins.str","configparser.SectionProxy"],"extra_attrs":null,"type_ref":"typing.ItemsView"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,1,1],"arg_names":["self","section","raw","vars"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated"],"fullname":"configparser.RawConfigParser.items","name":"items","type":{".class":"CallableType","arg_kinds":[0,0,1,1],"arg_names":["self","section","raw","vars"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"items of RawConfigParser","ret_type":{".class":"Instance","args":[{".class":"TupleType","implicit":false,"items":["builtins.str","builtins.str"],"partial_fallback":{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.tuple"}}],"extra_attrs":null,"type_ref":"builtins.list"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"configparser.RawConfigParser.items","name":"items","type":{".class":"CallableType","arg_kinds":[0,0,1,1],"arg_names":["self","section","raw","vars"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"items of RawConfigParser","ret_type":{".class":"Instance","args":[{".class":"TupleType","implicit":false,"items":["builtins.str","builtins.str"],"partial_fallback":{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.tuple"}}],"extra_attrs":null,"type_ref":"builtins.list"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}],"type":{".class":"Overloaded","items":[{".class":"CallableType","arg_kinds":[0,5,5],"arg_names":["self","raw","vars"],"arg_types":["configparser.RawConfigParser","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"items of RawConfigParser","ret_type":{".class":"Instance","args":["builtins.str","configparser.SectionProxy"],"extra_attrs":null,"type_ref":"typing.ItemsView"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"CallableType","arg_kinds":[0,0,1,1],"arg_names":["self","section","raw","vars"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"items of RawConfigParser","ret_type":{".class":"Instance","args":[{".class":"TupleType","implicit":false,"items":["builtins.str","builtins.str"],"partial_fallback":{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.tuple"}}],"extra_attrs":null,"type_ref":"builtins.list"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}]}}},"options":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","section"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.RawConfigParser.options","name":"options","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","section"],"arg_types":["configparser.RawConfigParser","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"options of RawConfigParser","ret_type":{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"builtins.list"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"optionxform":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","optionstr"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.RawConfigParser.optionxform","name":"optionxform","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","optionstr"],"arg_types":["configparser.RawConfigParser","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"optionxform of RawConfigParser","ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"read":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,1],"arg_names":["self","filenames","encoding"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.RawConfigParser.read","name":"read","type":{".class":"CallableType","arg_kinds":[0,0,1],"arg_names":["self","filenames","encoding"],"arg_types":["configparser.RawConfigParser",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"_typeshed.StrOrBytesPath"},{".class":"Instance","args":[{".class":"TypeAliasType","args":[],"type_ref":"_typeshed.StrOrBytesPath"}],"extra_attrs":null,"type_ref":"typing.Iterable"}],"uses_pep604_syntax":true},{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"read of RawConfigParser","ret_type":{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"builtins.list"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"read_dict":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,1],"arg_names":["self","dictionary","source"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.RawConfigParser.read_dict","name":"read_dict","type":{".class":"CallableType","arg_kinds":[0,0,1],"arg_names":["self","dictionary","source"],"arg_types":["configparser.RawConfigParser",{".class":"Instance","args":["builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"typing.Mapping"}],"extra_attrs":null,"type_ref":"typing.Mapping"},"builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"read_dict of RawConfigParser","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"read_file":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,1],"arg_names":["self","f","source"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.RawConfigParser.read_file","name":"read_file","type":{".class":"CallableType","arg_kinds":[0,0,1],"arg_names":["self","f","source"],"arg_types":["configparser.RawConfigParser",{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Iterable"},{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"read_file of RawConfigParser","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"read_string":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,1],"arg_names":["self","string","source"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.RawConfigParser.read_string","name":"read_string","type":{".class":"CallableType","arg_kinds":[0,0,1],"arg_names":["self","string","source"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"read_string of RawConfigParser","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"remove_option":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":["self","section","option"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.RawConfigParser.remove_option","name":"remove_option","type":{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":["self","section","option"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"remove_option of RawConfigParser","ret_type":"builtins.bool","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"remove_section":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","section"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.RawConfigParser.remove_section","name":"remove_section","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","section"],"arg_types":["configparser.RawConfigParser","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"remove_section of RawConfigParser","ret_type":"builtins.bool","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"sections":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.RawConfigParser.sections","name":"sections","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["configparser.RawConfigParser"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"sections of RawConfigParser","ret_type":{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"builtins.list"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"set":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,1],"arg_names":["self","section","option","value"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.RawConfigParser.set","name":"set","type":{".class":"CallableType","arg_kinds":[0,0,0,1],"arg_names":["self","section","option","value"],"arg_types":["configparser.RawConfigParser","builtins.str","builtins.str",{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"set of RawConfigParser","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"write":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,1],"arg_names":["self","fp","space_around_delimiters"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.RawConfigParser.write","name":"write","type":{".class":"CallableType","arg_kinds":[0,0,1],"arg_names":["self","fp","space_around_delimiters"],"arg_types":["configparser.RawConfigParser",{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"_typeshed.SupportsWrite"},"builtins.bool"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"write of RawConfigParser","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser.RawConfigParser.Self","id":0,"name":"Self","namespace":"","upper_bound":"configparser.RawConfigParser","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"SectionProxy":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":[{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"typing.MutableMapping"}],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"configparser.SectionProxy","name":"SectionProxy","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"configparser.SectionProxy","has_param_spec_type":false,"metaclass_type":"abc.ABCMeta","metadata":{},"module_name":"configparser","mro":["configparser.SectionProxy","typing.MutableMapping","typing.Mapping","typing.Collection","typing.Iterable","typing.Container","builtins.object"],"names":{".class":"SymbolTable","__contains__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":[null,null],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.SectionProxy.__contains__","name":"__contains__","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":["configparser.SectionProxy","builtins.object"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__contains__ of SectionProxy","ret_type":"builtins.bool","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"__delitem__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":[null,null],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.SectionProxy.__delitem__","name":"__delitem__","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":["configparser.SectionProxy","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__delitem__ of SectionProxy","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"__getattr__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":[null,null],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.SectionProxy.__getattr__","name":"__getattr__","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":["configparser.SectionProxy","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__getattr__ of SectionProxy","ret_type":{".class":"CallableType","arg_kinds":[2,4],"arg_names":[null,null],"arg_types":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":true,"name":null,"ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"__getitem__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":[null,null],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.SectionProxy.__getitem__","name":"__getitem__","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":["configparser.SectionProxy","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__getitem__ of SectionProxy","ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"__init__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":["self","parser","name"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.SectionProxy.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":["self","parser","name"],"arg_types":["configparser.SectionProxy","configparser.RawConfigParser","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of SectionProxy","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"__iter__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":[null],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.SectionProxy.__iter__","name":"__iter__","type":{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["configparser.SectionProxy"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__iter__ of SectionProxy","ret_type":{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Iterator"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"__len__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":[null],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.SectionProxy.__len__","name":"__len__","type":{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["configparser.SectionProxy"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__len__ of SectionProxy","ret_type":"builtins.int","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"__setitem__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":[null,null,null],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"configparser.SectionProxy.__setitem__","name":"__setitem__","type":{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":[null,null,null],"arg_types":["configparser.SectionProxy","builtins.str","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__setitem__ of SectionProxy","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"OverloadedFuncDef","deprecated":null,"flags":[],"fullname":"configparser.SectionProxy.get","impl":null,"items":[{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,5,5,5,4],"arg_names":["self","option","raw","vars","_impl","kwargs"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated"],"fullname":"configparser.SectionProxy.get","name":"get","type":{".class":"CallableType","arg_kinds":[0,0,5,5,5,4],"arg_names":["self","option","raw","vars","_impl","kwargs"],"arg_types":["configparser.SectionProxy","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"UnionType","items":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get of SectionProxy","ret_type":{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"configparser.SectionProxy.get","name":"get","type":{".class":"CallableType","arg_kinds":[0,0,5,5,5,4],"arg_names":["self","option","raw","vars","_impl","kwargs"],"arg_types":["configparser.SectionProxy","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"UnionType","items":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get of SectionProxy","ret_type":{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,5,5,5,4],"arg_names":["self","option","fallback","raw","vars","_impl","kwargs"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated"],"fullname":"configparser.SectionProxy.get","name":"get","type":{".class":"CallableType","arg_kinds":[0,0,0,5,5,5,4],"arg_names":["self","option","fallback","raw","vars","_impl","kwargs"],"arg_types":["configparser.SectionProxy","builtins.str",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.get","upper_bound":"builtins.object","values":[],"variance":0},"builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"UnionType","items":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get of SectionProxy","ret_type":{".class":"UnionType","items":["builtins.str",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.get","upper_bound":"builtins.object","values":[],"variance":0}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.get","upper_bound":"builtins.object","values":[],"variance":0}]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"configparser.SectionProxy.get","name":"get","type":{".class":"CallableType","arg_kinds":[0,0,0,5,5,5,4],"arg_names":["self","option","fallback","raw","vars","_impl","kwargs"],"arg_types":["configparser.SectionProxy","builtins.str",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.get","upper_bound":"builtins.object","values":[],"variance":0},"builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"UnionType","items":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get of SectionProxy","ret_type":{".class":"UnionType","items":["builtins.str",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.get","upper_bound":"builtins.object","values":[],"variance":0}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.get","upper_bound":"builtins.object","values":[],"variance":0}]}}}],"type":{".class":"Overloaded","items":[{".class":"CallableType","arg_kinds":[0,0,5,5,5,4],"arg_names":["self","option","raw","vars","_impl","kwargs"],"arg_types":["configparser.SectionProxy","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"UnionType","items":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get of SectionProxy","ret_type":{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"CallableType","arg_kinds":[0,0,0,5,5,5,4],"arg_names":["self","option","fallback","raw","vars","_impl","kwargs"],"arg_types":["configparser.SectionProxy","builtins.str",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.get","upper_bound":"builtins.object","values":[],"variance":0},"builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"UnionType","items":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get of SectionProxy","ret_type":{".class":"UnionType","items":["builtins.str",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.get","upper_bound":"builtins.object","values":[],"variance":0}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.get","upper_bound":"builtins.object","values":[],"variance":0}]}]}}},"getboolean":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"OverloadedFuncDef","deprecated":null,"flags":[],"fullname":"configparser.SectionProxy.getboolean","impl":null,"items":[{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,5,5],"arg_names":["self","option","raw","vars"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated"],"fullname":"configparser.SectionProxy.getboolean","name":"getboolean","type":{".class":"CallableType","arg_kinds":[0,0,5,5],"arg_names":["self","option","raw","vars"],"arg_types":["configparser.SectionProxy","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getboolean of SectionProxy","ret_type":{".class":"UnionType","items":["builtins.bool",{".class":"NoneType"}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"configparser.SectionProxy.getboolean","name":"getboolean","type":{".class":"CallableType","arg_kinds":[0,0,5,5],"arg_names":["self","option","raw","vars"],"arg_types":["configparser.SectionProxy","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getboolean of SectionProxy","ret_type":{".class":"UnionType","items":["builtins.bool",{".class":"NoneType"}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,1,5,5],"arg_names":["self","option","fallback","raw","vars"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated"],"fullname":"configparser.SectionProxy.getboolean","name":"getboolean","type":{".class":"CallableType","arg_kinds":[0,0,1,5,5],"arg_names":["self","option","fallback","raw","vars"],"arg_types":["configparser.SectionProxy","builtins.str",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.getboolean","upper_bound":"builtins.object","values":[],"variance":0},"builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getboolean of SectionProxy","ret_type":{".class":"UnionType","items":["builtins.bool",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.getboolean","upper_bound":"builtins.object","values":[],"variance":0}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.getboolean","upper_bound":"builtins.object","values":[],"variance":0}]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"configparser.SectionProxy.getboolean","name":"getboolean","type":{".class":"CallableType","arg_kinds":[0,0,1,5,5],"arg_names":["self","option","fallback","raw","vars"],"arg_types":["configparser.SectionProxy","builtins.str",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.getboolean","upper_bound":"builtins.object","values":[],"variance":0},"builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getboolean of SectionProxy","ret_type":{".class":"UnionType","items":["builtins.bool",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.getboolean","upper_bound":"builtins.object","values":[],"variance":0}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.getboolean","upper_bound":"builtins.object","values":[],"variance":0}]}}}],"type":{".class":"Overloaded","items":[{".class":"CallableType","arg_kinds":[0,0,5,5],"arg_names":["self","option","raw","vars"],"arg_types":["configparser.SectionProxy","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getboolean of SectionProxy","ret_type":{".class":"UnionType","items":["builtins.bool",{".class":"NoneType"}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"CallableType","arg_kinds":[0,0,1,5,5],"arg_names":["self","option","fallback","raw","vars"],"arg_types":["configparser.SectionProxy","builtins.str",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.getboolean","upper_bound":"builtins.object","values":[],"variance":0},"builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getboolean of SectionProxy","ret_type":{".class":"UnionType","items":["builtins.bool",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.getboolean","upper_bound":"builtins.object","values":[],"variance":0}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.getboolean","upper_bound":"builtins.object","values":[],"variance":0}]}]}}},"getfloat":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"OverloadedFuncDef","deprecated":null,"flags":[],"fullname":"configparser.SectionProxy.getfloat","impl":null,"items":[{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,5,5],"arg_names":["self","option","raw","vars"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated"],"fullname":"configparser.SectionProxy.getfloat","name":"getfloat","type":{".class":"CallableType","arg_kinds":[0,0,5,5],"arg_names":["self","option","raw","vars"],"arg_types":["configparser.SectionProxy","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getfloat of SectionProxy","ret_type":{".class":"UnionType","items":["builtins.float",{".class":"NoneType"}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"configparser.SectionProxy.getfloat","name":"getfloat","type":{".class":"CallableType","arg_kinds":[0,0,5,5],"arg_names":["self","option","raw","vars"],"arg_types":["configparser.SectionProxy","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getfloat of SectionProxy","ret_type":{".class":"UnionType","items":["builtins.float",{".class":"NoneType"}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,1,5,5],"arg_names":["self","option","fallback","raw","vars"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated"],"fullname":"configparser.SectionProxy.getfloat","name":"getfloat","type":{".class":"CallableType","arg_kinds":[0,0,1,5,5],"arg_names":["self","option","fallback","raw","vars"],"arg_types":["configparser.SectionProxy","builtins.str",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.getfloat","upper_bound":"builtins.object","values":[],"variance":0},"builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getfloat of SectionProxy","ret_type":{".class":"UnionType","items":["builtins.float",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.getfloat","upper_bound":"builtins.object","values":[],"variance":0}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.getfloat","upper_bound":"builtins.object","values":[],"variance":0}]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"configparser.SectionProxy.getfloat","name":"getfloat","type":{".class":"CallableType","arg_kinds":[0,0,1,5,5],"arg_names":["self","option","fallback","raw","vars"],"arg_types":["configparser.SectionProxy","builtins.str",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.getfloat","upper_bound":"builtins.object","values":[],"variance":0},"builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getfloat of SectionProxy","ret_type":{".class":"UnionType","items":["builtins.float",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.getfloat","upper_bound":"builtins.object","values":[],"variance":0}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.getfloat","upper_bound":"builtins.object","values":[],"variance":0}]}}}],"type":{".class":"Overloaded","items":[{".class":"CallableType","arg_kinds":[0,0,5,5],"arg_names":["self","option","raw","vars"],"arg_types":["configparser.SectionProxy","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getfloat of SectionProxy","ret_type":{".class":"UnionType","items":["builtins.float",{".class":"NoneType"}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"CallableType","arg_kinds":[0,0,1,5,5],"arg_names":["self","option","fallback","raw","vars"],"arg_types":["configparser.SectionProxy","builtins.str",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.getfloat","upper_bound":"builtins.object","values":[],"variance":0},"builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getfloat of SectionProxy","ret_type":{".class":"UnionType","items":["builtins.float",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.getfloat","upper_bound":"builtins.object","values":[],"variance":0}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.getfloat","upper_bound":"builtins.object","values":[],"variance":0}]}]}}},"getint":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"OverloadedFuncDef","deprecated":null,"flags":[],"fullname":"configparser.SectionProxy.getint","impl":null,"items":[{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,5,5],"arg_names":["self","option","raw","vars"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated"],"fullname":"configparser.SectionProxy.getint","name":"getint","type":{".class":"CallableType","arg_kinds":[0,0,5,5],"arg_names":["self","option","raw","vars"],"arg_types":["configparser.SectionProxy","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getint of SectionProxy","ret_type":{".class":"UnionType","items":["builtins.int",{".class":"NoneType"}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"configparser.SectionProxy.getint","name":"getint","type":{".class":"CallableType","arg_kinds":[0,0,5,5],"arg_names":["self","option","raw","vars"],"arg_types":["configparser.SectionProxy","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getint of SectionProxy","ret_type":{".class":"UnionType","items":["builtins.int",{".class":"NoneType"}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,1,5,5],"arg_names":["self","option","fallback","raw","vars"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated"],"fullname":"configparser.SectionProxy.getint","name":"getint","type":{".class":"CallableType","arg_kinds":[0,0,1,5,5],"arg_names":["self","option","fallback","raw","vars"],"arg_types":["configparser.SectionProxy","builtins.str",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.getint","upper_bound":"builtins.object","values":[],"variance":0},"builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getint of SectionProxy","ret_type":{".class":"UnionType","items":["builtins.int",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.getint","upper_bound":"builtins.object","values":[],"variance":0}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.getint","upper_bound":"builtins.object","values":[],"variance":0}]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"configparser.SectionProxy.getint","name":"getint","type":{".class":"CallableType","arg_kinds":[0,0,1,5,5],"arg_names":["self","option","fallback","raw","vars"],"arg_types":["configparser.SectionProxy","builtins.str",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.getint","upper_bound":"builtins.object","values":[],"variance":0},"builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getint of SectionProxy","ret_type":{".class":"UnionType","items":["builtins.int",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.getint","upper_bound":"builtins.object","values":[],"variance":0}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.getint","upper_bound":"builtins.object","values":[],"variance":0}]}}}],"type":{".class":"Overloaded","items":[{".class":"CallableType","arg_kinds":[0,0,5,5],"arg_names":["self","option","raw","vars"],"arg_types":["configparser.SectionProxy","builtins.str","builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getint of SectionProxy","ret_type":{".class":"UnionType","items":["builtins.int",{".class":"NoneType"}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"CallableType","arg_kinds":[0,0,1,5,5],"arg_names":["self","option","fallback","raw","vars"],"arg_types":["configparser.SectionProxy","builtins.str",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.getint","upper_bound":"builtins.object","values":[],"variance":0},"builtins.bool",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"getint of SectionProxy","ret_type":{".class":"UnionType","items":["builtins.int",{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.getint","upper_bound":"builtins.object","values":[],"variance":0}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","id":-1,"name":"_T","namespace":"configparser.SectionProxy.getint","upper_bound":"builtins.object","values":[],"variance":0}]}]}}},"name":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_property","is_decorated"],"fullname":"configparser.SectionProxy.name","name":"name","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["configparser.SectionProxy"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"name of SectionProxy","ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":false,"var":{".class":"Var","flags":["is_initialized_in_class","is_property","is_ready","is_inferred"],"fullname":"configparser.SectionProxy.name","name":"name","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["configparser.SectionProxy"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"name of SectionProxy","ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"parser":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_property","is_decorated"],"fullname":"configparser.SectionProxy.parser","name":"parser","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["configparser.SectionProxy"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"parser of SectionProxy","ret_type":"configparser.RawConfigParser","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":false,"var":{".class":"Var","flags":["is_initialized_in_class","is_property","is_ready","is_inferred"],"fullname":"configparser.SectionProxy.parser","name":"parser","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["configparser.SectionProxy"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"parser of SectionProxy","ret_type":"configparser.RawConfigParser","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser.SectionProxy.Self","id":0,"name":"Self","namespace":"","upper_bound":"configparser.SectionProxy","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"Sequence":{".class":"SymbolTableNode","cross_ref":"typing.Sequence","kind":"Gdef","module_hidden":true,"module_public":false},"StrOrBytesPath":{".class":"SymbolTableNode","cross_ref":"_typeshed.StrOrBytesPath","kind":"Gdef","module_hidden":true,"module_public":false},"SupportsWrite":{".class":"SymbolTableNode","cross_ref":"_typeshed.SupportsWrite","kind":"Gdef","module_hidden":true,"module_public":false},"TypeAlias":{".class":"SymbolTableNode","cross_ref":"typing.TypeAlias","kind":"Gdef","module_hidden":true,"module_public":false},"TypeVar":{".class":"SymbolTableNode","cross_ref":"typing.TypeVar","kind":"Gdef","module_hidden":true,"module_public":false},"UNNAMED_SECTION":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"configparser.UNNAMED_SECTION","name":"UNNAMED_SECTION","type":"configparser._UNNAMED_SECTION"}},"_ConverterCallback":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"TypeAlias","alias_tvars":[],"column":0,"fullname":"configparser._ConverterCallback","line":82,"no_args":false,"normalized":false,"python_3_12_type_alias":false,"target":{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["builtins.str"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_ConvertersMap":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"TypeAlias","alias_tvars":[],"column":0,"fullname":"configparser._ConvertersMap","line":83,"no_args":false,"normalized":false,"python_3_12_type_alias":false,"target":{".class":"Instance","args":["builtins.str",{".class":"TypeAliasType","args":[],"type_ref":"configparser._ConverterCallback"}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"_Parser":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"TypeAlias","alias_tvars":[],"column":0,"fullname":"configparser._Parser","line":81,"no_args":false,"normalized":false,"python_3_12_type_alias":false,"target":{".class":"Instance","args":["builtins.str",{".class":"TypeAliasType","args":[],"type_ref":"configparser._Section"}],"extra_attrs":null,"type_ref":"typing.MutableMapping"}}},"_Section":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"TypeAlias","alias_tvars":[],"column":0,"fullname":"configparser._Section","line":80,"no_args":false,"normalized":false,"python_3_12_type_alias":false,"target":{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"typing.Mapping"}}},"_T":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"TypeVarExpr","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._T","name":"_T","upper_bound":"builtins.object","values":[],"variance":0}},"_UNNAMED_SECTION":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["builtins.object"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"configparser._UNNAMED_SECTION","name":"_UNNAMED_SECTION","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"configparser._UNNAMED_SECTION","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"configparser","mro":["configparser._UNNAMED_SECTION","builtins.object"],"names":{".class":"SymbolTable"},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"configparser._UNNAMED_SECTION.Self","id":0,"name":"Self","namespace":"","upper_bound":"configparser._UNNAMED_SECTION","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"__all__":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"Var","flags":["is_inferred","has_explicit_value"],"fullname":"configparser.__all__","name":"__all__","type":{".class":"TupleType","implicit":false,"items":["builtins.str","builtins.str","builtins.str","builtins.str","builtins.str","builtins.str","builtins.str","builtins.str","builtins.str","builtins.str","builtins.str","builtins.str","builtins.str","builtins.str","builtins.str","builtins.str","builtins.str","builtins.str","builtins.str","builtins.str","builtins.str"],"partial_fallback":{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.tuple"}}}},"__annotations__":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"Var","flags":["is_ready"],"fullname":"configparser.__annotations__","name":"__annotations__","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"__doc__":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"Var","flags":["is_ready"],"fullname":"configparser.__doc__","name":"__doc__","type":"builtins.str"}},"__file__":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"Var","flags":["is_ready"],"fullname":"configparser.__file__","name":"__file__","type":"builtins.str"}},"__name__":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"Var","flags":["is_ready"],"fullname":"configparser.__name__","name":"__name__","type":"builtins.str"}},"__package__":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"Var","flags":["is_ready"],"fullname":"configparser.__package__","name":"__package__","type":"builtins.str"}},"__spec__":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"Var","flags":["is_ready"],"fullname":"configparser.__spec__","name":"__spec__","type":"_frozen_importlib.ModuleSpec"}},"overload":{".class":"SymbolTableNode","cross_ref":"typing.overload","kind":"Gdef","module_hidden":true,"module_public":false},"sys":{".class":"SymbolTableNode","cross_ref":"sys","kind":"Gdef","module_hidden":true,"module_public":false}},"path":"/Users/yeogirlyun/.cursor/extensions/ms-python.mypy-type-checker-2024.2.0-universal/bundled/libs/mypy/typeshed/stdlib/configparser.pyi"}
```

---

### configparser.meta.json

**Path**: `.mypy_cache/3.13/configparser.meta.json`

**Size**: 1.7 KB

```json
{"data_mtime":1755238594,"dep_lines":[3,1,2,4,5,6,1,1,1,1,1],"dep_prios":[5,10,5,5,5,5,5,30,30,30,30],"dependencies":["collections.abc","sys","_typeshed","re","typing","typing_extensions","builtins","_frozen_importlib","abc","os","types"],"hash":"d185c70542a7112fcf498c8125ce9f15410bac95","id":"configparser","ignore_all":true,"interface_hash":"98bd4be77609be83ad16fd51f377f3d6ea62b26a","mtime":1753845420,"options":{"allow_redefinition":false,"allow_untyped_globals":false,"always_false":[],"always_true":[],"bazel":false,"check_untyped_defs":false,"disable_bytearray_promotion":false,"disable_error_code":[],"disable_memoryview_promotion":false,"disabled_error_codes":[],"disallow_any_decorated":false,"disallow_any_explicit":false,"disallow_any_expr":false,"disallow_any_generics":false,"disallow_any_unimported":false,"disallow_incomplete_defs":false,"disallow_subclassing_any":false,"disallow_untyped_calls":false,"disallow_untyped_decorators":false,"disallow_untyped_defs":false,"enable_error_code":[],"enabled_error_codes":[],"extra_checks":false,"follow_imports":"normal","follow_imports_for_stubs":false,"follow_untyped_imports":false,"ignore_errors":false,"ignore_missing_imports":false,"implicit_optional":false,"implicit_reexport":true,"local_partial_types":false,"mypyc":false,"old_type_inference":false,"platform":"darwin","plugins":[],"strict_concatenate":false,"strict_equality":false,"strict_optional":true,"warn_no_return":true,"warn_return_any":false,"warn_unreachable":false,"warn_unused_ignores":false},"path":"/Users/yeogirlyun/.cursor/extensions/ms-python.mypy-type-checker-2024.2.0-universal/bundled/libs/mypy/typeshed/stdlib/configparser.pyi","plugin_data":null,"size":16484,"suppressed":[],"version_id":"1.14.1"}
```

---

### config.data.json

**Path**: `.mypy_cache/3.13/logging/config.data.json`

**Size**: 57.9 KB

```json
{".class":"MypyFile","_fullname":"logging.config","future_import_flags":[],"is_partial_stub_package":false,"is_stub":true,"names":{".class":"SymbolTable","Any":{".class":"SymbolTableNode","cross_ref":"typing.Any","kind":"Gdef","module_hidden":true,"module_public":false},"BaseConfigurator":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["builtins.object"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"logging.config.BaseConfigurator","name":"BaseConfigurator","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"logging.config.BaseConfigurator","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"logging.config","mro":["logging.config.BaseConfigurator","builtins.object"],"names":{".class":"SymbolTable","CONVERT_PATTERN":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready"],"fullname":"logging.config.BaseConfigurator.CONVERT_PATTERN","name":"CONVERT_PATTERN","type":{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"re.Pattern"}}},"DIGIT_PATTERN":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready"],"fullname":"logging.config.BaseConfigurator.DIGIT_PATTERN","name":"DIGIT_PATTERN","type":{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"re.Pattern"}}},"DOT_PATTERN":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready"],"fullname":"logging.config.BaseConfigurator.DOT_PATTERN","name":"DOT_PATTERN","type":{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"re.Pattern"}}},"INDEX_PATTERN":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready"],"fullname":"logging.config.BaseConfigurator.INDEX_PATTERN","name":"INDEX_PATTERN","type":{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"re.Pattern"}}},"WORD_PATTERN":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready"],"fullname":"logging.config.BaseConfigurator.WORD_PATTERN","name":"WORD_PATTERN","type":{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"re.Pattern"}}},"__init__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","config"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"logging.config.BaseConfigurator.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","config"],"arg_types":["logging.config.BaseConfigurator",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"logging.config._DictConfigArgs"},{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of BaseConfigurator","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"as_tuple":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","value"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"logging.config.BaseConfigurator.as_tuple","name":"as_tuple","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","value"],"arg_types":["logging.config.BaseConfigurator",{".class":"UnionType","items":[{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.list"},{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.tuple"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"as_tuple of BaseConfigurator","ret_type":{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.tuple"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"cfg_convert":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","value"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"logging.config.BaseConfigurator.cfg_convert","name":"cfg_convert","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","value"],"arg_types":["logging.config.BaseConfigurator","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"cfg_convert of BaseConfigurator","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"configure_custom":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","config"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"logging.config.BaseConfigurator.configure_custom","name":"configure_custom","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","config"],"arg_types":["logging.config.BaseConfigurator",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"configure_custom of BaseConfigurator","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"convert":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","value"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"logging.config.BaseConfigurator.convert","name":"convert","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","value"],"arg_types":["logging.config.BaseConfigurator",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"convert of BaseConfigurator","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"ext_convert":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","value"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"logging.config.BaseConfigurator.ext_convert","name":"ext_convert","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","value"],"arg_types":["logging.config.BaseConfigurator","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"ext_convert of BaseConfigurator","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"importer":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready"],"fullname":"logging.config.BaseConfigurator.importer","name":"importer","type":{".class":"CallableType","arg_kinds":[2,4],"arg_names":[null,null],"arg_types":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":true,"name":null,"ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"resolve":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","s"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"logging.config.BaseConfigurator.resolve","name":"resolve","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","s"],"arg_types":["logging.config.BaseConfigurator","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"resolve of BaseConfigurator","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"value_converters":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready"],"fullname":"logging.config.BaseConfigurator.value_converters","name":"value_converters","type":{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"builtins.dict"}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"logging.config.BaseConfigurator.Self","id":0,"name":"Self","namespace":"","upper_bound":"logging.config.BaseConfigurator","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"Callable":{".class":"SymbolTableNode","cross_ref":"typing.Callable","kind":"Gdef","module_hidden":true,"module_public":false},"ConvertingDict":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":[{".class":"Instance","args":["typing.Hashable",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"logging.config.ConvertingMixin"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"logging.config.ConvertingDict","name":"ConvertingDict","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"logging.config.ConvertingDict","has_param_spec_type":false,"metaclass_type":"abc.ABCMeta","metadata":{},"module_name":"logging.config","mro":["logging.config.ConvertingDict","builtins.dict","typing.MutableMapping","typing.Mapping","typing.Collection","typing.Iterable","typing.Container","logging.config.ConvertingMixin","builtins.object"],"names":{".class":"SymbolTable","__getitem__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":[null,null],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"logging.config.ConvertingDict.__getitem__","name":"__getitem__","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":["logging.config.ConvertingDict","typing.Hashable"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__getitem__ of ConvertingDict","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,1],"arg_names":["self","key","default"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"logging.config.ConvertingDict.get","name":"get","type":{".class":"CallableType","arg_kinds":[0,0,1],"arg_names":["self","key","default"],"arg_types":["logging.config.ConvertingDict","typing.Hashable",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get of ConvertingDict","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"pop":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,1],"arg_names":["self","key","default"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"logging.config.ConvertingDict.pop","name":"pop","type":{".class":"CallableType","arg_kinds":[0,0,1],"arg_names":["self","key","default"],"arg_types":["logging.config.ConvertingDict","typing.Hashable",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"pop of ConvertingDict","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"logging.config.ConvertingDict.Self","id":0,"name":"Self","namespace":"","upper_bound":"logging.config.ConvertingDict","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"ConvertingList":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":[{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.list"},"logging.config.ConvertingMixin"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"logging.config.ConvertingList","name":"ConvertingList","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"logging.config.ConvertingList","has_param_spec_type":false,"metaclass_type":"abc.ABCMeta","metadata":{},"module_name":"logging.config","mro":["logging.config.ConvertingList","builtins.list","typing.MutableSequence","typing.Sequence","typing.Reversible","typing.Collection","typing.Iterable","typing.Container","logging.config.ConvertingMixin","builtins.object"],"names":{".class":"SymbolTable","__getitem__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"OverloadedFuncDef","deprecated":null,"flags":[],"fullname":"logging.config.ConvertingList.__getitem__","impl":null,"items":[{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":[null,null],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated"],"fullname":"logging.config.ConvertingList.__getitem__","name":"__getitem__","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":["logging.config.ConvertingList","typing.SupportsIndex"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__getitem__ of ConvertingList","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"logging.config.ConvertingList.__getitem__","name":"__getitem__","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":["logging.config.ConvertingList","typing.SupportsIndex"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__getitem__ of ConvertingList","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":[null,null],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated"],"fullname":"logging.config.ConvertingList.__getitem__","name":"__getitem__","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":["logging.config.ConvertingList",{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.slice"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__getitem__ of ConvertingList","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"logging.config.ConvertingList.__getitem__","name":"__getitem__","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":["logging.config.ConvertingList",{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.slice"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__getitem__ of ConvertingList","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}],"type":{".class":"Overloaded","items":[{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":["logging.config.ConvertingList","typing.SupportsIndex"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__getitem__ of ConvertingList","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":["logging.config.ConvertingList",{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.slice"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__getitem__ of ConvertingList","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}]}}},"pop":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,1],"arg_names":["self","idx"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"logging.config.ConvertingList.pop","name":"pop","type":{".class":"CallableType","arg_kinds":[0,1],"arg_names":["self","idx"],"arg_types":["logging.config.ConvertingList","typing.SupportsIndex"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"pop of ConvertingList","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"logging.config.ConvertingList.Self","id":0,"name":"Self","namespace":"","upper_bound":"logging.config.ConvertingList","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"ConvertingMixin":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["builtins.object"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"logging.config.ConvertingMixin","name":"ConvertingMixin","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"logging.config.ConvertingMixin","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"logging.config","mro":["logging.config.ConvertingMixin","builtins.object"],"names":{".class":"SymbolTable","convert":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","value"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"logging.config.ConvertingMixin.convert","name":"convert","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","value"],"arg_types":["logging.config.ConvertingMixin",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"convert of ConvertingMixin","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"convert_with_key":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,1],"arg_names":["self","key","value","replace"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"logging.config.ConvertingMixin.convert_with_key","name":"convert_with_key","type":{".class":"CallableType","arg_kinds":[0,0,0,1],"arg_names":["self","key","value","replace"],"arg_types":["logging.config.ConvertingMixin",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"builtins.bool"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"convert_with_key of ConvertingMixin","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"logging.config.ConvertingMixin.Self","id":0,"name":"Self","namespace":"","upper_bound":"logging.config.ConvertingMixin","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"ConvertingTuple":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":[{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.tuple"},"logging.config.ConvertingMixin"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"logging.config.ConvertingTuple","name":"ConvertingTuple","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"logging.config.ConvertingTuple","has_param_spec_type":false,"metaclass_type":"abc.ABCMeta","metadata":{},"module_name":"logging.config","mro":["logging.config.ConvertingTuple","builtins.tuple","typing.Sequence","typing.Reversible","typing.Collection","typing.Iterable","typing.Container","logging.config.ConvertingMixin","builtins.object"],"names":{".class":"SymbolTable","__getitem__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"OverloadedFuncDef","deprecated":null,"flags":[],"fullname":"logging.config.ConvertingTuple.__getitem__","impl":null,"items":[{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":[null,null],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated"],"fullname":"logging.config.ConvertingTuple.__getitem__","name":"__getitem__","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":["logging.config.ConvertingTuple","typing.SupportsIndex"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__getitem__ of ConvertingTuple","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"logging.config.ConvertingTuple.__getitem__","name":"__getitem__","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":["logging.config.ConvertingTuple","typing.SupportsIndex"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__getitem__ of ConvertingTuple","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":[null,null],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated"],"fullname":"logging.config.ConvertingTuple.__getitem__","name":"__getitem__","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":["logging.config.ConvertingTuple",{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.slice"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__getitem__ of ConvertingTuple","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"logging.config.ConvertingTuple.__getitem__","name":"__getitem__","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":["logging.config.ConvertingTuple",{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.slice"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__getitem__ of ConvertingTuple","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}],"type":{".class":"Overloaded","items":[{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":["logging.config.ConvertingTuple","typing.SupportsIndex"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__getitem__ of ConvertingTuple","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":["logging.config.ConvertingTuple",{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.slice"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__getitem__ of ConvertingTuple","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}]}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"logging.config.ConvertingTuple.Self","id":0,"name":"Self","namespace":"","upper_bound":"logging.config.ConvertingTuple","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"DEFAULT_LOGGING_CONFIG_PORT":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"logging.config.DEFAULT_LOGGING_CONFIG_PORT","name":"DEFAULT_LOGGING_CONFIG_PORT","type":"builtins.int"}},"DictConfigurator":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["logging.config.BaseConfigurator"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"logging.config.DictConfigurator","name":"DictConfigurator","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"logging.config.DictConfigurator","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"logging.config","mro":["logging.config.DictConfigurator","logging.config.BaseConfigurator","builtins.object"],"names":{".class":"SymbolTable","add_filters":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":["self","filterer","filters"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"logging.config.DictConfigurator.add_filters","name":"add_filters","type":{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":["self","filterer","filters"],"arg_types":["logging.config.DictConfigurator","logging.Filterer",{".class":"Instance","args":[{".class":"TypeAliasType","args":[],"type_ref":"logging._FilterType"}],"extra_attrs":null,"type_ref":"typing.Iterable"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"add_filters of DictConfigurator","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"add_handlers":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":["self","logger","handlers"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"logging.config.DictConfigurator.add_handlers","name":"add_handlers","type":{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":["self","logger","handlers"],"arg_types":["logging.config.DictConfigurator","logging.Logger",{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Iterable"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"add_handlers of DictConfigurator","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"common_logger_config":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,1],"arg_names":["self","logger","config","incremental"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"logging.config.DictConfigurator.common_logger_config","name":"common_logger_config","type":{".class":"CallableType","arg_kinds":[0,0,0,1],"arg_names":["self","logger","config","incremental"],"arg_types":["logging.config.DictConfigurator","logging.Logger",{".class":"TypeAliasType","args":[],"type_ref":"logging.config._LoggerConfiguration"},"builtins.bool"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"common_logger_config of DictConfigurator","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"configure":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"logging.config.DictConfigurator.configure","name":"configure","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["logging.config.DictConfigurator"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"configure of DictConfigurator","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"configure_filter":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","config"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"logging.config.DictConfigurator.configure_filter","name":"configure_filter","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","config"],"arg_types":["logging.config.DictConfigurator",{".class":"TypeAliasType","args":[],"type_ref":"logging.config._FilterConfiguration"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"configure_filter of DictConfigurator","ret_type":{".class":"UnionType","items":["logging.Filter",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"configure_formatter":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","config"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"logging.config.DictConfigurator.configure_formatter","name":"configure_formatter","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","config"],"arg_types":["logging.config.DictConfigurator",{".class":"TypeAliasType","args":[],"type_ref":"logging.config._FormatterConfiguration"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"configure_formatter of DictConfigurator","ret_type":{".class":"UnionType","items":["logging.Formatter",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"configure_handler":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","config"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"logging.config.DictConfigurator.configure_handler","name":"configure_handler","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","config"],"arg_types":["logging.config.DictConfigurator",{".class":"TypeAliasType","args":[],"type_ref":"logging.config._HandlerConfiguration"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"configure_handler of DictConfigurator","ret_type":{".class":"UnionType","items":["logging.Handler",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"configure_logger":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,1],"arg_names":["self","name","config","incremental"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"logging.config.DictConfigurator.configure_logger","name":"configure_logger","type":{".class":"CallableType","arg_kinds":[0,0,0,1],"arg_names":["self","name","config","incremental"],"arg_types":["logging.config.DictConfigurator","builtins.str",{".class":"TypeAliasType","args":[],"type_ref":"logging.config._LoggerConfiguration"},"builtins.bool"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"configure_logger of DictConfigurator","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"configure_root":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,1],"arg_names":["self","config","incremental"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"logging.config.DictConfigurator.configure_root","name":"configure_root","type":{".class":"CallableType","arg_kinds":[0,0,1],"arg_names":["self","config","incremental"],"arg_types":["logging.config.DictConfigurator",{".class":"TypeAliasType","args":[],"type_ref":"logging.config._LoggerConfiguration"},"builtins.bool"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"configure_root of DictConfigurator","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"logging.config.DictConfigurator.Self","id":0,"name":"Self","namespace":"","upper_bound":"logging.config.DictConfigurator","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"Filter":{".class":"SymbolTableNode","cross_ref":"logging.Filter","kind":"Gdef","module_hidden":true,"module_public":false},"Filterer":{".class":"SymbolTableNode","cross_ref":"logging.Filterer","kind":"Gdef","module_hidden":true,"module_public":false},"Final":{".class":"SymbolTableNode","cross_ref":"typing.Final","kind":"Gdef","module_hidden":true,"module_public":false},"Formatter":{".class":"SymbolTableNode","cross_ref":"logging.Formatter","kind":"Gdef","module_hidden":true,"module_public":false},"Handler":{".class":"SymbolTableNode","cross_ref":"logging.Handler","kind":"Gdef","module_hidden":true,"module_public":false},"Hashable":{".class":"SymbolTableNode","cross_ref":"typing.Hashable","kind":"Gdef","module_hidden":true,"module_public":false},"IDENTIFIER":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_final","is_ready"],"fullname":"logging.config.IDENTIFIER","name":"IDENTIFIER","type":{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"re.Pattern"}}},"IO":{".class":"SymbolTableNode","cross_ref":"typing.IO","kind":"Gdef","module_hidden":true,"module_public":false},"Iterable":{".class":"SymbolTableNode","cross_ref":"typing.Iterable","kind":"Gdef","module_hidden":true,"module_public":false},"Literal":{".class":"SymbolTableNode","cross_ref":"typing.Literal","kind":"Gdef","module_hidden":true,"module_public":false},"Logger":{".class":"SymbolTableNode","cross_ref":"logging.Logger","kind":"Gdef","module_hidden":true,"module_public":false},"Mapping":{".class":"SymbolTableNode","cross_ref":"typing.Mapping","kind":"Gdef","module_hidden":true,"module_public":false},"Pattern":{".class":"SymbolTableNode","cross_ref":"re.Pattern","kind":"Gdef","module_hidden":true,"module_public":false},"RESET_ERROR":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_final","is_ready"],"fullname":"logging.config.RESET_ERROR","name":"RESET_ERROR","type":"builtins.int"}},"RawConfigParser":{".class":"SymbolTableNode","cross_ref":"configparser.RawConfigParser","kind":"Gdef","module_hidden":true,"module_public":false},"Required":{".class":"SymbolTableNode","cross_ref":"typing.Required","kind":"Gdef","module_hidden":true,"module_public":false},"Sequence":{".class":"SymbolTableNode","cross_ref":"typing.Sequence","kind":"Gdef","module_hidden":true,"module_public":false},"StrOrBytesPath":{".class":"SymbolTableNode","cross_ref":"_typeshed.StrOrBytesPath","kind":"Gdef","module_hidden":true,"module_public":false},"SupportsIndex":{".class":"SymbolTableNode","cross_ref":"typing.SupportsIndex","kind":"Gdef","module_hidden":true,"module_public":false},"Thread":{".class":"SymbolTableNode","cross_ref":"threading.Thread","kind":"Gdef","module_hidden":true,"module_public":false},"TypeAlias":{".class":"SymbolTableNode","cross_ref":"typing.TypeAlias","kind":"Gdef","module_hidden":true,"module_public":false},"TypedDict":{".class":"SymbolTableNode","cross_ref":"typing.TypedDict","kind":"Gdef","module_hidden":true,"module_public":false},"_DictConfigArgs":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["typing._TypedDict"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"logging.config._DictConfigArgs","name":"_DictConfigArgs","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"logging.config._DictConfigArgs","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"logging.config","mro":["logging.config._DictConfigArgs","typing._TypedDict","typing.Mapping","typing.Collection","typing.Iterable","typing.Container","builtins.object"],"names":{".class":"SymbolTable"},"self_type":null,"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":{".class":"TypedDictType","fallback":"typing._TypedDict","items":[["version",{".class":"LiteralType","fallback":"builtins.int","value":1}],["formatters",{".class":"Instance","args":["builtins.str",{".class":"TypeAliasType","args":[],"type_ref":"logging.config._FormatterConfiguration"}],"extra_attrs":null,"type_ref":"builtins.dict"}],["filters",{".class":"Instance","args":["builtins.str",{".class":"TypeAliasType","args":[],"type_ref":"logging.config._FilterConfiguration"}],"extra_attrs":null,"type_ref":"builtins.dict"}],["handlers",{".class":"Instance","args":["builtins.str",{".class":"TypeAliasType","args":[],"type_ref":"logging.config._HandlerConfiguration"}],"extra_attrs":null,"type_ref":"builtins.dict"}],["loggers",{".class":"Instance","args":["builtins.str",{".class":"TypeAliasType","args":[],"type_ref":"logging.config._LoggerConfiguration"}],"extra_attrs":null,"type_ref":"builtins.dict"}],["root",{".class":"TypeAliasType","args":[],"type_ref":"logging.config._RootLoggerConfiguration"}],["incremental","builtins.bool"],["disable_existing_loggers","builtins.bool"]],"readonly_keys":[],"required_keys":["version"]}}},"_FilterConfiguration":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeAlias","alias_tvars":[],"column":0,"fullname":"logging.config._FilterConfiguration","line":42,"no_args":false,"normalized":false,"python_3_12_type_alias":false,"target":{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"logging.config._FilterConfigurationTypedDict"},{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.dict"}],"uses_pep604_syntax":true}}},"_FilterConfigurationTypedDict":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["typing._TypedDict"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"logging.config._FilterConfigurationTypedDict","name":"_FilterConfigurationTypedDict","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"logging.config._FilterConfigurationTypedDict","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"logging.config","mro":["logging.config._FilterConfigurationTypedDict","typing._TypedDict","typing.Mapping","typing.Collection","typing.Iterable","typing.Container","builtins.object"],"names":{".class":"SymbolTable"},"self_type":null,"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":{".class":"TypedDictType","fallback":"typing._TypedDict","items":[["name","builtins.str"]],"readonly_keys":[],"required_keys":["name"]}}},"_FilterType":{".class":"SymbolTableNode","cross_ref":"logging._FilterType","kind":"Gdef","module_hidden":true,"module_public":false},"_FormatStyle":{".class":"SymbolTableNode","cross_ref":"logging._FormatStyle","kind":"Gdef","module_hidden":true,"module_public":false},"_FormatterConfiguration":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeAlias","alias_tvars":[],"column":0,"fullname":"logging.config._FormatterConfiguration","line":41,"no_args":false,"normalized":false,"python_3_12_type_alias":false,"target":{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"logging.config._FormatterConfigurationTypedDict"},{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.dict"}],"uses_pep604_syntax":true}}},"_FormatterConfigurationTypedDict":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["typing._TypedDict"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"logging.config._FormatterConfigurationTypedDict","name":"_FormatterConfigurationTypedDict","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"logging.config._FormatterConfigurationTypedDict","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"logging.config","mro":["logging.config._FormatterConfigurationTypedDict","typing._TypedDict","typing.Mapping","typing.Collection","typing.Iterable","typing.Container","builtins.object"],"names":{".class":"SymbolTable"},"self_type":null,"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":{".class":"TypedDictType","fallback":"typing._TypedDict","items":[["class","builtins.str"],["format","builtins.str"],["datefmt","builtins.str"],["style",{".class":"TypeAliasType","args":[],"type_ref":"logging._FormatStyle"}]],"readonly_keys":[],"required_keys":[]}}},"_HandlerConfiguration":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeAlias","alias_tvars":[],"column":0,"fullname":"logging.config._HandlerConfiguration","line":44,"no_args":false,"normalized":false,"python_3_12_type_alias":false,"target":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"_Level":{".class":"SymbolTableNode","cross_ref":"logging._Level","kind":"Gdef","module_hidden":true,"module_public":false},"_LoggerConfiguration":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["typing._TypedDict"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"logging.config._LoggerConfiguration","name":"_LoggerConfiguration","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"logging.config._LoggerConfiguration","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"logging.config","mro":["logging.config._LoggerConfiguration","typing._TypedDict","typing.Mapping","typing.Collection","typing.Iterable","typing.Container","builtins.object"],"names":{".class":"SymbolTable"},"self_type":null,"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":{".class":"TypedDictType","fallback":"typing._TypedDict","items":[["level",{".class":"TypeAliasType","args":[],"type_ref":"logging._Level"}],["filters",{".class":"Instance","args":[{".class":"UnionType","items":["builtins.str",{".class":"TypeAliasType","args":[],"type_ref":"logging._FilterType"}],"uses_pep604_syntax":true}],"extra_attrs":null,"type_ref":"typing.Sequence"}],["handlers",{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Sequence"}],["propagate","builtins.bool"]],"readonly_keys":[],"required_keys":[]}}},"_RootLoggerConfiguration":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["typing._TypedDict"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"logging.config._RootLoggerConfiguration","name":"_RootLoggerConfiguration","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"logging.config._RootLoggerConfiguration","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"logging.config","mro":["logging.config._RootLoggerConfiguration","typing._TypedDict","typing.Mapping","typing.Collection","typing.Iterable","typing.Container","builtins.object"],"names":{".class":"SymbolTable"},"self_type":null,"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":{".class":"TypedDictType","fallback":"typing._TypedDict","items":[["level",{".class":"TypeAliasType","args":[],"type_ref":"logging._Level"}],["filters",{".class":"Instance","args":[{".class":"UnionType","items":["builtins.str",{".class":"TypeAliasType","args":[],"type_ref":"logging._FilterType"}],"uses_pep604_syntax":true}],"extra_attrs":null,"type_ref":"typing.Sequence"}],["handlers",{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.Sequence"}]],"readonly_keys":[],"required_keys":[]}}},"__annotations__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"logging.config.__annotations__","name":"__annotations__","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"__doc__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"logging.config.__doc__","name":"__doc__","type":"builtins.str"}},"__file__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"logging.config.__file__","name":"__file__","type":"builtins.str"}},"__name__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"logging.config.__name__","name":"__name__","type":"builtins.str"}},"__package__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"logging.config.__package__","name":"__package__","type":"builtins.str"}},"__spec__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"logging.config.__spec__","name":"__spec__","type":"_frozen_importlib.ModuleSpec"}},"dictConfig":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["config"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"logging.config.dictConfig","name":"dictConfig","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["config"],"arg_types":[{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"logging.config._DictConfigArgs"},{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"dictConfig","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"dictConfigClass":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeAlias","alias_tvars":[],"column":0,"fullname":"logging.config.dictConfigClass","line":134,"no_args":true,"normalized":false,"python_3_12_type_alias":false,"target":"logging.config.DictConfigurator"}},"fileConfig":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,1,1,1],"arg_names":["fname","defaults","disable_existing_loggers","encoding"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"logging.config.fileConfig","name":"fileConfig","type":{".class":"CallableType","arg_kinds":[0,1,1,1],"arg_names":["fname","defaults","disable_existing_loggers","encoding"],"arg_types":[{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"_typeshed.StrOrBytesPath"},{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"typing.IO"},"configparser.RawConfigParser"],"uses_pep604_syntax":true},{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"typing.Mapping"},{".class":"NoneType"}],"uses_pep604_syntax":true},"builtins.bool",{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"fileConfig","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"listen":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[1,1],"arg_names":["port","verify"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"logging.config.listen","name":"listen","type":{".class":"CallableType","arg_kinds":[1,1],"arg_names":["port","verify"],"arg_types":["builtins.int",{".class":"UnionType","items":[{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["builtins.bytes"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"UnionType","items":["builtins.bytes",{".class":"NoneType"}],"uses_pep604_syntax":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"listen","ret_type":"threading.Thread","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"overload":{".class":"SymbolTableNode","cross_ref":"typing.overload","kind":"Gdef","module_hidden":true,"module_public":false},"stopListening":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[],"arg_names":[],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"logging.config.stopListening","name":"stopListening","type":{".class":"CallableType","arg_kinds":[],"arg_names":[],"arg_types":[],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"stopListening","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"sys":{".class":"SymbolTableNode","cross_ref":"sys","kind":"Gdef","module_hidden":true,"module_public":false},"valid_ident":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["s"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"logging.config.valid_ident","name":"valid_ident","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["s"],"arg_types":["builtins.str"],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"valid_ident","ret_type":{".class":"LiteralType","fallback":"builtins.bool","value":true},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"path":"/Users/yeogirlyun/.cursor/extensions/ms-python.mypy-type-checker-2024.2.0-universal/bundled/libs/mypy/typeshed/stdlib/logging/config.pyi"}
```

---

### config.meta.json

**Path**: `.mypy_cache/3.13/logging/config.meta.json`

**Size**: 1.7 KB

```json
{"data_mtime":1755238595,"dep_lines":[3,1,2,4,5,6,7,8,10,1,1,1,1,1],"dep_prios":[5,10,5,5,5,5,5,5,5,5,30,30,30,30],"dependencies":["collections.abc","sys","_typeshed","configparser","re","threading","typing","typing_extensions","logging","builtins","_frozen_importlib","abc","os","types"],"hash":"b7f479c52fc853ec764e7d54d833159ce83f7db0","id":"logging.config","ignore_all":true,"interface_hash":"1193b1a1a235ea64f5f16802e5eef8b78622e15f","mtime":1753845420,"options":{"allow_redefinition":false,"allow_untyped_globals":false,"always_false":[],"always_true":[],"bazel":false,"check_untyped_defs":false,"disable_bytearray_promotion":false,"disable_error_code":[],"disable_memoryview_promotion":false,"disabled_error_codes":[],"disallow_any_decorated":false,"disallow_any_explicit":false,"disallow_any_expr":false,"disallow_any_generics":false,"disallow_any_unimported":false,"disallow_incomplete_defs":false,"disallow_subclassing_any":false,"disallow_untyped_calls":false,"disallow_untyped_decorators":false,"disallow_untyped_defs":false,"enable_error_code":[],"enabled_error_codes":[],"extra_checks":false,"follow_imports":"normal","follow_imports_for_stubs":false,"follow_untyped_imports":false,"ignore_errors":false,"ignore_missing_imports":false,"implicit_optional":false,"implicit_reexport":true,"local_partial_types":false,"mypyc":false,"old_type_inference":false,"platform":"darwin","plugins":[],"strict_concatenate":false,"strict_equality":false,"strict_optional":true,"warn_no_return":true,"warn_return_any":false,"warn_unreachable":false,"warn_unused_ignores":false},"path":"/Users/yeogirlyun/.cursor/extensions/ms-python.mypy-type-checker-2024.2.0-universal/bundled/libs/mypy/typeshed/stdlib/logging/config.pyi","plugin_data":null,"size":5788,"suppressed":[],"version_id":"1.14.1"}
```

---

### config.data.json

**Path**: `.mypy_cache/3.13/pydantic/config.data.json`

**Size**: 54.2 KB

```json
{".class":"MypyFile","_fullname":"pydantic.config","future_import_flags":["annotations"],"is_partial_stub_package":false,"is_stub":false,"names":{".class":"SymbolTable","AliasGenerator":{".class":"SymbolTableNode","cross_ref":"pydantic.aliases.AliasGenerator","kind":"Gdef","module_public":false},"Any":{".class":"SymbolTableNode","cross_ref":"typing.Any","kind":"Gdef","module_public":false},"Callable":{".class":"SymbolTableNode","cross_ref":"typing.Callable","kind":"Gdef","module_public":false},"ComputedFieldInfo":{".class":"SymbolTableNode","cross_ref":"pydantic.fields.ComputedFieldInfo","kind":"Gdef","module_public":false},"ConfigDict":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["typing._TypedDict"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"pydantic.config.ConfigDict","name":"ConfigDict","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"pydantic.config.ConfigDict","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"pydantic.config","mro":["pydantic.config.ConfigDict","typing._TypedDict","typing.Mapping","typing.Collection","typing.Iterable","typing.Container","builtins.object"],"names":{".class":"SymbolTable"},"self_type":null,"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":{".class":"TypedDictType","fallback":"typing._TypedDict","items":[["title",{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}],["model_title_generator",{".class":"UnionType","items":[{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["builtins.type"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"NoneType"}],"uses_pep604_syntax":true}],["field_title_generator",{".class":"UnionType","items":[{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":["builtins.str",{".class":"UnionType","items":["pydantic.fields.FieldInfo","pydantic.fields.ComputedFieldInfo"],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"NoneType"}],"uses_pep604_syntax":true}],["str_to_lower","builtins.bool"],["str_to_upper","builtins.bool"],["str_strip_whitespace","builtins.bool"],["str_min_length","builtins.int"],["str_max_length",{".class":"UnionType","items":["builtins.int",{".class":"NoneType"}],"uses_pep604_syntax":true}],["extra",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"pydantic.config.ExtraValues"},{".class":"NoneType"}],"uses_pep604_syntax":true}],["frozen","builtins.bool"],["populate_by_name","builtins.bool"],["use_enum_values","builtins.bool"],["validate_assignment","builtins.bool"],["arbitrary_types_allowed","builtins.bool"],["from_attributes","builtins.bool"],["loc_by_alias","builtins.bool"],["alias_generator",{".class":"UnionType","items":[{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["builtins.str"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},"pydantic.aliases.AliasGenerator",{".class":"NoneType"}],"uses_pep604_syntax":true}],["ignored_types",{".class":"Instance","args":["builtins.type"],"extra_attrs":null,"type_ref":"builtins.tuple"}],["allow_inf_nan","builtins.bool"],["json_schema_extra",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"pydantic.config.JsonDict"},{".class":"TypeAliasType","args":[],"type_ref":"pydantic.config.JsonSchemaExtraCallable"},{".class":"NoneType"}],"uses_pep604_syntax":true}],["json_encoders",{".class":"UnionType","items":[{".class":"Instance","args":[{".class":"TypeType","item":"builtins.object"},{".class":"TypeAliasType","args":[],"type_ref":"pydantic.config.JsonEncoder"}],"extra_attrs":null,"type_ref":"builtins.dict"},{".class":"NoneType"}],"uses_pep604_syntax":true}],["strict","builtins.bool"],["revalidate_instances",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"always"},{".class":"LiteralType","fallback":"builtins.str","value":"never"},{".class":"LiteralType","fallback":"builtins.str","value":"subclass-instances"}],"uses_pep604_syntax":false}],["ser_json_timedelta",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"iso8601"},{".class":"LiteralType","fallback":"builtins.str","value":"float"}],"uses_pep604_syntax":false}],["ser_json_bytes",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"utf8"},{".class":"LiteralType","fallback":"builtins.str","value":"base64"},{".class":"LiteralType","fallback":"builtins.str","value":"hex"}],"uses_pep604_syntax":false}],["val_json_bytes",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"utf8"},{".class":"LiteralType","fallback":"builtins.str","value":"base64"},{".class":"LiteralType","fallback":"builtins.str","value":"hex"}],"uses_pep604_syntax":false}],["ser_json_inf_nan",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"null"},{".class":"LiteralType","fallback":"builtins.str","value":"constants"},{".class":"LiteralType","fallback":"builtins.str","value":"strings"}],"uses_pep604_syntax":false}],["validate_default","builtins.bool"],["validate_return","builtins.bool"],["protected_namespaces",{".class":"Instance","args":[{".class":"UnionType","items":["builtins.str",{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"re.Pattern"}],"uses_pep604_syntax":true}],"extra_attrs":null,"type_ref":"builtins.tuple"}],["hide_input_in_errors","builtins.bool"],["defer_build","builtins.bool"],["plugin_settings",{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str","builtins.object"],"extra_attrs":null,"type_ref":"builtins.dict"},{".class":"NoneType"}],"uses_pep604_syntax":true}],["schema_generator",{".class":"UnionType","items":[{".class":"TypeType","item":"pydantic._internal._generate_schema.GenerateSchema"},{".class":"NoneType"}],"uses_pep604_syntax":true}],["json_schema_serialization_defaults_required","builtins.bool"],["json_schema_mode_override",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"validation"},{".class":"LiteralType","fallback":"builtins.str","value":"serialization"},{".class":"NoneType"}],"uses_pep604_syntax":false}],["coerce_numbers_to_str","builtins.bool"],["regex_engine",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"rust-regex"},{".class":"LiteralType","fallback":"builtins.str","value":"python-re"}],"uses_pep604_syntax":false}],["validation_error_cause","builtins.bool"],["use_attribute_docstrings","builtins.bool"],["cache_strings",{".class":"UnionType","items":["builtins.bool",{".class":"LiteralType","fallback":"builtins.str","value":"all"},{".class":"LiteralType","fallback":"builtins.str","value":"keys"},{".class":"LiteralType","fallback":"builtins.str","value":"none"}],"uses_pep604_syntax":true}],["validate_by_alias","builtins.bool"],["validate_by_name","builtins.bool"],["serialize_by_alias","builtins.bool"]],"readonly_keys":[],"required_keys":[]}}},"ExtraValues":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"TypeAlias","alias_tvars":[],"column":0,"fullname":"pydantic.config.ExtraValues","line":33,"no_args":false,"normalized":false,"python_3_12_type_alias":false,"target":{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"allow"},{".class":"LiteralType","fallback":"builtins.str","value":"ignore"},{".class":"LiteralType","fallback":"builtins.str","value":"forbid"}],"uses_pep604_syntax":false}}},"FieldInfo":{".class":"SymbolTableNode","cross_ref":"pydantic.fields.FieldInfo","kind":"Gdef","module_public":false},"JsonDict":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"TypeAlias","alias_tvars":[],"column":0,"fullname":"pydantic.config.JsonDict","line":24,"no_args":false,"normalized":false,"python_3_12_type_alias":false,"target":{".class":"Instance","args":["builtins.str",{".class":"TypeAliasType","args":[],"type_ref":"pydantic.config.JsonValue"}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"JsonEncoder":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"TypeAlias","alias_tvars":[],"column":0,"fullname":"pydantic.config.JsonEncoder","line":26,"no_args":false,"normalized":false,"python_3_12_type_alias":false,"target":{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"JsonSchemaExtraCallable":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"TypeAlias","alias_tvars":[],"column":0,"fullname":"pydantic.config.JsonSchemaExtraCallable","line":28,"no_args":false,"normalized":false,"python_3_12_type_alias":false,"target":{".class":"UnionType","items":[{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":[{".class":"TypeAliasType","args":[],"type_ref":"pydantic.config.JsonDict"}],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":[{".class":"TypeAliasType","args":[],"type_ref":"pydantic.config.JsonDict"},{".class":"TypeType","item":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}}],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}],"uses_pep604_syntax":false}}},"JsonValue":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"TypeAlias","alias_tvars":[],"column":0,"fullname":"pydantic.config.JsonValue","line":23,"no_args":false,"normalized":false,"python_3_12_type_alias":false,"target":{".class":"UnionType","items":["builtins.int","builtins.float","builtins.str","builtins.bool",{".class":"NoneType"},{".class":"Instance","args":[{".class":"TypeAliasType","args":[],"type_ref":"pydantic.config.JsonValue"}],"extra_attrs":null,"type_ref":"builtins.list"},{".class":"TypeAliasType","args":[],"type_ref":"pydantic.config.JsonDict"}],"uses_pep604_syntax":false}}},"Literal":{".class":"SymbolTableNode","cross_ref":"typing.Literal","kind":"Gdef","module_public":false},"Pattern":{".class":"SymbolTableNode","cross_ref":"re.Pattern","kind":"Gdef","module_public":false},"PydanticDeprecatedSince211":{".class":"SymbolTableNode","cross_ref":"pydantic.warnings.PydanticDeprecatedSince211","kind":"Gdef","module_public":false},"PydanticUserError":{".class":"SymbolTableNode","cross_ref":"pydantic.errors.PydanticUserError","kind":"Gdef","module_public":false},"TYPE_CHECKING":{".class":"SymbolTableNode","cross_ref":"typing.TYPE_CHECKING","kind":"Gdef","module_public":false},"TypeAlias":{".class":"SymbolTableNode","cross_ref":"typing.TypeAlias","kind":"Gdef","module_public":false},"TypeVar":{".class":"SymbolTableNode","cross_ref":"typing.TypeVar","kind":"Gdef","module_public":false},"TypedDict":{".class":"SymbolTableNode","cross_ref":"typing.TypedDict","kind":"Gdef","module_public":false},"Union":{".class":"SymbolTableNode","cross_ref":"typing.Union","kind":"Gdef","module_public":false},"Unpack":{".class":"SymbolTableNode","cross_ref":"typing.Unpack","kind":"Gdef","module_public":false},"_GenerateSchema":{".class":"SymbolTableNode","cross_ref":"pydantic._internal._generate_schema.GenerateSchema","kind":"Gdef","module_public":false},"_TypeT":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"TypeVarExpr","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","name":"_TypeT","upper_bound":"builtins.type","values":[],"variance":0}},"__all__":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"Var","flags":["is_inferred","has_explicit_value"],"fullname":"pydantic.config.__all__","name":"__all__","type":{".class":"TupleType","implicit":false,"items":["builtins.str","builtins.str"],"partial_fallback":{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.tuple"}}}},"__annotations__":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"Var","flags":["is_ready"],"fullname":"pydantic.config.__annotations__","name":"__annotations__","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"__doc__":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"Var","flags":["is_ready"],"fullname":"pydantic.config.__doc__","name":"__doc__","type":"builtins.str"}},"__file__":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"Var","flags":["is_ready"],"fullname":"pydantic.config.__file__","name":"__file__","type":"builtins.str"}},"__getattr__":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"Var","flags":["is_inferred","has_explicit_value"],"fullname":"pydantic.config.__getattr__","name":"__getattr__","type":{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["builtins.str"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"__name__":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"Var","flags":["is_ready"],"fullname":"pydantic.config.__name__","name":"__name__","type":"builtins.str"}},"__package__":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"Var","flags":["is_ready"],"fullname":"pydantic.config.__package__","name":"__package__","type":"builtins.str"}},"__spec__":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"Var","flags":["is_ready"],"fullname":"pydantic.config.__spec__","name":"__spec__","type":"_frozen_importlib.ModuleSpec"}},"_annotations":{".class":"SymbolTableNode","cross_ref":"__future__.annotations","kind":"Gdef","module_public":false},"cast":{".class":"SymbolTableNode","cross_ref":"typing.cast","kind":"Gdef","module_public":false},"deprecated":{".class":"SymbolTableNode","cross_ref":"warnings.deprecated","kind":"Gdef","module_public":false},"getattr_migration":{".class":"SymbolTableNode","cross_ref":"pydantic._migration.getattr_migration","kind":"Gdef","module_public":false},"overload":{".class":"SymbolTableNode","cross_ref":"typing.overload","kind":"Gdef","module_public":false},"warnings":{".class":"SymbolTableNode","cross_ref":"warnings","kind":"Gdef","module_public":false},"with_config":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"OverloadedFuncDef","deprecated":null,"flags":[],"fullname":"pydantic.config.with_config","impl":{".class":"FuncDef","abstract_status":0,"arg_kinds":[1,4],"arg_names":[null,"kwargs"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload"],"fullname":"pydantic.config.with_config","name":"with_config","type":{".class":"CallableType","arg_kinds":[1,4],"arg_names":[null,"kwargs"],"arg_types":[{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"pydantic.config.ConfigDict"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"with_config","ret_type":{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0}],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0}]},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"items":[{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[3],"arg_names":["config"],"dataclass_transform_spec":null,"deprecated":"overload def (*, config: TypedDict('pydantic.config.ConfigDict', {'title'?: Union[builtins.str, None], 'model_title_generator'?: Union[def (builtins.type) -> builtins.str, None], 'field_title_generator'?: Union[def (builtins.str, Union[pydantic.fields.FieldInfo, pydantic.fields.ComputedFieldInfo]) -> builtins.str, None], 'str_to_lower'?: builtins.bool, 'str_to_upper'?: builtins.bool, 'str_strip_whitespace'?: builtins.bool, 'str_min_length'?: builtins.int, 'str_max_length'?: Union[builtins.int, None], 'extra'?: Union[Literal['allow'], Literal['ignore'], Literal['forbid'], None], 'frozen'?: builtins.bool, 'populate_by_name'?: builtins.bool, 'use_enum_values'?: builtins.bool, 'validate_assignment'?: builtins.bool, 'arbitrary_types_allowed'?: builtins.bool, 'from_attributes'?: builtins.bool, 'loc_by_alias'?: builtins.bool, 'alias_generator'?: Union[def (builtins.str) -> builtins.str, pydantic.aliases.AliasGenerator, None], 'ignored_types'?: builtins.tuple[builtins.type, ...], 'allow_inf_nan'?: builtins.bool, 'json_schema_extra'?: Union[builtins.dict[builtins.str, Union[builtins.int, builtins.float, builtins.str, builtins.bool, None, builtins.list[...], ...]], def (builtins.dict[builtins.str, Union[builtins.int, builtins.float, builtins.str, builtins.bool, None, builtins.list[...], ...]]), def (builtins.dict[builtins.str, Union[builtins.int, builtins.float, builtins.str, builtins.bool, None, builtins.list[...], ...]], type[...]), None], 'json_encoders'?: Union[builtins.dict[type[builtins.object], def (...) -> ...], None], 'strict'?: builtins.bool, 'revalidate_instances'?: Union[Literal['always'], Literal['never'], Literal['subclass-instances']], 'ser_json_timedelta'?: Union[Literal['iso8601'], Literal['float']], 'ser_json_bytes'?: Union[Literal['utf8'], Literal['base64'], Literal['hex']], 'val_json_bytes'?: Union[Literal['utf8'], Literal['base64'], Literal['hex']], 'ser_json_inf_nan'?: Union[Literal['null'], Literal['constants'], Literal['strings']], 'validate_default'?: builtins.bool, 'validate_return'?: builtins.bool, 'protected_namespaces'?: builtins.tuple[Union[builtins.str, re.Pattern[builtins.str]], ...], 'hide_input_in_errors'?: builtins.bool, 'defer_build'?: builtins.bool, 'plugin_settings'?: Union[builtins.dict[builtins.str, builtins.object], None], 'schema_generator'?: Union[type[pydantic._internal._generate_schema.GenerateSchema], None], 'json_schema_serialization_defaults_required'?: builtins.bool, 'json_schema_mode_override'?: Union[Literal['validation'], Literal['serialization'], None], 'coerce_numbers_to_str'?: builtins.bool, 'regex_engine'?: Union[Literal['rust-regex'], Literal['python-re']], 'validation_error_cause'?: builtins.bool, 'use_attribute_docstrings'?: builtins.bool, 'cache_strings'?: Union[builtins.bool, Literal['all'], Literal['keys'], Literal['none']], 'validate_by_alias'?: builtins.bool, 'validate_by_name'?: builtins.bool, 'serialize_by_alias'?: builtins.bool})) -> def [_TypeT <: builtins.type] (_TypeT`-1) -> _TypeT`-1 of function pydantic.config.with_config is deprecated: Passing `config` as a keyword argument is deprecated. Pass `config` as a positional argument instead.","flags":["is_overload","is_decorated"],"fullname":"pydantic.config.with_config","name":"with_config","type":{".class":"CallableType","arg_kinds":[3],"arg_names":["config"],"arg_types":[{".class":"TypeAliasType","args":[],"type_ref":"pydantic.config.ConfigDict"}],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"with_config","ret_type":{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0}],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0}]},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"pydantic.config.with_config","name":"with_config","type":{".class":"CallableType","arg_kinds":[3],"arg_names":["config"],"arg_types":[{".class":"TypeAliasType","args":[],"type_ref":"pydantic.config.ConfigDict"}],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"with_config","ret_type":{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0}],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0}]},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":[null],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated"],"fullname":"pydantic.config.with_config","name":"with_config","type":{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":[{".class":"TypeAliasType","args":[],"type_ref":"pydantic.config.ConfigDict"}],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"with_config","ret_type":{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0}],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0}]},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"pydantic.config.with_config","name":"with_config","type":{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":[{".class":"TypeAliasType","args":[],"type_ref":"pydantic.config.ConfigDict"}],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"with_config","ret_type":{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0}],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0}]},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[4],"arg_names":["config"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated"],"fullname":"pydantic.config.with_config","name":"with_config","type":{".class":"CallableType","arg_kinds":[4],"arg_names":["config"],"arg_types":[{".class":"TypedDictType","fallback":"pydantic.config.ConfigDict","items":[["title",{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}],["model_title_generator",{".class":"UnionType","items":[{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["builtins.type"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"NoneType"}],"uses_pep604_syntax":true}],["field_title_generator",{".class":"UnionType","items":[{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":["builtins.str",{".class":"UnionType","items":["pydantic.fields.FieldInfo","pydantic.fields.ComputedFieldInfo"],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"NoneType"}],"uses_pep604_syntax":true}],["str_to_lower","builtins.bool"],["str_to_upper","builtins.bool"],["str_strip_whitespace","builtins.bool"],["str_min_length","builtins.int"],["str_max_length",{".class":"UnionType","items":["builtins.int",{".class":"NoneType"}],"uses_pep604_syntax":true}],["extra",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"pydantic.config.ExtraValues"},{".class":"NoneType"}],"uses_pep604_syntax":true}],["frozen","builtins.bool"],["populate_by_name","builtins.bool"],["use_enum_values","builtins.bool"],["validate_assignment","builtins.bool"],["arbitrary_types_allowed","builtins.bool"],["from_attributes","builtins.bool"],["loc_by_alias","builtins.bool"],["alias_generator",{".class":"UnionType","items":[{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["builtins.str"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},"pydantic.aliases.AliasGenerator",{".class":"NoneType"}],"uses_pep604_syntax":true}],["ignored_types",{".class":"Instance","args":["builtins.type"],"extra_attrs":null,"type_ref":"builtins.tuple"}],["allow_inf_nan","builtins.bool"],["json_schema_extra",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"pydantic.config.JsonDict"},{".class":"TypeAliasType","args":[],"type_ref":"pydantic.config.JsonSchemaExtraCallable"},{".class":"NoneType"}],"uses_pep604_syntax":true}],["json_encoders",{".class":"UnionType","items":[{".class":"Instance","args":[{".class":"TypeType","item":"builtins.object"},{".class":"TypeAliasType","args":[],"type_ref":"pydantic.config.JsonEncoder"}],"extra_attrs":null,"type_ref":"builtins.dict"},{".class":"NoneType"}],"uses_pep604_syntax":true}],["strict","builtins.bool"],["revalidate_instances",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"always"},{".class":"LiteralType","fallback":"builtins.str","value":"never"},{".class":"LiteralType","fallback":"builtins.str","value":"subclass-instances"}],"uses_pep604_syntax":false}],["ser_json_timedelta",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"iso8601"},{".class":"LiteralType","fallback":"builtins.str","value":"float"}],"uses_pep604_syntax":false}],["ser_json_bytes",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"utf8"},{".class":"LiteralType","fallback":"builtins.str","value":"base64"},{".class":"LiteralType","fallback":"builtins.str","value":"hex"}],"uses_pep604_syntax":false}],["val_json_bytes",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"utf8"},{".class":"LiteralType","fallback":"builtins.str","value":"base64"},{".class":"LiteralType","fallback":"builtins.str","value":"hex"}],"uses_pep604_syntax":false}],["ser_json_inf_nan",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"null"},{".class":"LiteralType","fallback":"builtins.str","value":"constants"},{".class":"LiteralType","fallback":"builtins.str","value":"strings"}],"uses_pep604_syntax":false}],["validate_default","builtins.bool"],["validate_return","builtins.bool"],["protected_namespaces",{".class":"Instance","args":[{".class":"UnionType","items":["builtins.str",{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"re.Pattern"}],"uses_pep604_syntax":true}],"extra_attrs":null,"type_ref":"builtins.tuple"}],["hide_input_in_errors","builtins.bool"],["defer_build","builtins.bool"],["plugin_settings",{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str","builtins.object"],"extra_attrs":null,"type_ref":"builtins.dict"},{".class":"NoneType"}],"uses_pep604_syntax":true}],["schema_generator",{".class":"UnionType","items":[{".class":"TypeType","item":"pydantic._internal._generate_schema.GenerateSchema"},{".class":"NoneType"}],"uses_pep604_syntax":true}],["json_schema_serialization_defaults_required","builtins.bool"],["json_schema_mode_override",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"validation"},{".class":"LiteralType","fallback":"builtins.str","value":"serialization"},{".class":"NoneType"}],"uses_pep604_syntax":false}],["coerce_numbers_to_str","builtins.bool"],["regex_engine",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"rust-regex"},{".class":"LiteralType","fallback":"builtins.str","value":"python-re"}],"uses_pep604_syntax":false}],["validation_error_cause","builtins.bool"],["use_attribute_docstrings","builtins.bool"],["cache_strings",{".class":"UnionType","items":["builtins.bool",{".class":"LiteralType","fallback":"builtins.str","value":"all"},{".class":"LiteralType","fallback":"builtins.str","value":"keys"},{".class":"LiteralType","fallback":"builtins.str","value":"none"}],"uses_pep604_syntax":true}],["validate_by_alias","builtins.bool"],["validate_by_name","builtins.bool"],["serialize_by_alias","builtins.bool"]],"readonly_keys":[],"required_keys":[]}],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"with_config","ret_type":{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0}],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0}]},"type_guard":null,"type_is":null,"unpack_kwargs":true,"variables":[]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"pydantic.config.with_config","name":"with_config","type":{".class":"CallableType","arg_kinds":[4],"arg_names":["config"],"arg_types":[{".class":"TypedDictType","fallback":"pydantic.config.ConfigDict","items":[["title",{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}],["model_title_generator",{".class":"UnionType","items":[{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["builtins.type"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"NoneType"}],"uses_pep604_syntax":true}],["field_title_generator",{".class":"UnionType","items":[{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":["builtins.str",{".class":"UnionType","items":["pydantic.fields.FieldInfo","pydantic.fields.ComputedFieldInfo"],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"NoneType"}],"uses_pep604_syntax":true}],["str_to_lower","builtins.bool"],["str_to_upper","builtins.bool"],["str_strip_whitespace","builtins.bool"],["str_min_length","builtins.int"],["str_max_length",{".class":"UnionType","items":["builtins.int",{".class":"NoneType"}],"uses_pep604_syntax":true}],["extra",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"pydantic.config.ExtraValues"},{".class":"NoneType"}],"uses_pep604_syntax":true}],["frozen","builtins.bool"],["populate_by_name","builtins.bool"],["use_enum_values","builtins.bool"],["validate_assignment","builtins.bool"],["arbitrary_types_allowed","builtins.bool"],["from_attributes","builtins.bool"],["loc_by_alias","builtins.bool"],["alias_generator",{".class":"UnionType","items":[{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["builtins.str"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},"pydantic.aliases.AliasGenerator",{".class":"NoneType"}],"uses_pep604_syntax":true}],["ignored_types",{".class":"Instance","args":["builtins.type"],"extra_attrs":null,"type_ref":"builtins.tuple"}],["allow_inf_nan","builtins.bool"],["json_schema_extra",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"pydantic.config.JsonDict"},{".class":"TypeAliasType","args":[],"type_ref":"pydantic.config.JsonSchemaExtraCallable"},{".class":"NoneType"}],"uses_pep604_syntax":true}],["json_encoders",{".class":"UnionType","items":[{".class":"Instance","args":[{".class":"TypeType","item":"builtins.object"},{".class":"TypeAliasType","args":[],"type_ref":"pydantic.config.JsonEncoder"}],"extra_attrs":null,"type_ref":"builtins.dict"},{".class":"NoneType"}],"uses_pep604_syntax":true}],["strict","builtins.bool"],["revalidate_instances",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"always"},{".class":"LiteralType","fallback":"builtins.str","value":"never"},{".class":"LiteralType","fallback":"builtins.str","value":"subclass-instances"}],"uses_pep604_syntax":false}],["ser_json_timedelta",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"iso8601"},{".class":"LiteralType","fallback":"builtins.str","value":"float"}],"uses_pep604_syntax":false}],["ser_json_bytes",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"utf8"},{".class":"LiteralType","fallback":"builtins.str","value":"base64"},{".class":"LiteralType","fallback":"builtins.str","value":"hex"}],"uses_pep604_syntax":false}],["val_json_bytes",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"utf8"},{".class":"LiteralType","fallback":"builtins.str","value":"base64"},{".class":"LiteralType","fallback":"builtins.str","value":"hex"}],"uses_pep604_syntax":false}],["ser_json_inf_nan",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"null"},{".class":"LiteralType","fallback":"builtins.str","value":"constants"},{".class":"LiteralType","fallback":"builtins.str","value":"strings"}],"uses_pep604_syntax":false}],["validate_default","builtins.bool"],["validate_return","builtins.bool"],["protected_namespaces",{".class":"Instance","args":[{".class":"UnionType","items":["builtins.str",{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"re.Pattern"}],"uses_pep604_syntax":true}],"extra_attrs":null,"type_ref":"builtins.tuple"}],["hide_input_in_errors","builtins.bool"],["defer_build","builtins.bool"],["plugin_settings",{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str","builtins.object"],"extra_attrs":null,"type_ref":"builtins.dict"},{".class":"NoneType"}],"uses_pep604_syntax":true}],["schema_generator",{".class":"UnionType","items":[{".class":"TypeType","item":"pydantic._internal._generate_schema.GenerateSchema"},{".class":"NoneType"}],"uses_pep604_syntax":true}],["json_schema_serialization_defaults_required","builtins.bool"],["json_schema_mode_override",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"validation"},{".class":"LiteralType","fallback":"builtins.str","value":"serialization"},{".class":"NoneType"}],"uses_pep604_syntax":false}],["coerce_numbers_to_str","builtins.bool"],["regex_engine",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"rust-regex"},{".class":"LiteralType","fallback":"builtins.str","value":"python-re"}],"uses_pep604_syntax":false}],["validation_error_cause","builtins.bool"],["use_attribute_docstrings","builtins.bool"],["cache_strings",{".class":"UnionType","items":["builtins.bool",{".class":"LiteralType","fallback":"builtins.str","value":"all"},{".class":"LiteralType","fallback":"builtins.str","value":"keys"},{".class":"LiteralType","fallback":"builtins.str","value":"none"}],"uses_pep604_syntax":true}],["validate_by_alias","builtins.bool"],["validate_by_name","builtins.bool"],["serialize_by_alias","builtins.bool"]],"readonly_keys":[],"required_keys":[]}],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"with_config","ret_type":{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0}],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0}]},"type_guard":null,"type_is":null,"unpack_kwargs":true,"variables":[]}}}],"type":{".class":"Overloaded","items":[{".class":"CallableType","arg_kinds":[3],"arg_names":["config"],"arg_types":[{".class":"TypeAliasType","args":[],"type_ref":"pydantic.config.ConfigDict"}],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"with_config","ret_type":{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0}],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0}]},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":[{".class":"TypeAliasType","args":[],"type_ref":"pydantic.config.ConfigDict"}],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"with_config","ret_type":{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0}],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0}]},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"CallableType","arg_kinds":[4],"arg_names":["config"],"arg_types":[{".class":"TypedDictType","fallback":"pydantic.config.ConfigDict","items":[["title",{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}],["model_title_generator",{".class":"UnionType","items":[{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["builtins.type"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"NoneType"}],"uses_pep604_syntax":true}],["field_title_generator",{".class":"UnionType","items":[{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":["builtins.str",{".class":"UnionType","items":["pydantic.fields.FieldInfo","pydantic.fields.ComputedFieldInfo"],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"NoneType"}],"uses_pep604_syntax":true}],["str_to_lower","builtins.bool"],["str_to_upper","builtins.bool"],["str_strip_whitespace","builtins.bool"],["str_min_length","builtins.int"],["str_max_length",{".class":"UnionType","items":["builtins.int",{".class":"NoneType"}],"uses_pep604_syntax":true}],["extra",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"pydantic.config.ExtraValues"},{".class":"NoneType"}],"uses_pep604_syntax":true}],["frozen","builtins.bool"],["populate_by_name","builtins.bool"],["use_enum_values","builtins.bool"],["validate_assignment","builtins.bool"],["arbitrary_types_allowed","builtins.bool"],["from_attributes","builtins.bool"],["loc_by_alias","builtins.bool"],["alias_generator",{".class":"UnionType","items":[{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["builtins.str"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},"pydantic.aliases.AliasGenerator",{".class":"NoneType"}],"uses_pep604_syntax":true}],["ignored_types",{".class":"Instance","args":["builtins.type"],"extra_attrs":null,"type_ref":"builtins.tuple"}],["allow_inf_nan","builtins.bool"],["json_schema_extra",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"pydantic.config.JsonDict"},{".class":"TypeAliasType","args":[],"type_ref":"pydantic.config.JsonSchemaExtraCallable"},{".class":"NoneType"}],"uses_pep604_syntax":true}],["json_encoders",{".class":"UnionType","items":[{".class":"Instance","args":[{".class":"TypeType","item":"builtins.object"},{".class":"TypeAliasType","args":[],"type_ref":"pydantic.config.JsonEncoder"}],"extra_attrs":null,"type_ref":"builtins.dict"},{".class":"NoneType"}],"uses_pep604_syntax":true}],["strict","builtins.bool"],["revalidate_instances",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"always"},{".class":"LiteralType","fallback":"builtins.str","value":"never"},{".class":"LiteralType","fallback":"builtins.str","value":"subclass-instances"}],"uses_pep604_syntax":false}],["ser_json_timedelta",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"iso8601"},{".class":"LiteralType","fallback":"builtins.str","value":"float"}],"uses_pep604_syntax":false}],["ser_json_bytes",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"utf8"},{".class":"LiteralType","fallback":"builtins.str","value":"base64"},{".class":"LiteralType","fallback":"builtins.str","value":"hex"}],"uses_pep604_syntax":false}],["val_json_bytes",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"utf8"},{".class":"LiteralType","fallback":"builtins.str","value":"base64"},{".class":"LiteralType","fallback":"builtins.str","value":"hex"}],"uses_pep604_syntax":false}],["ser_json_inf_nan",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"null"},{".class":"LiteralType","fallback":"builtins.str","value":"constants"},{".class":"LiteralType","fallback":"builtins.str","value":"strings"}],"uses_pep604_syntax":false}],["validate_default","builtins.bool"],["validate_return","builtins.bool"],["protected_namespaces",{".class":"Instance","args":[{".class":"UnionType","items":["builtins.str",{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"re.Pattern"}],"uses_pep604_syntax":true}],"extra_attrs":null,"type_ref":"builtins.tuple"}],["hide_input_in_errors","builtins.bool"],["defer_build","builtins.bool"],["plugin_settings",{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str","builtins.object"],"extra_attrs":null,"type_ref":"builtins.dict"},{".class":"NoneType"}],"uses_pep604_syntax":true}],["schema_generator",{".class":"UnionType","items":[{".class":"TypeType","item":"pydantic._internal._generate_schema.GenerateSchema"},{".class":"NoneType"}],"uses_pep604_syntax":true}],["json_schema_serialization_defaults_required","builtins.bool"],["json_schema_mode_override",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"validation"},{".class":"LiteralType","fallback":"builtins.str","value":"serialization"},{".class":"NoneType"}],"uses_pep604_syntax":false}],["coerce_numbers_to_str","builtins.bool"],["regex_engine",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"rust-regex"},{".class":"LiteralType","fallback":"builtins.str","value":"python-re"}],"uses_pep604_syntax":false}],["validation_error_cause","builtins.bool"],["use_attribute_docstrings","builtins.bool"],["cache_strings",{".class":"UnionType","items":["builtins.bool",{".class":"LiteralType","fallback":"builtins.str","value":"all"},{".class":"LiteralType","fallback":"builtins.str","value":"keys"},{".class":"LiteralType","fallback":"builtins.str","value":"none"}],"uses_pep604_syntax":true}],["validate_by_alias","builtins.bool"],["validate_by_name","builtins.bool"],["serialize_by_alias","builtins.bool"]],"readonly_keys":[],"required_keys":[]}],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"with_config","ret_type":{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0}],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.config._TypeT","id":-1,"name":"_TypeT","namespace":"","upper_bound":"builtins.type","values":[],"variance":0}]},"type_guard":null,"type_is":null,"unpack_kwargs":true,"variables":[]}]}}}},"path":"/Users/yeogirlyun/Python/Poker/.venv/lib/python3.13/site-packages/pydantic/config.py"}
```

---

### config.meta.json

**Path**: `.mypy_cache/3.13/pydantic/config.meta.json`

**Size**: 1.8 KB

```json
{"data_mtime":1755238597,"dep_lines":[17,11,12,13,14,18,3,5,6,7,9,1,1,1,1,1,1],"dep_prios":[25,5,5,5,5,25,5,10,5,5,5,5,30,30,30,30,30],"dependencies":["pydantic._internal._generate_schema","pydantic._migration","pydantic.aliases","pydantic.errors","pydantic.warnings","pydantic.fields","__future__","warnings","re","typing","typing_extensions","builtins","_frozen_importlib","_typeshed","abc","pydantic._internal","pydantic._internal._repr"],"hash":"9899f9cd5d39e5b9f40a748aabf1fe25837b358e","id":"pydantic.config","ignore_all":true,"interface_hash":"d524a96081ebd7ce6be3c83ade9fe23a95178f53","mtime":1754977747,"options":{"allow_redefinition":false,"allow_untyped_globals":false,"always_false":[],"always_true":[],"bazel":false,"check_untyped_defs":false,"disable_bytearray_promotion":false,"disable_error_code":[],"disable_memoryview_promotion":false,"disabled_error_codes":[],"disallow_any_decorated":false,"disallow_any_explicit":false,"disallow_any_expr":false,"disallow_any_generics":false,"disallow_any_unimported":false,"disallow_incomplete_defs":false,"disallow_subclassing_any":false,"disallow_untyped_calls":false,"disallow_untyped_decorators":false,"disallow_untyped_defs":false,"enable_error_code":[],"enabled_error_codes":[],"extra_checks":false,"follow_imports":"normal","follow_imports_for_stubs":false,"follow_untyped_imports":false,"ignore_errors":false,"ignore_missing_imports":false,"implicit_optional":false,"implicit_reexport":true,"local_partial_types":false,"mypyc":false,"old_type_inference":false,"platform":"darwin","plugins":[],"strict_concatenate":false,"strict_equality":false,"strict_optional":true,"warn_no_return":true,"warn_return_any":false,"warn_unreachable":false,"warn_unused_ignores":false},"path":"/Users/yeogirlyun/Python/Poker/.venv/lib/python3.13/site-packages/pydantic/config.py","plugin_data":null,"size":42048,"suppressed":[],"version_id":"1.14.1"}
```

---

### config.data.json

**Path**: `.mypy_cache/3.13/pydantic/deprecated/config.data.json`

**Size**: 11.6 KB

```json
{".class":"MypyFile","_fullname":"pydantic.deprecated.config","future_import_flags":["annotations"],"is_partial_stub_package":false,"is_stub":false,"names":{".class":"SymbolTable","Any":{".class":"SymbolTableNode","cross_ref":"typing.Any","kind":"Gdef","module_public":false},"BaseConfig":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["builtins.object"],"dataclass_transform_spec":null,"declared_metaclass":"pydantic.deprecated.config._ConfigMetaclass","defn":{".class":"ClassDef","fullname":"pydantic.deprecated.config.BaseConfig","name":"BaseConfig","type_vars":[]},"deletable_attributes":[],"deprecated":"class pydantic.deprecated.config.BaseConfig is deprecated: BaseConfig is deprecated. Use the `pydantic.ConfigDict` instead.","flags":[],"fullname":"pydantic.deprecated.config.BaseConfig","has_param_spec_type":false,"metaclass_type":"pydantic.deprecated.config._ConfigMetaclass","metadata":{},"module_name":"pydantic.deprecated.config","mro":["pydantic.deprecated.config.BaseConfig","builtins.object"],"names":{".class":"SymbolTable","__getattr__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":[null,null],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"pydantic.deprecated.config.BaseConfig.__getattr__","name":"__getattr__","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":["pydantic.deprecated.config.BaseConfig","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__getattr__ of BaseConfig","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"__init_subclass__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,4],"arg_names":["cls","kwargs"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_class"],"fullname":"pydantic.deprecated.config.BaseConfig.__init_subclass__","name":"__init_subclass__","type":{".class":"CallableType","arg_kinds":[0,4],"arg_names":["cls","kwargs"],"arg_types":[{".class":"TypeType","item":"pydantic.deprecated.config.BaseConfig"},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"bound_args":[],"def_extras":{"first_arg":"cls"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init_subclass__ of BaseConfig","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.deprecated.config.BaseConfig.Self","id":0,"name":"Self","namespace":"","upper_bound":"pydantic.deprecated.config.BaseConfig","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"Extra":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["builtins.object"],"dataclass_transform_spec":null,"declared_metaclass":"pydantic.deprecated.config._ExtraMeta","defn":{".class":"ClassDef","fullname":"pydantic.deprecated.config.Extra","name":"Extra","type_vars":[]},"deletable_attributes":[],"deprecated":"class pydantic.deprecated.config.Extra is deprecated: Extra is deprecated. Use literal values instead (e.g. `extra='allow'`)","flags":[],"fullname":"pydantic.deprecated.config.Extra","has_param_spec_type":false,"metaclass_type":"pydantic.deprecated.config._ExtraMeta","metadata":{},"module_name":"pydantic.deprecated.config","mro":["pydantic.deprecated.config.Extra","builtins.object"],"names":{".class":"SymbolTable","allow":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.deprecated.config.Extra.allow","name":"allow","type":{".class":"LiteralType","fallback":"builtins.str","value":"allow"}}},"forbid":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.deprecated.config.Extra.forbid","name":"forbid","type":{".class":"LiteralType","fallback":"builtins.str","value":"forbid"}}},"ignore":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.deprecated.config.Extra.ignore","name":"ignore","type":{".class":"LiteralType","fallback":"builtins.str","value":"ignore"}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.deprecated.config.Extra.Self","id":0,"name":"Self","namespace":"","upper_bound":"pydantic.deprecated.config.Extra","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"Literal":{".class":"SymbolTableNode","cross_ref":"typing.Literal","kind":"Gdef","module_public":false},"PydanticDeprecatedSince20":{".class":"SymbolTableNode","cross_ref":"pydantic.warnings.PydanticDeprecatedSince20","kind":"Gdef","module_public":false},"TYPE_CHECKING":{".class":"SymbolTableNode","cross_ref":"typing.TYPE_CHECKING","kind":"Gdef","module_public":false},"_ConfigMetaclass":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["builtins.type"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"pydantic.deprecated.config._ConfigMetaclass","name":"_ConfigMetaclass","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"pydantic.deprecated.config._ConfigMetaclass","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"pydantic.deprecated.config","mro":["pydantic.deprecated.config._ConfigMetaclass","builtins.type","builtins.object"],"names":{".class":"SymbolTable","__getattr__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":[null,null],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"pydantic.deprecated.config._ConfigMetaclass.__getattr__","name":"__getattr__","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":["pydantic.deprecated.config._ConfigMetaclass","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__getattr__ of _ConfigMetaclass","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.deprecated.config._ConfigMetaclass.Self","id":0,"name":"Self","namespace":"","upper_bound":"pydantic.deprecated.config._ConfigMetaclass","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"_ExtraMeta":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["builtins.type"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"pydantic.deprecated.config._ExtraMeta","name":"_ExtraMeta","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"pydantic.deprecated.config._ExtraMeta","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"pydantic.deprecated.config","mro":["pydantic.deprecated.config._ExtraMeta","builtins.type","builtins.object"],"names":{".class":"SymbolTable","__getattribute__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":[null,null],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"pydantic.deprecated.config._ExtraMeta.__getattribute__","name":"__getattribute__","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":[null,null],"arg_types":["pydantic.deprecated.config._ExtraMeta","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__getattribute__ of _ExtraMeta","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.deprecated.config._ExtraMeta.Self","id":0,"name":"Self","namespace":"","upper_bound":"pydantic.deprecated.config._ExtraMeta","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"__all__":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"Var","flags":["is_inferred","has_explicit_value"],"fullname":"pydantic.deprecated.config.__all__","name":"__all__","type":{".class":"TupleType","implicit":false,"items":["builtins.str","builtins.str"],"partial_fallback":{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.tuple"}}}},"__annotations__":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"Var","flags":["is_ready"],"fullname":"pydantic.deprecated.config.__annotations__","name":"__annotations__","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"__doc__":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"Var","flags":["is_ready"],"fullname":"pydantic.deprecated.config.__doc__","name":"__doc__","type":"builtins.str"}},"__file__":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"Var","flags":["is_ready"],"fullname":"pydantic.deprecated.config.__file__","name":"__file__","type":"builtins.str"}},"__name__":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"Var","flags":["is_ready"],"fullname":"pydantic.deprecated.config.__name__","name":"__name__","type":"builtins.str"}},"__package__":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"Var","flags":["is_ready"],"fullname":"pydantic.deprecated.config.__package__","name":"__package__","type":"builtins.str"}},"__spec__":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"Var","flags":["is_ready"],"fullname":"pydantic.deprecated.config.__spec__","name":"__spec__","type":"_frozen_importlib.ModuleSpec"}},"_annotations":{".class":"SymbolTableNode","cross_ref":"__future__.annotations","kind":"Gdef","module_public":false},"_config":{".class":"SymbolTableNode","cross_ref":"pydantic._internal._config","kind":"Gdef","module_public":false},"deprecated":{".class":"SymbolTableNode","cross_ref":"warnings.deprecated","kind":"Gdef","module_public":false},"warnings":{".class":"SymbolTableNode","cross_ref":"warnings","kind":"Gdef","module_public":false}},"path":"/Users/yeogirlyun/Python/Poker/.venv/lib/python3.13/site-packages/pydantic/deprecated/config.py"}
```

---

### config.meta.json

**Path**: `.mypy_cache/3.13/pydantic/deprecated/config.meta.json`

**Size**: 1.7 KB

```json
{"data_mtime":1755238597,"dep_lines":[8,8,9,1,3,4,6,1,1,1],"dep_prios":[10,20,5,5,10,5,5,5,30,30],"dependencies":["pydantic._internal._config","pydantic._internal","pydantic.warnings","__future__","warnings","typing","typing_extensions","builtins","_frozen_importlib","abc"],"hash":"f48eb0b69adaac6686e01eddd666c88d4fc84d2d","id":"pydantic.deprecated.config","ignore_all":true,"interface_hash":"1a6497a3053483e3724bb5b9da7d5627a17af577","mtime":1754977747,"options":{"allow_redefinition":false,"allow_untyped_globals":false,"always_false":[],"always_true":[],"bazel":false,"check_untyped_defs":false,"disable_bytearray_promotion":false,"disable_error_code":[],"disable_memoryview_promotion":false,"disabled_error_codes":[],"disallow_any_decorated":false,"disallow_any_explicit":false,"disallow_any_expr":false,"disallow_any_generics":false,"disallow_any_unimported":false,"disallow_incomplete_defs":false,"disallow_subclassing_any":false,"disallow_untyped_calls":false,"disallow_untyped_decorators":false,"disallow_untyped_defs":false,"enable_error_code":[],"enabled_error_codes":[],"extra_checks":false,"follow_imports":"normal","follow_imports_for_stubs":false,"follow_untyped_imports":false,"ignore_errors":false,"ignore_missing_imports":false,"implicit_optional":false,"implicit_reexport":true,"local_partial_types":false,"mypyc":false,"old_type_inference":false,"platform":"darwin","plugins":[],"strict_concatenate":false,"strict_equality":false,"strict_optional":true,"warn_no_return":true,"warn_return_any":false,"warn_unreachable":false,"warn_unused_ignores":false},"path":"/Users/yeogirlyun/Python/Poker/.venv/lib/python3.13/site-packages/pydantic/deprecated/config.py","plugin_data":null,"size":2663,"suppressed":[],"version_id":"1.14.1"}
```

---

### config.data.json

**Path**: `.mypy_cache/3.13/pydantic/v1/config.data.json`

**Size**: 34.3 KB

```json
{".class":"MypyFile","_fullname":"pydantic.v1.config","future_import_flags":[],"is_partial_stub_package":false,"is_stub":false,"names":{".class":"SymbolTable","Any":{".class":"SymbolTableNode","cross_ref":"typing.Any","kind":"Gdef","module_public":false},"AnyArgTCallable":{".class":"SymbolTableNode","cross_ref":"pydantic.v1.typing.AnyArgTCallable","kind":"Gdef","module_public":false},"AnyCallable":{".class":"SymbolTableNode","cross_ref":"pydantic.v1.typing.AnyCallable","kind":"Gdef","module_public":false},"BaseConfig":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["builtins.object"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"pydantic.v1.config.BaseConfig","name":"BaseConfig","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"pydantic.v1.config.BaseConfig","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"pydantic.v1.config","mro":["pydantic.v1.config.BaseConfig","builtins.object"],"names":{".class":"SymbolTable","alias_generator":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.v1.config.BaseConfig.alias_generator","name":"alias_generator","type":{".class":"UnionType","items":[{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["builtins.str"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"NoneType"}],"uses_pep604_syntax":false}}},"allow_inf_nan":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.v1.config.BaseConfig.allow_inf_nan","name":"allow_inf_nan","type":"builtins.bool"}},"allow_mutation":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.v1.config.BaseConfig.allow_mutation","name":"allow_mutation","type":"builtins.bool"}},"allow_population_by_field_name":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.v1.config.BaseConfig.allow_population_by_field_name","name":"allow_population_by_field_name","type":"builtins.bool"}},"anystr_lower":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.v1.config.BaseConfig.anystr_lower","name":"anystr_lower","type":"builtins.bool"}},"anystr_strip_whitespace":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.v1.config.BaseConfig.anystr_strip_whitespace","name":"anystr_strip_whitespace","type":"builtins.bool"}},"anystr_upper":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.v1.config.BaseConfig.anystr_upper","name":"anystr_upper","type":"builtins.bool"}},"arbitrary_types_allowed":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.v1.config.BaseConfig.arbitrary_types_allowed","name":"arbitrary_types_allowed","type":"builtins.bool"}},"copy_on_model_validation":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.v1.config.BaseConfig.copy_on_model_validation","name":"copy_on_model_validation","type":{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"none"},{".class":"LiteralType","fallback":"builtins.str","value":"deep"},{".class":"LiteralType","fallback":"builtins.str","value":"shallow"}],"uses_pep604_syntax":false}}},"error_msg_templates":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.v1.config.BaseConfig.error_msg_templates","name":"error_msg_templates","type":{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"builtins.dict"}}},"extra":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.v1.config.BaseConfig.extra","name":"extra","type":"pydantic.v1.config.Extra"}},"fields":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.v1.config.BaseConfig.fields","name":"fields","type":{".class":"Instance","args":["builtins.str",{".class":"UnionType","items":["builtins.str",{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"builtins.dict"}],"uses_pep604_syntax":false}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"frozen":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.v1.config.BaseConfig.frozen","name":"frozen","type":"builtins.bool"}},"get_field_info":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["cls","name"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_class","is_decorated"],"fullname":"pydantic.v1.config.BaseConfig.get_field_info","name":"get_field_info","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["cls","name"],"arg_types":[{".class":"TypeType","item":"pydantic.v1.config.BaseConfig"},"builtins.str"],"bound_args":[],"def_extras":{"first_arg":"cls"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_field_info of BaseConfig","ret_type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":false,"var":{".class":"Var","flags":["is_initialized_in_class","is_classmethod","is_ready","is_inferred"],"fullname":"pydantic.v1.config.BaseConfig.get_field_info","name":"get_field_info","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["cls","name"],"arg_types":[{".class":"TypeType","item":"pydantic.v1.config.BaseConfig"},"builtins.str"],"bound_args":[],"def_extras":{"first_arg":"cls"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_field_info of BaseConfig","ret_type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"getter_dict":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.v1.config.BaseConfig.getter_dict","name":"getter_dict","type":{".class":"TypeType","item":"pydantic.v1.utils.GetterDict"}}},"json_dumps":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.v1.config.BaseConfig.json_dumps","name":"json_dumps","type":{".class":"CallableType","arg_kinds":[2,4],"arg_names":[null,null],"arg_types":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":true,"name":null,"ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"json_encoders":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.v1.config.BaseConfig.json_encoders","name":"json_encoders","type":{".class":"Instance","args":[{".class":"UnionType","items":[{".class":"TypeType","item":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}},"builtins.str","typing.ForwardRef"],"uses_pep604_syntax":false},{".class":"TypeAliasType","args":[],"type_ref":"pydantic.v1.typing.AnyCallable"}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"json_loads":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.v1.config.BaseConfig.json_loads","name":"json_loads","type":{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["builtins.str"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"keep_untouched":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.v1.config.BaseConfig.keep_untouched","name":"keep_untouched","type":{".class":"Instance","args":["builtins.type"],"extra_attrs":null,"type_ref":"builtins.tuple"}}},"max_anystr_length":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.v1.config.BaseConfig.max_anystr_length","name":"max_anystr_length","type":{".class":"UnionType","items":["builtins.int",{".class":"NoneType"}],"uses_pep604_syntax":false}}},"min_anystr_length":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.v1.config.BaseConfig.min_anystr_length","name":"min_anystr_length","type":"builtins.int"}},"orm_mode":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.v1.config.BaseConfig.orm_mode","name":"orm_mode","type":"builtins.bool"}},"post_init_call":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.v1.config.BaseConfig.post_init_call","name":"post_init_call","type":{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"before_validation"},{".class":"LiteralType","fallback":"builtins.str","value":"after_validation"}],"uses_pep604_syntax":false}}},"prepare_field":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["cls","field"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_class","is_decorated"],"fullname":"pydantic.v1.config.BaseConfig.prepare_field","name":"prepare_field","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["cls","field"],"arg_types":[{".class":"TypeType","item":"pydantic.v1.config.BaseConfig"},"pydantic.v1.fields.ModelField"],"bound_args":[],"def_extras":{"first_arg":"cls"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"prepare_field of BaseConfig","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":false,"var":{".class":"Var","flags":["is_initialized_in_class","is_classmethod","is_ready","is_inferred"],"fullname":"pydantic.v1.config.BaseConfig.prepare_field","name":"prepare_field","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["cls","field"],"arg_types":[{".class":"TypeType","item":"pydantic.v1.config.BaseConfig"},"pydantic.v1.fields.ModelField"],"bound_args":[],"def_extras":{"first_arg":"cls"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"prepare_field of BaseConfig","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"schema_extra":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.v1.config.BaseConfig.schema_extra","name":"schema_extra","type":{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"pydantic.v1.config.SchemaExtraCallable"],"uses_pep604_syntax":false}}},"smart_union":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.v1.config.BaseConfig.smart_union","name":"smart_union","type":"builtins.bool"}},"title":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.v1.config.BaseConfig.title","name":"title","type":{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":false}}},"underscore_attrs_are_private":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.v1.config.BaseConfig.underscore_attrs_are_private","name":"underscore_attrs_are_private","type":"builtins.bool"}},"use_enum_values":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.v1.config.BaseConfig.use_enum_values","name":"use_enum_values","type":"builtins.bool"}},"validate_all":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.v1.config.BaseConfig.validate_all","name":"validate_all","type":"builtins.bool"}},"validate_assignment":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_ready","has_explicit_value"],"fullname":"pydantic.v1.config.BaseConfig.validate_assignment","name":"validate_assignment","type":"builtins.bool"}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.v1.config.BaseConfig.Self","id":0,"name":"Self","namespace":"","upper_bound":"pydantic.v1.config.BaseConfig","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"BaseModel":{".class":"SymbolTableNode","cross_ref":"pydantic.v1.main.BaseModel","kind":"Gdef","module_public":false},"Callable":{".class":"SymbolTableNode","cross_ref":"typing.Callable","kind":"Gdef","module_public":false},"ConfigDict":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["typing._TypedDict"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"pydantic.v1.config.ConfigDict","name":"ConfigDict","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"pydantic.v1.config.ConfigDict","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"pydantic.v1.config","mro":["pydantic.v1.config.ConfigDict","typing._TypedDict","typing.Mapping","typing.Collection","typing.Iterable","typing.Container","builtins.object"],"names":{".class":"SymbolTable"},"self_type":null,"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":{".class":"TypedDictType","fallback":"typing._TypedDict","items":[["title",{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":false}],["anystr_lower","builtins.bool"],["anystr_strip_whitespace","builtins.bool"],["min_anystr_length","builtins.int"],["max_anystr_length",{".class":"UnionType","items":["builtins.int",{".class":"NoneType"}],"uses_pep604_syntax":false}],["validate_all","builtins.bool"],["extra","pydantic.v1.config.Extra"],["allow_mutation","builtins.bool"],["frozen","builtins.bool"],["allow_population_by_field_name","builtins.bool"],["use_enum_values","builtins.bool"],["fields",{".class":"Instance","args":["builtins.str",{".class":"UnionType","items":["builtins.str",{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"builtins.dict"}],"uses_pep604_syntax":false}],"extra_attrs":null,"type_ref":"builtins.dict"}],["validate_assignment","builtins.bool"],["error_msg_templates",{".class":"Instance","args":["builtins.str","builtins.str"],"extra_attrs":null,"type_ref":"builtins.dict"}],["arbitrary_types_allowed","builtins.bool"],["orm_mode","builtins.bool"],["getter_dict",{".class":"TypeType","item":"pydantic.v1.utils.GetterDict"}],["alias_generator",{".class":"UnionType","items":[{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["builtins.str"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"NoneType"}],"uses_pep604_syntax":false}],["keep_untouched",{".class":"Instance","args":["builtins.type"],"extra_attrs":null,"type_ref":"builtins.tuple"}],["schema_extra",{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str","builtins.object"],"extra_attrs":null,"type_ref":"builtins.dict"},"pydantic.v1.config.SchemaExtraCallable"],"uses_pep604_syntax":false}],["json_loads",{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["builtins.str"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":"builtins.object","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}],["json_dumps",{".class":"TypeAliasType","args":["builtins.str"],"type_ref":"pydantic.v1.typing.AnyArgTCallable"}],["json_encoders",{".class":"Instance","args":[{".class":"TypeType","item":"builtins.object"},{".class":"TypeAliasType","args":[],"type_ref":"pydantic.v1.typing.AnyCallable"}],"extra_attrs":null,"type_ref":"builtins.dict"}],["underscore_attrs_are_private","builtins.bool"],["allow_inf_nan","builtins.bool"],["copy_on_model_validation",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"none"},{".class":"LiteralType","fallback":"builtins.str","value":"deep"},{".class":"LiteralType","fallback":"builtins.str","value":"shallow"}],"uses_pep604_syntax":false}],["post_init_call",{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"before_validation"},{".class":"LiteralType","fallback":"builtins.str","value":"after_validation"}],"uses_pep604_syntax":false}]],"readonly_keys":[],"required_keys":[]}}},"ConfigType":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"TypeAlias","alias_tvars":[],"column":4,"fullname":"pydantic.v1.config.ConfigType","line":17,"no_args":false,"normalized":false,"python_3_12_type_alias":false,"target":{".class":"TypeType","item":"pydantic.v1.config.BaseConfig"}}},"Dict":{".class":"SymbolTableNode","cross_ref":"typing.Dict","kind":"Gdef","module_public":false},"Enum":{".class":"SymbolTableNode","cross_ref":"enum.Enum","kind":"Gdef","module_public":false},"Extra":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["builtins.str","enum.Enum"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"pydantic.v1.config.Extra","name":"Extra","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":["is_enum"],"fullname":"pydantic.v1.config.Extra","has_param_spec_type":false,"metaclass_type":"enum.EnumMeta","metadata":{},"module_name":"pydantic.v1.config","mro":["pydantic.v1.config.Extra","builtins.str","typing.Sequence","typing.Reversible","typing.Collection","typing.Iterable","typing.Container","enum.Enum","builtins.object"],"names":{".class":"SymbolTable","allow":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_final","is_ready","is_inferred","has_explicit_value"],"fullname":"pydantic.v1.config.Extra.allow","name":"allow","type":{".class":"Instance","args":[],"extra_attrs":null,"last_known_value":{".class":"LiteralType","fallback":"builtins.str","value":"allow"},"type_ref":"builtins.str"}}},"forbid":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_final","is_ready","is_inferred","has_explicit_value"],"fullname":"pydantic.v1.config.Extra.forbid","name":"forbid","type":{".class":"Instance","args":[],"extra_attrs":null,"last_known_value":{".class":"LiteralType","fallback":"builtins.str","value":"forbid"},"type_ref":"builtins.str"}}},"ignore":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_final","is_ready","is_inferred","has_explicit_value"],"fullname":"pydantic.v1.config.Extra.ignore","name":"ignore","type":{".class":"Instance","args":[],"extra_attrs":null,"last_known_value":{".class":"LiteralType","fallback":"builtins.str","value":"ignore"},"type_ref":"builtins.str"}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.v1.config.Extra.Self","id":0,"name":"Self","namespace":"","upper_bound":"pydantic.v1.config.Extra","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"ForwardRef":{".class":"SymbolTableNode","cross_ref":"typing.ForwardRef","kind":"Gdef","module_public":false},"GetterDict":{".class":"SymbolTableNode","cross_ref":"pydantic.v1.utils.GetterDict","kind":"Gdef","module_public":false},"Literal":{".class":"SymbolTableNode","cross_ref":"typing_extensions.Literal","kind":"Gdef","module_public":false},"ModelField":{".class":"SymbolTableNode","cross_ref":"pydantic.v1.fields.ModelField","kind":"Gdef","module_public":false},"Optional":{".class":"SymbolTableNode","cross_ref":"typing.Optional","kind":"Gdef","module_public":false},"Protocol":{".class":"SymbolTableNode","cross_ref":"typing_extensions.Protocol","kind":"Gdef","module_public":false},"SchemaExtraCallable":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[["__call__",1]],"alt_promote":null,"bases":["builtins.object"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"pydantic.v1.config.SchemaExtraCallable","name":"SchemaExtraCallable","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":["is_abstract","is_protocol"],"fullname":"pydantic.v1.config.SchemaExtraCallable","has_param_spec_type":false,"metaclass_type":"abc.ABCMeta","metadata":{},"module_name":"pydantic.v1.config","mro":["pydantic.v1.config.SchemaExtraCallable","builtins.object"],"names":{".class":"SymbolTable","__call__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"OverloadedFuncDef","deprecated":null,"flags":[],"fullname":"pydantic.v1.config.SchemaExtraCallable.__call__","impl":null,"items":[{".class":"Decorator","func":{".class":"FuncDef","abstract_status":1,"arg_kinds":[0,0],"arg_names":["self","schema"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated","is_mypy_only"],"fullname":"pydantic.v1.config.SchemaExtraCallable.__call__","name":"__call__","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","schema"],"arg_types":["pydantic.v1.config.SchemaExtraCallable",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__call__ of SchemaExtraCallable","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"pydantic.v1.config.SchemaExtraCallable.__call__","name":"__call__","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","schema"],"arg_types":["pydantic.v1.config.SchemaExtraCallable",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__call__ of SchemaExtraCallable","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},{".class":"Decorator","func":{".class":"FuncDef","abstract_status":1,"arg_kinds":[0,0,0],"arg_names":["self","schema","model_class"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_overload","is_decorated","is_mypy_only"],"fullname":"pydantic.v1.config.SchemaExtraCallable.__call__","name":"__call__","type":{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":["self","schema","model_class"],"arg_types":["pydantic.v1.config.SchemaExtraCallable",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},{".class":"TypeType","item":"pydantic.v1.main.BaseModel"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__call__ of SchemaExtraCallable","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":true,"var":{".class":"Var","flags":["is_ready","is_inferred"],"fullname":"pydantic.v1.config.SchemaExtraCallable.__call__","name":"__call__","type":{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":["self","schema","model_class"],"arg_types":["pydantic.v1.config.SchemaExtraCallable",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},{".class":"TypeType","item":"pydantic.v1.main.BaseModel"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__call__ of SchemaExtraCallable","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}],"type":{".class":"Overloaded","items":[{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","schema"],"arg_types":["pydantic.v1.config.SchemaExtraCallable",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__call__ of SchemaExtraCallable","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":["self","schema","model_class"],"arg_types":["pydantic.v1.config.SchemaExtraCallable",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},{".class":"TypeType","item":"pydantic.v1.main.BaseModel"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__call__ of SchemaExtraCallable","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}]}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"pydantic.v1.config.SchemaExtraCallable.Self","id":0,"name":"Self","namespace":"","upper_bound":"pydantic.v1.config.SchemaExtraCallable","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"TYPE_CHECKING":{".class":"SymbolTableNode","cross_ref":"typing.TYPE_CHECKING","kind":"Gdef","module_public":false},"Tuple":{".class":"SymbolTableNode","cross_ref":"typing.Tuple","kind":"Gdef","module_public":false},"Type":{".class":"SymbolTableNode","cross_ref":"typing.Type","kind":"Gdef","module_public":false},"TypedDict":{".class":"SymbolTableNode","cross_ref":"typing.TypedDict","kind":"Gdef","module_public":false},"Union":{".class":"SymbolTableNode","cross_ref":"typing.Union","kind":"Gdef","module_public":false},"__all__":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"Var","flags":["is_inferred","has_explicit_value"],"fullname":"pydantic.v1.config.__all__","name":"__all__","type":{".class":"TupleType","implicit":false,"items":["builtins.str","builtins.str","builtins.str","builtins.str","builtins.str","builtins.str"],"partial_fallback":{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.tuple"}}}},"__annotations__":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"Var","flags":["is_ready"],"fullname":"pydantic.v1.config.__annotations__","name":"__annotations__","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"__doc__":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"Var","flags":["is_ready"],"fullname":"pydantic.v1.config.__doc__","name":"__doc__","type":"builtins.str"}},"__file__":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"Var","flags":["is_ready"],"fullname":"pydantic.v1.config.__file__","name":"__file__","type":"builtins.str"}},"__name__":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"Var","flags":["is_ready"],"fullname":"pydantic.v1.config.__name__","name":"__name__","type":"builtins.str"}},"__package__":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"Var","flags":["is_ready"],"fullname":"pydantic.v1.config.__package__","name":"__package__","type":"builtins.str"}},"__spec__":{".class":"SymbolTableNode","kind":"Gdef","module_public":false,"node":{".class":"Var","flags":["is_ready"],"fullname":"pydantic.v1.config.__spec__","name":"__spec__","type":"_frozen_importlib.ModuleSpec"}},"compiled":{".class":"SymbolTableNode","cross_ref":"pydantic.v1.version.compiled","kind":"Gdef","module_public":false},"get_config":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["config"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"pydantic.v1.config.get_config","name":"get_config","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["config"],"arg_types":[{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"pydantic.v1.config.ConfigDict"},{".class":"TypeType","item":"builtins.object"},{".class":"NoneType"}],"uses_pep604_syntax":false}],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_config","ret_type":{".class":"TypeType","item":"pydantic.v1.config.BaseConfig"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"inherit_config":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,4],"arg_names":["self_config","parent_config","namespace"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"pydantic.v1.config.inherit_config","name":"inherit_config","type":{".class":"CallableType","arg_kinds":[0,0,4],"arg_names":["self_config","parent_config","namespace"],"arg_types":[{".class":"TypeAliasType","args":[],"type_ref":"pydantic.v1.config.ConfigType"},{".class":"TypeAliasType","args":[],"type_ref":"pydantic.v1.config.ConfigType"},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"inherit_config","ret_type":{".class":"TypeAliasType","args":[],"type_ref":"pydantic.v1.config.ConfigType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"json":{".class":"SymbolTableNode","cross_ref":"json","kind":"Gdef","module_public":false},"overload":{".class":"SymbolTableNode","cross_ref":"typing.overload","kind":"Gdef","module_public":false},"prepare_config":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["config","cls_name"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"pydantic.v1.config.prepare_config","name":"prepare_config","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["config","cls_name"],"arg_types":[{".class":"TypeType","item":"pydantic.v1.config.BaseConfig"},"builtins.str"],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"prepare_config","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"path":"/Users/yeogirlyun/Python/Poker/.venv/lib/python3.13/site-packages/pydantic/v1/config.py"}
```

---

### config.meta.json

**Path**: `.mypy_cache/3.13/pydantic/v1/config.meta.json`

**Size**: 1.8 KB

```json
{"data_mtime":1755238595,"dep_lines":[7,8,9,14,15,1,2,3,5,1,1,1,1,1,1,1],"dep_prios":[5,5,5,25,25,10,5,5,5,5,30,30,30,30,30,30],"dependencies":["pydantic.v1.typing","pydantic.v1.utils","pydantic.v1.version","pydantic.v1.fields","pydantic.v1.main","json","enum","typing","typing_extensions","builtins","_collections_abc","_frozen_importlib","_typeshed","abc","json.decoder","json.encoder"],"hash":"6581db36b9f61bed44ed1870e4f551529b9da21e","id":"pydantic.v1.config","ignore_all":true,"interface_hash":"8cbd94ba7da4f72329870d785756c10f0120908d","mtime":1754977747,"options":{"allow_redefinition":false,"allow_untyped_globals":false,"always_false":[],"always_true":[],"bazel":false,"check_untyped_defs":false,"disable_bytearray_promotion":false,"disable_error_code":[],"disable_memoryview_promotion":false,"disabled_error_codes":[],"disallow_any_decorated":false,"disallow_any_explicit":false,"disallow_any_expr":false,"disallow_any_generics":false,"disallow_any_unimported":false,"disallow_incomplete_defs":false,"disallow_subclassing_any":false,"disallow_untyped_calls":false,"disallow_untyped_decorators":false,"disallow_untyped_defs":false,"enable_error_code":[],"enabled_error_codes":[],"extra_checks":false,"follow_imports":"normal","follow_imports_for_stubs":false,"follow_untyped_imports":false,"ignore_errors":false,"ignore_missing_imports":false,"implicit_optional":false,"implicit_reexport":true,"local_partial_types":false,"mypyc":false,"old_type_inference":false,"platform":"darwin","plugins":[],"strict_concatenate":false,"strict_equality":false,"strict_optional":true,"warn_no_return":true,"warn_return_any":false,"warn_unreachable":false,"warn_unused_ignores":false},"path":"/Users/yeogirlyun/Python/Poker/.venv/lib/python3.13/site-packages/pydantic/v1/config.py","plugin_data":null,"size":6532,"suppressed":[],"version_id":"1.14.1"}
```

---

### config.data.json

**Path**: `.mypy_cache/3.13/uvicorn/config.data.json`

**Size**: 47.7 KB

```json
{".class":"MypyFile","_fullname":"uvicorn.config","future_import_flags":["annotations"],"is_partial_stub_package":false,"is_stub":false,"names":{".class":"SymbolTable","ASGI2Middleware":{".class":"SymbolTableNode","cross_ref":"uvicorn.middleware.asgi2.ASGI2Middleware","kind":"Gdef"},"ASGIApplication":{".class":"SymbolTableNode","cross_ref":"uvicorn._types.ASGIApplication","kind":"Gdef"},"Any":{".class":"SymbolTableNode","cross_ref":"typing.Any","kind":"Gdef"},"Awaitable":{".class":"SymbolTableNode","cross_ref":"typing.Awaitable","kind":"Gdef"},"Callable":{".class":"SymbolTableNode","cross_ref":"typing.Callable","kind":"Gdef"},"Config":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["builtins.object"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"uvicorn.config.Config","name":"Config","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"uvicorn.config.Config","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"uvicorn.config","mro":["uvicorn.config.Config","builtins.object"],"names":{".class":"SymbolTable","__init__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"arg_names":["self","app","host","port","uds","fd","loop","http","ws","ws_max_size","ws_max_queue","ws_ping_interval","ws_ping_timeout","ws_per_message_deflate","lifespan","env_file","log_config","log_level","access_log","use_colors","interface","reload","reload_dirs","reload_delay","reload_includes","reload_excludes","workers","proxy_headers","server_header","date_header","forwarded_allow_ips","root_path","limit_concurrency","limit_max_requests","backlog","timeout_keep_alive","timeout_notify","timeout_graceful_shutdown","callback_notify","ssl_keyfile","ssl_certfile","ssl_keyfile_password","ssl_version","ssl_cert_reqs","ssl_ca_certs","ssl_ciphers","headers","factory","h11_max_incomplete_event_size"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"uvicorn.config.Config.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],"arg_names":["self","app","host","port","uds","fd","loop","http","ws","ws_max_size","ws_max_queue","ws_ping_interval","ws_ping_timeout","ws_per_message_deflate","lifespan","env_file","log_config","log_level","access_log","use_colors","interface","reload","reload_dirs","reload_delay","reload_includes","reload_excludes","workers","proxy_headers","server_header","date_header","forwarded_allow_ips","root_path","limit_concurrency","limit_max_requests","backlog","timeout_keep_alive","timeout_notify","timeout_graceful_shutdown","callback_notify","ssl_keyfile","ssl_certfile","ssl_keyfile_password","ssl_version","ssl_cert_reqs","ssl_ca_certs","ssl_ciphers","headers","factory","h11_max_incomplete_event_size"],"arg_types":["uvicorn.config.Config",{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"uvicorn._types.ASGIApplication"},{".class":"CallableType","arg_kinds":[2,4],"arg_names":[null,null],"arg_types":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":true,"name":null,"ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},"builtins.str"],"uses_pep604_syntax":true},"builtins.str","builtins.int",{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"UnionType","items":["builtins.int",{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeAliasType","args":[],"type_ref":"uvicorn.config.LoopSetupType"},{".class":"UnionType","items":[{".class":"TypeType","item":"asyncio.protocols.Protocol"},{".class":"TypeAliasType","args":[],"type_ref":"uvicorn.config.HTTPProtocolType"}],"uses_pep604_syntax":true},{".class":"UnionType","items":[{".class":"TypeType","item":"asyncio.protocols.Protocol"},{".class":"TypeAliasType","args":[],"type_ref":"uvicorn.config.WSProtocolType"}],"uses_pep604_syntax":true},"builtins.int","builtins.int",{".class":"UnionType","items":["builtins.float",{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"UnionType","items":["builtins.float",{".class":"NoneType"}],"uses_pep604_syntax":true},"builtins.bool",{".class":"TypeAliasType","args":[],"type_ref":"uvicorn.config.LifespanType"},{".class":"UnionType","items":["builtins.str",{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"os.PathLike"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"builtins.str","configparser.RawConfigParser",{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"typing.IO"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"UnionType","items":["builtins.str","builtins.int",{".class":"NoneType"}],"uses_pep604_syntax":true},"builtins.bool",{".class":"UnionType","items":["builtins.bool",{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"TypeAliasType","args":[],"type_ref":"uvicorn.config.InterfaceType"},"builtins.bool",{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"builtins.list"},"builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true},"builtins.float",{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"builtins.list"},"builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"builtins.list"},"builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"UnionType","items":["builtins.int",{".class":"NoneType"}],"uses_pep604_syntax":true},"builtins.bool","builtins.bool","builtins.bool",{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"builtins.list"},"builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true},"builtins.str",{".class":"UnionType","items":["builtins.int",{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"UnionType","items":["builtins.int",{".class":"NoneType"}],"uses_pep604_syntax":true},"builtins.int","builtins.int","builtins.int",{".class":"UnionType","items":["builtins.int",{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"UnionType","items":[{".class":"CallableType","arg_kinds":[2,4],"arg_names":[null,null],"arg_types":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":true,"name":null,"ret_type":{".class":"Instance","args":[{".class":"NoneType"}],"extra_attrs":null,"type_ref":"typing.Awaitable"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"UnionType","items":["builtins.str",{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"os.PathLike"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"UnionType","items":["builtins.str",{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"os.PathLike"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true},"builtins.int","builtins.int",{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true},"builtins.str",{".class":"UnionType","items":[{".class":"Instance","args":[{".class":"TupleType","implicit":false,"items":["builtins.str","builtins.str"],"partial_fallback":{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.tuple"}}],"extra_attrs":null,"type_ref":"builtins.list"},{".class":"NoneType"}],"uses_pep604_syntax":true},"builtins.bool",{".class":"UnionType","items":["builtins.int",{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of Config","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"access_log":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.access_log","name":"access_log","type":"builtins.bool"}},"app":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.app","name":"app","type":{".class":"UnionType","items":[{".class":"TypeAliasType","args":[],"type_ref":"uvicorn._types.ASGIApplication"},{".class":"CallableType","arg_kinds":[2,4],"arg_names":[null,null],"arg_types":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":true,"name":null,"ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},"builtins.str"],"uses_pep604_syntax":true}}},"asgi_version":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_property","is_decorated"],"fullname":"uvicorn.config.Config.asgi_version","name":"asgi_version","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["uvicorn.config.Config"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"asgi_version of Config","ret_type":{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"2.0"},{".class":"LiteralType","fallback":"builtins.str","value":"3.0"}],"uses_pep604_syntax":false},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":false,"var":{".class":"Var","flags":["is_initialized_in_class","is_property","is_ready","is_inferred"],"fullname":"uvicorn.config.Config.asgi_version","name":"asgi_version","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["uvicorn.config.Config"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"asgi_version of Config","ret_type":{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"2.0"},{".class":"LiteralType","fallback":"builtins.str","value":"3.0"}],"uses_pep604_syntax":false},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"backlog":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.backlog","name":"backlog","type":"builtins.int"}},"bind_socket":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"uvicorn.config.Config.bind_socket","name":"bind_socket","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["uvicorn.config.Config"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"bind_socket of Config","ret_type":"socket.socket","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"callback_notify":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.callback_notify","name":"callback_notify","type":{".class":"UnionType","items":[{".class":"CallableType","arg_kinds":[2,4],"arg_names":[null,null],"arg_types":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2},{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":true,"name":null,"ret_type":{".class":"Instance","args":[{".class":"NoneType"}],"extra_attrs":null,"type_ref":"typing.Awaitable"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},{".class":"NoneType"}],"uses_pep604_syntax":true}}},"configure_logging":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"uvicorn.config.Config.configure_logging","name":"configure_logging","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["uvicorn.config.Config"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"configure_logging of Config","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"date_header":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.date_header","name":"date_header","type":"builtins.bool"}},"encoded_headers":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"uvicorn.config.Config.encoded_headers","name":"encoded_headers","type":{".class":"Instance","args":[{".class":"TupleType","implicit":false,"items":["builtins.bytes","builtins.bytes"],"partial_fallback":{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.tuple"}}],"extra_attrs":null,"type_ref":"builtins.list"}}},"factory":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.factory","name":"factory","type":"builtins.bool"}},"fd":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.fd","name":"fd","type":{".class":"UnionType","items":["builtins.int",{".class":"NoneType"}],"uses_pep604_syntax":true}}},"forwarded_allow_ips":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"uvicorn.config.Config.forwarded_allow_ips","name":"forwarded_allow_ips","type":{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"builtins.list"},"builtins.str"],"uses_pep604_syntax":true}}},"h11_max_incomplete_event_size":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.h11_max_incomplete_event_size","name":"h11_max_incomplete_event_size","type":{".class":"UnionType","items":["builtins.int",{".class":"NoneType"}],"uses_pep604_syntax":true}}},"headers":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"uvicorn.config.Config.headers","name":"headers","type":{".class":"Instance","args":[{".class":"TupleType","implicit":false,"items":["builtins.str","builtins.str"],"partial_fallback":{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.tuple"}}],"extra_attrs":null,"type_ref":"builtins.list"}}},"host":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.host","name":"host","type":"builtins.str"}},"http":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.http","name":"http","type":{".class":"UnionType","items":[{".class":"TypeType","item":"asyncio.protocols.Protocol"},{".class":"TypeAliasType","args":[],"type_ref":"uvicorn.config.HTTPProtocolType"}],"uses_pep604_syntax":true}}},"http_protocol_class":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"uvicorn.config.Config.http_protocol_class","name":"http_protocol_class","type":{".class":"TypeType","item":"asyncio.protocols.Protocol"}}},"interface":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.interface","name":"interface","type":{".class":"TypeAliasType","args":[],"type_ref":"uvicorn.config.InterfaceType"}}},"is_ssl":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_property","is_decorated"],"fullname":"uvicorn.config.Config.is_ssl","name":"is_ssl","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["uvicorn.config.Config"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"is_ssl of Config","ret_type":"builtins.bool","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":false,"var":{".class":"Var","flags":["is_initialized_in_class","is_property","is_ready","is_inferred"],"fullname":"uvicorn.config.Config.is_ssl","name":"is_ssl","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["uvicorn.config.Config"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"is_ssl of Config","ret_type":"builtins.bool","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"lifespan":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.lifespan","name":"lifespan","type":{".class":"TypeAliasType","args":[],"type_ref":"uvicorn.config.LifespanType"}}},"lifespan_class":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.lifespan_class","name":"lifespan_class","type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}}},"limit_concurrency":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.limit_concurrency","name":"limit_concurrency","type":{".class":"UnionType","items":["builtins.int",{".class":"NoneType"}],"uses_pep604_syntax":true}}},"limit_max_requests":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.limit_max_requests","name":"limit_max_requests","type":{".class":"UnionType","items":["builtins.int",{".class":"NoneType"}],"uses_pep604_syntax":true}}},"load":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"uvicorn.config.Config.load","name":"load","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["uvicorn.config.Config"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"load of Config","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"loaded":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.loaded","name":"loaded","type":"builtins.bool"}},"loaded_app":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.loaded_app","name":"loaded_app","type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}}},"log_config":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.log_config","name":"log_config","type":{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"builtins.str","configparser.RawConfigParser",{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"typing.IO"},{".class":"NoneType"}],"uses_pep604_syntax":false}}},"log_level":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.log_level","name":"log_level","type":{".class":"UnionType","items":["builtins.str","builtins.int",{".class":"NoneType"}],"uses_pep604_syntax":false}}},"loop":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.loop","name":"loop","type":{".class":"TypeAliasType","args":[],"type_ref":"uvicorn.config.LoopSetupType"}}},"port":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.port","name":"port","type":"builtins.int"}},"proxy_headers":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.proxy_headers","name":"proxy_headers","type":"builtins.bool"}},"reload":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.reload","name":"reload","type":"builtins.bool"}},"reload_delay":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.reload_delay","name":"reload_delay","type":"builtins.float"}},"reload_dirs":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"uvicorn.config.Config.reload_dirs","name":"reload_dirs","type":{".class":"Instance","args":["pathlib.Path"],"extra_attrs":null,"type_ref":"builtins.list"}}},"reload_dirs_excludes":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"uvicorn.config.Config.reload_dirs_excludes","name":"reload_dirs_excludes","type":{".class":"Instance","args":["pathlib.Path"],"extra_attrs":null,"type_ref":"builtins.list"}}},"reload_excludes":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"uvicorn.config.Config.reload_excludes","name":"reload_excludes","type":{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"builtins.list"}}},"reload_includes":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"uvicorn.config.Config.reload_includes","name":"reload_includes","type":{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"builtins.list"}}},"root_path":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.root_path","name":"root_path","type":"builtins.str"}},"server_header":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.server_header","name":"server_header","type":"builtins.bool"}},"setup_event_loop":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"uvicorn.config.Config.setup_event_loop","name":"setup_event_loop","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["uvicorn.config.Config"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"setup_event_loop of Config","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"should_reload":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_property","is_decorated"],"fullname":"uvicorn.config.Config.should_reload","name":"should_reload","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["uvicorn.config.Config"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"should_reload of Config","ret_type":"builtins.bool","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":false,"var":{".class":"Var","flags":["is_initialized_in_class","is_property","is_ready","is_inferred"],"fullname":"uvicorn.config.Config.should_reload","name":"should_reload","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["uvicorn.config.Config"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"should_reload of Config","ret_type":"builtins.bool","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"ssl":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"uvicorn.config.Config.ssl","name":"ssl","type":{".class":"UnionType","items":["ssl.SSLContext",{".class":"NoneType"}],"uses_pep604_syntax":true}}},"ssl_ca_certs":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.ssl_ca_certs","name":"ssl_ca_certs","type":{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}}},"ssl_cert_reqs":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.ssl_cert_reqs","name":"ssl_cert_reqs","type":"builtins.int"}},"ssl_certfile":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.ssl_certfile","name":"ssl_certfile","type":{".class":"UnionType","items":["builtins.str",{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"os.PathLike"},{".class":"NoneType"}],"uses_pep604_syntax":false}}},"ssl_ciphers":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.ssl_ciphers","name":"ssl_ciphers","type":"builtins.str"}},"ssl_keyfile":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.ssl_keyfile","name":"ssl_keyfile","type":{".class":"UnionType","items":["builtins.str",{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"os.PathLike"},{".class":"NoneType"}],"uses_pep604_syntax":false}}},"ssl_keyfile_password":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.ssl_keyfile_password","name":"ssl_keyfile_password","type":{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}}},"ssl_version":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.ssl_version","name":"ssl_version","type":"builtins.int"}},"timeout_graceful_shutdown":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.timeout_graceful_shutdown","name":"timeout_graceful_shutdown","type":{".class":"UnionType","items":["builtins.int",{".class":"NoneType"}],"uses_pep604_syntax":true}}},"timeout_keep_alive":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.timeout_keep_alive","name":"timeout_keep_alive","type":"builtins.int"}},"timeout_notify":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.timeout_notify","name":"timeout_notify","type":"builtins.int"}},"uds":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.uds","name":"uds","type":{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}}},"use_colors":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.use_colors","name":"use_colors","type":{".class":"UnionType","items":["builtins.bool",{".class":"NoneType"}],"uses_pep604_syntax":true}}},"use_subprocess":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Decorator","func":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":["is_property","is_decorated"],"fullname":"uvicorn.config.Config.use_subprocess","name":"use_subprocess","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["uvicorn.config.Config"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"use_subprocess of Config","ret_type":"builtins.bool","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}},"is_overload":false,"var":{".class":"Var","flags":["is_initialized_in_class","is_property","is_ready","is_inferred"],"fullname":"uvicorn.config.Config.use_subprocess","name":"use_subprocess","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["uvicorn.config.Config"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"use_subprocess of Config","ret_type":"builtins.bool","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"workers":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.workers","name":"workers","type":"builtins.int"}},"ws":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.ws","name":"ws","type":{".class":"UnionType","items":[{".class":"TypeType","item":"asyncio.protocols.Protocol"},{".class":"TypeAliasType","args":[],"type_ref":"uvicorn.config.WSProtocolType"}],"uses_pep604_syntax":true}}},"ws_max_queue":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.ws_max_queue","name":"ws_max_queue","type":"builtins.int"}},"ws_max_size":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.ws_max_size","name":"ws_max_size","type":"builtins.int"}},"ws_per_message_deflate":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.ws_per_message_deflate","name":"ws_per_message_deflate","type":"builtins.bool"}},"ws_ping_interval":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.ws_ping_interval","name":"ws_ping_interval","type":{".class":"UnionType","items":["builtins.float",{".class":"NoneType"}],"uses_pep604_syntax":true}}},"ws_ping_timeout":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"uvicorn.config.Config.ws_ping_timeout","name":"ws_ping_timeout","type":{".class":"UnionType","items":["builtins.float",{".class":"NoneType"}],"uses_pep604_syntax":true}}},"ws_protocol_class":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"uvicorn.config.Config.ws_protocol_class","name":"ws_protocol_class","type":{".class":"UnionType","items":[{".class":"TypeType","item":"asyncio.protocols.Protocol"},{".class":"NoneType"}],"uses_pep604_syntax":true}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"uvicorn.config.Config.Self","id":0,"name":"Self","namespace":"","upper_bound":"uvicorn.config.Config","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"HTTPProtocolType":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeAlias","alias_tvars":[],"column":0,"fullname":"uvicorn.config.HTTPProtocolType","line":27,"no_args":false,"normalized":false,"python_3_12_type_alias":false,"target":{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"auto"},{".class":"LiteralType","fallback":"builtins.str","value":"h11"},{".class":"LiteralType","fallback":"builtins.str","value":"httptools"}],"uses_pep604_syntax":false}}},"HTTP_PROTOCOLS":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready","has_explicit_value"],"fullname":"uvicorn.config.HTTP_PROTOCOLS","name":"HTTP_PROTOCOLS","type":{".class":"Instance","args":[{".class":"TypeAliasType","args":[],"type_ref":"uvicorn.config.HTTPProtocolType"},"builtins.str"],"extra_attrs":null,"type_ref":"builtins.dict"}}},"INTERFACES":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready","has_explicit_value"],"fullname":"uvicorn.config.INTERFACES","name":"INTERFACES","type":{".class":"Instance","args":[{".class":"TypeAliasType","args":[],"type_ref":"uvicorn.config.InterfaceType"}],"extra_attrs":null,"type_ref":"builtins.list"}}},"IO":{".class":"SymbolTableNode","cross_ref":"typing.IO","kind":"Gdef"},"ImportFromStringError":{".class":"SymbolTableNode","cross_ref":"uvicorn.importer.ImportFromStringError","kind":"Gdef"},"InterfaceType":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeAlias","alias_tvars":[],"column":0,"fullname":"uvicorn.config.InterfaceType","line":31,"no_args":false,"normalized":false,"python_3_12_type_alias":false,"target":{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"auto"},{".class":"LiteralType","fallback":"builtins.str","value":"asgi3"},{".class":"LiteralType","fallback":"builtins.str","value":"asgi2"},{".class":"LiteralType","fallback":"builtins.str","value":"wsgi"}],"uses_pep604_syntax":false}}},"LIFESPAN":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready","has_explicit_value"],"fullname":"uvicorn.config.LIFESPAN","name":"LIFESPAN","type":{".class":"Instance","args":[{".class":"TypeAliasType","args":[],"type_ref":"uvicorn.config.LifespanType"},"builtins.str"],"extra_attrs":null,"type_ref":"builtins.dict"}}},"LOGGING_CONFIG":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready","has_explicit_value"],"fullname":"uvicorn.config.LOGGING_CONFIG","name":"LOGGING_CONFIG","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"LOG_LEVELS":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready","has_explicit_value"],"fullname":"uvicorn.config.LOG_LEVELS","name":"LOG_LEVELS","type":{".class":"Instance","args":["builtins.str","builtins.int"],"extra_attrs":null,"type_ref":"builtins.dict"}}},"LOOP_SETUPS":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready","has_explicit_value"],"fullname":"uvicorn.config.LOOP_SETUPS","name":"LOOP_SETUPS","type":{".class":"Instance","args":[{".class":"TypeAliasType","args":[],"type_ref":"uvicorn.config.LoopSetupType"},{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"LifespanType":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeAlias","alias_tvars":[],"column":0,"fullname":"uvicorn.config.LifespanType","line":29,"no_args":false,"normalized":false,"python_3_12_type_alias":false,"target":{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"auto"},{".class":"LiteralType","fallback":"builtins.str","value":"on"},{".class":"LiteralType","fallback":"builtins.str","value":"off"}],"uses_pep604_syntax":false}}},"Literal":{".class":"SymbolTableNode","cross_ref":"typing.Literal","kind":"Gdef"},"LoopSetupType":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeAlias","alias_tvars":[],"column":0,"fullname":"uvicorn.config.LoopSetupType","line":30,"no_args":false,"normalized":false,"python_3_12_type_alias":false,"target":{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"none"},{".class":"LiteralType","fallback":"builtins.str","value":"auto"},{".class":"LiteralType","fallback":"builtins.str","value":"asyncio"},{".class":"LiteralType","fallback":"builtins.str","value":"uvloop"}],"uses_pep604_syntax":false}}},"MessageLoggerMiddleware":{".class":"SymbolTableNode","cross_ref":"uvicorn.middleware.message_logger.MessageLoggerMiddleware","kind":"Gdef"},"Path":{".class":"SymbolTableNode","cross_ref":"pathlib.Path","kind":"Gdef"},"ProxyHeadersMiddleware":{".class":"SymbolTableNode","cross_ref":"uvicorn.middleware.proxy_headers.ProxyHeadersMiddleware","kind":"Gdef"},"RawConfigParser":{".class":"SymbolTableNode","cross_ref":"configparser.RawConfigParser","kind":"Gdef"},"SSL_PROTOCOL_VERSION":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready","has_explicit_value"],"fullname":"uvicorn.config.SSL_PROTOCOL_VERSION","name":"SSL_PROTOCOL_VERSION","type":"builtins.int"}},"TRACE_LOG_LEVEL":{".class":"SymbolTableNode","cross_ref":"uvicorn.logging.TRACE_LOG_LEVEL","kind":"Gdef"},"WSGIMiddleware":{".class":"SymbolTableNode","cross_ref":"uvicorn.middleware.wsgi.WSGIMiddleware","kind":"Gdef"},"WSProtocolType":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeAlias","alias_tvars":[],"column":0,"fullname":"uvicorn.config.WSProtocolType","line":28,"no_args":false,"normalized":false,"python_3_12_type_alias":false,"target":{".class":"UnionType","items":[{".class":"LiteralType","fallback":"builtins.str","value":"auto"},{".class":"LiteralType","fallback":"builtins.str","value":"none"},{".class":"LiteralType","fallback":"builtins.str","value":"websockets"},{".class":"LiteralType","fallback":"builtins.str","value":"websockets-sansio"},{".class":"LiteralType","fallback":"builtins.str","value":"wsproto"}],"uses_pep604_syntax":false}}},"WS_PROTOCOLS":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready","has_explicit_value"],"fullname":"uvicorn.config.WS_PROTOCOLS","name":"WS_PROTOCOLS","type":{".class":"Instance","args":[{".class":"TypeAliasType","args":[],"type_ref":"uvicorn.config.WSProtocolType"},{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"__annotations__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"uvicorn.config.__annotations__","name":"__annotations__","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"__doc__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"uvicorn.config.__doc__","name":"__doc__","type":"builtins.str"}},"__file__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"uvicorn.config.__file__","name":"__file__","type":"builtins.str"}},"__name__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"uvicorn.config.__name__","name":"__name__","type":"builtins.str"}},"__package__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"uvicorn.config.__package__","name":"__package__","type":"builtins.str"}},"__spec__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"uvicorn.config.__spec__","name":"__spec__","type":"_frozen_importlib.ModuleSpec"}},"_normalize_dirs":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["dirs"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"uvicorn.config._normalize_dirs","name":"_normalize_dirs","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["dirs"],"arg_types":[{".class":"UnionType","items":[{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"builtins.list"},"builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_normalize_dirs","ret_type":{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"builtins.list"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"annotations":{".class":"SymbolTableNode","cross_ref":"__future__.annotations","kind":"Gdef"},"asyncio":{".class":"SymbolTableNode","cross_ref":"asyncio","kind":"Gdef"},"click":{".class":"SymbolTableNode","cross_ref":"click","kind":"Gdef"},"create_ssl_context":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0,0,0,0,0],"arg_names":["certfile","keyfile","password","ssl_version","cert_reqs","ca_certs","ciphers"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"uvicorn.config.create_ssl_context","name":"create_ssl_context","type":{".class":"CallableType","arg_kinds":[0,0,0,0,0,0,0],"arg_names":["certfile","keyfile","password","ssl_version","cert_reqs","ca_certs","ciphers"],"arg_types":[{".class":"UnionType","items":["builtins.str",{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"os.PathLike"}],"uses_pep604_syntax":true},{".class":"UnionType","items":["builtins.str",{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"os.PathLike"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true},"builtins.int","builtins.int",{".class":"UnionType","items":["builtins.str",{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"os.PathLike"},{".class":"NoneType"}],"uses_pep604_syntax":true},{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"create_ssl_context","ret_type":"ssl.SSLContext","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"import_from_string":{".class":"SymbolTableNode","cross_ref":"uvicorn.importer.import_from_string","kind":"Gdef"},"inspect":{".class":"SymbolTableNode","cross_ref":"inspect","kind":"Gdef"},"is_dir":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["path"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"uvicorn.config.is_dir","name":"is_dir","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["path"],"arg_types":["pathlib.Path"],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"is_dir","ret_type":"builtins.bool","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"json":{".class":"SymbolTableNode","cross_ref":"json","kind":"Gdef"},"logger":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_inferred","has_explicit_value"],"fullname":"uvicorn.config.logger","name":"logger","type":"logging.Logger"}},"logging":{".class":"SymbolTableNode","cross_ref":"logging","kind":"Gdef"},"os":{".class":"SymbolTableNode","cross_ref":"os","kind":"Gdef"},"resolve_reload_patterns":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["patterns_list","directories_list"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"uvicorn.config.resolve_reload_patterns","name":"resolve_reload_patterns","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["patterns_list","directories_list"],"arg_types":[{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"builtins.list"},{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"builtins.list"}],"bound_args":[],"def_extras":{"first_arg":null},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"resolve_reload_patterns","ret_type":{".class":"TupleType","implicit":false,"items":[{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"builtins.list"},{".class":"Instance","args":["pathlib.Path"],"extra_attrs":null,"type_ref":"builtins.list"}],"partial_fallback":{".class":"Instance","args":[{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.tuple"}},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"socket":{".class":"SymbolTableNode","cross_ref":"socket","kind":"Gdef"},"ssl":{".class":"SymbolTableNode","cross_ref":"ssl","kind":"Gdef"},"sys":{".class":"SymbolTableNode","cross_ref":"sys","kind":"Gdef"}},"path":"/Users/yeogirlyun/Python/Poker/.venv/lib/python3.13/site-packages/uvicorn/config.py"}
```

---

### config.meta.json

**Path**: `.mypy_cache/3.13/uvicorn/config.meta.json`

**Size**: 2.2 KB

```json
{"data_mtime":1755238601,"dep_lines":[22,23,24,25,7,12,19,20,21,1,3,4,5,6,8,9,10,11,13,14,15,17,325,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,375],"dep_prios":[5,5,5,5,10,5,5,5,5,5,10,10,10,10,10,10,10,10,5,5,5,10,20,5,30,30,30,30,30,30,30,30,30,30,30,30,30,30,20],"dependencies":["uvicorn.middleware.asgi2","uvicorn.middleware.message_logger","uvicorn.middleware.proxy_headers","uvicorn.middleware.wsgi","logging.config","collections.abc","uvicorn._types","uvicorn.importer","uvicorn.logging","__future__","asyncio","inspect","json","logging","os","socket","ssl","sys","configparser","pathlib","typing","click","dotenv","builtins","_collections_abc","_frozen_importlib","_io","_socket","_ssl","_typeshed","abc","asyncio.protocols","dotenv.main","enum","io","json.decoder","types","uvicorn.middleware"],"hash":"b1c2f29eb6765e56942870f937ee1e08b5fddfb8","id":"uvicorn.config","ignore_all":true,"interface_hash":"ff05ac57be3b100ee16064d0c0874454055e5a35","mtime":1754977747,"options":{"allow_redefinition":false,"allow_untyped_globals":false,"always_false":[],"always_true":[],"bazel":false,"check_untyped_defs":false,"disable_bytearray_promotion":false,"disable_error_code":[],"disable_memoryview_promotion":false,"disabled_error_codes":[],"disallow_any_decorated":false,"disallow_any_explicit":false,"disallow_any_expr":false,"disallow_any_generics":false,"disallow_any_unimported":false,"disallow_incomplete_defs":false,"disallow_subclassing_any":false,"disallow_untyped_calls":false,"disallow_untyped_decorators":false,"disallow_untyped_defs":false,"enable_error_code":[],"enabled_error_codes":[],"extra_checks":false,"follow_imports":"normal","follow_imports_for_stubs":false,"follow_untyped_imports":false,"ignore_errors":false,"ignore_missing_imports":false,"implicit_optional":false,"implicit_reexport":true,"local_partial_types":false,"mypyc":false,"old_type_inference":false,"platform":"darwin","plugins":[],"strict_concatenate":false,"strict_equality":false,"strict_optional":true,"warn_no_return":true,"warn_return_any":false,"warn_unreachable":false,"warn_unused_ignores":false},"path":"/Users/yeogirlyun/Python/Poker/.venv/lib/python3.13/site-packages/uvicorn/config.py","plugin_data":null,"size":21013,"suppressed":["yaml"],"version_id":"1.14.1"}
```

---

### theme_manager.data.json

**Path**: `backend/.mypy_cache/3.13/backend/ui/services/theme_manager.data.json`

**Size**: 17.2 KB

```json
{".class":"MypyFile","_fullname":"backend.ui.services.theme_manager","future_import_flags":["annotations"],"is_partial_stub_package":false,"is_stub":false,"names":{".class":"SymbolTable","Any":{".class":"SymbolTableNode","cross_ref":"typing.Any","kind":"Gdef"},"Callable":{".class":"SymbolTableNode","cross_ref":"typing.Callable","kind":"Gdef"},"Dict":{".class":"SymbolTableNode","cross_ref":"typing.Dict","kind":"Gdef"},"List":{".class":"SymbolTableNode","cross_ref":"typing.List","kind":"Gdef"},"ThemeManager":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["builtins.object"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"backend.ui.services.theme_manager.ThemeManager","name":"ThemeManager","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"backend.ui.services.theme_manager","mro":["backend.ui.services.theme_manager.ThemeManager","builtins.object"],"names":{".class":"SymbolTable","CONFIG_PATH":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_inferred","has_explicit_value"],"fullname":"backend.ui.services.theme_manager.ThemeManager.CONFIG_PATH","name":"CONFIG_PATH","type":"builtins.str"}},"__init__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_builtin_packs":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager._builtin_packs","name":"_builtin_packs","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_builtin_packs of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_current":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager.ThemeManager._current","name":"_current","type":{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}}},"_fonts":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager.ThemeManager._fonts","name":"_fonts","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"_load_config":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager._load_config","name":"_load_config","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_load_config of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_save_config":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager._save_config","name":"_save_config","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_save_config of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_subs":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager.ThemeManager._subs","name":"_subs","type":{".class":"Instance","args":[{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}],"extra_attrs":null,"type_ref":"builtins.list"}}},"_theme":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager.ThemeManager._theme","name":"_theme","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"_themes":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager.ThemeManager._themes","name":"_themes","type":{".class":"Instance","args":["builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"current_profile_name":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.current_profile_name","name":"current_profile_name","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"current_profile_name of ThemeManager","ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,1],"arg_names":["self","token","default"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.get","name":"get","type":{".class":"CallableType","arg_kinds":[0,0,1],"arg_names":["self","token","default"],"arg_types":["backend.ui.services.theme_manager.ThemeManager","builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get of ThemeManager","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_fonts":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.get_fonts","name":"get_fonts","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_fonts of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_theme":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.get_theme","name":"get_theme","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_theme of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"names":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.names","name":"names","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"names of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"builtins.list"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"register":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":["self","name","tokens"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.register","name":"register","type":{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":["self","name","tokens"],"arg_types":["backend.ui.services.theme_manager.ThemeManager","builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"register of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"set_fonts":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","fonts"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.set_fonts","name":"set_fonts","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","fonts"],"arg_types":["backend.ui.services.theme_manager.ThemeManager",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"set_fonts of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"set_profile":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","name"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.set_profile","name":"set_profile","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","name"],"arg_types":["backend.ui.services.theme_manager.ThemeManager","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"set_profile of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"subscribe":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","fn"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.subscribe","name":"subscribe","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","fn"],"arg_types":["backend.ui.services.theme_manager.ThemeManager",{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"subscribe of ThemeManager","ret_type":{".class":"CallableType","arg_kinds":[],"arg_names":[],"arg_types":[],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"backend.ui.services.theme_manager.ThemeManager.Self","id":0,"name":"Self","namespace":"","upper_bound":"backend.ui.services.theme_manager.ThemeManager","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"__annotations__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__annotations__","name":"__annotations__","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"__doc__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__doc__","name":"__doc__","type":"builtins.str"}},"__file__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__file__","name":"__file__","type":"builtins.str"}},"__name__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__name__","name":"__name__","type":"builtins.str"}},"__package__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__package__","name":"__package__","type":"builtins.str"}},"__spec__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__spec__","name":"__spec__","type":"_frozen_importlib.ModuleSpec"}},"annotations":{".class":"SymbolTableNode","cross_ref":"__future__.annotations","kind":"Gdef"},"importlib":{".class":"SymbolTableNode","cross_ref":"importlib","kind":"Gdef"},"json":{".class":"SymbolTableNode","cross_ref":"json","kind":"Gdef"},"os":{".class":"SymbolTableNode","cross_ref":"os","kind":"Gdef"}},"path":"/Users/yeogirlyun/Poker/backend/ui/services/theme_manager.py"}
```

---

### theme_manager.meta.json

**Path**: `backend/.mypy_cache/3.13/backend/ui/services/theme_manager.meta.json`

**Size**: 1.7 KB

```json
{"data_mtime":1755328004,"dep_lines":[1,3,4,5,6,1,1,1,1,1,1,1,1,1],"dep_prios":[5,5,10,10,10,5,30,30,30,30,30,30,30,30],"dependencies":["__future__","typing","importlib","json","os","builtins","_collections_abc","_frozen_importlib","_io","_typeshed","abc","io","json.decoder","types"],"hash":"d7ed5573626e788a4fb52f9bc7e3c74d3f3ddd25","id":"backend.ui.services.theme_manager","ignore_all":true,"interface_hash":"808b05726706aa6f1094c83ace58179f987c0a07","mtime":1755328111,"options":{"allow_redefinition":false,"allow_untyped_globals":false,"always_false":[],"always_true":[],"bazel":false,"check_untyped_defs":false,"disable_bytearray_promotion":false,"disable_error_code":[],"disable_memoryview_promotion":false,"disabled_error_codes":[],"disallow_any_decorated":false,"disallow_any_explicit":false,"disallow_any_expr":false,"disallow_any_generics":false,"disallow_any_unimported":false,"disallow_incomplete_defs":false,"disallow_subclassing_any":false,"disallow_untyped_calls":false,"disallow_untyped_decorators":false,"disallow_untyped_defs":false,"enable_error_code":[],"enabled_error_codes":[],"extra_checks":false,"follow_imports":"normal","follow_imports_for_stubs":false,"follow_untyped_imports":false,"ignore_errors":false,"ignore_missing_imports":false,"implicit_optional":false,"implicit_reexport":true,"local_partial_types":false,"mypyc":false,"old_type_inference":false,"platform":"darwin","plugins":[],"strict_concatenate":false,"strict_equality":false,"strict_optional":true,"warn_no_return":true,"warn_return_any":false,"warn_unreachable":false,"warn_unused_ignores":false},"path":"/Users/yeogirlyun/Poker/backend/ui/services/theme_manager.py","plugin_data":null,"size":14533,"suppressed":[],"version_id":"1.14.1"}
```

---

### theme_config.json

**Path**: `backend/backend/ui/theme_config.json`

**Size**: 889 bytes

```json
{
  "profile": "Oceanic Aqua \ud83c\udf0a",
  "fonts": {
    "main": [
      "Segoe UI",
      13,
      "normal"
    ],
    "title": [
      "Segoe UI",
      18,
      "bold"
    ],
    "header": [
      "Segoe UI",
      15,
      "bold"
    ],
    "small": [
      "Consolas",
      10
    ],
    "large": [
      "Segoe UI",
      16,
      "bold"
    ],
    "player_name": [
      "Segoe UI",
      13,
      "bold"
    ],
    "stack_amount": [
      "Segoe UI",
      16,
      "bold"
    ],
    "bet_amount": [
      "Segoe UI",
      17,
      "bold"
    ],
    "action_button": [
      "Segoe UI",
      14,
      "bold"
    ],
    "cards": [
      "Consolas",
      14,
      "bold"
    ],
    "pot_display": [
      "Segoe UI",
      21,
      "bold"
    ],
    "stack_bet": [
      "Segoe UI",
      16,
      "bold"
    ],
    "body": [
      "Consolas",
      13
    ]
  }
}
```

---

### legendary_hands.json

**Path**: `backend/data/legendary_hands.json`

**Size**: 569.0 KB

```json
{
  "hands": [
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "BB001",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Kh",
            "Kd"
          ],
          "seat2": [
            "Ad",
            "2c"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player 1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player 2",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "actor_uid": null,
              "action": "DEAL_HOLE",
              "amount": 0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "actor_uid": "seat1",
              "action": "POST_BLIND",
              "amount": 5,
              "to_amount": 5,
              "all_in": false,
              "note": null,
              "posting_meta": {
                "blind_type": "SB"
              }
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "actor_uid": "seat2",
              "action": "POST_BLIND",
              "amount": 10,
              "to_amount": 10,
              "all_in": false,
              "note": null,
              "posting_meta": {
                "blind_type": "BB"
              }
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "actor_uid": "seat1",
              "action": "RAISE",
              "amount": 30,
              "to_amount": 30,
              "all_in": false,
              "note": null,
              "posting_meta": null
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "actor_uid": "seat2",
              "action": "CALL",
              "amount": 30,
              "to_amount": 30,
              "all_in": false,
              "note": null,
              "posting_meta": null
            }
          ]
        },
        "FLOP": {
          "board": [
            "4h",
            "4s",
            "Qh"
          ],
          "actions": [
            {
              "order": 6,
              "street": "FLOP",
              "actor_uid": "seat1",
              "action": "BET",
              "amount": 60,
              "to_amount": 60,
              "all_in": false,
              "note": null,
              "posting_meta": null
            },
            {
              "order": 7,
              "street": "FLOP",
              "actor_uid": "seat2",
              "action": "CALL",
              "amount": 60,
              "to_amount": 60,
              "all_in": false,
              "note": null,
              "posting_meta": null
            }
          ]
        },
        "TURN": {
          "board": [
            "4h",
            "4s",
            "Qh",
            "2h"
          ],
          "actions": [
            {
              "order": 8,
              "street": "TURN",
              "actor_uid": "seat1",
              "action": "BET",
              "amount": 150,
              "to_amount": 150,
              "all_in": false,
              "note": null,
              "posting_meta": null
            },
            {
              "order": 9,
              "street": "TURN",
              "actor_uid": "seat2",
              "action": "CALL",
              "amount": 150,
              "to_amount": 150,
              "all_in": false,
              "note": null,
              "posting_meta": null
            }
          ]
        },
        "RIVER": {
          "board": [
            "4h",
            "4s",
            "Qh",
            "2h",
            "2d"
          ],
          "actions": [
            {
              "order": 10,
              "street": "RIVER",
              "actor_uid": "seat1",
              "action": "BET",
              "amount": 760,
              "to_amount": 760,
              "all_in": true,
              "note": null,
              "posting_meta": null
            },
            {
              "order": 11,
              "street": "RIVER",
              "actor_uid": "seat2",
              "action": "CALL",
              "amount": 760,
              "to_amount": 760,
              "all_in": false,
              "note": null,
              "posting_meta": null
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "BB002",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "As",
            "Ah"
          ],
          "seat2": [
            "7d",
            "2c"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Doug Polk",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Villain",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "actor_uid": null,
              "action": "DEAL_HOLE",
              "amount": 0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "actor_uid": "seat1",
              "action": "POST_BLIND",
              "amount": 5,
              "to_amount": 5,
              "all_in": false,
              "note": null,
              "posting_meta": {
                "blind_type": "SB"
              }
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "actor_uid": "seat2",
              "action": "POST_BLIND",
              "amount": 10,
              "to_amount": 10,
              "all_in": false,
              "note": null,
              "posting_meta": {
                "blind_type": "BB"
              }
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "actor_uid": "seat1",
              "action": "RAISE",
              "amount": 30,
              "to_amount": 30,
              "all_in": false,
              "note": null,
              "posting_meta": null
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "actor_uid": "seat2",
              "action": "CALL",
              "amount": 30,
              "to_amount": 30,
              "all_in": false,
              "note": null,
              "posting_meta": null
            }
          ]
        },
        "FLOP": {
          "board": [
            "Th",
            "9h",
            "3h"
          ],
          "actions": [
            {
              "order": 6,
              "street": "FLOP",
              "actor_uid": "seat1",
              "action": "BET",
              "amount": 60,
              "to_amount": 60,
              "all_in": false,
              "note": null,
              "posting_meta": null
            },
            {
              "order": 7,
              "street": "FLOP",
              "actor_uid": "seat2",
              "action": "CALL",
              "amount": 60,
              "to_amount": 60,
              "all_in": false,
              "note": null,
              "posting_meta": null
            }
          ]
        },
        "TURN": {
          "board": [
            "Th",
            "9h",
            "3h",
            "5h"
          ],
          "actions": [
            {
              "order": 8,
              "street": "TURN",
              "actor_uid": "seat1",
              "action": "BET",
              "amount": 150,
              "to_amount": 150,
              "all_in": false,
              "note": null,
              "posting_meta": null
            },
            {
              "order": 9,
              "street": "TURN",
              "actor_uid": "seat2",
              "action": "CALL",
              "amount": 150,
              "to_amount": 150,
              "all_in": false,
              "note": null,
              "posting_meta": null
            }
          ]
        },
        "RIVER": {
          "board": [
            "Th",
            "9h",
            "3h",
            "5h",
            "Kd"
          ],
          "actions": [
            {
              "order": 10,
              "street": "RIVER",
              "actor_uid": "seat1",
              "action": "BET",
              "amount": 760,
              "to_amount": 760,
              "all_in": true,
              "note": null,
              "posting_meta": null
            },
            {
              "order": 11,
              "street": "RIVER",
              "actor_uid": "seat2",
              "action": "CALL",
              "amount": 760,
              "to_amount": 760,
              "all_in": false,
              "note": null,
              "posting_meta": null
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "BB003",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "9s",
            "9d"
          ],
          "seat2": [
            "Jh",
            "Tc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Phil Hellmuth",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Opponent",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "actor_uid": null,
              "action": "DEAL_HOLE",
              "amount": 0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "actor_uid": "seat1",
              "action": "POST_BLIND",
              "amount": 5,
              "to_amount": 5,


# FILE TRUNCATED FOR BREVITY
# Showing first 500 and last 500 lines
# Total lines: 23604
# File size: 569.0 KB

        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Bubble Player",
          "starting_stack": 500,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Opponent",
          "starting_stack": 800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "actor_uid": null,
              "action": "DEAL_HOLE",
              "amount": 0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "actor_uid": "seat1",
              "action": "POST_BLIND",
              "amount": 5,
              "to_amount": 5,
              "all_in": false,
              "note": null,
              "posting_meta": {
                "blind_type": "SB"
              }
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "actor_uid": "seat2",
              "action": "POST_BLIND",
              "amount": 10,
              "to_amount": 10,
              "all_in": false,
              "note": null,
              "posting_meta": {
                "blind_type": "BB"
              }
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "actor_uid": "seat1",
              "action": "RAISE",
              "amount": 20,
              "to_amount": 20,
              "all_in": false,
              "note": null,
              "posting_meta": null
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "actor_uid": "seat2",
              "action": "CALL",
              "amount": 20,
              "to_amount": 20,
              "all_in": false,
              "note": null,
              "posting_meta": null
            }
          ]
        },
        "FLOP": {
          "board": [
            "Qh",
            "Td",
            "4s"
          ],
          "actions": [
            {
              "order": 6,
              "street": "FLOP",
              "actor_uid": "seat2",
              "action": "CHECK",
              "amount": 0,
              "to_amount": null,
              "all_in": false,
              "note": null,
              "posting_meta": null
            },
            {
              "order": 7,
              "street": "FLOP",
              "actor_uid": "seat1",
              "action": "CHECK",
              "amount": 0,
              "to_amount": null,
              "all_in": false,
              "note": null,
              "posting_meta": null
            }
          ]
        },
        "TURN": {
          "board": [
            "Qh",
            "Td",
            "4s",
            "7s"
          ],
          "actions": [
            {
              "order": 8,
              "street": "TURN",
              "actor_uid": "seat2",
              "action": "BET",
              "amount": 40,
              "to_amount": 40,
              "all_in": false,
              "note": null,
              "posting_meta": null
            },
            {
              "order": 9,
              "street": "TURN",
              "actor_uid": "seat1",
              "action": "CALL",
              "amount": 40,
              "to_amount": 40,
              "all_in": false,
              "note": null,
              "posting_meta": null
            },
            {
              "order": 10,
              "street": "TURN",
              "actor_uid": "seat2",
              "action": "CHECK",
              "amount": 0
            },
            {
              "order": 11,
              "street": "TURN",
              "actor_uid": "seat1",
              "action": "CHECK",
              "amount": 0,
              "to_amount": null,
              "all_in": false,
              "note": null,
              "posting_meta": null
            }
          ]
        },
        "RIVER": {
          "board": [
            "Qh",
            "Td",
            "4s",
            "7s",
            "8s"
          ],
          "actions": [
            {
              "order": 12,
              "street": "RIVER",
              "actor_uid": "seat2",
              "action": "BET",
              "amount": 80,
              "to_amount": 80,
              "all_in": false,
              "note": null,
              "posting_meta": null
            },
            {
              "order": 13,
              "street": "RIVER",
              "actor_uid": "seat1",
              "action": "CALL",
              "amount": 80,
              "to_amount": 80,
              "all_in": false,
              "note": null,
              "posting_meta": null
            },
            {
              "order": 14,
              "street": "RIVER",
              "actor_uid": "seat2",
              "action": "CHECK",
              "amount": 0
            },
            {
              "order": 15,
              "street": "RIVER",
              "actor_uid": "seat1",
              "action": "CHECK",
              "amount": 0,
              "to_amount": null,
              "all_in": false,
              "note": null,
              "posting_meta": null
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 295,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "BP010",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Bubble Player",
          "starting_stack": 500,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Opponent",
          "starting_stack": 800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "actor_uid": null,
              "action": "DEAL_HOLE",
              "amount": 0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "actor_uid": "seat1",
              "action": "POST_BLIND",
              "amount": 5,
              "to_amount": 5,
              "all_in": false,
              "note": null,
              "posting_meta": {
                "blind_type": "SB"
              }
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "actor_uid": "seat2",
              "action": "POST_BLIND",
              "amount": 10,
              "to_amount": 10,
              "all_in": false,
              "note": null,
              "posting_meta": {
                "blind_type": "BB"
              }
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "actor_uid": "seat1",
              "action": "RAISE",
              "amount": 20,
              "to_amount": 20,
              "all_in": false,
              "note": null,
              "posting_meta": null
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "actor_uid": "seat2",
              "action": "CALL",
              "amount": 20,
              "to_amount": 20,
              "all_in": false,
              "note": null,
              "posting_meta": null
            }
          ]
        },
        "FLOP": {
          "board": [
            "2h",
            "8d",
            "Jd"
          ],
          "actions": [
            {
              "order": 6,
              "street": "FLOP",
              "actor_uid": "seat2",
              "action": "CHECK",
              "amount": 0,
              "to_amount": null,
              "all_in": false,
              "note": null,
              "posting_meta": null
            },
            {
              "order": 7,
              "street": "FLOP",
              "actor_uid": "seat1",
              "action": "CHECK",
              "amount": 0,
              "to_amount": null,
              "all_in": false,
              "note": null,
              "posting_meta": null
            }
          ]
        },
        "TURN": {
          "board": [
            "2h",
            "8d",
            "Jd",
            "7h"
          ],
          "actions": [
            {
              "order": 8,
              "street": "TURN",
              "actor_uid": "seat2",
              "action": "BET",
              "amount": 40,
              "to_amount": 40,
              "all_in": false,
              "note": null,
              "posting_meta": null
            },
            {
              "order": 9,
              "street": "TURN",
              "actor_uid": "seat1",
              "action": "CALL",
              "amount": 40,
              "to_amount": 40,
              "all_in": false,
              "note": null,
              "posting_meta": null
            },
            {
              "order": 10,
              "street": "TURN",
              "actor_uid": "seat2",
              "action": "CHECK",
              "amount": 0
            },
            {
              "order": 11,
              "street": "TURN",
              "actor_uid": "seat1",
              "action": "CHECK",
              "amount": 0,
              "to_amount": null,
              "all_in": false,
              "note": null,
              "posting_meta": null
            }
          ]
        },
        "RIVER": {
          "board": [
            "2h",
            "8d",
            "Jd",
            "7h",
            "6h"
          ],
          "actions": [
            {
              "order": 12,
              "street": "RIVER",
              "actor_uid": "seat2",
              "action": "BET",
              "amount": 80,
              "to_amount": 80,
              "all_in": false,
              "note": null,
              "posting_meta": null
            },
            {
              "order": 13,
              "street": "RIVER",
              "actor_uid": "seat1",
              "action": "CALL",
              "amount": 80,
              "to_amount": 80,
              "all_in": false,
              "note": null,
              "posting_meta": null
            },
            {
              "order": 14,
              "street": "RIVER",
              "actor_uid": "seat2",
              "action": "CHECK",
              "amount": 0
            },
            {
              "order": 15,
              "street": "RIVER",
              "actor_uid": "seat1",
              "action": "CHECK",
              "amount": 0,
              "to_amount": null,
              "all_in": false,
              "note": null,
              "posting_meta": null
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 295,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    }
  ]
}
```

---

### legendary_hands_normalized.json

**Path**: `backend/data/legendary_hands_normalized.json`

**Size**: 427.2 KB

```json
{
  "hands": [
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "BB001",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Kh",
            "Kd"
          ],
          "seat2": [
            "Ad",
            "2c"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player 1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player 2",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 30.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "4h",
            "4s",
            "Qh"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 60.0
            }
          ]
        },
        "TURN": {
          "board": [
            "4h",
            "4s",
            "Qh",
            "2h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "4h",
            "4s",
            "Qh",
            "2h",
            "2d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 760.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 760.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "BB002",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "As",
            "Ah"
          ],
          "seat2": [
            "7d",
            "2c"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Doug Polk",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Villain",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 30.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Th",
            "9h",
            "3h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 60.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Th",
            "9h",
            "3h",
            "5h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Th",
            "9h",
            "3h",
            "5h",
            "Kd"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 760.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 760.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "BB003",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "9s",
            "9d"
          ],
          "seat2": [
            "Jh",
            "Tc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Phil Hellmuth",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Opponent",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 30.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Kh",
            "3c",
            "7h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 60.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Kh",
            "3c",
            "7h",
            "6c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Kh",
            "3c",
            "7h",
            "6c",
            "Js"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 760.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 760.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "BB004",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Kh",
            "Kd"
          ],
          "seat2": [
            "Ah",
            "2s"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 30.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "9c",
            "5d",
            "4c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 60.0
            }
          ]
        },
        "TURN": {
          "board": [
            "9c",
            "5d",
            "4c",
            "Qs"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "9c",
            "5d",
            "4c",
            "Qs",
            "Qc"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 760.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 760.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "BB005",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Qh",
            "Qd"
          ],
          "seat2": [
            "Jc",
            "9s"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 30.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "2s",
            "Jd",
            "6c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 60.0
            }
          ]
        },
        "TURN": {
          "board": [
            "2s",
            "Jd",
            "6c",
            "Ac"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "2s",
            "Jd",
            "6c",
            "Ac",
            "As"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 760.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 760.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "BB006",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kd"
          ],
          "seat2": [
            "7c",
            "2s"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 30.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Jd",
            "5c",
            "Qs"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 60.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Jd",
            "5c",
            "Qs",
            "Th"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Jd",
            "5c",
            "Qs",
            "Th",
            "9d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 760.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 760.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "BB007",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Jh",
            "Jd"
          ],
          "seat2": [
            "Tc",
            "9s"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 30.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Ad",
            "Qd",
            "4d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 60.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Ad",
            "Qd",
            "4d",
            "5h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Ad",
            "Qd",
            "4d",
            "5h",
            "Qs"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 760.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 760.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "BB008",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Th",
            "Td"
          ],
          "seat2": [
            "9c",
            "8s"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 30.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "5h",
            "As",
            "7c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 60.0
            }
          ]
        },
        "TURN": {
          "board": [
            "5h",
            "As",
            "7c",
            "9h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "5h",
            "As",
            "7c",
            "9h",
            "9s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 760.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 760.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "BB009",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "9h",
            "9d"
          ],
          "seat2": [
            "8c",
            "7s"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 30.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Qd",
            "Qh",
            "8h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 60.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Qd",
            "Qh",
            "8h",
            "Th"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Qd",
            "Qh",
            "8h",
            "Th",
            "Ac"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 760.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 760.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "BB010",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "8h",
            "8d"
          ],
          "seat2": [
            "7c",
            "6s"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 30.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Qh",
            "7h",
            "6d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 60.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Qh",
            "7h",
            "6d",
            "Qd"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Qh",
            "7h",
            "6d",
            "Qd",
            "5c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 760.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 760.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "HC001",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Jd"
          ],
          "seat2": [
            "Ks",
            "Qs"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Hero",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Villain",
          "starting_stack": 1200,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 25.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 25.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "4h",
            "9c",
            "Ts"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "4h",
            "9c",
            "Ts",
            "7s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 35.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 35.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "4h",
            "9c",
            "Ts",
            "7s",
            "Kh"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 200.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 200.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 535,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "HC002",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Qd",
            "Jh"
          ],
          "seat2": [
            "Ks",
            "Qs"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Hero",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Villain",
          "starting_stack": 1200,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 25.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 25.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "8s",
            "Kd",
            "8d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "8s",
            "Kd",
            "8d",
            "Ts"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 35.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 35.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "8s",
            "Kd",
            "8d",
            "Ts",
            "6h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 200.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 200.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 535,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "HC003",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Jh",
            "Td"
          ],
          "seat2": [
            "Ks",
            "Qs"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Hero",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Villain",
          "starting_stack": 1200,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 25.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 25.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Qh",
            "5d",
            "3d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Qh",
            "5d",
            "3d",
            "7c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 35.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 35.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Qh",
            "5d",
            "3d",
            "7c",
            "Qd"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 200.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 200.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 535,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "HC004",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Th",
            "9d"
          ],
          "seat2": [
            "Ks",
            "Qs"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Hero",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Villain",
          "starting_stack": 1200,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 25.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 25.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "8s",
            "8c",
            "Qd"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "8s",
            "8c",
            "Qd",
            "4h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 35.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 35.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "8s",
            "8c",
            "Qd",
            "4h",
            "8d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 200.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 200.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 535,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "HC005",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "9h",
            "8d"
          ],
          "seat2": [
            "Ks",
            "Qs"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Hero",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Villain",
          "starting_stack": 1200,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 25.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 25.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Tc",
            "6c",
            "2c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Tc",
            "6c",
            "2c",
            "Kc"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 35.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 35.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Tc",
            "6c",
            "2c",
            "Kc",
            "4s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 200.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 200.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 535,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "HC006",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "8h",
            "7d"
          ],
          "seat2": [
            "Ks",
            "Qs"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Hero",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Villain",
          "starting_stack": 1200,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 25.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 25.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "As",
            "Kc",
            "2s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "As",
            "Kc",
            "2s",
            "Ad"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 35.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 35.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "As",
            "Kc",
            "2s",
            "Ad",
            "7c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 200.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 200.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 535,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "HC007",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "7h",
            "6d"
          ],
          "seat2": [
            "Ks",
            "Qs"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Hero",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Villain",
          "starting_stack": 1200,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 25.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 25.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "7s",
            "6c",
            "5s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "7s",
            "6c",
            "5s",
            "8h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 35.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 35.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "7s",
            "6c",
            "5s",
            "8h",
            "6h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 200.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 200.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 535,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "HC008",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "6h",
            "5d"
          ],
          "seat2": [
            "Ks",
            "Qs"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Hero",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Villain",
          "starting_stack": 1200,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 25.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 25.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "6s",
            "Td",
            "As"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "6s",
            "Td",
            "As",
            "2c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 35.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 35.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "6s",
            "Td",
            "As",
            "2c",
            "5h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 200.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 200.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 535,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "HC009",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "5h",
            "4d"
          ],
          "seat2": [
            "Ks",
            "Qs"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Hero",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Villain",
          "starting_stack": 1200,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 25.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 25.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "2d",
            "8c",
            "Ac"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "2d",
            "8c",
            "Ac",
            "5s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 35.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 35.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "2d",
            "8c",
            "Ac",
            "5s",
            "Qh"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 200.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 200.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 535,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "HC010",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "4h",
            "3d"
          ],
          "seat2": [
            "Ks",
            "Qs"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Hero",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Villain",
          "starting_stack": 1200,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 25.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 25.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "5h",
            "Qd",
            "As"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "5h",
            "Qd",
            "As",
            "9h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 35.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 35.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "5h",
            "Qd",
            "As",
            "9h",
            "Ac"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 200.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 200.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 535,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "MB001",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "5d",
            "4d"
          ],
          "seat2": [
            "Qc",
            "9h"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Bluffer",
          "starting_stack": 2000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Caller",
          "starting_stack": 1800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 100.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 100.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "4c",
            "3s",
            "9c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 175.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "RAISE",
              "actor_uid": "seat2",
              "amount": 500.0
            },
            {
              "order": 4,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 325.0
            }
          ]
        },
        "TURN": {
          "board": [
            "4c",
            "3s",
            "9c",
            "2s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "4c",
            "3s",
            "9c",
            "2s",
            "Qd"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 300.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 1400.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "FOLD",
              "actor_uid": "seat2",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2915,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "MB002",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "5d",
            "4d"
          ],
          "seat2": [
            "Qc",
            "9h"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Bluffer",
          "starting_stack": 2000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Caller",
          "starting_stack": 1800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 100.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 100.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Th",
            "Ts",
            "Kc"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 175.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "RAISE",
              "actor_uid": "seat2",
              "amount": 500.0
            },
            {
              "order": 4,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 325.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Th",
            "Ts",
            "Kc",
            "2s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Th",
            "Ts",
            "Kc",
            "2s",
            "9d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 300.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 1400.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "FOLD",
              "actor_uid": "seat2",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2915,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "MB003",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "5d",
            "4d"
          ],
          "seat2": [
            "Qc",
            "9h"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Bluffer",
          "starting_stack": 2000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Caller",
          "starting_stack": 1800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 100.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 100.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Qs",
            "4h",
            "8d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 175.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "RAISE",
              "actor_uid": "seat2",
              "amount": 500.0
            },
            {
              "order": 4,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 325.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Qs",
            "4h",
            "8d",
            "Kd"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Qs",
            "4h",
            "8d",
            "Kd",
            "6s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 300.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 1400.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "FOLD",
              "actor_uid": "seat2",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2915,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "MB004",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "5d",
            "4d"
          ],
          "seat2": [
            "Qc",
            "9h"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Bluffer",
          "starting_stack": 2000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Caller",
          "starting_stack": 1800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 100.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 100.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "2c",
            "Qh",
            "5c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 175.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "RAISE",
              "actor_uid": "seat2",
              "amount": 500.0
            },
            {
              "order": 4,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 325.0
            }
          ]
        },
        "TURN": {
          "board": [
            "2c",
            "Qh",
            "5c",
            "2s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "2c",
            "Qh",
            "5c",
            "2s",
            "Kd"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 300.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 1400.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "FOLD",
              "actor_uid": "seat2",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2915,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "MB005",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "5d",
            "4d"
          ],
          "seat2": [
            "Qc",
            "9h"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Bluffer",
          "starting_stack": 2000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Caller",
          "starting_stack": 1800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 100.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 100.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "3s",
            "Td",
            "7h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 175.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "RAISE",
              "actor_uid": "seat2",
              "amount": 500.0
            },
            {
              "order": 4,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 325.0
            }
          ]
        },
        "TURN": {
          "board": [
            "3s",
            "Td",
            "7h",
            "Jc"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "3s",
            "Td",
            "7h",
            "Jc",
            "Ts"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 300.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 1400.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "FOLD",
              "actor_uid": "seat2",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2915,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "MB006",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "5d",
            "4d"
          ],
          "seat2": [
            "Qc",
            "9h"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Bluffer",
          "starting_stack": 2000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Caller",
          "starting_stack": 1800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 100.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 100.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Td",
            "5h",
            "3c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 175.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "RAISE",
              "actor_uid": "seat2",
              "amount": 500.0
            },
            {
              "order": 4,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 325.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Td",
            "5h",
            "3c",
            "3s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Td",
            "5h",
            "3c",
            "3s",
            "Qs"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 300.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 1400.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "FOLD",
              "actor_uid": "seat2",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2915,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "MB007",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "5d",
            "4d"
          ],
          "seat2": [
            "Qc",
            "9h"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Bluffer",
          "starting_stack": 2000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Caller",
          "starting_stack": 1800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 100.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 100.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "8h",
            "Kh",
            "Ad"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 175.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "RAISE",
              "actor_uid": "seat2",
              "amount": 500.0
            },
            {
              "order": 4,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 325.0
            }
          ]
        },
        "TURN": {
          "board": [
            "8h",
            "Kh",
            "Ad",
            "6s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "8h",
            "Kh",
            "Ad",
            "6s",
            "9c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 300.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 1400.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "FOLD",
              "actor_uid": "seat2",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2915,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "MB008",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "5d",
            "4d"
          ],
          "seat2": [
            "Qc",
            "9h"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Bluffer",
          "starting_stack": 2000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Caller",
          "starting_stack": 1800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 100.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 100.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "7h",
            "Ad",
            "Kd"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 175.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "RAISE",
              "actor_uid": "seat2",
              "amount": 500.0
            },
            {
              "order": 4,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 325.0
            }
          ]
        },
        "TURN": {
          "board": [
            "7h",
            "Ad",
            "Kd",
            "8d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "7h",
            "Ad",
            "Kd",
            "8d",
            "3d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 300.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 1400.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "FOLD",
              "actor_uid": "seat2",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2915,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "MB009",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "5d",
            "4d"
          ],
          "seat2": [
            "Qc",
            "9h"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Bluffer",
          "starting_stack": 2000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Caller",
          "starting_stack": 1800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 100.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 100.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Jd",
            "2s",
            "Jc"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 175.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "RAISE",
              "actor_uid": "seat2",
              "amount": 500.0
            },
            {
              "order": 4,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 325.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Jd",
            "2s",
            "Jc",
            "7h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Jd",
            "2s",
            "Jc",
            "7h",
            "9s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 300.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 1400.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "FOLD",
              "actor_uid": "seat2",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2915,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "MB010",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "5d",
            "4d"
          ],
          "seat2": [
            "Qc",
            "9h"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Bluffer",
          "starting_stack": 2000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Caller",
          "starting_stack": 1800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 100.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 100.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Qd",
            "8s",
            "5h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 175.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "RAISE",
              "actor_uid": "seat2",
              "amount": 500.0
            },
            {
              "order": 4,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 325.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Qd",
            "8s",
            "5h",
            "6d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Qd",
            "8s",
            "5h",
            "6d",
            "4s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 300.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 1400.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "FOLD",
              "actor_uid": "seat2",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2915,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "CH001",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Kh",
            "Kd"
          ],
          "seat2": [
            "Ah",
            "Ad"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 30.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "As",
            "7c",
            "Qh"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 60.0
            }
          ]
        },
        "TURN": {
          "board": [
            "As",
            "7c",
            "Qh",
            "6c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "As",
            "7c",
            "Qh",
            "6c",
            "6d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 760.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 760.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "CH002",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "7h",
            "8h"
          ],
          "seat2": [
            "Kh",
            "Kd"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 30.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Jc",
            "4c",
            "4s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 60.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Jc",
            "4c",
            "4s",
            "9h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Jc",
            "4c",
            "4s",
            "9h",
            "2d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 760.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 760.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "CH003",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "7h",
            "8h"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 30.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Th",
            "4c",
            "9h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 60.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Th",
            "4c",
            "9h",
            "2s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Th",
            "4c",
            "9h",
            "2s",
            "3d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 760.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 760.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "CH004",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Ad"
          ],
          "seat2": [
            "Kh",
            "Qh"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 30.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "9c",
            "2c",
            "5d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 60.0
            }
          ]
        },
        "TURN": {
          "board": [
            "9c",
            "2c",
            "5d",
            "5h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "9c",
            "2c",
            "5d",
            "5h",
            "Js"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 760.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 760.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "CH005",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Jc",
            "Tc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 30.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "9s",
            "2c",
            "2s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 60.0
            }
          ]
        },
        "TURN": {
          "board": [
            "9s",
            "2c",
            "2s",
            "9d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "9s",
            "2c",
            "2s",
            "9d",
            "Jh"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 760.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 760.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "CH006",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Jc",
            "Tc"
          ],
          "seat2": [
            "Ah",
            "Ad"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 30.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "5s",
            "6d",
            "6c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 60.0
            }
          ]
        },
        "TURN": {
          "board": [
            "5s",
            "6d",
            "6c",
            "8c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "5s",
            "6d",
            "6c",
            "8c",
            "5c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 760.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 760.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "CH007",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Ad"
          ],
          "seat2": [
            "Kh",
            "Qd"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 30.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "8h",
            "Tc",
            "Th"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 60.0
            }
          ]
        },
        "TURN": {
          "board": [
            "8h",
            "Tc",
            "Th",
            "3c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "8h",
            "Tc",
            "Th",
            "3c",
            "Qh"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 760.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 760.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "CH008",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Kh",
            "Qd"
          ],
          "seat2": [
            "Ah",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 30.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "9c",
            "8c",
            "Ac"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 60.0
            }
          ]
        },
        "TURN": {
          "board": [
            "9c",
            "8c",
            "Ac",
            "8h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "9c",
            "8c",
            "Ac",
            "8h",
            "Qc"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 760.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 760.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "CH009",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Jc"
          ],
          "seat2": [
            "Kh",
            "Qd"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 30.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Ac",
            "6d",
            "Tc"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 60.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Ac",
            "6d",
            "Tc",
            "6h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Ac",
            "6d",
            "Tc",
            "6h",
            "7s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 760.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 760.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "CH010",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Jc"
          ],
          "seat2": [
            "Kh",
            "Qd"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 30.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "4s",
            "8c",
            "Ac"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 60.0
            }
          ]
        },
        "TURN": {
          "board": [
            "4s",
            "8c",
            "Ac",
            "2d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "4s",
            "8c",
            "Ac",
            "2d",
            "3d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 760.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 760.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 2015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "WS001",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Champion",
          "starting_stack": 5000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Runner-up",
          "starting_stack": 4500,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 200.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 200.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "7d",
            "Kc",
            "3d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 400.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 400.0
            }
          ]
        },
        "TURN": {
          "board": [
            "7d",
            "Kc",
            "3d",
            "Jd"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 800.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 800.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "7d",
            "Kc",
            "3d",
            "Jd",
            "5d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 1600.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 1600.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 6015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "WS002",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Champion",
          "starting_stack": 5000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Runner-up",
          "starting_stack": 4500,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 200.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 200.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "8h",
            "Tc",
            "Jd"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 400.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 400.0
            }
          ]
        },
        "TURN": {
          "board": [
            "8h",
            "Tc",
            "Jd",
            "Ts"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 800.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 800.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "8h",
            "Tc",
            "Jd",
            "Ts",
            "8s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 1600.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 1600.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 6015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "WS003",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Champion",
          "starting_stack": 5000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Runner-up",
          "starting_stack": 4500,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 200.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 200.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "7c",
            "7h",
            "2h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 400.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 400.0
            }
          ]
        },
        "TURN": {
          "board": [
            "7c",
            "7h",
            "2h",
            "9d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 800.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 800.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "7c",
            "7h",
            "2h",
            "9d",
            "Jd"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 1600.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 1600.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 6015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "WS004",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Champion",
          "starting_stack": 5000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Runner-up",
          "starting_stack": 4500,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 200.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 200.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "2h",
            "Kc",
            "6d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 400.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 400.0
            }
          ]
        },
        "TURN": {
          "board": [
            "2h",
            "Kc",
            "6d",
            "Qs"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 800.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 800.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "2h",
            "Kc",
            "6d",
            "Qs",
            "4s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 1600.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 1600.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 6015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "WS005",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Champion",
          "starting_stack": 5000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Runner-up",
          "starting_stack": 4500,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 200.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 200.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "5c",
            "Kd",
            "As"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 400.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 400.0
            }
          ]
        },
        "TURN": {
          "board": [
            "5c",
            "Kd",
            "As",
            "7s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 800.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 800.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "5c",
            "Kd",
            "As",
            "7s",
            "Jh"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 1600.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 1600.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 6015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "WS006",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Champion",
          "starting_stack": 5000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Runner-up",
          "starting_stack": 4500,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 200.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 200.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "2d",
            "9c",
            "Tc"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 400.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 400.0
            }
          ]
        },
        "TURN": {
          "board": [
            "2d",
            "9c",
            "Tc",
            "8h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 800.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 800.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "2d",
            "9c",
            "Tc",
            "8h",
            "2s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 1600.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 1600.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 6015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "WS007",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Champion",
          "starting_stack": 5000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Runner-up",
          "starting_stack": 4500,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 200.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 200.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "8s",
            "9s",
            "6d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 400.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 400.0
            }
          ]
        },
        "TURN": {
          "board": [
            "8s",
            "9s",
            "6d",
            "Jd"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 800.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 800.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "8s",
            "9s",
            "6d",
            "Jd",
            "7d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 1600.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 1600.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 6015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "WS008",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Champion",
          "starting_stack": 5000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Runner-up",
          "starting_stack": 4500,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 200.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 200.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Td",
            "4s",
            "3h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 400.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 400.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Td",
            "4s",
            "3h",
            "Tc"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 800.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 800.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Td",
            "4s",
            "3h",
            "Tc",
            "Qc"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 1600.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 1600.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 6015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "WS009",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Champion",
          "starting_stack": 5000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Runner-up",
          "starting_stack": 4500,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 200.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 200.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "4h",
            "4c",
            "Ac"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 400.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 400.0
            }
          ]
        },
        "TURN": {
          "board": [
            "4h",
            "4c",
            "Ac",
            "Ts"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 800.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 800.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "4h",
            "4c",
            "Ac",
            "Ts",
            "8c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 1600.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 1600.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 6015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "WS010",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Champion",
          "starting_stack": 5000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Runner-up",
          "starting_stack": 4500,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 200.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 200.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "6s",
            "5s",
            "4s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 400.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 400.0
            }
          ]
        },
        "TURN": {
          "board": [
            "6s",
            "5s",
            "4s",
            "3d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 800.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 800.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "6s",
            "5s",
            "4s",
            "3d",
            "8c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 1600.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 1600.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 6015,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "TV001",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 2000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Qh",
            "Tc",
            "5s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 300.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 300.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Qh",
            "Tc",
            "5s",
            "9d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 600.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 600.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Qh",
            "Tc",
            "5s",
            "9d",
            "2h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 950.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 750.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 3815,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "TV002",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 2000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Tc",
            "6h",
            "Ks"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 300.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 300.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Tc",
            "6h",
            "Ks",
            "Jd"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 600.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 600.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Tc",
            "6h",
            "Ks",
            "Jd",
            "2h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 950.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 750.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 3815,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "TV003",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 2000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Ts",
            "6c",
            "Td"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 300.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 300.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Ts",
            "6c",
            "Td",
            "2s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 600.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 600.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Ts",
            "6c",
            "Td",
            "2s",
            "7s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 950.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 750.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 3815,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "TV004",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 2000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "8d",
            "Jh",
            "Ks"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 300.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 300.0
            }
          ]
        },
        "TURN": {
          "board": [
            "8d",
            "Jh",
            "Ks",
            "2d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 600.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 600.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "8d",
            "Jh",
            "Ks",
            "2d",
            "Td"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 950.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 750.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 3815,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "TV005",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 2000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Ts",
            "6h",
            "8d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 300.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 300.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Ts",
            "6h",
            "8d",
            "2d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 600.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 600.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Ts",
            "6h",
            "8d",
            "2d",
            "7d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 950.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 750.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 3815,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "TV006",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 2000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "8s",
            "Qs",
            "As"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 300.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 300.0
            }
          ]
        },
        "TURN": {
          "board": [
            "8s",
            "Qs",
            "As",
            "Td"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 600.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 600.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "8s",
            "Qs",
            "As",
            "Td",
            "7d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 950.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 750.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 3815,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "TV007",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 2000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "3d",
            "6c",
            "6h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 300.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 300.0
            }
          ]
        },
        "TURN": {
          "board": [
            "3d",
            "6c",
            "6h",
            "Ks"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 600.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 600.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "3d",
            "6c",
            "6h",
            "Ks",
            "Jd"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 950.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 750.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 3815,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "TV008",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 2000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Js",
            "7s",
            "6s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 300.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 300.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Js",
            "7s",
            "6s",
            "5h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 600.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 600.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Js",
            "7s",
            "6s",
            "5h",
            "4d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 950.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 750.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 3815,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "TV009",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 2000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "2h",
            "2s",
            "Jh"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 300.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 300.0
            }
          ]
        },
        "TURN": {
          "board": [
            "2h",
            "2s",
            "Jh",
            "Ts"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 600.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 600.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "2h",
            "2s",
            "Jh",
            "Ts",
            "4d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 950.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 750.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 3815,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "TV010",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 2000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 150.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 150.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Js",
            "Tc",
            "Kc"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 300.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 300.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Js",
            "Tc",
            "Kc",
            "6c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 600.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 600.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Js",
            "Tc",
            "Kc",
            "6c",
            "7s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 950.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 750.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 3815,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "HU001",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Kd",
            "Qc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 50.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 50.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "7c",
            "3c",
            "Td"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 100.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 100.0
            }
          ]
        },
        "TURN": {
          "board": [
            "7c",
            "3c",
            "Td",
            "4h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 200.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 200.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "7c",
            "3c",
            "Td",
            "4h",
            "Ac"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 400.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 400.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 1515,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "HU002",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Qh",
            "Jd"
          ],
          "seat2": [
            "Jc",
            "Tc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 50.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 50.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Ad",
            "4c",
            "Js"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 100.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 100.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Ad",
            "4c",
            "Js",
            "Kc"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 200.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 200.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Ad",
            "4c",
            "Js",
            "Kc",
            "5d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 400.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 400.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 1515,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "HU003",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Th",
            "9d"
          ],
          "seat2": [
            "9c",
            "8s"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 50.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 50.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "3s",
            "7d",
            "2s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 100.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 100.0
            }
          ]
        },
        "TURN": {
          "board": [
            "3s",
            "7d",
            "2s",
            "Kc"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 200.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 200.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "3s",
            "7d",
            "2s",
            "Kc",
            "Ts"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 400.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 400.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 1515,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "HU004",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "8h",
            "7d"
          ],
          "seat2": [
            "7c",
            "6s"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 50.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 50.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "2c",
            "4d",
            "2d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 100.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 100.0
            }
          ]
        },
        "TURN": {
          "board": [
            "2c",
            "4d",
            "2d",
            "9s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 200.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 200.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "2c",
            "4d",
            "2d",
            "9s",
            "5s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 400.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 400.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 1515,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "HU005",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "6h",
            "5d"
          ],
          "seat2": [
            "5c",
            "4s"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 50.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 50.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "9h",
            "Qd",
            "Qs"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 100.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 100.0
            }
          ]
        },
        "TURN": {
          "board": [
            "9h",
            "Qd",
            "Qs",
            "8d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 200.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 200.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "9h",
            "Qd",
            "Qs",
            "8d",
            "8h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 400.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 400.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 1515,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "HU006",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "4h",
            "3d"
          ],
          "seat2": [
            "3c",
            "2s"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 50.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 50.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Jh",
            "9d",
            "5c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 100.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 100.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Jh",
            "9d",
            "5c",
            "As"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 200.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 200.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Jh",
            "9d",
            "5c",
            "As",
            "6h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 400.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 400.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 1515,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "HU007",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Qd"
          ],
          "seat2": [
            "Qc",
            "Js"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 50.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 50.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "5d",
            "Ks",
            "4s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 100.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 100.0
            }
          ]
        },
        "TURN": {
          "board": [
            "5d",
            "Ks",
            "4s",
            "9h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 200.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 200.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "5d",
            "Ks",
            "4s",
            "9h",
            "7s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 400.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 400.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 1515,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "HU008",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Kh",
            "Td"
          ],
          "seat2": [
            "Tc",
            "9s"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 50.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 50.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "2d",
            "2s",
            "7h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 100.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 100.0
            }
          ]
        },
        "TURN": {
          "board": [
            "2d",
            "2s",
            "7h",
            "Qd"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 200.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 200.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "2d",
            "2s",
            "7h",
            "Qd",
            "6h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 400.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 400.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 1515,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "HU009",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Jh",
            "8d"
          ],
          "seat2": [
            "8c",
            "7s"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 50.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 50.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "2s",
            "3h",
            "6s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 100.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 100.0
            }
          ]
        },
        "TURN": {
          "board": [
            "2s",
            "3h",
            "6s",
            "Ad"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 200.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 200.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "2s",
            "3h",
            "6s",
            "Ad",
            "5h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 400.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 400.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 1515,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "HU010",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "9h",
            "6d"
          ],
          "seat2": [
            "6c",
            "5s"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 50.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 50.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "2c",
            "Qc",
            "Jc"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 100.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 100.0
            }
          ]
        },
        "TURN": {
          "board": [
            "2c",
            "Qc",
            "Jc",
            "4s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 200.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 200.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "2c",
            "Qc",
            "Jc",
            "4s",
            "Kh"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 400.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 400.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 1515,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "MW001",
        "variant": "NLHE",
        "max_players": 3,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ],
          "seat3": [
            "9s",
            "8h"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        },
        {
          "seat_no": 3,
          "player_uid": "seat3",
          "display_name": "Player3",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat3",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 10.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 6,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat3",
              "amount": 10.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "3s",
            "Ad",
            "7s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 50.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 50.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat3",
              "amount": 50.0
            }
          ]
        },
        "TURN": {
          "board": [
            "3s",
            "Ad",
            "7s",
            "9c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat3",
              "amount": 0.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "3s",
            "Ad",
            "7s",
            "9c",
            "Kc"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat3",
              "amount": 0.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 195,
          "eligible_player_uids": [
            "seat1",
            "seat2",
            "seat3"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "MW002",
        "variant": "NLHE",
        "max_players": 4,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ],
          "seat3": [
            "9s",
            "8h"
          ],
          "seat4": [
            "7d",
            "6c"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        },
        {
          "seat_no": 3,
          "player_uid": "seat3",
          "display_name": "Player3",
          "starting_stack": 1000,
          "is_button": false
        },
        {
          "seat_no": 4,
          "player_uid": "seat4",
          "display_name": "Player4",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat3",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat4",
              "amount": 10.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 10.0
            },
            {
              "order": 6,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 7,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat3",
              "amount": 10.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Th",
            "Tc",
            "Ad"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 50.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 50.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat3",
              "amount": 50.0
            },
            {
              "order": 4,
              "street": "FLOP",
              "action": "FOLD",
              "actor_uid": "seat4",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Th",
            "Tc",
            "Ad",
            "Qc"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat3",
              "amount": 0.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Th",
            "Tc",
            "Ad",
            "Qc",
            "4h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat3",
              "amount": 0.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 205,
          "eligible_player_uids": [
            "seat1",
            "seat2",
            "seat3",
            "seat4"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "MW003",
        "variant": "NLHE",
        "max_players": 5,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ],
          "seat3": [
            "9s",
            "8h"
          ],
          "seat4": [
            "7d",
            "6c"
          ],
          "seat5": [
            "2c",
            "2d"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        },
        {
          "seat_no": 3,
          "player_uid": "seat3",
          "display_name": "Player3",
          "starting_stack": 1000,
          "is_button": false
        },
        {
          "seat_no": 4,
          "player_uid": "seat4",
          "display_name": "Player4",
          "starting_stack": 1000,
          "is_button": false
        },
        {
          "seat_no": 5,
          "player_uid": "seat5",
          "display_name": "Player5",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat3",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat4",
              "amount": 10.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat5",
              "amount": 10.0
            },
            {
              "order": 6,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 10.0
            },
            {
              "order": 7,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 8,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat3",
              "amount": 10.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Qs",
            "2h",
            "Jh"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 50.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 50.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat3",
              "amount": 50.0
            },
            {
              "order": 4,
              "street": "FLOP",
              "action": "FOLD",
              "actor_uid": "seat4",
              "amount": 0.0
            },
            {
              "order": 5,
              "street": "FLOP",
              "action": "FOLD",
              "actor_uid": "seat5",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Qs",
            "2h",
            "Jh",
            "Tc"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat3",
              "amount": 0.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Qs",
            "2h",
            "Jh",
            "Tc",
            "8s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat3",
              "amount": 0.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 215,
          "eligible_player_uids": [
            "seat1",
            "seat2",
            "seat3",
            "seat4",
            "seat5"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "MW004",
        "variant": "NLHE",
        "max_players": 6,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ],
          "seat3": [
            "9s",
            "8h"
          ],
          "seat4": [
            "7d",
            "6c"
          ],
          "seat5": [
            "2c",
            "2d"
          ],
          "seat6": [
            "2h",
            "2s"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        },
        {
          "seat_no": 3,
          "player_uid": "seat3",
          "display_name": "Player3",
          "starting_stack": 1000,
          "is_button": false
        },
        {
          "seat_no": 4,
          "player_uid": "seat4",
          "display_name": "Player4",
          "starting_stack": 1000,
          "is_button": false
        },
        {
          "seat_no": 5,
          "player_uid": "seat5",
          "display_name": "Player5",
          "starting_stack": 1000,
          "is_button": false
        },
        {
          "seat_no": 6,
          "player_uid": "seat6",
          "display_name": "Player6",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat3",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat4",
              "amount": 10.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat5",
              "amount": 10.0
            },
            {
              "order": 6,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat6",
              "amount": 10.0
            },
            {
              "order": 7,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 10.0
            },
            {
              "order": 8,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 9,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat3",
              "amount": 10.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "6s",
            "4s",
            "3s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 50.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 50.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat3",
              "amount": 50.0
            },
            {
              "order": 4,
              "street": "FLOP",
              "action": "FOLD",
              "actor_uid": "seat4",
              "amount": 0.0
            },
            {
              "order": 5,
              "street": "FLOP",
              "action": "FOLD",
              "actor_uid": "seat5",
              "amount": 0.0
            },
            {
              "order": 6,
              "street": "FLOP",
              "action": "FOLD",
              "actor_uid": "seat6",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "6s",
            "4s",
            "3s",
            "3d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat3",
              "amount": 0.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "6s",
            "4s",
            "3s",
            "3d",
            "Js"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat3",
              "amount": 0.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 225,
          "eligible_player_uids": [
            "seat1",
            "seat2",
            "seat3",
            "seat4",
            "seat5",
            "seat6"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "MW005",
        "variant": "NLHE",
        "max_players": 3,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ],
          "seat3": [
            "9s",
            "8h"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        },
        {
          "seat_no": 3,
          "player_uid": "seat3",
          "display_name": "Player3",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat3",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 10.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 6,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat3",
              "amount": 10.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "8d",
            "3h",
            "4d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 50.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 50.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat3",
              "amount": 50.0
            }
          ]
        },
        "TURN": {
          "board": [
            "8d",
            "3h",
            "4d",
            "3d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat3",
              "amount": 0.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "8d",
            "3h",
            "4d",
            "3d",
            "8c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat3",
              "amount": 0.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 195,
          "eligible_player_uids": [
            "seat1",
            "seat2",
            "seat3"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "MW006",
        "variant": "NLHE",
        "max_players": 4,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ],
          "seat3": [
            "9s",
            "8h"
          ],
          "seat4": [
            "7d",
            "6c"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        },
        {
          "seat_no": 3,
          "player_uid": "seat3",
          "display_name": "Player3",
          "starting_stack": 1000,
          "is_button": false
        },
        {
          "seat_no": 4,
          "player_uid": "seat4",
          "display_name": "Player4",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat3",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat4",
              "amount": 10.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 10.0
            },
            {
              "order": 6,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 7,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat3",
              "amount": 10.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "6h",
            "9c",
            "Td"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 50.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 50.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat3",
              "amount": 50.0
            },
            {
              "order": 4,
              "street": "FLOP",
              "action": "FOLD",
              "actor_uid": "seat4",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "6h",
            "9c",
            "Td",
            "7h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat3",
              "amount": 0.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "6h",
            "9c",
            "Td",
            "7h",
            "9h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat3",
              "amount": 0.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 205,
          "eligible_player_uids": [
            "seat1",
            "seat2",
            "seat3",
            "seat4"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "MW007",
        "variant": "NLHE",
        "max_players": 5,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ],
          "seat3": [
            "9s",
            "8h"
          ],
          "seat4": [
            "7d",
            "6c"
          ],
          "seat5": [
            "2c",
            "2d"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        },
        {
          "seat_no": 3,
          "player_uid": "seat3",
          "display_name": "Player3",
          "starting_stack": 1000,
          "is_button": false
        },
        {
          "seat_no": 4,
          "player_uid": "seat4",
          "display_name": "Player4",
          "starting_stack": 1000,
          "is_button": false
        },
        {
          "seat_no": 5,
          "player_uid": "seat5",
          "display_name": "Player5",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat3",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat4",
              "amount": 10.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat5",
              "amount": 10.0
            },
            {
              "order": 6,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 10.0
            },
            {
              "order": 7,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 8,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat3",
              "amount": 10.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "4d",
            "Qh",
            "5d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 50.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 50.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat3",
              "amount": 50.0
            },
            {
              "order": 4,
              "street": "FLOP",
              "action": "FOLD",
              "actor_uid": "seat4",
              "amount": 0.0
            },
            {
              "order": 5,
              "street": "FLOP",
              "action": "FOLD",
              "actor_uid": "seat5",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "4d",
            "Qh",
            "5d",
            "3s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat3",
              "amount": 0.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "4d",
            "Qh",
            "5d",
            "3s",
            "Ad"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat3",
              "amount": 0.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 215,
          "eligible_player_uids": [
            "seat1",
            "seat2",
            "seat3",
            "seat4",
            "seat5"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "MW008",
        "variant": "NLHE",
        "max_players": 6,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ],
          "seat3": [
            "9s",
            "8h"
          ],
          "seat4": [
            "7d",
            "6c"
          ],
          "seat5": [
            "2c",
            "2d"
          ],
          "seat6": [
            "2h",
            "2s"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        },
        {
          "seat_no": 3,
          "player_uid": "seat3",
          "display_name": "Player3",
          "starting_stack": 1000,
          "is_button": false
        },
        {
          "seat_no": 4,
          "player_uid": "seat4",
          "display_name": "Player4",
          "starting_stack": 1000,
          "is_button": false
        },
        {
          "seat_no": 5,
          "player_uid": "seat5",
          "display_name": "Player5",
          "starting_stack": 1000,
          "is_button": false
        },
        {
          "seat_no": 6,
          "player_uid": "seat6",
          "display_name": "Player6",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat3",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat4",
              "amount": 10.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat5",
              "amount": 10.0
            },
            {
              "order": 6,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat6",
              "amount": 10.0
            },
            {
              "order": 7,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 10.0
            },
            {
              "order": 8,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 9,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat3",
              "amount": 10.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "6s",
            "3d",
            "Jh"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 50.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 50.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat3",
              "amount": 50.0
            },
            {
              "order": 4,
              "street": "FLOP",
              "action": "FOLD",
              "actor_uid": "seat4",
              "amount": 0.0
            },
            {
              "order": 5,
              "street": "FLOP",
              "action": "FOLD",
              "actor_uid": "seat5",
              "amount": 0.0
            },
            {
              "order": 6,
              "street": "FLOP",
              "action": "FOLD",
              "actor_uid": "seat6",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "6s",
            "3d",
            "Jh",
            "Ks"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat3",
              "amount": 0.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "6s",
            "3d",
            "Jh",
            "Ks",
            "8d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat3",
              "amount": 0.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 225,
          "eligible_player_uids": [
            "seat1",
            "seat2",
            "seat3",
            "seat4",
            "seat5",
            "seat6"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "MW009",
        "variant": "NLHE",
        "max_players": 3,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ],
          "seat3": [
            "9s",
            "8h"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        },
        {
          "seat_no": 3,
          "player_uid": "seat3",
          "display_name": "Player3",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat3",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 10.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 6,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat3",
              "amount": 10.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "4s",
            "9c",
            "8s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 50.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 50.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat3",
              "amount": 50.0
            }
          ]
        },
        "TURN": {
          "board": [
            "4s",
            "9c",
            "8s",
            "8c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat3",
              "amount": 0.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "4s",
            "9c",
            "8s",
            "8c",
            "4c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat3",
              "amount": 0.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 195,
          "eligible_player_uids": [
            "seat1",
            "seat2",
            "seat3"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "MW010",
        "variant": "NLHE",
        "max_players": 4,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ],
          "seat3": [
            "9s",
            "8h"
          ],
          "seat4": [
            "7d",
            "6c"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Player1",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Player2",
          "starting_stack": 1000,
          "is_button": false
        },
        {
          "seat_no": 3,
          "player_uid": "seat3",
          "display_name": "Player3",
          "starting_stack": 1000,
          "is_button": false
        },
        {
          "seat_no": 4,
          "player_uid": "seat4",
          "display_name": "Player4",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat3",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat4",
              "amount": 10.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 10.0
            },
            {
              "order": 6,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 7,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat3",
              "amount": 10.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "9c",
            "3c",
            "8s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat1",
              "amount": 50.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 50.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat3",
              "amount": 50.0
            },
            {
              "order": 4,
              "street": "FLOP",
              "action": "FOLD",
              "actor_uid": "seat4",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "9c",
            "3c",
            "8s",
            "4d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat3",
              "amount": 0.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "9c",
            "3c",
            "8s",
            "4d",
            "Tc"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat3",
              "amount": 0.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 205,
          "eligible_player_uids": [
            "seat1",
            "seat2",
            "seat3",
            "seat4"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "SP001",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Ad"
          ],
          "seat2": [
            "Kh",
            "2c"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Trapper",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Victim",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat2",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 6,
              "street": "PREFLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 7,
              "street": "PREFLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "9d",
            "3d",
            "6s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "9d",
            "3d",
            "6s",
            "2h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 120.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 300.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 180.0
            },
            {
              "order": 4,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "9d",
            "3d",
            "6s",
            "2h",
            "8h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 795,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "SP002",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Kh",
            "Kd"
          ],
          "seat2": [
            "Ah",
            "2c"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Trapper",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Victim",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat2",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 6,
              "street": "PREFLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 7,
              "street": "PREFLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Ts",
            "Ad",
            "9s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Ts",
            "Ad",
            "9s",
            "8s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 120.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 300.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 180.0
            },
            {
              "order": 4,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Ts",
            "Ad",
            "9s",
            "8s",
            "5h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 795,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "SP003",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Qh",
            "Qd"
          ],
          "seat2": [
            "Ah",
            "Kh"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Trapper",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Victim",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat2",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 6,
              "street": "PREFLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 7,
              "street": "PREFLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Jd",
            "3d",
            "Js"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Jd",
            "3d",
            "Js",
            "Tc"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 120.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 300.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 180.0
            },
            {
              "order": 4,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Jd",
            "3d",
            "Js",
            "Tc",
            "9d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 795,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "SP004",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Jh",
            "Jd"
          ],
          "seat2": [
            "Ah",
            "Kh"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Trapper",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Victim",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat2",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 6,
              "street": "PREFLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 7,
              "street": "PREFLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "3d",
            "9d",
            "3c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "3d",
            "9d",
            "3c",
            "8s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 120.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 300.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 180.0
            },
            {
              "order": 4,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "3d",
            "9d",
            "3c",
            "8s",
            "9s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 795,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "SP005",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Th",
            "Td"
          ],
          "seat2": [
            "Ah",
            "Kh"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Trapper",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Victim",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat2",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 6,
              "street": "PREFLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 7,
              "street": "PREFLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "4h",
            "6d",
            "3h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "4h",
            "6d",
            "3h",
            "As"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 120.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 300.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 180.0
            },
            {
              "order": 4,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "4h",
            "6d",
            "3h",
            "As",
            "Js"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 795,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "SP006",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "9h",
            "9d"
          ],
          "seat2": [
            "Ah",
            "Kh"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Trapper",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Victim",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat2",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 6,
              "street": "PREFLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 7,
              "street": "PREFLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "8c",
            "4c",
            "Js"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "8c",
            "4c",
            "Js",
            "6s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 120.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 300.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 180.0
            },
            {
              "order": 4,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "8c",
            "4c",
            "Js",
            "6s",
            "6h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 795,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "SP007",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "8h",
            "8d"
          ],
          "seat2": [
            "Ah",
            "Kh"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Trapper",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Victim",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat2",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 6,
              "street": "PREFLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 7,
              "street": "PREFLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Tc",
            "2h",
            "4c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Tc",
            "2h",
            "4c",
            "8s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 120.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 300.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 180.0
            },
            {
              "order": 4,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Tc",
            "2h",
            "4c",
            "8s",
            "6d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 795,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "SP008",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "7h",
            "7d"
          ],
          "seat2": [
            "Ah",
            "Kh"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Trapper",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Victim",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat2",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 6,
              "street": "PREFLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 7,
              "street": "PREFLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "5c",
            "8c",
            "Jc"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "5c",
            "8c",
            "Jc",
            "9h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 120.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 300.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 180.0
            },
            {
              "order": 4,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "5c",
            "8c",
            "Jc",
            "9h",
            "8d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 795,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "SP009",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "6h",
            "6d"
          ],
          "seat2": [
            "Ah",
            "Kh"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Trapper",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Victim",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat2",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 6,
              "street": "PREFLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 7,
              "street": "PREFLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "5c",
            "4c",
            "Ad"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "5c",
            "4c",
            "Ad",
            "7h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 120.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 300.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 180.0
            },
            {
              "order": 4,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "5c",
            "4c",
            "Ad",
            "7h",
            "Tc"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 795,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "SP010",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "5h",
            "5d"
          ],
          "seat2": [
            "Ah",
            "Kh"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Trapper",
          "starting_stack": 1000,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Victim",
          "starting_stack": 1000,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat2",
              "amount": 30.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 30.0
            },
            {
              "order": 6,
              "street": "PREFLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 7,
              "street": "PREFLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Qd",
            "2c",
            "9h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 60.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 60.0
            },
            {
              "order": 3,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Qd",
            "2c",
            "9h",
            "Ac"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 120.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 300.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 180.0
            },
            {
              "order": 4,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Qd",
            "2c",
            "9h",
            "Ac",
            "2h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 795,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "BP001",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Bubble Player",
          "starting_stack": 500,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Opponent",
          "starting_stack": 800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 20.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 20.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "8d",
            "Qc",
            "8h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "8d",
            "Qc",
            "8h",
            "As"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 40.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 40.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "8d",
            "Qc",
            "8h",
            "As",
            "Qh"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 80.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 80.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 295,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "BP002",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Bubble Player",
          "starting_stack": 500,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Opponent",
          "starting_stack": 800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 20.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 20.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Tc",
            "2h",
            "Kd"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Tc",
            "2h",
            "Kd",
            "9h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 40.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 40.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Tc",
            "2h",
            "Kd",
            "9h",
            "Ad"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 80.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 80.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 295,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "BP003",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Bubble Player",
          "starting_stack": 500,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Opponent",
          "starting_stack": 800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 20.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 20.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "8h",
            "9s",
            "8c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "8h",
            "9s",
            "8c",
            "As"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 40.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 40.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "8h",
            "9s",
            "8c",
            "As",
            "Ac"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 80.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 80.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 295,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "BP004",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Bubble Player",
          "starting_stack": 500,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Opponent",
          "starting_stack": 800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 20.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 20.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "5h",
            "3c",
            "8h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "5h",
            "3c",
            "8h",
            "5c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 40.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 40.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "5h",
            "3c",
            "8h",
            "5c",
            "As"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 80.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 80.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 295,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "BP005",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Bubble Player",
          "starting_stack": 500,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Opponent",
          "starting_stack": 800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 20.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 20.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "3c",
            "Ks",
            "7d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "3c",
            "Ks",
            "7d",
            "2c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 40.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 40.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "3c",
            "Ks",
            "7d",
            "2c",
            "9d"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 80.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 80.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 295,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "BP006",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Bubble Player",
          "starting_stack": 500,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Opponent",
          "starting_stack": 800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 20.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 20.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Td",
            "Qh",
            "Qs"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Td",
            "Qh",
            "Qs",
            "3c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 40.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 40.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Td",
            "Qh",
            "Qs",
            "3c",
            "Ks"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 80.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 80.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 295,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "BP007",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Bubble Player",
          "starting_stack": 500,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Opponent",
          "starting_stack": 800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 20.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 20.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "3h",
            "5s",
            "2c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "3h",
            "5s",
            "2c",
            "4c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 40.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 40.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "3h",
            "5s",
            "2c",
            "4c",
            "Jh"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 80.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 80.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 295,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "BP008",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Bubble Player",
          "starting_stack": 500,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Opponent",
          "starting_stack": 800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 20.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 20.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "As",
            "7d",
            "Jh"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "As",
            "7d",
            "Jh",
            "6s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 40.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 40.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "As",
            "7d",
            "Jh",
            "6s",
            "7c"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 80.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 80.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 295,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "BP009",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Bubble Player",
          "starting_stack": 500,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Opponent",
          "starting_stack": 800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 20.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 20.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "Qh",
            "Td",
            "4s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "Qh",
            "Td",
            "4s",
            "7s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 40.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 40.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "Qh",
            "Td",
            "4s",
            "7s",
            "8s"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 80.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 80.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 295,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    },
    {
      "metadata": {
        "table_id": "Legendary-Table-1",
        "hand_id": "BP010",
        "variant": "NLHE",
        "max_players": 2,
        "small_blind": 5,
        "big_blind": 10,
        "ante": 0,
        "rake": 0,
        "currency": "CHIPS",
        "started_at_utc": null,
        "ended_at_utc": null,
        "run_count": 1,
        "session_type": "review",
        "bot_strategy": null,
        "analysis_tags": [],
        "button_seat_no": 1,
        "hole_cards": {
          "seat1": [
            "Ah",
            "Kh"
          ],
          "seat2": [
            "Qd",
            "Jc"
          ]
        }
      },
      "seats": [
        {
          "seat_no": 1,
          "player_uid": "seat1",
          "display_name": "Bubble Player",
          "starting_stack": 500,
          "is_button": true
        },
        {
          "seat_no": 2,
          "player_uid": "seat2",
          "display_name": "Opponent",
          "starting_stack": 800,
          "is_button": false
        }
      ],
      "hero_player_uid": "seat1",
      "streets": {
        "PREFLOP": {
          "board": [],
          "actions": [
            {
              "order": 1,
              "street": "PREFLOP",
              "action": "DEAL_HOLE",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat1",
              "amount": 5.0
            },
            {
              "order": 3,
              "street": "PREFLOP",
              "action": "POST_BLIND",
              "actor_uid": "seat2",
              "amount": 10.0
            },
            {
              "order": 4,
              "street": "PREFLOP",
              "action": "RAISE",
              "actor_uid": "seat1",
              "amount": 20.0
            },
            {
              "order": 5,
              "street": "PREFLOP",
              "action": "CALL",
              "actor_uid": "seat2",
              "amount": 20.0
            }
          ]
        },
        "FLOP": {
          "board": [
            "2h",
            "8d",
            "Jd"
          ],
          "actions": [
            {
              "order": 1,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 2,
              "street": "FLOP",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "TURN": {
          "board": [
            "2h",
            "8d",
            "Jd",
            "7h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "TURN",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 40.0
            },
            {
              "order": 2,
              "street": "TURN",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 40.0
            },
            {
              "order": 3,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "TURN",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        },
        "RIVER": {
          "board": [
            "2h",
            "8d",
            "Jd",
            "7h",
            "6h"
          ],
          "actions": [
            {
              "order": 1,
              "street": "RIVER",
              "action": "BET",
              "actor_uid": "seat2",
              "amount": 80.0
            },
            {
              "order": 2,
              "street": "RIVER",
              "action": "CALL",
              "actor_uid": "seat1",
              "amount": 80.0
            },
            {
              "order": 3,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat2",
              "amount": 0.0
            },
            {
              "order": 4,
              "street": "RIVER",
              "action": "CHECK",
              "actor_uid": "seat1",
              "amount": 0.0
            }
          ]
        }
      },
      "pots": [
        {
          "amount": 295,
          "eligible_player_uids": [
            "seat1",
            "seat2"
          ],
          "shares": []
        }
      ],
      "showdown": [],
      "final_stacks": {}
    }
  ]
}
```

---

### poker_themes.json

**Path**: `backend/data/poker_themes.json`

**Size**: 20.4 KB

```json
{
  "version": "2.1",
  "defaults": {
    "state": {
      "active": {
        "glow": "$accent",
        "shimmer": "$metal",
        "strength": 1.0,
        "period_ms": 2000
      },
      "folded": {
        "desaturate": 0.8,
        "opacity": 0.4
      },
      "winner": {
        "glow": "$metal",
        "shimmer": "$accent",
        "strength": 1.4,
        "period_ms": 1500,
        "particles": true
      },
      "showdown": {
        "spotlight": "#FFFFFF",
        "spotlight_opacity": 0.18,
        "duration_ms": 1500
      },
      "allin": {
        "glow": "$raise",
        "shimmer": "$metal",
        "strength": 1.2,
        "flash_ms": 400
      }
    },
    "selection": {
      "row_bg": "$highlight",
      "row_fg": "$highlight_text"
    },
    "emphasis_bar": {
      "bg_top": "$felt",
      "bg_bottom": "$rail",
      "text": "$emphasis_text",
      "accent_text": "$raise",
      "divider": "$metal",
      "texture": "velvet_8pct"
    },
    "chips": {
      "stack": {
        "face": "$chip_face",
        "edge": "$chip_edge",
        "rim": "$chip_rim",
        "text": "$chip_text"
      },
      "bet": {
        "face": "$bet_face",
        "edge": "$bet_edge",
        "rim": "$bet_rim",
        "text": "$bet_text",
        "glow": "$bet_glow"
      },
      "pot": {
        "face": "$pot_face",
        "edge": "$pot_edge",
        "rim": "$pot_rim",
        "text": "$pot_text",
        "glow": "$pot_glow"
      }
    }
  },
  "themes": [
    {
      "id": "forest-green-pro",
      "name": "Forest Green Professional üåø",
      "intro": "Classic casino green with dark wood rails‚Äîcalm, familiar, relentlessly focused. Built on fundamentals and discipline, echoing Doyle Brunson‚Äôs steady command under pressure.",
      "persona": "Doyle Brunson",
      "palette": {
        "felt": "#FF0000",
        "rail": "#4A3428",
        "metal": "#C9A34E",
        "accent": "#1DB954",
        "raise": "#B63D3D",
        "call": "#2AA37A",
        "neutral": "#9AA0A6",
        "text": "#EDECEC",
        "highlight": "#D4AF37",
        "highlight_text": "#0B0B0E",
        "emphasis_text": "#F8F3E2",
        "emphasis_bg_top": "#314F3A",
        "emphasis_bg_bottom": "#1E3A28",
        "emphasis_border": "#A88433",
        "emphasis_accent_text": "#D4AF37",
        "chip_face": "#2D5A3D",
        "chip_edge": "#4A3428",
        "chip_rim": "#C9A34E",
        "chip_text": "#F8F7F4",
        "bet_face": "#1DB954",
        "bet_edge": "#4A3428",
        "bet_rim": "#C9A34E",
        "bet_text": "#FFFFFF",
        "bet_glow": "#74E8A3",
        "pot_face": "#E0C98A",
        "pot_edge": "#3A2A20",
        "pot_rim": "#EAD49A",
        "pot_text": "#0B0B0E",
        "pot_glow": "#F1DFAF"
      }
    },
    {
      "id": "velvet-burgundy",
      "name": "Velvet Burgundy üç∑",
      "intro": "Wine-red felt and brass trim; a private salon after midnight‚Äîhushed and opulent. Charisma with calculation, channeling Antonio Esfandiari‚Äôs flair without sacrificing precision.",
      "persona": "Antonio Esfandiari",
      "palette": {
        "felt": "#4B1C2B",
        "rail": "#3D0F1F",
        "metal": "#C98B5E",
        "accent": "#8C2233",
        "raise": "#B53A44",
        "call": "#2AA37A",
        "neutral": "#A29A90",
        "text": "#F2E9DF",
        "highlight": "#A31D2B",
        "highlight_text": "#F9E7C9",
        "emphasis_text": "#FFEFE3",
        "chip_face": "#4B1C2B",
        "chip_edge": "#3D0F1F",
        "chip_rim": "#C98B5E",
        "chip_text": "#F8F7F4",
        "bet_face": "#8C2233",
        "bet_edge": "#3D0F1F",
        "bet_rim": "#C98B5E",
        "bet_text": "#FFFFFF",
        "bet_glow": "#E37D8C",
        "pot_face": "#E1B78E",
        "pot_edge": "#2B0B14",
        "pot_rim": "#F0CBA0",
        "pot_text": "#0B0B0E",
        "pot_glow": "#F5D8B7",
        "emphasis_bg_top": "#5A1F2F",
        "emphasis_bg_bottom": "#3A0F1F",
        "emphasis_border": "#B97B54",
        "emphasis_accent_text": "#E5B086"
      }
    },
    {
      "id": "emerald-aurora",
      "name": "Emerald Aurora üåå",
      "intro": "Emerald felt lit by aurora glow‚Äîcrisp, modern, quietly electric. Analytical brilliance and composure, reflecting Justin Bonomo‚Äôs polished tournament edge.",
      "persona": "Justin Bonomo",
      "palette": {
        "felt": "#046D47",
        "rail": "#0C0C0C",
        "metal": "#C9A86A",
        "accent": "#59FFAD",
        "raise": "#B23B43",
        "call": "#32B37A",
        "neutral": "#9CB1A8",
        "text": "#F1F7F4",
        "highlight": "#59FFAD",
        "highlight_text": "#062318",
        "emphasis_text": "#ECFFF7",
        "chip_face": "#046D47",
        "chip_edge": "#0C0C0C",
        "chip_rim": "#C9A86A",
        "chip_text": "#F8F7F4",
        "bet_face": "#59FFAD",
        "bet_edge": "#0C0C0C",
        "bet_rim": "#C9A86A",
        "bet_text": "#06170F",
        "bet_glow": "#A7FFD4",
        "pot_face": "#E3CFA0",
        "pot_edge": "#0A0A0A",
        "pot_rim": "#F0DBAE",
        "pot_text": "#0B0B0E",
        "pot_glow": "#F5E6BE",
        "emphasis_bg_top": "#0D7A55",
        "emphasis_bg_bottom": "#064B35",
        "emphasis_border": "#BFA066",
        "emphasis_accent_text": "#59FFAD"
      }
    },
    {
      "id": "imperial-jade",
      "name": "Imperial Jade üíé",
      "intro": "Deep emerald with antique gold; stately and serene, breathing confidence. Surgical decisions and posture, echoing Stephen Chidwick‚Äôs icy precision.",
      "persona": "Stephen Chidwick",
      "palette": {
        "felt": "#0E8044",
        "rail": "#1B1B1B",
        "metal": "#D5C07E",
        "accent": "#166A3E",
        "raise": "#B23B43",
        "call": "#32B37A",
        "neutral": "#9CB1A8",
        "text": "#F9F3DD",
        "highlight": "#00A86B",
        "highlight_text": "#08110D",
        "emphasis_text": "#FAF4DE",
        "chip_face": "#0E8044",
        "chip_edge": "#1B1B1B",
        "chip_rim": "#D5C07E",
        "chip_text": "#F8F7F4",
        "bet_face": "#166A3E",
        "bet_edge": "#1B1B1B",
        "bet_rim": "#D5C07E",
        "bet_text": "#F0FFF8",
        "bet_glow": "#6BDEB0",
        "pot_face": "#E7D8A7",
        "pot_edge": "#141414",
        "pot_rim": "#F1E5BB",
        "pot_text": "#0B0B0E",
        "pot_glow": "#F6EDC7",
        "emphasis_bg_top": "#156F46",
        "emphasis_bg_bottom": "#0B3E2A",
        "emphasis_border": "#C6B06F",
        "emphasis_accent_text": "#D5C07E"
      }
    },
    {
      "id": "ruby-royale",
      "name": "Ruby Royale ‚ù§Ô∏è‚Äçüî•",
      "intro": "Lustrous ruby felt in black lacquer with gilded edges‚Äîbrilliant, precise, unmistakable. Controlled aggression and elite poise, mirroring Jason Koon‚Äôs disciplined dominance.",
      "persona": "Jason Koon",
      "palette": {
        "felt": "#9B111E",
        "rail": "#0D0D0D",
        "metal": "#FFD700",
        "accent": "#C72C48",
        "raise": "#A41E34",
        "call": "#2AA37A",
        "neutral": "#B79B9B",
        "text": "#FAFAFA",
        "highlight": "#E0115F",
        "highlight_text": "#19070B",
        "emphasis_text": "#FFF7E6",
        "chip_face": "#9B111E",
        "chip_edge": "#0D0D0D",
        "chip_rim": "#FFD700",
        "chip_text": "#FFFFFF",
        "bet_face": "#C72C48",
        "bet_edge": "#0D0D0D",
        "bet_rim": "#FFD700",
        "bet_text": "#FFFFFF",
        "bet_glow": "#FF7A9B",
        "pot_face": "#FFE07A",
        "pot_edge": "#0A0A0A",
        "pot_rim": "#FFE89A",
        "pot_text": "#0B0B0E",
        "pot_glow": "#FFF0B8",
        "emphasis_bg_top": "#B01523",
        "emphasis_bg_bottom": "#6E0F18",
        "emphasis_border": "#E2C64F",
        "emphasis_accent_text": "#FFD700"
      }
    },
    {
      "id": "coral-royale",
      "name": "Coral Royale ü™∏",
      "intro": "Warm coral red under soft gold‚Äîlively, magnetic, made for bold moves. Big-game charisma with generosity, channeling Alan Keating‚Äôs fearless table energy.",
      "persona": "Alan Keating",
      "palette": {
        "felt": "#E34234",
        "rail": "#0F0F0F",
        "metal": "#E4B564",
        "accent": "#FF7F50",
        "raise": "#D64040",
        "call": "#2AA37A",
        "neutral": "#B59C91",
        "text": "#FFF0E6",
        "highlight": "#FF7F50",
        "highlight_text": "#2B120E",
        "emphasis_text": "#FFF3EB",
        "chip_face": "#E34234",
        "chip_edge": "#0F0F0F",
        "chip_rim": "#E4B564",
        "chip_text": "#FFFFFF",
        "bet_face": "#FF7F50",
        "bet_edge": "#0F0F0F",
        "bet_rim": "#E4B564",
        "bet_text": "#2B120E",
        "bet_glow": "#FFC4AE",
        "pot_face": "#F1D39B",
        "pot_edge": "#0D0D0D",
        "pot_rim": "#F6DDB0",
        "pot_text": "#0B0B0E",
        "pot_glow": "#FAE7C9",
        "emphasis_bg_top": "#F15545",
        "emphasis_bg_bottom": "#A92F25",
        "emphasis_border": "#E4B564",
        "emphasis_accent_text": "#75ECC8"
      }
    },
    {
      "id": "golden-dusk",
      "name": "Golden Dusk üåá",
      "intro": "Burnished amber over dark leather; cinematic nostalgia that never hurries. Veteran reads and closing instinct, reflecting Jason Mercier‚Äôs calm endgame edge.",
      "persona": "Jason Mercier",
      "palette": {
        "felt": "#7A4A1F",
        "rail": "#3A1D0D",
        "metal": "#C18F65",
        "accent": "#A3622B",
        "raise": "#B35A3B",
        "call": "#2AA37A",
        "neutral": "#AF9A8A",
        "text": "#F3E3D3",
        "highlight": "#E4B564",
        "highlight_text": "#23160D",
        "emphasis_text": "#FFF3E3",
        "chip_face": "#7A4A1F",
        "chip_edge": "#3A1D0D",
        "chip_rim": "#C18F65",
        "chip_text": "#F8F7F4",
        "bet_face": "#A3622B",
        "bet_edge": "#3A1D0D",
        "bet_rim": "#C18F65",
        "bet_text": "#FFF1E2",
        "bet_glow": "#E8C49E",
        "pot_face": "#E2C39B",
        "pot_edge": "#2C1409",
        "pot_rim": "#EFD2AD",
        "pot_text": "#0B0B0E",
        "pot_glow": "#F5E2C8",
        "emphasis_bg_top": "#8B572A",
        "emphasis_bg_bottom": "#4B2C14",
        "emphasis_border": "#CFA377",
        "emphasis_accent_text": "#E4B564"
      }
    },
    {
      "id": "klimt-royale",
      "name": "Klimt Royale ‚ú®",
      "intro": "Obsidian field with ornamental gold; decadent patterns that shimmer like a gala. Elegant intellect and creative lines, echoing Liv Boeree‚Äôs balance of logic and style.",
      "persona": "Liv Boeree",
      "palette": {
        "felt": "#17130E",
        "rail": "#23211B",
        "metal": "#E4C97D",
        "accent": "#166A3E",
        "raise": "#B23B43",
        "call": "#32B37A",
        "neutral": "#A38E6A",
        "text": "#FFF2D9",
        "highlight": "#B87333",
        "highlight_text": "#0D0A07",
        "emphasis_text": "#FFEED0",
        "chip_face": "#17130E",
        "chip_edge": "#23211B",
        "chip_rim": "#E4C97D",
        "chip_text": "#F8F7F4",
        "bet_face": "#166A3E",
        "bet_edge": "#23211B",
        "bet_rim": "#E4C97D",
        "bet_text": "#EFFFF7",
        "bet_glow": "#82D9AE",
        "pot_face": "#EBD79F",
        "pot_edge": "#1A1812",
        "pot_rim": "#F2E2B5",
        "pot_text": "#0B0B0E",
        "pot_glow": "#F7EDC9",
        "emphasis_bg_top": "#221C12",
        "emphasis_bg_bottom": "#130F09",
        "emphasis_border": "#E4C97D",
        "emphasis_accent_text": "#B87333"
      }
    },
    {
      "id": "deco-luxe",
      "name": "Deco Luxe üèõÔ∏è",
      "intro": "Champagne geometry on jet black‚Äîsleek Art-Deco lines and effortless poise. Thoughtful innovation and restraint, channeling Phil Galfond‚Äôs cerebral mastery.",
      "persona": "Phil Galfond",
      "palette": {
        "felt": "#1B1E2B",
        "rail": "#111111",
        "metal": "#D6C08F",
        "accent": "#1A3E34",
        "raise": "#5B1922",
        "call": "#2AA37A",
        "neutral": "#9B9486",
        "text": "#F8F4EA",
        "highlight": "#E1B382",
        "highlight_text": "#0E0C09",
        "emphasis_text": "#F6EFDF",
        "chip_face": "#1B1E2B",
        "chip_edge": "#111111",
        "chip_rim": "#D6C08F",
        "chip_text": "#F8F7F4",
        "bet_face": "#1A3E34",
        "bet_edge": "#111111",
        "bet_rim": "#D6C08F",
        "bet_text": "#E8FFF6",
        "bet_glow": "#8EC9B6",
        "pot_face": "#E7D7AF",
        "pot_edge": "#0F0F0F",
        "pot_rim": "#F0E2BF",
        "pot_text": "#0B0B0E",
        "pot_glow": "#F6ECCD",
        "emphasis_bg_top": "#222532",
        "emphasis_bg_bottom": "#141720",
        "emphasis_border": "#D6C08F",
        "emphasis_accent_text": "#E1B382"
      }
    },
    {
      "id": "oceanic-aqua",
      "name": "Oceanic Aqua üåä",
      "intro": "Midnight teal with bright aqua spray‚Äîrefreshing, steady, quietly modern. Patience and clarity in deep waters, reflecting Erik Seidel‚Äôs timeless control.",
      "persona": "Erik Seidel",
      "palette": {
        "felt": "#126E82",
        "rail": "#0D1B2A",
        "metal": "#B7C1C8",
        "accent": "#4EEAFF",
        "raise": "#ABCE00",
        "call": "#57C2B6",
        "neutral": "#9DB3C4",
        "text": "#F5F7FA",
        "highlight": "#4EEAFF",
        "highlight_text": "#071018",
        "emphasis_text": "#00FAB7",
        "chip_face": "#126E82",
        "chip_edge": "#0D1B2A",
        "chip_rim": "#B7C1C8",
        "chip_text": "#F8F7F4",
        "bet_face": "#4EEAFF",
        "bet_edge": "#0D1B2A",
        "bet_rim": "#B7C1C8",
        "bet_text": "#06222A",
        "bet_glow": "#A4F6FF",
        "pot_face": "#D6E2EA",
        "pot_edge": "#0B1723",
        "pot_rim": "#E3EDF3",
        "pot_text": "#0B0B0E",
        "pot_glow": "#EFF6FA",
        "emphasis_bg_top": "#177C93",
        "emphasis_bg_bottom": "#0A4153",
        "emphasis_border": "#B7C1C8",
        "emphasis_accent_text": "#D9B4F9"
      }
    },
    {
      "id": "royal-sapphire",
      "name": "Royal Sapphire üî∑",
      "intro": "Jewel-blue confidence with crisp trim‚Äîbright, polished, commanding. Relentless precision and tournament steel, capturing Adri√°n Mateos‚Äôs clinical edge.",
      "persona": "Adri√°n Mateos",
      "palette": {
        "felt": "#0D3B66",
        "rail": "#161616",
        "metal": "#C7D3E0",
        "accent": "#2656D9",
        "raise": "#6C4AB6",
        "call": "#57C2B6",
        "neutral": "#9AB1CF",
        "text": "#F2F6FC",
        "highlight": "#1E90FF",
        "highlight_text": "#061224",
        "emphasis_text": "#EEF6FF",
        "chip_face": "#0D3B66",
        "chip_edge": "#161616",
        "chip_rim": "#C7D3E0",
        "chip_text": "#F8F7F4",
        "bet_face": "#2656D9",
        "bet_edge": "#161616",
        "bet_rim": "#C7D3E0",
        "bet_text": "#E9EEFF",
        "bet_glow": "#8FB1FF",
        "pot_face": "#DEE7EF",
        "pot_edge": "#131313",
        "pot_rim": "#EAF1F6",
        "pot_text": "#0B0B0E",
        "pot_glow": "#F4F8FB",
        "emphasis_bg_top": "#14467B",
        "emphasis_bg_bottom": "#0B2746",
        "emphasis_border": "#C7D3E0",
        "emphasis_accent_text": "#A8C7FF"
      }
    },
    {
      "id": "monet-twilight",
      "name": "Monet Twilight üé®",
      "intro": "Navy-violet felt with misted glow‚Äîsoft reflections, poetic and nocturnal. Grace under variance and stoic poise, echoing Patrik Antonius‚Äôs midnight composure.",
      "persona": "Patrik Antonius",
      "palette": {
        "felt": "#2A2D64",
        "rail": "#1F1F1B",
        "metal": "#C8BEDF",
        "accent": "#B7A6D0",
        "raise": "#B63D3D",
        "call": "#2AA37A",
        "neutral": "#8EA6B5",
        "text": "#F5F7FA",
        "highlight": "#B7A6D0",
        "highlight_text": "#0E0E15",
        "emphasis_text": "#F2EEFB",
        "chip_face": "#2A2D64",
        "chip_edge": "#1F1F1B",
        "chip_rim": "#C8BEDF",
        "chip_text": "#F8F7F4",
        "bet_face": "#B7A6D0",
        "bet_edge": "#1F1F1B",
        "bet_rim": "#C8BEDF",
        "bet_text": "#15141B",
        "bet_glow": "#E0D9F0",
        "pot_face": "#E6E1F1",
        "pot_edge": "#191916",
        "pot_rim": "#EEEAF6",
        "pot_text": "#0B0B0E",
        "pot_glow": "#F6F3FA",
        "emphasis_bg_top": "#2F326E",
        "emphasis_bg_bottom": "#1B1E44",
        "emphasis_border": "#C8BEDF",
        "emphasis_accent_text": "#E6EF75"
      }
    },
    {
      "id": "caravaggio-sepia-noir",
      "name": "Caravaggio Sepia Noir üïØÔ∏è",
      "intro": "Candlelit sepia over deep shadow‚Äîdrama, heat, fearless contrasts. Audacious pressure and brinkmanship, mirroring Tom Dwan‚Äôs fearless lines.",
      "persona": "Tom Dwan",
      "palette": {
        "felt": "#2A1F1A",
        "rail": "#101010",
        "metal": "#D4A373",
        "accent": "#9E0F28",
        "raise": "#B3122E",
        "call": "#2AA37A",
        "neutral": "#9C8F7A",
        "text": "#FFF7E6",
        "highlight": "#EAD6B7",
        "highlight_text": "#1B130B",
        "emphasis_text": "#FFF6E5",
        "chip_face": "#2A1F1A",
        "chip_edge": "#101010",
        "chip_rim": "#D4A373",
        "chip_text": "#F8F7F4",
        "bet_face": "#9E0F28",
        "bet_edge": "#101010",
        "bet_rim": "#D4A373",
        "bet_text": "#FFEFF2",
        "bet_glow": "#F29BAA",
        "pot_face": "#E9D0AA",
        "pot_edge": "#0E0E0E",
        "pot_rim": "#F2DBB9",
        "pot_text": "#0B0B0E",
        "pot_glow": "#F7E8CD",
        "emphasis_bg_top": "#3A2A22",
        "emphasis_bg_bottom": "#1F1612",
        "emphasis_border": "#D4A373",
        "emphasis_accent_text": "#EEB200"
      }
    },
    {
      "id": "stealth-graphite-steel",
      "name": "Stealth Graphite Steel üñ§",
      "intro": "Matte blacks and brushed steel; silent, aerodynamic focus. Unreadable calm and surgical timing, channeling Phil Ivey‚Äôs cold precision.",
      "persona": "Phil Ivey",
      "palette": {
        "felt": "#2E2E2E",
        "rail": "#444444",
        "metal": "#8D8D8D",
        "accent": "#00D4FF",
        "raise": "#9E3B49",
        "call": "#57C2B6",
        "neutral": "#8E9196",
        "text": "#E6E7EA",
        "highlight": "#00D4FF",
        "highlight_text": "#041014",
        "emphasis_text": "#F3F4F6",
        "chip_face": "#2E2E2E",
        "chip_edge": "#444444",
        "chip_rim": "#8D8D8D",
        "chip_text": "#F8F7F4",
        "bet_face": "#00D4FF",
        "bet_edge": "#444444",
        "bet_rim": "#8D8D8D",
        "bet_text": "#031418",
        "bet_glow": "#89F0FF",
        "pot_face": "#D9D9D9",
        "pot_edge": "#3A3A3A",
        "pot_rim": "#E6E6E6",
        "pot_text": "#0B0B0E",
        "pot_glow": "#F2F2F2",
        "emphasis_bg_top": "#3A3A3A",
        "emphasis_bg_bottom": "#242424",
        "emphasis_border": "#8D8D8D",
        "emphasis_accent_text": "#9BE3FF"
      }
    },
    {
      "id": "sunset-mirage",
      "name": "Sunset Mirage üåÖ",
      "intro": "Amber to violet across the felt‚Äîthe warmth of desert dusk under velvet lights. Live-read mastery and table conversation, reflecting Daniel Negreanu‚Äôs friendly edge.",
      "persona": "Daniel Negreanu",
      "palette": {
        "felt": "#8C1C13",
        "rail": "#2B1B0E",
        "metal": "#E6B87A",
        "accent": "#FF9E57",
        "raise": "#C85C5C",
        "call": "#2AA37A",
        "neutral": "#A68C7A",
        "text": "#F7E7D6",
        "highlight": "#FF9E57",
        "highlight_text": "#2B160E",
        "emphasis_text": "#FFECDD",
        "chip_face": "#8C1C13",
        "chip_edge": "#2B1B0E",
        "chip_rim": "#E6B87A",
        "chip_text": "#F8F7F4",
        "bet_face": "#FF9E57",
        "bet_edge": "#2B1B0E",
        "bet_rim": "#E6B87A",
        "bet_text": "#2B160E",
        "bet_glow": "#FFD1AE",
        "pot_face": "#F1D7AF",
        "pot_edge": "#24170D",
        "pot_rim": "#F7E2C3",
        "pot_text": "#0B0B0E",
        "pot_glow": "#FBEBD3",
        "emphasis_bg_top": "#9B2A20",
        "emphasis_bg_bottom": "#5A1912",
        "emphasis_border": "#E6B87A",
        "emphasis_accent_text": "#FFC499"
      }
    },
    {
      "id": "cyber-neon",
      "name": "Cyber Neon ‚ö°",
      "intro": "Electric teals and magentas on charcoal‚Äîarcade energy for fast grinders. Hyper-focused volume and fearless optimization, channeling Fedor Holz's modern engine.",
      "persona": "Fedor Holz",
      "palette": {
        "felt": "#0A0D10",
        "rail": "#1A1D23",
        "metal": "#00FFFF",
        "accent": "#FF00FF",
        "raise": "#FF0080",
        "call": "#00FF80",
        "neutral": "#808080",
        "text": "#E0E0E0",
        "highlight": "#00FFFF",
        "highlight_text": "#000000",
        "emphasis_text": "#EAF8FF",
        "emphasis_bg_top": "#141417",
        "emphasis_bg_bottom": "#0B0B0D",
        "emphasis_border": "#9BE3FF",
        "emphasis_accent_text": "#FF79F6"
      }
    }
  ]
}
```

---

### poker_themes_backup.json

**Path**: `backend/data/poker_themes_backup.json`

**Size**: 17.8 KB

```json
{
  "version": "2.1",
  "defaults": {
    "state": {
      "active":   { "glow": "$accent", "shimmer": "$metal", "strength": 1.0, "period_ms": 2000 },
      "folded":   { "desaturate": 0.8, "opacity": 0.4 },
      "winner":   { "glow": "$metal", "shimmer": "$accent", "strength": 1.4, "period_ms": 1500, "particles": true },
      "showdown": { "spotlight": "#FFFFFF", "spotlight_opacity": 0.18, "duration_ms": 1500 },
      "allin":    { "glow": "$raise", "shimmer": "$metal", "strength": 1.2, "flash_ms": 400 }
    },
    "selection": { "row_bg": "$highlight", "row_fg": "$highlight_text" },
    "emphasis_bar": {
      "bg_top": "$felt",
      "bg_bottom": "$rail",
      "text": "$emphasis_text",
      "accent_text": "$raise",
      "divider": "$metal",
      "texture": "velvet_8pct"
    },
    "chips": {
      "stack": { "face": "$chip_face", "edge": "$chip_edge", "rim": "$chip_rim", "text": "$chip_text" },
      "bet":   { "face": "$bet_face",  "edge": "$bet_edge",  "rim": "$bet_rim",  "text": "$bet_text", "glow": "$bet_glow" },
      "pot":   { "face": "$pot_face",  "edge": "$pot_edge",  "rim": "$pot_rim",  "text": "$pot_text", "glow": "$pot_glow" }
    }
  },
  "themes": [
    {
      "id": "forest-green-pro",
      "name": "Forest Green Professional üåø",
      "intro": "Classic casino green with dark wood rails‚Äîcalm, familiar, relentlessly focused. Built on fundamentals and discipline, echoing Doyle Brunson‚Äôs steady command under pressure.",
      "persona": "Doyle Brunson",
      "palette": {
        "felt": "#2D5A3D",
        "rail": "#4A3428",
        "metal": "#C9A34E",
        "accent": "#1DB954",
        "raise": "#B63D3D",
        "call": "#2AA37A",
        "neutral": "#9AA0A6",
        "text": "#EDECEC",
        "highlight": "#D4AF37",
        "highlight_text": "#0B0B0E",
        "emphasis_text": "#F8E7C9",

        "emphasis_bg_top": "#314F3A",
        "emphasis_bg_bottom": "#1E3A28",
        "emphasis_border": "#A88433",
        "emphasis_accent_text": "#D4AF37",

        "chip_face": "#2D5A3D",
        "chip_edge": "#4A3428",
        "chip_rim": "#C9A34E",
        "chip_text": "#F8F7F4",
        "bet_face": "#1DB954",
        "bet_edge": "#4A3428",
        "bet_rim": "#C9A34E",
        "bet_text": "#FFFFFF",
        "bet_glow": "#74E8A3",
        "pot_face": "#E0C98A",
        "pot_edge": "#3A2A20",
        "pot_rim": "#EAD49A",
        "pot_text": "#0B0B0E",
        "pot_glow": "#F1DFAF"
      }
    },
    {
      "id": "velvet-burgundy",
      "name": "Velvet Burgundy üç∑",
      "intro": "Wine-red felt and brass trim; a private salon after midnight‚Äîhushed and opulent. Charisma with calculation, channeling Antonio Esfandiari‚Äôs flair without sacrificing precision.",
      "persona": "Antonio Esfandiari",
      "palette": {
        "felt": "#4B1C2B",
        "rail": "#3D0F1F",
        "metal": "#C98B5E",
        "accent": "#8C2233",
        "raise": "#B53A44",
        "call": "#2AA37A",
        "neutral": "#A29A90",
        "text": "#F2E9DF",
        "highlight": "#A31D2B",
        "highlight_text": "#F9E7C9",
        "emphasis_text": "#F9E7C9",

        "chip_face": "#4B1C2B",
        "chip_edge": "#3D0F1F",
        "chip_rim": "#C98B5E",
        "chip_text": "#F8F7F4",
        "bet_face": "#8C2233",
        "bet_edge": "#3D0F1F",
        "bet_rim": "#C98B5E",
        "bet_text": "#FFFFFF",
        "bet_glow": "#E37D8C",
        "pot_face": "#E1B78E",
        "pot_edge": "#2B0B14",
        "pot_rim": "#F0CBA0",
        "pot_text": "#0B0B0E",
        "pot_glow": "#F5D8B7"
      }
    },
    {
      "id": "emerald-aurora",
      "name": "Emerald Aurora üåå",
      "intro": "Emerald felt lit by aurora glow‚Äîcrisp, modern, quietly electric. Analytical brilliance and composure, reflecting Justin Bonomo‚Äôs polished tournament edge.",
      "persona": "Justin Bonomo",
      "palette": {
        "felt": "#046D47",
        "rail": "#0C0C0C",
        "metal": "#C9A86A",
        "accent": "#59FFAD",
        "raise": "#B23B43",
        "call": "#32B37A",
        "neutral": "#9CB1A8",
        "text": "#F1F7F4",
        "highlight": "#59FFAD",
        "highlight_text": "#062318",
        "emphasis_text": "#EAF9F2",

        "chip_face": "#046D47",
        "chip_edge": "#0C0C0C",
        "chip_rim": "#C9A86A",
        "chip_text": "#F8F7F4",
        "bet_face": "#59FFAD",
        "bet_edge": "#0C0C0C",
        "bet_rim": "#C9A86A",
        "bet_text": "#06170F",
        "bet_glow": "#A7FFD4",
        "pot_face": "#E3CFA0",
        "pot_edge": "#0A0A0A",
        "pot_rim": "#F0DBAE",
        "pot_text": "#0B0B0E",
        "pot_glow": "#F5E6BE"
      }
    },
    {
      "id": "imperial-jade",
      "name": "Imperial Jade üíé",
      "intro": "Deep emerald with antique gold; stately and serene, breathing confidence. Surgical decisions and posture, echoing Stephen Chidwick‚Äôs icy precision.",
      "persona": "Stephen Chidwick",
      "palette": {
        "felt": "#0E8044",
        "rail": "#1B1B1B",
        "metal": "#D5C07E",
        "accent": "#166A3E",
        "raise": "#B23B43",
        "call": "#32B37A",
        "neutral": "#9CB1A8",
        "text": "#F9F3DD",
        "highlight": "#00A86B",
        "highlight_text": "#08110D",
        "emphasis_text": "#F6F0DC",

        "chip_face": "#0E8044",
        "chip_edge": "#1B1B1B",
        "chip_rim": "#D5C07E",
        "chip_text": "#F8F7F4",
        "bet_face": "#166A3E",
        "bet_edge": "#1B1B1B",
        "bet_rim": "#D5C07E",
        "bet_text": "#F0FFF8",
        "bet_glow": "#6BDEB0",
        "pot_face": "#E7D8A7",
        "pot_edge": "#141414",
        "pot_rim": "#F1E5BB",
        "pot_text": "#0B0B0E",
        "pot_glow": "#F6EDC7"
      }
    },
    {
      "id": "ruby-royale",
      "name": "Ruby Royale ‚ù§Ô∏è‚Äçüî•",
      "intro": "Lustrous ruby felt in black lacquer with gilded edges‚Äîbrilliant, precise, unmistakable. Controlled aggression and elite poise, mirroring Jason Koon‚Äôs disciplined dominance.",
      "persona": "Jason Koon",
      "palette": {
        "felt": "#9B111E",
        "rail": "#0D0D0D",
        "metal": "#FFD700",
        "accent": "#C72C48",
        "raise": "#A41E34",
        "call": "#2AA37A",
        "neutral": "#B79B9B",
        "text": "#FAFAFA",
        "highlight": "#E0115F",
        "highlight_text": "#19070B",
        "emphasis_text": "#FFE5B2",

        "chip_face": "#9B111E",
        "chip_edge": "#0D0D0D",
        "chip_rim": "#FFD700",
        "chip_text": "#FFFFFF",
        "bet_face": "#C72C48",
        "bet_edge": "#0D0D0D",
        "bet_rim": "#FFD700",
        "bet_text": "#FFFFFF",
        "bet_glow": "#FF7A9B",
        "pot_face": "#FFE07A",
        "pot_edge": "#0A0A0A",
        "pot_rim": "#FFE89A",
        "pot_text": "#0B0B0E",
        "pot_glow": "#FFF0B8"
      }
    },
    {
      "id": "coral-royale",
      "name": "Coral Royale ü™∏",
      "intro": "Warm coral red under soft gold‚Äîlively, magnetic, made for bold moves. Big-game charisma with generosity, channeling Alan Keating‚Äôs fearless table energy.",
      "persona": "Alan Keating",
      "palette": {
        "felt": "#E34234",
        "rail": "#0F0F0F",
        "metal": "#E4B564",
        "accent": "#FF7F50",
        "raise": "#D64040",
        "call": "#2AA37A",
        "neutral": "#B59C91",
        "text": "#FFF0E6",
        "highlight": "#FF7F50",
        "highlight_text": "#2B120E",
        "emphasis_text": "#FFE6D8",

        "chip_face": "#E34234",
        "chip_edge": "#0F0F0F",
        "chip_rim": "#E4B564",
        "chip_text": "#FFFFFF",
        "bet_face": "#FF7F50",
        "bet_edge": "#0F0F0F",
        "bet_rim": "#E4B564",
        "bet_text": "#2B120E",
        "bet_glow": "#FFC4AE",
        "pot_face": "#F1D39B",
        "pot_edge": "#0D0D0D",
        "pot_rim": "#F6DDB0",
        "pot_text": "#0B0B0E",
        "pot_glow": "#FAE7C9"
      }
    },
    {
      "id": "golden-dusk",
      "name": "Golden Dusk üåá",
      "intro": "Burnished amber over dark leather; cinematic nostalgia that never hurries. Veteran reads and closing instinct, reflecting Jason Mercier‚Äôs calm endgame edge.",
      "persona": "Jason Mercier",
      "palette": {
        "felt": "#7A4A1F",
        "rail": "#3A1D0D",
        "metal": "#C18F65",
        "accent": "#A3622B",
        "raise": "#B35A3B",
        "call": "#2AA37A",
        "neutral": "#AF9A8A",
        "text": "#F3E3D3",
        "highlight": "#E4B564",
        "highlight_text": "#23160D",
        "emphasis_text": "#F8E6CF",

        "chip_face": "#7A4A1F",
        "chip_edge": "#3A1D0D",
        "chip_rim": "#C18F65",
        "chip_text": "#F8F7F4",
        "bet_face": "#A3622B",
        "bet_edge": "#3A1D0D",
        "bet_rim": "#C18F65",
        "bet_text": "#FFF1E2",
        "bet_glow": "#E8C49E",
        "pot_face": "#E2C39B",
        "pot_edge": "#2C1409",
        "pot_rim": "#EFD2AD",
        "pot_text": "#0B0B0E",
        "pot_glow": "#F5E2C8"
      }
    },
    {
      "id": "klimt-royale",
      "name": "Klimt Royale ‚ú®",
      "intro": "Obsidian field with ornamental gold; decadent patterns that shimmer like a gala. Elegant intellect and creative lines, echoing Liv Boeree‚Äôs balance of logic and style.",
      "persona": "Liv Boeree",
      "palette": {
        "felt": "#17130E",
        "rail": "#23211B",
        "metal": "#E4C97D",
        "accent": "#166A3E",
        "raise": "#B23B43",
        "call": "#32B37A",
        "neutral": "#A38E6A",
        "text": "#FFF2D9",
        "highlight": "#B87333",
        "highlight_text": "#0D0A07",
        "emphasis_text": "#FFEBC6",

        "chip_face": "#17130E",
        "chip_edge": "#23211B",
        "chip_rim": "#E4C97D",
        "chip_text": "#F8F7F4",
        "bet_face": "#166A3E",
        "bet_edge": "#23211B",
        "bet_rim": "#E4C97D",
        "bet_text": "#EFFFF7",
        "bet_glow": "#82D9AE",
        "pot_face": "#EBD79F",
        "pot_edge": "#1A1812",
        "pot_rim": "#F2E2B5",
        "pot_text": "#0B0B0E",
        "pot_glow": "#F7EDC9"
      }
    },
    {
      "id": "deco-luxe",
      "name": "Deco Luxe üèõÔ∏è",
      "intro": "Champagne geometry on jet black‚Äîsleek Art-Deco lines and effortless poise. Thoughtful innovation and restraint, channeling Phil Galfond‚Äôs cerebral mastery.",
      "persona": "Phil Galfond",
      "palette": {
        "felt": "#1B1E2B",
        "rail": "#111111",
        "metal": "#D6C08F",
        "accent": "#1A3E34",
        "raise": "#5B1922",
        "call": "#2AA37A",
        "neutral": "#9B9486",
        "text": "#F8F4EA",
        "highlight": "#E1B382",
        "highlight_text": "#0E0C09",
        "emphasis_text": "#F4EAD3",

        "chip_face": "#1B1E2B",
        "chip_edge": "#111111",
        "chip_rim": "#D6C08F",
        "chip_text": "#F8F7F4",
        "bet_face": "#1A3E34",
        "bet_edge": "#111111",
        "bet_rim": "#D6C08F",
        "bet_text": "#E8FFF6",
        "bet_glow": "#8EC9B6",
        "pot_face": "#E7D7AF",
        "pot_edge": "#0F0F0F",
        "pot_rim": "#F0E2BF",
        "pot_text": "#0B0B0E",
        "pot_glow": "#F6ECCD"
      }
    },
    {
      "id": "oceanic-aqua",
      "name": "Oceanic Aqua üåä",
      "intro": "Midnight teal with bright aqua spray‚Äîrefreshing, steady, quietly modern. Patience and clarity in deep waters, reflecting Erik Seidel‚Äôs timeless control.",
      "persona": "Erik Seidel",
      "palette": {
        "felt": "#126E82",
        "rail": "#0D1B2A",
        "metal": "#B7C1C8",
        "accent": "#4EEAFF",
        "raise": "#6C94D2",
        "call": "#57C2B6",
        "neutral": "#9DB3C4",
        "text": "#F5F7FA",
        "highlight": "#4EEAFF",
        "highlight_text": "#071018",
        "emphasis_text": "#EAF6FF",

        "chip_face": "#126E82",
        "chip_edge": "#0D1B2A",
        "chip_rim": "#B7C1C8",
        "chip_text": "#F8F7F4",
        "bet_face": "#4EEAFF",
        "bet_edge": "#0D1B2A",
        "bet_rim": "#B7C1C8",
        "bet_text": "#06222A",
        "bet_glow": "#A4F6FF",
        "pot_face": "#D6E2EA",
        "pot_edge": "#0B1723",
        "pot_rim": "#E3EDF3",
        "pot_text": "#0B0B0E",
        "pot_glow": "#EFF6FA"
      }
    },
    {
      "id": "royal-sapphire",
      "name": "Royal Sapphire üî∑",
      "intro": "Jewel-blue confidence with crisp trim‚Äîbright, polished, commanding. Relentless precision and tournament steel, capturing Adri√°n Mateos‚Äôs clinical edge.",
      "persona": "Adri√°n Mateos",
      "palette": {
        "felt": "#0D3B66",
        "rail": "#161616",
        "metal": "#C7D3E0",
        "accent": "#2656D9",
        "raise": "#6C4AB6",
        "call": "#57C2B6",
        "neutral": "#9AB1CF",
        "text": "#F2F6FC",
        "highlight": "#1E90FF",
        "highlight_text": "#061224",
        "emphasis_text": "#E8F1FF",

        "chip_face": "#0D3B66",
        "chip_edge": "#161616",
        "chip_rim": "#C7D3E0",
        "chip_text": "#F8F7F4",
        "bet_face": "#2656D9",
        "bet_edge": "#161616",
        "bet_rim": "#C7D3E0",
        "bet_text": "#E9EEFF",
        "bet_glow": "#8FB1FF",
        "pot_face": "#DEE7EF",
        "pot_edge": "#131313",
        "pot_rim": "#EAF1F6",
        "pot_text": "#0B0B0E",
        "pot_glow": "#F4F8FB"
      }
    },
    {
      "id": "monet-twilight",
      "name": "Monet Twilight üé®",
      "intro": "Navy-violet felt with misted glow‚Äîsoft reflections, poetic and nocturnal. Grace under variance and stoic poise, echoing Patrik Antonius‚Äôs midnight composure.",
      "persona": "Patrik Antonius",
      "palette": {
        "felt": "#2A2D64",
        "rail": "#1F1F1B",
        "metal": "#C8BEDF",
        "accent": "#B7A6D0",
        "raise": "#B63D3D",
        "call": "#2AA37A",
        "neutral": "#8EA6B5",
        "text": "#F5F7FA",
        "highlight": "#B7A6D0",
        "highlight_text": "#0E0E15",
        "emphasis_text": "#EDE8F6",

        "chip_face": "#2A2D64",
        "chip_edge": "#1F1F1B",
        "chip_rim": "#C8BEDF",
        "chip_text": "#F8F7F4",
        "bet_face": "#B7A6D0",
        "bet_edge": "#1F1F1B",
        "bet_rim": "#C8BEDF",
        "bet_text": "#15141B",
        "bet_glow": "#E0D9F0",
        "pot_face": "#E6E1F1",
        "pot_edge": "#191916",
        "pot_rim": "#EEEAF6",
        "pot_text": "#0B0B0E",
        "pot_glow": "#F6F3FA"
      }
    },
    {
      "id": "caravaggio-sepia-noir",
      "name": "Caravaggio Sepia Noir üïØÔ∏è",
      "intro": "Candlelit sepia over deep shadow‚Äîdrama, heat, fearless contrasts. Audacious pressure and brinkmanship, mirroring Tom Dwan‚Äôs fearless lines.",
      "persona": "Tom Dwan",
      "palette": {
        "felt": "#2A1F1A",
        "rail": "#101010",
        "metal": "#D4A373",
        "accent": "#9E0F28",
        "raise": "#B3122E",
        "call": "#2AA37A",
        "neutral": "#9C8F7A",
        "text": "#FFF7E6",
        "highlight": "#EAD6B7",
        "highlight_text": "#1B130B",
        "emphasis_text": "#F7E8CD",

        "chip_face": "#2A1F1A",
        "chip_edge": "#101010",
        "chip_rim": "#D4A373",
        "chip_text": "#F8F7F4",
        "bet_face": "#9E0F28",
        "bet_edge": "#101010",
        "bet_rim": "#D4A373",
        "bet_text": "#FFEFF2",
        "bet_glow": "#F29BAA",
        "pot_face": "#E9D0AA",
        "pot_edge": "#0E0E0E",
        "pot_rim": "#F2DBB9",
        "pot_text": "#0B0B0E",
        "pot_glow": "#F7E8CD"
      }
    },
    {
      "id": "stealth-graphite-steel",
      "name": "Stealth Graphite Steel üñ§",
      "intro": "Matte blacks and brushed steel; silent, aerodynamic focus. Unreadable calm and surgical timing, channeling Phil Ivey‚Äôs cold precision.",
      "persona": "Phil Ivey",
      "palette": {
        "felt": "#2E2E2E",
        "rail": "#444444",
        "metal": "#8D8D8D",
        "accent": "#00D4FF",
        "raise": "#9E3B49",
        "call": "#57C2B6",
        "neutral": "#8E9196",
        "text": "#E6E7EA",
        "highlight": "#00D4FF",
        "highlight_text": "#041014",
        "emphasis_text": "#F2F3F5",

        "chip_face": "#2E2E2E",
        "chip_edge": "#444444",
        "chip_rim": "#8D8D8D",
        "chip_text": "#F8F7F4",
        "bet_face": "#00D4FF",
        "bet_edge": "#444444",
        "bet_rim": "#8D8D8D",
        "bet_text": "#031418",
        "bet_glow": "#89F0FF",
        "pot_face": "#D9D9D9",
        "pot_edge": "#3A3A3A",
        "pot_rim": "#E6E6E6",
        "pot_text": "#0B0B0E",
        "pot_glow": "#F2F2F2"
      }
    },
    {
      "id": "sunset-mirage",
      "name": "Sunset Mirage üåÖ",
      "intro": "Amber to violet across the felt‚Äîthe warmth of desert dusk under velvet lights. Live-read mastery and table conversation, reflecting Daniel Negreanu‚Äôs friendly edge.",
      "persona": "Daniel Negreanu",
      "palette": {
        "felt": "#8C1C13",
        "rail": "#2B1B0E",
        "metal": "#E6B87A",
        "accent": "#FF9E57",
        "raise": "#C85C5C",
        "call": "#2AA37A",
        "neutral": "#A68C7A",
        "text": "#F7E7D6",
        "highlight": "#FF9E57",
        "highlight_text": "#2B160E",
        "emphasis_text": "#FFE6C9",

        "chip_face": "#8C1C13",
        "chip_edge": "#2B1B0E",
        "chip_rim": "#E6B87A",
        "chip_text": "#F8F7F4",
        "bet_face": "#FF9E57",
        "bet_edge": "#2B1B0E",
        "bet_rim": "#E6B87A",
        "bet_text": "#2B160E",
        "bet_glow": "#FFD1AE",
        "pot_face": "#F1D7AF",
        "pot_edge": "#24170D",
        "pot_rim": "#F7E2C3",
        "pot_text": "#0B0B0E",
        "pot_glow": "#FBEBD3"
      }
    },
    {
      "id": "cyber-neon",
      "name": "Cyber Neon ‚ö°",
      "intro": "Electric teals and magentas on charcoal‚Äîarcade energy for fast grinders. Hyper-focused volume and fearless optimization, channeling Fedor Holz's modern engine.",
      "persona": "Fedor Holz",
      "palette": {
        "felt": "#0A0D10",
        "rail": "#1A1D23",
        "metal": "#00FFFF",
        "accent": "#FF00FF",
        "raise": "#FF0080",
        "call": "#00FF80",
        "neutral": "#808080",
        "text": "#E0E0E0",
        "highlight": "#00FFFF",
        "highlight_text": "#000000",
        "emphasis_text": "#FFFFFF"
      }
    }
  ]
}
```

---

### theme_manager.data.json

**Path**: `backend/ui/.mypy_cache/3.13/backend/ui/services/theme_manager.data.json`

**Size**: 12.9 KB

```json
{".class":"MypyFile","_fullname":"backend.ui.services.theme_manager","future_import_flags":["annotations"],"is_partial_stub_package":false,"is_stub":false,"names":{".class":"SymbolTable","Any":{".class":"SymbolTableNode","cross_ref":"typing.Any","kind":"Gdef"},"Dict":{".class":"SymbolTableNode","cross_ref":"typing.Dict","kind":"Gdef"},"ThemeManager":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["builtins.object"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"backend.ui.services.theme_manager.ThemeManager","name":"ThemeManager","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"backend.ui.services.theme_manager","mro":["backend.ui.services.theme_manager.ThemeManager","builtins.object"],"names":{".class":"SymbolTable","CONFIG_PATH":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_inferred","has_explicit_value"],"fullname":"backend.ui.services.theme_manager.ThemeManager.CONFIG_PATH","name":"CONFIG_PATH","type":"builtins.str"}},"__init__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_build_profiles":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager._build_profiles","name":"_build_profiles","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_build_profiles of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_fonts":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager.ThemeManager._fonts","name":"_fonts","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"_load_config":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager._load_config","name":"_load_config","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_load_config of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_profiles":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["is_inferred"],"fullname":"backend.ui.services.theme_manager.ThemeManager._profiles","name":"_profiles","type":{".class":"Instance","args":["builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"_save_config":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager._save_config","name":"_save_config","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_save_config of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_theme":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager.ThemeManager._theme","name":"_theme","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"current_profile_name":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.current_profile_name","name":"current_profile_name","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"current_profile_name of ThemeManager","ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_fonts":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.get_fonts","name":"get_fonts","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_fonts of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_profiles":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.get_profiles","name":"get_profiles","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_profiles of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_theme":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.get_theme","name":"get_theme","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_theme of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"set_fonts":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","fonts"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.set_fonts","name":"set_fonts","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","fonts"],"arg_types":["backend.ui.services.theme_manager.ThemeManager",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"set_fonts of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"set_profile":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","name"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.set_profile","name":"set_profile","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","name"],"arg_types":["backend.ui.services.theme_manager.ThemeManager","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"set_profile of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"backend.ui.services.theme_manager.ThemeManager.Self","id":0,"name":"Self","namespace":"","upper_bound":"backend.ui.services.theme_manager.ThemeManager","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"__annotations__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__annotations__","name":"__annotations__","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"__doc__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__doc__","name":"__doc__","type":"builtins.str"}},"__file__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__file__","name":"__file__","type":"builtins.str"}},"__name__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__name__","name":"__name__","type":"builtins.str"}},"__package__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__package__","name":"__package__","type":"builtins.str"}},"__spec__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__spec__","name":"__spec__","type":"_frozen_importlib.ModuleSpec"}},"annotations":{".class":"SymbolTableNode","cross_ref":"__future__.annotations","kind":"Gdef"},"importlib":{".class":"SymbolTableNode","cross_ref":"importlib","kind":"Gdef"},"json":{".class":"SymbolTableNode","cross_ref":"json","kind":"Gdef"},"os":{".class":"SymbolTableNode","cross_ref":"os","kind":"Gdef"}},"path":"/Users/yeogirlyun/Poker/backend/ui/services/theme_manager.py"}
```

---

### theme_manager.meta.json

**Path**: `backend/ui/.mypy_cache/3.13/backend/ui/services/theme_manager.meta.json`

**Size**: 1.7 KB

```json
{"data_mtime":1755327923,"dep_lines":[1,3,4,5,6,1,1,1,1,1,1,1,1],"dep_prios":[5,5,10,10,10,5,30,30,30,30,30,30,30],"dependencies":["__future__","typing","importlib","json","os","builtins","_frozen_importlib","_io","_typeshed","abc","io","json.decoder","types"],"hash":"a7c0cdbee324cb373c6dfbcfdc84832265cb3aa3","id":"backend.ui.services.theme_manager","ignore_all":true,"interface_hash":"3b8a65a7375da1236a87e0015562dbb25a49903d","mtime":1755327729,"options":{"allow_redefinition":false,"allow_untyped_globals":false,"always_false":[],"always_true":[],"bazel":false,"check_untyped_defs":false,"disable_bytearray_promotion":false,"disable_error_code":[],"disable_memoryview_promotion":false,"disabled_error_codes":[],"disallow_any_decorated":false,"disallow_any_explicit":false,"disallow_any_expr":false,"disallow_any_generics":false,"disallow_any_unimported":false,"disallow_incomplete_defs":false,"disallow_subclassing_any":false,"disallow_untyped_calls":false,"disallow_untyped_decorators":false,"disallow_untyped_defs":false,"enable_error_code":[],"enabled_error_codes":[],"extra_checks":false,"follow_imports":"normal","follow_imports_for_stubs":false,"follow_untyped_imports":false,"ignore_errors":false,"ignore_missing_imports":false,"implicit_optional":false,"implicit_reexport":true,"local_partial_types":false,"mypyc":false,"old_type_inference":false,"platform":"darwin","plugins":[],"strict_concatenate":false,"strict_equality":false,"strict_optional":true,"warn_no_return":true,"warn_return_any":false,"warn_unreachable":false,"warn_unused_ignores":false},"path":"/Users/yeogirlyun/Poker/backend/ui/services/theme_manager.py","plugin_data":null,"size":3167,"suppressed":[],"version_id":"1.14.1"}
```

---

### theme_manager.data.json

**Path**: `backend/ui/services/.mypy_cache/3.13/backend/ui/services/theme_manager.data.json`

**Size**: 17.2 KB

```json
{".class":"MypyFile","_fullname":"backend.ui.services.theme_manager","future_import_flags":["annotations"],"is_partial_stub_package":false,"is_stub":false,"names":{".class":"SymbolTable","Any":{".class":"SymbolTableNode","cross_ref":"typing.Any","kind":"Gdef"},"Callable":{".class":"SymbolTableNode","cross_ref":"typing.Callable","kind":"Gdef"},"Dict":{".class":"SymbolTableNode","cross_ref":"typing.Dict","kind":"Gdef"},"List":{".class":"SymbolTableNode","cross_ref":"typing.List","kind":"Gdef"},"ThemeManager":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["builtins.object"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"backend.ui.services.theme_manager.ThemeManager","name":"ThemeManager","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"backend.ui.services.theme_manager","mro":["backend.ui.services.theme_manager.ThemeManager","builtins.object"],"names":{".class":"SymbolTable","CONFIG_PATH":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_inferred","has_explicit_value"],"fullname":"backend.ui.services.theme_manager.ThemeManager.CONFIG_PATH","name":"CONFIG_PATH","type":"builtins.str"}},"__init__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_builtin_packs":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager._builtin_packs","name":"_builtin_packs","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_builtin_packs of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_current":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager.ThemeManager._current","name":"_current","type":{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}}},"_fonts":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager.ThemeManager._fonts","name":"_fonts","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"_load_config":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager._load_config","name":"_load_config","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_load_config of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_save_config":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager._save_config","name":"_save_config","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_save_config of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_subs":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager.ThemeManager._subs","name":"_subs","type":{".class":"Instance","args":[{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}],"extra_attrs":null,"type_ref":"builtins.list"}}},"_theme":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager.ThemeManager._theme","name":"_theme","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"_themes":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager.ThemeManager._themes","name":"_themes","type":{".class":"Instance","args":["builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"current_profile_name":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.current_profile_name","name":"current_profile_name","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"current_profile_name of ThemeManager","ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,1],"arg_names":["self","token","default"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.get","name":"get","type":{".class":"CallableType","arg_kinds":[0,0,1],"arg_names":["self","token","default"],"arg_types":["backend.ui.services.theme_manager.ThemeManager","builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get of ThemeManager","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_fonts":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.get_fonts","name":"get_fonts","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_fonts of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_theme":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.get_theme","name":"get_theme","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_theme of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"names":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.names","name":"names","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"names of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"builtins.list"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"register":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":["self","name","tokens"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.register","name":"register","type":{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":["self","name","tokens"],"arg_types":["backend.ui.services.theme_manager.ThemeManager","builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"register of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"set_fonts":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","fonts"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.set_fonts","name":"set_fonts","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","fonts"],"arg_types":["backend.ui.services.theme_manager.ThemeManager",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"set_fonts of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"set_profile":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","name"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.set_profile","name":"set_profile","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","name"],"arg_types":["backend.ui.services.theme_manager.ThemeManager","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"set_profile of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"subscribe":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","fn"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.subscribe","name":"subscribe","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","fn"],"arg_types":["backend.ui.services.theme_manager.ThemeManager",{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"subscribe of ThemeManager","ret_type":{".class":"CallableType","arg_kinds":[],"arg_names":[],"arg_types":[],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"backend.ui.services.theme_manager.ThemeManager.Self","id":0,"name":"Self","namespace":"","upper_bound":"backend.ui.services.theme_manager.ThemeManager","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"__annotations__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__annotations__","name":"__annotations__","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"__doc__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__doc__","name":"__doc__","type":"builtins.str"}},"__file__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__file__","name":"__file__","type":"builtins.str"}},"__name__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__name__","name":"__name__","type":"builtins.str"}},"__package__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__package__","name":"__package__","type":"builtins.str"}},"__spec__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__spec__","name":"__spec__","type":"_frozen_importlib.ModuleSpec"}},"annotations":{".class":"SymbolTableNode","cross_ref":"__future__.annotations","kind":"Gdef"},"importlib":{".class":"SymbolTableNode","cross_ref":"importlib","kind":"Gdef"},"json":{".class":"SymbolTableNode","cross_ref":"json","kind":"Gdef"},"os":{".class":"SymbolTableNode","cross_ref":"os","kind":"Gdef"}},"path":"/Users/yeogirlyun/Poker/backend/ui/services/theme_manager.py"}
```

---

### theme_manager.meta.json

**Path**: `backend/ui/services/.mypy_cache/3.13/backend/ui/services/theme_manager.meta.json`

**Size**: 1.7 KB

```json
{"data_mtime":1755328004,"dep_lines":[1,3,4,5,6,1,1,1,1,1,1,1,1,1,1],"dep_prios":[5,5,10,10,10,5,30,30,30,30,30,30,30,30,30],"dependencies":["__future__","typing","importlib","json","os","builtins","_collections_abc","_frozen_importlib","_io","_typeshed","abc","io","json.decoder","json.encoder","types"],"hash":"d7ed5573626e788a4fb52f9bc7e3c74d3f3ddd25","id":"backend.ui.services.theme_manager","ignore_all":false,"interface_hash":"808b05726706aa6f1094c83ace58179f987c0a07","mtime":1755328111,"options":{"allow_redefinition":false,"allow_untyped_globals":false,"always_false":[],"always_true":[],"bazel":false,"check_untyped_defs":false,"disable_bytearray_promotion":false,"disable_error_code":[],"disable_memoryview_promotion":false,"disabled_error_codes":[],"disallow_any_decorated":false,"disallow_any_explicit":false,"disallow_any_expr":false,"disallow_any_generics":false,"disallow_any_unimported":false,"disallow_incomplete_defs":false,"disallow_subclassing_any":false,"disallow_untyped_calls":false,"disallow_untyped_decorators":false,"disallow_untyped_defs":false,"enable_error_code":[],"enabled_error_codes":[],"extra_checks":false,"follow_imports":"normal","follow_imports_for_stubs":false,"follow_untyped_imports":false,"ignore_errors":false,"ignore_missing_imports":false,"implicit_optional":false,"implicit_reexport":true,"local_partial_types":false,"mypyc":false,"old_type_inference":false,"platform":"darwin","plugins":[],"strict_concatenate":false,"strict_equality":false,"strict_optional":true,"warn_no_return":true,"warn_return_any":false,"warn_unreachable":false,"warn_unused_ignores":false},"path":"/Users/yeogirlyun/Poker/backend/ui/services/theme_manager.py","plugin_data":null,"size":14533,"suppressed":[],"version_id":"1.14.1"}
```

---

### theme_manager.data.json

**Path**: `backend/ui/tableview/components/.mypy_cache/3.13/backend/ui/services/theme_manager.data.json`

**Size**: 17.2 KB

```json
{".class":"MypyFile","_fullname":"backend.ui.services.theme_manager","future_import_flags":["annotations"],"is_partial_stub_package":false,"is_stub":false,"names":{".class":"SymbolTable","Any":{".class":"SymbolTableNode","cross_ref":"typing.Any","kind":"Gdef"},"Callable":{".class":"SymbolTableNode","cross_ref":"typing.Callable","kind":"Gdef"},"Dict":{".class":"SymbolTableNode","cross_ref":"typing.Dict","kind":"Gdef"},"List":{".class":"SymbolTableNode","cross_ref":"typing.List","kind":"Gdef"},"ThemeManager":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["builtins.object"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"backend.ui.services.theme_manager.ThemeManager","name":"ThemeManager","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"backend.ui.services.theme_manager","mro":["backend.ui.services.theme_manager.ThemeManager","builtins.object"],"names":{".class":"SymbolTable","CONFIG_PATH":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_inferred","has_explicit_value"],"fullname":"backend.ui.services.theme_manager.ThemeManager.CONFIG_PATH","name":"CONFIG_PATH","type":"builtins.str"}},"__init__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_builtin_packs":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager._builtin_packs","name":"_builtin_packs","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_builtin_packs of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_current":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager.ThemeManager._current","name":"_current","type":{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}}},"_fonts":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager.ThemeManager._fonts","name":"_fonts","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"_load_config":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager._load_config","name":"_load_config","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_load_config of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_save_config":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager._save_config","name":"_save_config","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_save_config of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_subs":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager.ThemeManager._subs","name":"_subs","type":{".class":"Instance","args":[{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}],"extra_attrs":null,"type_ref":"builtins.list"}}},"_theme":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager.ThemeManager._theme","name":"_theme","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"_themes":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager.ThemeManager._themes","name":"_themes","type":{".class":"Instance","args":["builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"current_profile_name":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.current_profile_name","name":"current_profile_name","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"current_profile_name of ThemeManager","ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,1],"arg_names":["self","token","default"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.get","name":"get","type":{".class":"CallableType","arg_kinds":[0,0,1],"arg_names":["self","token","default"],"arg_types":["backend.ui.services.theme_manager.ThemeManager","builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get of ThemeManager","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_fonts":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.get_fonts","name":"get_fonts","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_fonts of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_theme":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.get_theme","name":"get_theme","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_theme of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"names":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.names","name":"names","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"names of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"builtins.list"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"register":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":["self","name","tokens"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.register","name":"register","type":{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":["self","name","tokens"],"arg_types":["backend.ui.services.theme_manager.ThemeManager","builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"register of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"set_fonts":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","fonts"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.set_fonts","name":"set_fonts","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","fonts"],"arg_types":["backend.ui.services.theme_manager.ThemeManager",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"set_fonts of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"set_profile":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","name"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.set_profile","name":"set_profile","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","name"],"arg_types":["backend.ui.services.theme_manager.ThemeManager","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"set_profile of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"subscribe":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","fn"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.subscribe","name":"subscribe","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","fn"],"arg_types":["backend.ui.services.theme_manager.ThemeManager",{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"subscribe of ThemeManager","ret_type":{".class":"CallableType","arg_kinds":[],"arg_names":[],"arg_types":[],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"backend.ui.services.theme_manager.ThemeManager.Self","id":0,"name":"Self","namespace":"","upper_bound":"backend.ui.services.theme_manager.ThemeManager","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"__annotations__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__annotations__","name":"__annotations__","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"__doc__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__doc__","name":"__doc__","type":"builtins.str"}},"__file__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__file__","name":"__file__","type":"builtins.str"}},"__name__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__name__","name":"__name__","type":"builtins.str"}},"__package__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__package__","name":"__package__","type":"builtins.str"}},"__spec__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__spec__","name":"__spec__","type":"_frozen_importlib.ModuleSpec"}},"annotations":{".class":"SymbolTableNode","cross_ref":"__future__.annotations","kind":"Gdef"},"importlib":{".class":"SymbolTableNode","cross_ref":"importlib","kind":"Gdef"},"json":{".class":"SymbolTableNode","cross_ref":"json","kind":"Gdef"},"os":{".class":"SymbolTableNode","cross_ref":"os","kind":"Gdef"}},"path":"/Users/yeogirlyun/Poker/backend/ui/services/theme_manager.py"}
```

---

### theme_manager.meta.json

**Path**: `backend/ui/tableview/components/.mypy_cache/3.13/backend/ui/services/theme_manager.meta.json`

**Size**: 1.7 KB

```json
{"data_mtime":1755328002,"dep_lines":[1,3,4,5,6,1,1,1,1,1,1,1,1,1,1],"dep_prios":[5,5,10,10,10,5,30,30,30,30,30,30,30,30,30],"dependencies":["__future__","typing","importlib","json","os","builtins","_collections_abc","_frozen_importlib","_io","_typeshed","abc","io","json.decoder","json.encoder","types"],"hash":"d7ed5573626e788a4fb52f9bc7e3c74d3f3ddd25","id":"backend.ui.services.theme_manager","ignore_all":false,"interface_hash":"808b05726706aa6f1094c83ace58179f987c0a07","mtime":1755328111,"options":{"allow_redefinition":false,"allow_untyped_globals":false,"always_false":[],"always_true":[],"bazel":false,"check_untyped_defs":false,"disable_bytearray_promotion":false,"disable_error_code":[],"disable_memoryview_promotion":false,"disabled_error_codes":[],"disallow_any_decorated":false,"disallow_any_explicit":false,"disallow_any_expr":false,"disallow_any_generics":false,"disallow_any_unimported":false,"disallow_incomplete_defs":false,"disallow_subclassing_any":false,"disallow_untyped_calls":false,"disallow_untyped_decorators":false,"disallow_untyped_defs":false,"enable_error_code":[],"enabled_error_codes":[],"extra_checks":false,"follow_imports":"normal","follow_imports_for_stubs":false,"follow_untyped_imports":false,"ignore_errors":false,"ignore_missing_imports":false,"implicit_optional":false,"implicit_reexport":true,"local_partial_types":false,"mypyc":false,"old_type_inference":false,"platform":"darwin","plugins":[],"strict_concatenate":false,"strict_equality":false,"strict_optional":true,"warn_no_return":true,"warn_return_any":false,"warn_unreachable":false,"warn_unused_ignores":false},"path":"/Users/yeogirlyun/Poker/backend/ui/services/theme_manager.py","plugin_data":null,"size":14533,"suppressed":[],"version_id":"1.14.1"}
```

---

### theme_manager.data.json

**Path**: `backend/ui/tabs/.mypy_cache/3.13/backend/ui/services/theme_manager.data.json`

**Size**: 17.2 KB

```json
{".class":"MypyFile","_fullname":"backend.ui.services.theme_manager","future_import_flags":["annotations"],"is_partial_stub_package":false,"is_stub":false,"names":{".class":"SymbolTable","Any":{".class":"SymbolTableNode","cross_ref":"typing.Any","kind":"Gdef"},"Callable":{".class":"SymbolTableNode","cross_ref":"typing.Callable","kind":"Gdef"},"Dict":{".class":"SymbolTableNode","cross_ref":"typing.Dict","kind":"Gdef"},"List":{".class":"SymbolTableNode","cross_ref":"typing.List","kind":"Gdef"},"ThemeManager":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"TypeInfo","_promote":[],"abstract_attributes":[],"alt_promote":null,"bases":["builtins.object"],"dataclass_transform_spec":null,"declared_metaclass":null,"defn":{".class":"ClassDef","fullname":"backend.ui.services.theme_manager.ThemeManager","name":"ThemeManager","type_vars":[]},"deletable_attributes":[],"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager","has_param_spec_type":false,"metaclass_type":null,"metadata":{},"module_name":"backend.ui.services.theme_manager","mro":["backend.ui.services.theme_manager.ThemeManager","builtins.object"],"names":{".class":"SymbolTable","CONFIG_PATH":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"Var","flags":["is_initialized_in_class","is_inferred","has_explicit_value"],"fullname":"backend.ui.services.theme_manager.ThemeManager.CONFIG_PATH","name":"CONFIG_PATH","type":"builtins.str"}},"__init__":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.__init__","name":"__init__","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"__init__ of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_builtin_packs":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager._builtin_packs","name":"_builtin_packs","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_builtin_packs of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_current":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager.ThemeManager._current","name":"_current","type":{".class":"UnionType","items":["builtins.str",{".class":"NoneType"}],"uses_pep604_syntax":true}}},"_fonts":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager.ThemeManager._fonts","name":"_fonts","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"_load_config":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager._load_config","name":"_load_config","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_load_config of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_save_config":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager._save_config","name":"_save_config","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"_save_config of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"_subs":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager.ThemeManager._subs","name":"_subs","type":{".class":"Instance","args":[{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}],"extra_attrs":null,"type_ref":"builtins.list"}}},"_theme":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager.ThemeManager._theme","name":"_theme","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"_themes":{".class":"SymbolTableNode","implicit":true,"kind":"Mdef","node":{".class":"Var","flags":["explicit_self_type","is_ready","is_inferred"],"fullname":"backend.ui.services.theme_manager.ThemeManager._themes","name":"_themes","type":{".class":"Instance","args":["builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"current_profile_name":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.current_profile_name","name":"current_profile_name","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"current_profile_name of ThemeManager","ret_type":"builtins.str","type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,1],"arg_names":["self","token","default"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.get","name":"get","type":{".class":"CallableType","arg_kinds":[0,0,1],"arg_names":["self","token","default"],"arg_types":["backend.ui.services.theme_manager.ThemeManager","builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get of ThemeManager","ret_type":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":1},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_fonts":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.get_fonts","name":"get_fonts","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_fonts of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"get_theme":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.get_theme","name":"get_theme","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"get_theme of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"names":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0],"arg_names":["self"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.names","name":"names","type":{".class":"CallableType","arg_kinds":[0],"arg_names":["self"],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"names of ThemeManager","ret_type":{".class":"Instance","args":["builtins.str"],"extra_attrs":null,"type_ref":"builtins.list"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"register":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0,0],"arg_names":["self","name","tokens"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.register","name":"register","type":{".class":"CallableType","arg_kinds":[0,0,0],"arg_names":["self","name","tokens"],"arg_types":["backend.ui.services.theme_manager.ThemeManager","builtins.str",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"register of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"set_fonts":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","fonts"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.set_fonts","name":"set_fonts","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","fonts"],"arg_types":["backend.ui.services.theme_manager.ThemeManager",{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":2}],"extra_attrs":null,"type_ref":"builtins.dict"}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"set_fonts of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"set_profile":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","name"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.set_profile","name":"set_profile","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","name"],"arg_types":["backend.ui.services.theme_manager.ThemeManager","builtins.str"],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"set_profile of ThemeManager","ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}},"subscribe":{".class":"SymbolTableNode","kind":"Mdef","node":{".class":"FuncDef","abstract_status":0,"arg_kinds":[0,0],"arg_names":["self","fn"],"dataclass_transform_spec":null,"deprecated":null,"flags":[],"fullname":"backend.ui.services.theme_manager.ThemeManager.subscribe","name":"subscribe","type":{".class":"CallableType","arg_kinds":[0,0],"arg_names":["self","fn"],"arg_types":["backend.ui.services.theme_manager.ThemeManager",{".class":"CallableType","arg_kinds":[0],"arg_names":[null],"arg_types":["backend.ui.services.theme_manager.ThemeManager"],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}],"bound_args":[],"def_extras":{"first_arg":"self"},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":"subscribe of ThemeManager","ret_type":{".class":"CallableType","arg_kinds":[],"arg_names":[],"arg_types":[],"bound_args":[],"def_extras":{},"fallback":"builtins.function","from_concatenate":false,"implicit":false,"imprecise_arg_kinds":false,"is_ellipsis_args":false,"name":null,"ret_type":{".class":"NoneType"},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]},"type_guard":null,"type_is":null,"unpack_kwargs":false,"variables":[]}}}},"self_type":{".class":"TypeVarType","default":{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":4},"fullname":"backend.ui.services.theme_manager.ThemeManager.Self","id":0,"name":"Self","namespace":"","upper_bound":"backend.ui.services.theme_manager.ThemeManager","values":[],"variance":0},"slots":null,"tuple_type":null,"type_vars":[],"typeddict_type":null}},"__annotations__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__annotations__","name":"__annotations__","type":{".class":"Instance","args":["builtins.str",{".class":"AnyType","missing_import_name":null,"source_any":null,"type_of_any":6}],"extra_attrs":null,"type_ref":"builtins.dict"}}},"__doc__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__doc__","name":"__doc__","type":"builtins.str"}},"__file__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__file__","name":"__file__","type":"builtins.str"}},"__name__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__name__","name":"__name__","type":"builtins.str"}},"__package__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__package__","name":"__package__","type":"builtins.str"}},"__spec__":{".class":"SymbolTableNode","kind":"Gdef","node":{".class":"Var","flags":["is_ready"],"fullname":"backend.ui.services.theme_manager.__spec__","name":"__spec__","type":"_frozen_importlib.ModuleSpec"}},"annotations":{".class":"SymbolTableNode","cross_ref":"__future__.annotations","kind":"Gdef"},"importlib":{".class":"SymbolTableNode","cross_ref":"importlib","kind":"Gdef"},"json":{".class":"SymbolTableNode","cross_ref":"json","kind":"Gdef"},"os":{".class":"SymbolTableNode","cross_ref":"os","kind":"Gdef"}},"path":"/Users/yeogirlyun/Poker/backend/ui/services/theme_manager.py"}
```

---

### theme_manager.meta.json

**Path**: `backend/ui/tabs/.mypy_cache/3.13/backend/ui/services/theme_manager.meta.json`

**Size**: 1.7 KB

```json
{"data_mtime":1755328003,"dep_lines":[1,3,4,5,6,1,1,1,1,1,1,1,1,1,1],"dep_prios":[5,5,10,10,10,5,30,30,30,30,30,30,30,30,30],"dependencies":["__future__","typing","importlib","json","os","builtins","_collections_abc","_frozen_importlib","_io","_typeshed","abc","io","json.decoder","json.encoder","types"],"hash":"d7ed5573626e788a4fb52f9bc7e3c74d3f3ddd25","id":"backend.ui.services.theme_manager","ignore_all":false,"interface_hash":"808b05726706aa6f1094c83ace58179f987c0a07","mtime":1755328111,"options":{"allow_redefinition":false,"allow_untyped_globals":false,"always_false":[],"always_true":[],"bazel":false,"check_untyped_defs":false,"disable_bytearray_promotion":false,"disable_error_code":[],"disable_memoryview_promotion":false,"disabled_error_codes":[],"disallow_any_decorated":false,"disallow_any_explicit":false,"disallow_any_expr":false,"disallow_any_generics":false,"disallow_any_unimported":false,"disallow_incomplete_defs":false,"disallow_subclassing_any":false,"disallow_untyped_calls":false,"disallow_untyped_decorators":false,"disallow_untyped_defs":false,"enable_error_code":[],"enabled_error_codes":[],"extra_checks":false,"follow_imports":"normal","follow_imports_for_stubs":false,"follow_untyped_imports":false,"ignore_errors":false,"ignore_missing_imports":false,"implicit_optional":false,"implicit_reexport":true,"local_partial_types":false,"mypyc":false,"old_type_inference":false,"platform":"darwin","plugins":[],"strict_concatenate":false,"strict_equality":false,"strict_optional":true,"warn_no_return":true,"warn_return_any":false,"warn_unreachable":false,"warn_unused_ignores":false},"path":"/Users/yeogirlyun/Poker/backend/ui/services/theme_manager.py","plugin_data":null,"size":14533,"suppressed":[],"version_id":"1.14.1"}
```

---

### theme_config.json

**Path**: `backend/ui/theme_config.json`

**Size**: 866 bytes

```json
{
  "profile": "Royal Sapphire",
  "fonts": {
    "main": [
      "Arial",
      19,
      "normal"
    ],
    "pot_display": [
      "Arial",
      27,
      "bold"
    ],
    "bet_amount": [
      "Arial",
      23,
      "bold"
    ],
    "body": [
      "Consolas",
      19
    ],
    "small": [
      "Consolas",
      15
    ],
    "header": [
      "Arial",
      21,
      "bold"
    ],
    "title": [
      "Segoe UI",
      18,
      "bold"
    ],
    "large": [
      "Segoe UI",
      16,
      "bold"
    ],
    "player_name": [
      "Segoe UI",
      13,
      "bold"
    ],
    "stack_amount": [
      "Segoe UI",
      16,
      "bold"
    ],
    "action_button": [
      "Segoe UI",
      14,
      "bold"
    ],
    "cards": [
      "Consolas",
      14,
      "bold"
    ],
    "stack_bet": [
      "Segoe UI",
      16,
      "bold"
    ]
  }
}
```

---

### theme_tokens.json

**Path**: `backend/ui/theme_tokens.json`

**Size**: 0 bytes

```json

```

---

## üìä **DOCUMENT STATISTICS**

- **Total Files Included**: 169
- **Total Source Size**: 2.9 MB
- **Categories Processed**: 4
- **Generation Time**: 2025-08-20 13:54:54

## üìã **END OF MEGA DOCUMENT**

*This comprehensive requirements document contains all relevant information and source code.*
