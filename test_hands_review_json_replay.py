#!/usr/bin/env python3
"""
Hands Review JSON Replay Test

This test will:
1. Read the JSON file generated by the GTO bot
2. Load it into the Hands Review poker state machine
3. Replay every action step by step
4. Log each action in English to verify it matches the original
5. Compare the final state to ensure accuracy
"""

import json
import sys
import os
from typing import List, Dict, Any, Tuple

# Add backend to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'backend'))

from core.bot_session_state_machine import HandsReviewBotSession
from core.flexible_poker_state_machine import GameConfig
from core.decision_engine_v2 import PreloadedDecisionEngine

def load_gto_hand_from_json(filename: str) -> Dict[str, Any]:
    """Load the GTO-generated hand from JSON file."""
    try:
        with open(filename, 'r') as f:
            hand_data = json.load(f)
        
        print(f"üìÇ Loaded hand from {filename}")
        print(f"   Hand ID: {hand_data.get('id', 'Unknown')}")
        print(f"   Players: {len(hand_data.get('initial_state', {}).get('players', []))}")
        print(f"   Actions: {len(hand_data.get('actions', []))}")
        print(f"   Final pot: ${hand_data.get('final_state', {}).get('pot', 0):.2f}")
        
        return hand_data
        
    except FileNotFoundError:
        print(f"‚ùå File {filename} not found!")
        return None
    except json.JSONDecodeError as e:
        print(f"‚ùå JSON decode error: {e}")
        return None

def setup_hands_review_session(hand_data: Dict[str, Any]) -> HandsReviewBotSession:
    """Set up a Hands Review session with the loaded hand data."""
    
    initial_state = hand_data.get('initial_state', {})
    players = initial_state.get('players', [])
    
    # Create game config based on the initial state
    config = GameConfig(
        starting_stack=initial_state.get('players', [{}])[0].get('stack', 1000),
        small_blind=initial_state.get('small_blind', 5),
        big_blind=initial_state.get('big_blind', 10),
        num_players=len(players)
    )
    
    print(f"üéØ Setting up Hands Review session:")
    print(f"   Config: ${config.starting_stack} stacks, ${config.small_blind}/${config.big_blind} blinds")
    
    # Create decision engine with preloaded data
    decision_engine = PreloadedDecisionEngine(hand_data)
    print(f"   Decision engine: {len(hand_data.get('actions', []))} preloaded actions")
    
    # Create the session
    session = HandsReviewBotSession(config, decision_engine)
    
    # Set the preloaded hand data
    session.set_preloaded_hand_data(hand_data)
    
    return session

def replay_hand_step_by_step(session: HandsReviewBotSession, original_hand: Dict[str, Any]) -> Tuple[List[str], bool]:
    """Replay the hand step by step and log each action in English."""
    
    replay_log = []
    original_actions = original_hand.get('actions', [])
    action_count = 0
    max_actions = len(original_actions) + 5  # Safety buffer
    
    print(f"\nüé¨ Starting hand replay...")
    print(f"Expected {len(original_actions)} actions")
    
    # Start the session
    session.start_session()
    
    # Log initial state
    initial_state = original_hand.get('initial_state', {})
    replay_log.append("=== HANDS REVIEW REPLAY ===")
    
    for i, player_data in enumerate(initial_state.get('players', [])):
        replay_log.append(f"Setup: {player_data['name']} (Position {i}) starts with ${player_data['stack']:.2f}, cards: {player_data['cards']}")
    
    replay_log.append(f"Setup: Pot starts at ${initial_state.get('pot', 0):.2f}, current bet: ${initial_state.get('current_bet', 0):.2f}")
    replay_log.append("")
    
    print(f"Initial state: Pot=${session.game_state.pot:.2f}, Current bet=${session.game_state.current_bet:.2f}")
    
    # Track mismatches
    mismatches = []
    
    while session.current_state.value != 'END_HAND' and action_count < max_actions:
        action_count += 1
        
        # Get current state before action
        current_player_index = session.action_player_index
        if current_player_index < 0 or current_player_index >= len(session.game_state.players):
            replay_log.append(f"Replay Action {action_count}: Invalid player index {current_player_index} - ending")
            break
            
        current_player = session.game_state.players[current_player_index]
        street = session.current_state.value
        pot_before = session.game_state.pot
        current_bet_before = session.game_state.current_bet
        player_stack_before = current_player.stack
        player_bet_before = current_player.current_bet
        board_before = session.game_state.board.copy()
        
        print(f"\nüé≤ Replay Action {action_count}: {current_player.name} to act on {street}")
        print(f"   Game state: Pot=${pot_before:.2f}, current_bet=${current_bet_before:.2f}")
        print(f"   Player state: stack=${player_stack_before:.2f}, bet=${player_bet_before:.2f}")
        if board_before:
            print(f"   Board: {board_before}")
        
        # Get the expected action from original data
        expected_action = None
        if action_count <= len(original_actions):
            expected_action = original_actions[action_count - 1]
            print(f"   Expected: Player {expected_action['player_index']+1} {expected_action['action'].upper()} ${expected_action['amount']:.2f}")
        
        # Execute the next action
        result = session.execute_next_bot_action()
        
        if not result:
            replay_log.append(f"Replay Action {action_count}: {current_player.name} - action failed or session complete")
            print(f"‚ùå Action failed or session complete")
            break
        
        # Analyze what happened
        pot_after = session.game_state.pot
        current_bet_after = session.game_state.current_bet
        player_stack_after = current_player.stack
        player_bet_after = current_player.current_bet
        board_after = session.game_state.board.copy()
        
        stack_change = player_stack_before - player_stack_after
        
        # Determine the action that occurred
        action_type = "unknown"
        action_amount = 0.0
        
        if current_player.has_folded:
            action_type = "fold"
            action_amount = 0.0
            english_description = f"{current_player.name} folds"
        elif stack_change == 0:
            action_type = "check"
            action_amount = 0.0
            english_description = f"{current_player.name} checks"
        elif stack_change > 0:
            action_amount = stack_change
            if player_bet_before == 0 and current_bet_before == 0:
                action_type = "bet"
                english_description = f"{current_player.name} bets ${action_amount:.2f}"
            elif player_bet_after == current_bet_before:
                action_type = "call"
                english_description = f"{current_player.name} calls ${action_amount:.2f}"
            elif player_bet_after > current_bet_before:
                action_type = "raise"
                english_description = f"{current_player.name} raises to ${player_bet_after:.2f} (putting in ${action_amount:.2f})"
            else:
                action_type = "call"  # Default for money actions
                english_description = f"{current_player.name} puts in ${action_amount:.2f}"
        
        # Check for board changes
        if len(board_after) > len(board_before):
            new_cards = board_after[len(board_before):]
            if len(board_before) == 0:
                english_description += f" | Flop dealt: {new_cards}"
            elif len(board_before) == 3:
                english_description += f" | Turn dealt: {new_cards[0]}"
            elif len(board_before) == 4:
                english_description += f" | River dealt: {new_cards[0]}"
        
        # Compare with expected action
        status = "‚úÖ"
        if expected_action:
            expected_player = expected_action['player_index']
            expected_action_type = expected_action['action']
            expected_amount = expected_action['amount']
            
            if (current_player_index != expected_player or 
                action_type != expected_action_type or 
                abs(action_amount - expected_amount) > 0.01):
                
                status = "‚ùå"
                mismatch = {
                    'action_number': action_count,
                    'expected': f"Player {expected_player+1} {expected_action_type.upper()} ${expected_amount:.2f}",
                    'actual': f"Player {current_player_index+1} {action_type.upper()} ${action_amount:.2f}",
                    'pot_expected': expected_action.get('pot_after', 0),
                    'pot_actual': pot_after
                }
                mismatches.append(mismatch)
                print(f"   ‚ùå MISMATCH: Expected {mismatch['expected']}, got {mismatch['actual']}")
            else:
                print(f"   ‚úÖ MATCH: {action_type.upper()} ${action_amount:.2f}")
        
        # Log the action
        replay_log.append(f"Replay Action {action_count}: {english_description} {status}")
        replay_log.append(f"  Result: Pot=${pot_before:.2f}‚Üí${pot_after:.2f}, {current_player.name} stack=${player_stack_before:.2f}‚Üí${player_stack_after:.2f}")
        
        print(f"{status} {english_description}")
        print(f"   Result: Pot=${pot_after:.2f}, {current_player.name} stack=${player_stack_after:.2f}")
    
    # Final state comparison
    final_pot = session.game_state.pot
    expected_final_pot = original_hand.get('final_state', {}).get('pot', 0)
    
    replay_log.append("")
    replay_log.append(f"Final state comparison:")
    replay_log.append(f"  Pot: ${final_pot:.2f} (expected: ${expected_final_pot:.2f})")
    
    for player in session.game_state.players:
        status = " (FOLDED)" if player.has_folded else ""
        replay_log.append(f"  {player.name}: ${player.stack:.2f}{status}")
    
    print(f"\nüèÅ Replay completed after {action_count} actions")
    print(f"Final pot: ${final_pot:.2f} (expected: ${expected_final_pot:.2f})")
    
    # Check for pot mismatch
    pot_matches = abs(final_pot - expected_final_pot) < 0.01
    if not pot_matches:
        mismatches.append({
            'type': 'final_pot',
            'expected': expected_final_pot,
            'actual': final_pot
        })
    
    success = len(mismatches) == 0
    
    if mismatches:
        print(f"\n‚ö†Ô∏è  Found {len(mismatches)} mismatches:")
        for mismatch in mismatches:
            if mismatch.get('type') == 'final_pot':
                print(f"   Final pot: expected ${mismatch['expected']:.2f}, got ${mismatch['actual']:.2f}")
            else:
                print(f"   Action {mismatch['action_number']}: expected {mismatch['expected']}, got {mismatch['actual']}")
    else:
        print(f"\nüéâ Perfect replay! All {action_count-1} actions matched exactly.")
    
    return replay_log, success

def save_replay_results(replay_log: List[str], success: bool, original_hand: Dict[str, Any]):
    """Save the replay results to files."""
    
    # Save replay log
    replay_filename = 'hands_review_replay_log.txt'
    with open(replay_filename, 'w') as f:
        f.write('\n'.join(replay_log))
    print(f"üìÑ Replay log saved to {replay_filename}")
    
    # Save comparison report
    report = {
        'test_type': 'hands_review_json_replay',
        'success': success,
        'original_hand_id': original_hand.get('id', 'unknown'),
        'original_actions': len(original_hand.get('actions', [])),
        'replay_actions': len([line for line in replay_log if line.startswith('Replay Action')]),
        'original_final_pot': original_hand.get('final_state', {}).get('pot', 0),
        'replay_log': replay_log
    }
    
    report_filename = 'hands_review_replay_report.json'
    with open(report_filename, 'w') as f:
        json.dump(report, f, indent=2)
    print(f"üìä Replay report saved to {report_filename}")

def main():
    """Main test function."""
    print("üß™ Hands Review JSON Replay Test")
    print("=" * 60)
    
    try:
        # Load the GTO-generated hand
        hand_data = load_gto_hand_from_json('gto_hand_for_verification.json')
        if not hand_data:
            print("‚ùå Failed to load hand data")
            return
        
        # Set up Hands Review session
        session = setup_hands_review_session(hand_data)
        
        # Replay the hand step by step
        replay_log, success = replay_hand_step_by_step(session, hand_data)
        
        # Save results
        save_replay_results(replay_log, success, hand_data)
        
        if success:
            print("\nüéâ SUCCESS! The Hands Review system perfectly replayed the GTO-generated hand.")
            print("‚úÖ JSON ‚Üí Hands Review conversion is working correctly.")
        else:
            print("\nüö® ISSUES FOUND! There are discrepancies between the original and replay.")
        
    except Exception as e:
        print(f"‚ùå Test failed: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()
